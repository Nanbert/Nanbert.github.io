---
title: 文本处理瑞士军刀--小而强悍
date: 2020-11-21 17:50:14
subtitle:
categories:
tags:
index_img: https://z3.ax1x.com/2021/04/03/cnhmQS.jpg
banner_img: https://z3.ax1x.com/2021/04/03/cnhmQS.jpg
---
<font size=4>**1.cat命令**</font>

|选项|说明|
|:-:|:-:|
|-A|用$表示每行的结尾,^I表示tab空格字符(是个判别空格和tab的方法)|
|-n|显示行号|
|-s|对于连续空行,只保留一行|

**cat用例**
`cat << END`接下来直到END之间的内容
`cat > foo.txt`快捷新建foo.txt并输入内容,以ctrl-D结束
`cat <<< filename`打印filename这个单词
<font size=4>**2.sort命令**</font>

|选项|说明|
|:-:|:-:|
|-b|忽略开头的空白字符,从第一个非空白字符进行排序|
|-f|让排序忽略大小写|
|-n|基于字符串的数值来排序,而不是字母值|
|-r|降序排序|
|-k [field1],[field2]|举例`-k 4,5`,根据[4,5]间的字符段对行进行排序,如果没有5,则只是根据第四个字符段进行行排序,字符段的分隔符默认为空,可以由-t来指定|
|-t [char]|定义域分割字符,默认为空格或制表|
|-u|去除比较相等的行,即便行内容不相等,如果比较结果相等(如只从第二个字符比较)改行也会被去除,|

**-key选项的魅力**
`sort -k 1,1 -k 2n foo.txt`先按第一个字段按字符串排序,如果第一字段相等,再2n表示第二个字段用数值排序,n和sort选项一样表示数值排序,同样还可以指定b(忽略开头的空格),r(逆向排序)
考虑系列文本字段,如何以日期的格式降序排序呢
```
10/30/2008
11/25/2008
06/19/2008
```

简单用如下命令:
`sort -k 1.7nbr -k 1.1nbr -k 1.4nbr xx.txt`表示先从第一个字段第7个字符开始进行排序,如果相等,再比较第一个字符开始的第一个字段开始排序,再者第四个字符开始排序
**sort用例**
`sort > foo.txt`同cat一样只不过对你输入的内容进行排序,也是ctrl-d结束
`sort file1.txt file2.txt file3.txt > final_sorted.txt`对多个文件进行排序
<font size=4>**3.unique命令**</font>
unique命令只能删除排好序的行,即是它只判断连续相等的行

|选项|说明|
|:-:|:-:|
|-e|输出所有重复行,并且每行开头显示重复次数|
|-d|只输所有出重复行|
|-f [n]|忽略每行开头的n个字段,字段之间由空格分割(不支持自定义)|
|-i|忽略大小写|
|-s [n]|跳过每行开头的n个字符|
|-u|只输出独有的文本,默认选项|

<font size=4>**4.cut命令**</font>
cut 程序被用来从文本行 抽取文本，并把其输出到标准输出。能够接受多个文件参数或标准输入

|选项|说明|
|:-:|:-:|
|-b [num_list]|从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分隔开的数值区间组成|
|-c [num_list]|从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分割开的数值区间组成|
|-f [num_list]|从文本行中抽取一个或多个由num_list定义的字段。这个列表可能包括一个或多个字段,或由逗号分割开的字段区间|
|-d [delim_char]|指定字段分隔符,默认情况下,由单个tab字符分隔开|
|--complement|抽取整个文本行，除了那些由-c或-f选项指定的文本|

选项中各个list列表格式如下:
N     从第1个开始数的第N个字节、字符或域
N-    从第N个开始到所在行结束的所有字符、字节或域
N-M   从第N个开始到第M个之间(包括第M个)的所有字符、字节或域
-M    从第1个开始到第M个之间(包括第M个)的所有字符、字节或域
<font size=4>**4.paste命令**</font>
格式:`paste [file1] [file2]`,在file1每行后添加file2中对应行内容,默认使用制表符分割两个文件的内容,可以用-d选项指定分割符
<font size=4>**5.join命令**</font>
与paste类似,但是它对文件有一个要求,每个文件对应行,都有相同的字段(默认为空白分割符),效果如下图:

|A文本|B文本|结果|
|John 20|John man|John 20 man|
|May 15|May woman|May 15 woman|
|Mike 33|Mike man|Mike 33 man|

各种设置有待研究
<font size=4>**6.comm命令**</font>
comm比较两个文本文件,会产生三列输出,第一列包含第一个文件独有的文本行,第二列包含第二个文本行独有的,第三列,两个文本共有的,-n选项会隐藏第n列的内容,n只有三个数字选择1,2,3
<font size=4>**7.diff命令**</font>
格式:`diff <options> [old file] [new file]`
diff默认输出如何使第一个文件变成第二个文件
常用选项-c,-u选项
<font size=4>**8.patch命令**</font>
patch程序被用来把更改应用到文本文件中。它接受从diff程序的输出,并且通常被用来把较老的文件转变为较新的文件,注意不一定要指定文件名,因为diff信息中已经有了文件信息
<font size=4>**9.tr命令**</font>
选项:`tr [选项] [set1] [set2]`
tr用来更改字符(只能从标准输出中接受数据),把一个字母换成另一个字母
set1,set2是下列选项之一:
1.一个枚举列表,例如:ABSCKAL
2.一个字符域:A-Z,a-z
3.POSIX字符类:[:upper:]
<font color=#FF0000>注意:</font>set1和set2字符集长度相同,一对一,但是,也有多对一,把所有符合字符换成同一个字符
**tr例子**
1.`tr -d '\r' dos_file > unix_file`把dos_file的换行符删除
2.`echo "aabbbbccc" | tr -s ab`挤压重复字符,这个结果为"abccc"
但如果是`echo "abcabcabc" | tr -s ab`结果不变
3.`seq 1 2 9 | paste -sd,`paste的神奇用法



