---
title: TCP/IP
date: 2022-10-03 10:52:48
subtitle:
categories:
tags:
banner_img: /images/TCP_IP.png
index_img: /images/TCP_IP.png
---

# UDP存在的意义
![](/images/UDP.png)
- 无需建立连接，不会引入建立连接的时延
- 无连接状态，tcp需要维护接发缓存、拥塞控制参数、序号及确认号的参数
- 分组首部更小
- 无拥塞控制，对于不希望过分延迟报文段的传送并且容忍数据丢失的场景适用
# 校验和的计算
- 发送方对UDP报文段中的所有16比特字进行累加，溢出将回卷，并取反得到校验和。
- 接收方将所有16比特字(包括校验和)进行累加,无错即得到全1
# TCP
![](/images/TCP.png)
## 涉及概念
- ACK:肯定确认,在TCP头部中表示当前对确认字段中的值是有效的,明显第一次握手时，该值置为0
- NAK:否定确儿（TCP中没有，只需确认最后一次接收到的分组即可）
- GBN:回退N步
- SR:选择重传
- MSS:最大报文长度,不包括头40字节
- MTU:最大传输单元，链路层的最大帧长度(以太网中为1500字节)，MSS=MTU-40(TCP+IP首部长度)
- RTT:往返时间
## 六比特标识位
- URG:用于指示报文段里存在着被发送端的上层实体置为紧急的数据(一般不用)
- ACK:用于指示确认字段的值是有效的
- PSH:用于指示接收方应立即将数据交给上层(一般不用)
- RST:用于告诉源：我没有那个报文段的套接字(即端口号未开)，不要再发送该报文,udp遇到这种情况会发送一个ICMP的数据报
- SYN:用于建立连接
- FIN:用于拆除连接
## 流量控制
- rwnd(接受窗口)=RcvBuffer-[LastByteRcvd-LastByteRead]
## 三次握手
![](/images/handshake.png)
- 第一次：SYN为1,ACK为0,随机初始化一个seq(client_isn)
- 第二次：SYN为1,ACK为1,随机初始化一个seq(server_isn),并设置确认号ack(client_isn+1)，此时服务器可能分配缓存和变量（此时分配会受到SYN洪泛攻击）
- 第三次：SYN为1,ACK为1,客户分配缓存和变量，并可以携带有效数据
### 为啥3次(反证法)
- 只有一次：无法证明自己发送和接受是否正常,无法证明接收方发送和接受是否正常
- 两次：接受方无法确认发送方的接受是否正常以及自己的发送是否正常
### 为啥3次(比喻)
1. 你听到吗？
2. 我能，你能听到我吗？
3. 我也能，那啥你把。。。。
### 为啥3次(正经版)
TCP连接：用于保证可靠性和流控制机制的信息，包括Socket,序列号以及窗口大小叫做连接。
所以通信双方要对这三种信息达成共识，socket就是ip+端口号，窗口大小用于流控制，序列号用于用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。问题转化为为啥3次才可以初始花这三个信息呢？
从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：
- **通过三次握手才能阻止重复历史连接的初始化**(最主要)
- 通过三次握手才能对通信双方的初始序列号进行初始化；
- 讨论其他次数握手建立连接的可能性；
#### point1
RFC793指出：连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。
所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：
- 如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；
- 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；
使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。
#### point2
另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：
- 数据包被发送方多次发送造成数据的重复；
- 数据包在传输的过程中被路由或者其他节点丢失；
- 数据包到达接收方可能无法按照发送顺序；
为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：
- 接收方可以通过序列号对重复的数据包进行去重；
- 发送方会在对应数据包未被 ACK 时进行重复发送；
- 接收方可以根据数据包的序列号对它们进行重新排序；
序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。
除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。
#### point3
当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以使用更多的通信次数交换相同的信息，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。
这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。
#### 结论
TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：
- 『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；
- 『四次握手』：TCP 协议的设计可以让我们同时传递 ACK 和 SYN 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；

### 第一次握手时可以携带应用数据吗
不行，因为此时连接还没有建立。
是否可以由接收方将应用数据缓存起来，等到三次握手完成，连接建立之后，再由接收方交给上层应用呢？
也不行，这样会放大 TCP SYN Flood 攻击，如果攻击者伪造了大量的携带数据报文，那么接收方就需要大量的内存来临时存储应用数据，最终导致内存耗尽。
### 第二次握手时可以携带应用数据吗？
第二次握手是接收方向发送方发送数据，虽然可以携带数据，但是没有任何实质意义。

### 第三次握手时可以携带应用数据吗？
可以。
发送第三次握手之前，发送方此时已经进入 ESTABLISHED 状态，所以只要第三次握手的报文到达接收方，那么接收方的状态也会进入 ESTABLISHED 状态，连接就算建立完成了。
此时接收方将发送方在第三次握手时携带的应用数据，转交给上层应用即可。
那这样就不会引发 TCP SYN Flood 攻击吗？
作为攻击者来说，也是需要考虑攻击成本的，如果在第三次握手携带应用数据，就会建立起正常的 TCP 连接，攻击者同样需要资源来存储建立的连接，对于攻击者来说，这是本末倒置的。如果攻击者是远程操纵 “肉鸡” 进行攻击的话，直接在连接建立完成后，让 “肉鸡” 发送海量应用请求就可以了，没有必要在第三次握手时携带应用数据。

## 四次挥手
![](/images/byebye.png)
- 第一次(假设客户端先手)：FIN为1，ACK=0,随机一个seq,此时不发送有效数据，仍然可以接受数据
- 第二次：ACK=1,ackNum为seq+1,此时服务器仍然可以发送数据
- 第三次：FIN为1，ACK=0,随机一个seq，此时服务器不发送有效数据
- 第四次：ACK=1,ackNum为seq+1
## 拥塞控制
- 发送方跟踪额外的变量:拥塞窗口(cwnd),注意这与流量控制不同，**不体现在tcp头部中**
- LastByteSent-LastByteAcked<=min{cwnd,rwnd}
- 初始化时，cwnd通常为1个MSS，然后进入慢启动(指数增长),遇到拥塞，cwnd减半，并设置ssthresh=cwnd/2(慢启动阈值),结束慢启动
- TCP的拥塞控制：每个RTT内cwnd线性增加1个MSS，出现3个冗余ACK时，cwnd减半（加性增、乘性减）
# IP
## ipv4
![](/images/IP.png)
### 关键字段
- 版本号：4比特，定义是ipv4还是ipv6
- 首部长度：4比特，定义首部长度
- 服务类型：8比特，服务类型(延时低，高吞吐等)
- 数据包长度：ip数据报总长度（首部+数据）
- 标识、标志、偏移：ip分片有关
- 寿命：8字节，没经过一个路由减1,为0时丢弃
- 协议：表示上层协议（UDP还是）
- 首部校验和：只针对头部计算，注意由于寿命会变，所以需要不断的更新
- 源和目的ip地址：没啥好说
- 选项：很少使用，ipv6中就没有
- 有效数据
### 数据报分片
![](/images/IP_fra.png)
- 之前提到过，一个链路层帧能承载的最大数据量叫做**最大传送单元（MTU）**
- 广域网和局域网可能MTU不同所以要分片
- 分片的重组放在端系统中，路由器不负责重组
- 最后一片标志被置为0
### ipv4编址
- 接口：主机与物理链路之间的边界叫做接口
- ip地址：IP协议要求每台主机和路由器的接口拥有自己的IP地址
**从技术上来讲一个ip地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联**
- 子网掩码：a.b.c.d/x,x最高比特构成了IP地址的网络部分，为网络前缀
- CIDR：无类别域间路由选择，这种更灵活
- 分类编址（不灵活）：A类子网(8bit)，B类子网(16bit)，C类子网(24bit),会有c类太少，b类太大的烦恼
### DHCP动态主机配置协议
性质：基于UDP的应用层协议,默认端口67
作用： 除了分配IP地址外，DHCP还允许获取其他信息子网掩码，默认网关（第一跳路由器），本地DNS服务器地址
![](/images/DHCP.png)
### 网络地址转换-NAT
- 会改写IP地址和端口号
![](/images/NAT.png)
## ipv6
![](/images/IPV6.png)
- 版本：显然设为6
- 流量类型：与ipv4服务类型类似
- 流标签：标识一条数据报的流，还未完全确定
- 有效载荷长度
- 跳限制：计数为0丢弃
### ipv4->ipv6:隧道
![](/images/tunneling.png)
## 通用转发和SDN
- OpenFLow标准
- SDN
- 就是根据各层的头信息执行特定转发，有更大灵活性，跳出IP转发的局限性

