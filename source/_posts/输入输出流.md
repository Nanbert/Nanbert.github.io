---
title: 输入输出流
date: 2021-03-11 17:33:06
subtitle:
categories:
tags:
index_img: /images/stream.jpg
banner_img: /images/stream.jpg
---
1.操纵符

|操纵符|含义|
|:-:|:-:|
|boolalpha|将true和false输出为字符串|
|\*noboolalpha|将true和false输出为1,0|
|showbase|对整型值输出表示进制的前缀|
|\*noshowbase|不生成表示进制的前缀|
|showpoint|对浮点值总是显示小数点|
|\*noshowpoint|只有当浮点值包含小数部分时,显示小数点|
|showpos|对非负数显示+|
|\*noshowpos|对非负数不显示+|
|uppercase|在十六进制中打印0X,在科学计数法中打印E|
|\*uppercase|在十六进制中打印0x,在科学计数法中打印e|
|\*dec|整型值显示为十进制|
|hex|整型值显示为十六进制|
|oct|整型值显示为十进制|
|left|左对齐,在值的右侧添加填充字符|
|right|右对齐,在值的左侧添加填充字符|
|internal|左对齐符号,右对齐值,在值和符号之间添加填充字符|
|fixed|浮点值显示为定点十进制|
|scientific|浮点值显示为科学计数法|
|hexfloat|浮点值显示为十六进制(c++11)|
|defaultfloat|重置浮点值显示为十进制(c++11)|
|unitbuf|每次输出操作后都刷新缓冲区|
|\*nounitbuf|恢复正常的缓冲区刷新方式|
|\*skipws|输入运算符跳过空白符|
|noskipws|输入运算符不跳过空白符|
|flush|刷新ostream缓冲区|
|ends|插入空字符,然后刷新ostream缓冲区|
|endl|插入换行符,然后刷新ostream缓冲区|
|setprecision([int])|在iomanip,接受一个int值,来设置精度,见详解|
|setfill([char])|在iomanip,用一个字符填充空白|
|setw([int])|在iomanip,指定值的最小宽度,注意它只影响接下来的那个值|
|setbase([int])|在iomanip,将整数输出为某进制|

2.流对象的成员函数

|成员函数|含义|
|:-:|:-:|
|precision()|返回当前精度值|
|precision(int)|将精度设置为此值,返回旧精度|
|is.get(ch)|从istream is读取下一个字节存入字符ch。返回is|
|os.put(ch)|将字符ch输出到ostream os。返回os|
|is.get()|将is的下个字节作为int返回,不返回char的原因是可以多存个结尾符,与cstdio里的EOF做比较|
|is.putback(ch)|将字符ch放回is。返回is|
|is.unget()|将is向后移动一个字节。返回is|
|is.peek()|将下个字节作为int返回。但不从流中删除|
|is.get(sink,size,delim)|从is中读取最多size字节,并保存在字符数组中,字符数组的起始地址由sink给出。读取过程知道遇到字符delim或读取了size个字节或遇到文件尾。如果遇到delim，将其留在输入流中，不读取出来存入sink|
|is.getline(sink,size,delim)|与接受三个参数的类似，但会丢弃delim|
|is.read(sink,size)|读取最多size个字节，存入字符数组sink中，返回is|
|is.gcount()|返回上一个未格式化读取操作从is读取的字节数|
|os.write(source,size)|将字符数组source中的size个字节写入os，返回os|
|is.ignore(size,delim)|读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾|

3.流的随机访问(只支持fstream,sstream)

|函数|含义|
|:-:|:-:|
|tellg()|返回输入流中标记的当前位置|
|tellp()|返回输出流中标记的当前位置|
|seekg()|在一个输入流中将标记重定位到给定的绝对地址。pos通常是tellg的返回值|
|seekp()|在一个输出流中将标记重定位到给定的绝对地址。pos通常是tellp的返回值|
|seekg(off,from)|在一个输入流中将标记定位到from之前(off为负的时候)或之后off个字符。from是下列的值:beg(流开始位置)，cur(当前位置)，end(结尾位置)|
|seekp(off,from)|(输出流同上)|

4.getline()函数
getlint([istream],[string])从输入流中读取一行，并舍弃换行符，赋值给string
5.流的状态位

|状态成员(类型为strm::iostate)|成员函数|函数意义|
|:-:|:-:|:-:|
|badbit|s.bad()|strm:badbit用来指出流已经奔溃。若流s的badbit置位，成员函数返回true，这个一般由系统造成，一般这个流就废了|
|failbit|s.fail()|strm::failbit用来指出一个IO操作失败。若s的failbit置位，成员函数返回true,流还可以修正继续使用|
|eofbit|s.eof()|strm::eofbit用来指出流到达结尾。若s的eofbit置位，成员函数返回true|
|goodbit|s.good()|strm::goodbit用来指出流未处于错误状态。若上述三个被置位任何一个，成员函数返回true|
||s.clear()|所有条件状态复位，流状态设置为有效，返回void|
||s.clear(flags)|根据给定的flags标志位，进行条件置位，如：`cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit)`只对failbit和badbit复位，其余保持不变|
||s.rdstate()|返回流当前状态，类型为strm::iostate|

6.流之间的关联
一般情况下cin和cerr被关联到cout,所以cin操纵之后，都会刷新cout的缓冲区
cin.tie()会返回关联的输出流的指针
cin.tie([\*os])关联流到该指针
每个流最多关联到一个输出流，但多个流可以同时关联到同一个输出流。
istream可以关联ostream的对象，ostream也可以关联到ostream的对象，也可以关联到一个空指针。
7.文件模式

|文件模式|含义|
|in|以读方式打开|
|out|以写方式打开|
|app|每次写操作前均定位到文件末尾|
|ate|打开文件后立刻定位到文件末尾|
|trunc|截断文件|
|binary|以二进制方式进行IO|

文件模式指定之间以‘|’分割，并有如下限制:
-只可以对ofstream或fstream对象设定out模式
-只可以对ifstream或fstream对象设定in模式
-只有当out模式设定时才可以设定trunc模式
-只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出模式打开
-默认情况下，即使我们没有指定trunc,out模式打开的文件也会被截断，或者同时指定app模式或者in模式
-ate和binary可以用于任何文件流对象，可以与其他模式任意组合
4.精度
默认情况下,精度会控制打印的数字的总数。打印时,<font color=#FF0000>浮点值按当前精度舍入而非截断</font>,在执行scientific,fixed或hexfloat后,精度值控制的是小数点后面的数字位数

1.scanf与printf
格式:`scanf("format_specifier",&val)`与`printf("format_specifier",&val)`
例子:
```C++
char ch;
double d;
scanf("%c %lf",&ch,&d);
printf("%c %lf",ch,d);
```
|:-:|:-:|:-:|
|类型|格式|大小|
|int|%d|32bit|
|long|%ld|64bit|
|char|%c|16bit|
|float|%f|32bit|
|double|%lf|64bit|
2.float与double固定小数点后的位数输出
```C++
float a=8.333291;
printf("%.03f",a);//小数点后面保留3位
cout.precision(3);
cout<<fixed<<endl;//保留3位

```
3.进制转换
十六进制 `cout<<hex;`
十进制 `cout<<dec`;
八进制 `cout<<oct`;
