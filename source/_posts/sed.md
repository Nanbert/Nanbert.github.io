---
title: 'sed'
date: 2019-07-18 18:16:15
subtitle:
categories: 文本处理
tags:
index_img: /img/sed.jpeg
banner_img: /img/sed.jpeg
---
### sed作用原理
sed首先将整个编辑脚本应用于第一个输入行(存在模式空间)，然后再读取第二个输入行。sed总是处理原始行的最新形式，所以生成的任何编辑动作都会作用于后续命令。
### sed选项总结

|options|describe|example|
|:-:|:-:|:-:|
|-e|编辑随后的指令|`sed -e 's/brown/green/;s/dog/cat/' data.txt`|
|-f|跟随脚本中的文件名|
|-n|阻止输入行的自动输出|
|-r|支持扩展的正则表达式|
|-i|直接修改读取的文件内容,而不是由屏幕输出|
### 在命令行上指定多重命令
- `sed 's/MA/ma/; s/FA/fa/' file`
- `sed -e '/MA/ma/' -e 's/FA/fa/' file`
- bash等通用,输入单引号后回车,会出现`>`多行输入提示符
sed为流编辑器,一次读取一行内容,并执行相应的命令,格式如下:
`sed [options] '[command]' (file)`

### sed地址表示方法

|地址|说明|
|:-:|:-:|
|n|行号,n是一个正整数|
|$|最后一行|
|/regexp/|正则表达式匹配行|
|addr1,addr2|从addr1到addr2范围内的文本行,包含地址addr2在内,地址是上述任意的地址形式|
|first~step|匹配由数字first代表的文本行,然后随后的每个在step间隔处的文本行。例如1~2代表奇数行|
|addr1,+n|匹配地址addr1和随后的n个文本行|
|addr!|匹配所有文本行,除了addr之外,addr是上述任意的地址形式|

### 分组命令
sed使用大括号`{}`将一个地址嵌套在另一个地址上，或在相同的地址上应用多个命令，左大括号必须在行末，右大括号独占一行，之后必须没空格
**例1：**
```bash
1,5{
/^$/d
}
```
**例2：**
```bash
1,5{
/^$/d
s/a/b/
}
```

### 替换s
`[address]s/pattern/replacement/flags`
#### 替换的标志位

|flag|含义|
|:-:|:-:|
|n|1到512之间的一个数字,表示对文本模式中指定模式第n次出现的情况进行替换|
|g|对模式空间的所有出现的情况进行全局更改|
|p|打印模式空间的内容,可以加感叹号，表示不打印|
|W <file>|将模式空间的内容写到文件file中|

#### 替换部分的元字符
- `&`:表示命中的正则表达式
- `\`:后面可接回车,其他元字符转义
- `\<n>`:表示匹配的部分,在pattern中用`\(`和`\)`括起来

#### 界定符
- 如果模式中含有'/'可以用感叹号作定界符,如`s!/usr/mail!/usr2/mail!`
- 注意地址的界定符不能这么玩

### 删除d
匹配到这个地址就删除模式空间内容,并且会导致不再执行接下来的脚本，读取新的行。
### a、i、c
- 追加`[line-address(单行)]a\
		\<text\>`
  加入模式空间内容之后
- 插入`[line-address(单行)]i\
		\<text\>`
  插入模式空间内容之前
- 更改`[address(可以是范围)]c\
		\<text\>`
  替换模式空间(范围的话,替换范围内的内容)的内容
#### 注意项
- 每一个都要求后面跟一个反斜杠转义第一个行尾,text必须从下一行开始
- text内容如果是多行,则行末要加反斜线,最后一行不需要
- 如果更改存在于组命令中,且是个范围，则会存在每一行都替换,而不是范围替换一次
- 插入与追加的文本内容不受命令影响,也不影响行计数器
- 更改命令则与删除命令类似,接下来的脚本不会作用，会立刻读入新行
### 读和写命令
- `[line-address]r file`读入某个文件的内容,追加到模式空间后
- `[address]w file`把模式空间内容写到某个文件
#### 注意项
- 文件不存在不会报错
- 如果一个脚本中有多个指令写到同一个文件,那么每个写命令都将追加到这个文件
- 读的内容不受之后命令影响
- sed最多打开10个文件
### 其他命令
- 列表`[addess]l`:不仅显示内容,非打印字符显示为两个数字的ASCLL代码
- `[line-address]=`:不打印内容,但打印行号
- `[address]n`:输出模式空间内容(没抑制输出的话),读取输入的下一行,并且后续命令用于新行,之前的命令不会用于新行
- `[line-address]q`:停止读入新行，退出脚本,经常用来打印前几行
- 转换`[address]y/abc/xyz/`(类似于tr),有用的例子转换大小写y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
### 反斜线圆括号用法
`s/\([0-9]\)-\([0-9]\)/\2-\1/g`指交换斜杠前后的两个数字
### 多行模式N
多行模式空间:多行Next(N)命令通过读取新的输入行,并将它添加到模式空间的现有内容来创建多行模式空间。模式空间最初的内容和新的输入行之间用换行符分隔。在模式空间中嵌入的换行符可以用转义序列"\n"来匹配。在多行模式空间中,元字符"^"匹配空间中的第一个字条,而不匹配换行符后面的字符。同样,"$"只匹配模式空间中最后的换行符,而不匹配任何嵌入的换行符。在执行Next命令之后,控制将被传递给脚本中的后续命令。
这与next不同，next不创建多行模式，它输出内容，然后，读取新的行。
举例:例如要将"Owner and Operator Guide"换成"Installation Guide",对于处于不同行的情况可以这样做:
```bash
/Operator$/{
N
s/Owner and Operator\nGuide/Installation Guide/
}
```
上面比较不普遍,更普遍做法是:
```bash
s/Owner and Operator Guide/Installtion Guide/
/Owner/{
N
s/ *\n/ /
s/Owner and Operator Guide */Installation Guide\
/
}
```
### 多行模式D
删除命令(d)删除模式空间的内容并导致读入新的输入行,从而在脚本的顶端重新使用编辑方法。删除命令(D)稍微有些不同:它删除模式空间中直到第一个嵌入的换行符的这部分内容。他不会导致读入新的输入行,相反,**它返回到脚本的顶端**,将这些指令应用于模式空间的剩余内容。
例子:
```bash
/^ $/{
N
/^ \n$/D
}
```
以上可以删除连续多个空行,只保留一个空行
### 多行模式P
该命令输出多行模式空间的第一部分，直到第一个嵌入的换行符为止。  
P命令经常出现在Next命令之后和Delete命令之前，建立一个输入/输出循环，用来维护两行的模式空间，这样就能之输出第一行，然后返回到脚本的顶端，用于第二行。
### 保持空间
保持空间:当改变模式空间中的原始内容时,用于保留当前输入行的副本。影响模式空间的命令
|命令|缩写|功能|
|:-:|:-:|:-:|
|Hold|h或H|将模式空间的内容复制或追加到保持空间(大写追加)|
|Get|g或G|将保持空间的内容复制或追加到模式空间(大写追加)|
|Exchange|x|交换保持空间和模式空间的内容|

### 高级的流控制命令  
- 分支:在脚本中将控制转移到另一行
```bash
:top
command1
command2
/pattern/b top
command3
```
如果没有定义top或没有标签(可以为任意命名),则将跳转到脚本末尾,上面例子意思是如果找不到pattern,才执行commmand3
**注意**不要在标签后加空格
- 测试:如果当前匹配行上成功进行了替换,那么test命令就会转到标签处,用法和分支一样,把b改成t即可
```bash
/sth/{
s/a/b/
t
s/c/b/
t
s/d/b/
}
```
一旦一个替换被执行，控制就到脚本末尾
### 一些例子
- `sed '52q;d' file`打印52行，效率高
- `cat jane.txt | tr '[A-Z]' '[a-z]' | tr ';.?\047,():"-' ' '|tr ' ' '\012' | grep -v '^ *$' | sort | uniq -c | sort -n`:统计单词数,首先大写替换为小写，然后替换标点为空格,再替换空格为换行,去空行,排序，计数，再排序。
- `sed 'G' file`在每行后添加个空行
- `sed -n "$!N;/^(.*)n1$/!P;D' test.txt`删除文件中连续且重复的行
- `sed '/^$/d;G'`保证每一行后都有个空行，会删除连续空行，并添加空行
- `sed 'n;d' test.txt`删除偶数行
- `sed '/regex/{x;p;x}' test.txt`匹配regex之前添加空行
- `sed '/regex/G' test.txt`匹配regex之后添加空行
- `sed '/regex/{x;p;x;G;}' test.txt`之前之后都添加空行
- `sed 'n;n;n;n;G'`每5行添加一个空行或`sed '0~5G' text.txt`
- `sed '=' test.txt | sed 'N;s/s*ns*/t/'`给每一行添加行号，以制表符分隔
- `sed '/./=' test.txt | sed '/./N; s/s*ns*/t/'`为非空行添加行号
- `sed -n '$=' test.txt`统计行数
- `sed 's/^[[:blank:]]*|[[:blank:]]*$//' test.txt`删除行首和行尾空白
- `sed '1!G;h;$!d' test.txt`反转每一行的顺序(类似tac)
- `sed '/n/!G;s/(.)(.*n)/&21/;//D;s/.//'`反转每一行的字母顺序(类似rev)
- `sed -e ':a' -e 's/([0-9])([0-9]{3})($|,)/1,2/;ta' test.txt`给数字串加逗号或`sed -e ':a' -e 's/(.*[0-9])([0-9]{3})/1,2/;ta' test.txt`
- `sed 'q' test.txt`打印文件第一行
- `sed -n 'N;P' file`打印奇数行
- `sed -n '/regex/{n;p}' test.txt` 打印匹配那一行的后一行
- `sed -n '/regex/{=;x;1!p;g;$!N;p;D;}; h' test.txt`  打印匹配“regex”那一行的前后一行，并且打印匹配行的行号(类似grep -A1 -B1)
- `sed -n '/^.{65}/p' test.txt`打印长于65个字符的行
- `sed '/^$/N;/n$/D' test.txt`压缩连续空行(类似于cat -s)
- `sed '/./,$!d'`删除文件开头的空行
- `sed ':a;/^n*$/{$d;N;ba}' test.txt`删除文件结尾空行

