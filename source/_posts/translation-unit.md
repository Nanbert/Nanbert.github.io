---
title: translation_unit
date: 2024-03-30 17:46:13
tags:
index_img: /images/units_translate.jpg
banner_img: /images/units_translate.jpg
---

# 编译过程
![](/images/compile_process.png)
# static
- static修饰的全局变量或函数旨在当前文件可见属于内部链接
- 非static修饰的全局变量和函数在不同编译单元，如果有相同的名字，会产生编译错误
- static的局部变量的是否内外部连接依赖于所在函数的连接属性
# extern
- extern修饰的变量或函数必须定义在唯一一个编译单元
- 函数默认就是extern，无需加extern修饰符
# const和constexpr
- const和constexpr变量是内部连接(inline修饰符除外)
- const变量在不同编译单元，有不同的地址
- 最好不要和inline一起用，尽管会使const成external linkage,但会造成可能undefined behaviour
# inline
- inline修饰的函数或变量，可以被多次包含而不被编译器报重定义错误
- inline entities cannot be exported, namely, used by other translation units even
if they have external linkage (related warning: -Wundefined-inline )
- inline doesn’t mean that the compiler is forced to perform function inlining. It
just increases the optimization heuristic threshold

# namespace
- 匿名的namespace是内部连接
# No Linkage
- 局部变量（非static）
- 函数
- 类
# Internal Linkage
- static 全局变量
- const或constexpr(non-inline,non-template,non-specialized,non-extern)
- static 函数
- 匿名namespace内的所有内容包括类
# External Linkage
- 没修饰符的全局变量(extern除外)
- template/specialized的全局变量
- inline的全局变量 const????????
- 没有修饰符的函数
- template/specialized的函数
- 枚举，类以及它们的静态、非静态成员
# ODR
## Rules
1) In any (single) translation unit, a template, type, function, or object, cannot
have more than one definition
- Compiler error otherwise
- Any number of declarations are allowed
2) In the entire program, an object or non-inline function cannot have more
than one definition
- Multiple definitions linking error otherwise
- Entities with internal linkage in different translation units are allowed, even if their
names and types are the same
3) A template, type, or inline functions/variables, can be defined in more than
one translation unit. For a given entity, each definition must be the same
- Undefined behavior otherwise(为啥不报错误)
- Common case: same header included in multiple translation units
## 编译器辅助flag
以下flag可以帮助检查rule
- -detect-odr-violations flag for gold/llvm linker
- -Wodr -flto flag for GCC
- Clang address sanitizer + ASAN OPTIONS=detect odr violation=2
## UnknownTitle
- 模板，类型或inline 函数和变量可以在不同单元定义(定义肯定是一样的，最简单例子头文件可被多个文件包含)
  - 连接器会移除inline/template多余的定义
  - inline / template entities have the same linkage as the corresponding variables/functions without the specifier
  - inline / template entities have a unique memory address across all translation units
## function template case
- case 1
```C++
//==========================
header.hpp:
template<typename T>
void f(T x) {}; // DECLARATION and DEFINITION
//===========================
main.cpp:
# include "header.hpp"
int main() {
f(3); // call f<int>()
f(3.3f); // call f<float>()
f('a'); // call f<char>()
}
//=====================================================
source.cpp:
# include "header.hpp"
void h() {
f(3); // call f<int>()
f(3.3f); // call f<float>()
f('a'); // call f<char>()
}
//=====================================================
f<int>() , f<float>() , f<char>() are generated two times (in both translation units)
```
- case 2
```C++
//==================================
header.hpp:
template<typename T>
void f(T x); // DECLARATION
//=================================
main.cpp:
# include "header.hpp"
int main() {
f(3); // call f<int>()
f(3.3f); // call f<float>()
// f('a'); // linking error
} // the specialization does not exist
//=================================
source.cpp:
# include "header.hpp"
template<typename T>
void f(T x) {} // DEFINITION
// template SPECIALIZATION
template void f<int>(int);
template void f<float>(float);
// any explicit instance is also
// fine, e.g. f<int>(3)
```
- case 3
```C++
//==================================
header.hpp:
template<typename T>
void f() {} // DECLARATION and DEFINITION
//==================================
main.cpp:
# include "header.hpp"
int main() {
f<char>(); // use the generic function
f<int>(); // use the specialization
}
//=================================
source.cpp:
# include "header.hpp"
template<>
void f<int>() {} // SPECIALIZATION
// DEFINITION
```
- case 4
```C++
//===============================
header.hpp:
template<typename T>
void f() {} // DECLARATION and DEFINITION
//============================
main.cpp:
# include "header.hpp"
extern template void f<int>();
// f<int>() is not generated by the
// compiler in this translation unit
int main() {
f<int>();
}
//==========================
source.cpp:
# include "header.hpp"
void g() {
f<int>();
}
// or 'template void f<int>(int);'
```
- case 5
```C++
//===================
header.hpp:
template<typename T>
void f(); // DECLARATION
// template<> // linking error
// void f<int>() {} // multiple definitions -> included twice
// full specializations are like standard functions
// it can be solved by adding "inline"
//===================
main.cpp:
# include "header.hpp"
int main() {}
//=====================
source.cpp:
# include "header.hpp"
// some code
```
## class template case
- case 1
```C++
//=====================header.hpp:
template<typename T>
struct A {
T x = 3; // "inline" DEFINITION
void f() {}; // "inline" DEFINITION
};
//====================main.cpp:
# include "header.hpp"
int main() {
A<int> a1; // ok
A<float> a2; // ok
A<char> a3; // ok
}
//===================source.cpp:
# include "header.hpp"
int g() {
A<int> a1; // ok
A<float> a2; // ok
A<char> a3; // ok
}
```
- case 2
```C++
//==========================header.hpp:
template<typename T>
struct A {
T x;
void f(); // DECLARATION
};
# include "header.i.hpp"
//==========================header.i.hpp:
template<typename T>
T A<T>::x = 3; // DEFINITION
template<typename T>
void A<T>::f() {} // DEFINITION
//==========================main.cpp:
# include "header.hpp"
int main() {
A<int> a1; // ok
A<float> a2; // ok
A<char> a3; // ok
}
//==========================source.cpp:
# include "header.hpp"
int g() {
A<int> a1; // ok
A<float> a2; // ok
A<char> a3; // ok
} 
```
- case 3
```C++
//============================header.hpp:
template<typename T>
struct A {
T x;
void f(); // DECLARATION
};
//============================main.cpp:
# include "header.hpp"
int main() {
A<int> a1; // ok
// A<char> a2; // linking error
} // 'f()' is undefined
// while 'x' has an undefined
// value for A<char>
source.cpp:
# include "header.hpp"
template<typename T>
int A<T>::x = 3; // initialization
template<typename T>
void A<T>::f() {} // DEFINITION
// generate template special
template class A<int>;
```

# notes
- If the same identifier within a translation unit appears with both internal and external linkage,
the behavior is undefined
- inline , constexpr (which implies inline for functions) functions are not
accessible by other translation units even with external linkage
