---
title: Cpp-左右值
date: 2025-05-17 12:34:21
tags:
index_img: /images/LRValue.webp
banner_img: /images/LRValue.webp
---
# 原因
原因是C++为了兼容C，同时他既要高层的抽象，又离不开底层的限制，导致的，属于历史包袱
# 函数返回值
- C语言中函数返回值首先用一个或多个寄存器进行传递
## 寄存器空间不够
```C++
struct Test {
    long a, b, c;
}
struct Test Demo(){
    struct Test t = {1,2,3};
    return t;
}
```
如上，如果寄存器空间不够，编译器其实把返回值变成了出参，直接拿着将要接受返回值的变量地址进到函数里面来处理。
即**函数返回值会被转换为出参，内部直接操作外部栈空间**
## 只用返回值的部分
```C++
struct Test {
  long a, b, c;
};

struct Test Demo1() {
  struct Test t = {1, 2, 3};
  return t;
}

void Demo2() {
  long a = Demo1().a; // 只要其中的一个成员
}
```
编译器还是会分配一片用于保存返回值的空间，把这个空间的地址写在rdi中，然后拿着这个空间到Demo1中来操作。等Demo1函数执行完，再根据需要，把这片空间中的数据复制给局部变量a
等价于
```C++
void Demo2() {
  struct Test tmp = Demo1(); // 注意这个变量其实是匿名的
  int a = tmp.a;
}
```
## 总结
在C语言中函数返回值做如下处理
- 如果能在一个寄存器存下，就会存到寄存器中
- 如果在一个寄存器存不下，就会考虑拆分到多个寄存器中
- 如果多个可用的寄存器都存不下，就会考虑直接用内存来存放，在调用函数之前先开放一片内存空间用于储存返回值，然后函数内部直接使用这片空间
- 如果调用方直接接收函数返回值，那么就会直接把这片空间标记给这个变量
- 如果调用方只使用返回值的一部分，那么这片空间就会成为一个匿名的空间存在（只有地址，但没有变量名）
## C++构造和析构的问题
```C++
struct Test {
  Test() {}
  ~Test() {}
};

Test Demo1() {
  Test t;
  return t;
}

void Demo2() {
  Test t = Demo1();
}
```
由于构造函数和析构函数跟变量生命周期相绑定了，因此这时并不能直接把「函数返回值转出参」了，而是先生成一个局部变量，然后通过拷贝构造函数来构造「返回值」，再析构这个局部变量。所以整个过程会多一次拷贝和析构的过程
这么做，是为了保证对象的行为自闭环，但只有当析构函数和拷贝构造函数是非默认行为的时候，这样做才有意义，如果真的就是 C 类型的结构体，那就没这个必要了，按照原来 C 的方式来编译即可。因此 C++在这里强行定义了**「平凡（trivial）」类型**的概念，主要就是为了指导编译器，对于平凡类型，直接按照 C 的方式来编译，而对于非平凡的类型，要调用构造和析构函数，因此必须按照新的方式来处理（刚才例子那样的方式）。
## 直接使用部分返回值
```C++
struct Test {
  Test() {}
  ~Test() {}
  int a;
};

Test Demo1() {
  Test t;
  return t;
}

void Demo2() {
  int a = Demo1().a;
}
```
这里仍然会分配一个匿名的空间用于接收返回值，然后再从这个匿名空间中取值复制给局部变量a。从上面的代码能看出，匿名空间在rbp-8的位置，局部变量a在rbp-4的位置。但这里非常有意思的是，在给局部变量赋值后，立刻对匿名空间做了一次析构（所以它把rbp-8写到了rdi中，然后call了析构函数）。**「如果用匿名空间接收函数返回值的话，在处理完函数调用语句后，匿名空间将会被析构」**
# 左右值
## 纯右值(prvalue)
举例来说，1这就是个纯右值，它在汇编中就是一个单纯的常数。然后就是返回值通过寄存器来进行的这种情况。对于 C/C++这种语言来说，我们可以尽情操作内存，但没法染指寄存器，所以在它看来，寄存器中的数就跟一个常数值一样，只能感知到它的值而已，不能去操控，不能去改变。换一种说法，prvalue 就是「没有内存实体」的值，常数没有内存实体，寄存器中的数据也没有内存实体。所以 prvalue 没有地址。
## 将亡值(xvalue)
返回值」被保存在一个匿名的内存空间中，它在完成某一个动作之后就失效了（非平凡析构类型的就会调用析构函数）。比如用上一节的例子来说，从Demo1函数的返回值（匿名空间）获取了成员a交给了局部变量，然后，这个匿名空间就失效了，所以调用了~Demo析构函数。我们把这种值称为 xvalue（将亡值），xvalue 也有内存实体。
## 左值与将亡值区别
在 C++中生命周期比在 C 中更加重要，在 C 中讨论生命周期其实仅仅在于初始化和赋值的问题（比如说局部 static 变量的问题），但到了 C++中，生命周期会直接决定了构造和析构函数的调用，因此更加重要。xvalue 会在当前语句结束时立刻析构，而 lvalue 会在所属代码块结束时再析构。所以针对于 xvalue 的情况，在 C 中并不明显，反正我们是从匿名的内存空间读取出数据来，这件事情就结束了；但 C++中就会涉及析构函数的问题，这就是 xvalue 在 C++中非常特殊的原因。
## xvalue 取址问题与 C++引用
对于 prvalue 来说，它是纯「值」或「寄存器值」，因此不能取地址，这件事无可厚非。但对于 xvalue 来说呢？xvalue 有内存实体，但为什么也不能取地址呢？

原因就是在于，原本 C 语言在设计这个部分的时候，函数返回值究竟要写到一个局部变量里，还是要写到一个匿名的内存空间里这件事是不能仅通过一个函数调用语句来判断，而是要通过上下文。也就是说，struct Test t = Demo1();的时候，t本身的地址就是返回值地址，此时返回值是 lvalue（因为t就是 lvalue）；而如果是int ta = Demo1().a;的时候，返回值的地址是一个匿名的空间，此时返回值就是 xvalue，而这里的ta就不再是返回值的地址。所以，如果你什么都不给，单纯给一个Demo1();，编译器就无法判断要选取哪一种方式，所以干脆就不支持&Demo1();这种写法，你得表达清楚了，我才能确定你要的是谁的地址。所以前一种情况下的&t就是返回值所在的地址，而后一种情况的&ta就并不是返回值所在地址了。

原本 C 中的这种方式倒是也合理，但是 C++却引入了「引用」的概念，希望让「xx 的引用」从「语义上」成为「xx 的别名」这种感觉。但 C++在实现引用的时候，又没法做到真的给变量起别名，所以转而使用指针的语法糖来实现引用。比如说：
```C++
int a = 5;
int &r = a;
```
语义上，表达的是「a是一个变量，r代指这个变量，对r做任何行为就等价于对a做同样的行为，所以r是a的替身（引用）」。但实际上却做的是「定义了一个新的变量pr，初始化为a的地址，对p做任何行为就等价于对*pr做任何行为，这是一个取地址和解指针的语法糖」。

既然本质是指针，那么指针的解类型就是可以手动定义的，同理，变量的引用类型也是可以手动定义的。（本质上就不是别名，如果是别名的话，那类型怎么能变化呢？）比如说：
```C++
int a = 5;
char &r = reinterpret_cast<char &>(a);
//等价于
int a = 5;
char *pr = reinterpret_cast<char *>(&a);
```
变化的仅仅是指针的解类型而已。自然没什么问题。既然解类型可以强转，自然也就符合隐式转换特性，我们知道可变指针可以隐式转换为不可变指针，那么「可变引用」也自然可以隐式转换为「不可变引用」，比如说
```C++
int a = 5;
const int &r = a;
// 等价于：
const int &r = const_cast<const int &>(a);
// 等价于
const int *pr = &a;
// 等价于
const int *pr = const_cast<const int *>(&a);
```
绕来绕去本质都是指针的行为。刚才我们说到 rvalue 是不能取址的，那么自然，我们就不能用一个普通的引用来接收函数返回值:
```C++
Test &r = Demo1(); // 不可以！因为它等价于
Test *pr = &Demo1(); // 这个不可以，所以上面的也不可以
```
## 常引用与右值
虽然引用本质上就是指针的语法糖，但 C++并不满足于此，它为了让「语义」更加接近人类的直觉，它做了这样一件事：让用const修饰的引用可以绑定函数的返回值。

从语义上来说，它不希望我们程序员去区分「寄存器返回值」还是「内存空间返回值」，既然是函数的返回值，你就可以认为它是一个「纯值」就好了。或者换一个说法，如果你要屏蔽寄存器这一层的硬件实现，我们就不应该区分寄存器返回值还是内存返回值，而是假设寄存器足够大，那么函数返回值就一定是个「纯值」。那么这个「纯值」就叫做 rvalue。

这就是我前面提到的「语言设计」层面，在语言设计上，函数返回值就应当是个 rvalue，只不过在编译器实现的时候，根据返回值的大小，决定它放到寄存器里还是内存里，放寄存器里的就是 prvalue，放内存里的就是 xvalue。所以 prvalue 和 xvalue 合称 rvalue，就是这么来的。

而用const修饰的引用，它绑定普通变量的时候，语义上解释为「一个变量的替身，并且不可变」，实际上是「含了一次const_cast隐式转换的指针的语法糖」。

当它绑定函数返回值的时候，语义上解释为「一个值的替身（当然也是不可变的）」，实际上是代指一片内存空间，如果函数是通过寄存器返回的，那么就把寄存器的值复制到这片空间，而如果函数是通过内存方式返回的，那么就把这片内存空间传入函数中作为「类似于出参」的方式。

两种方式都同为「一个替身，并且不可变」，因此又把const修饰的引用叫做「常引用」。

等等！这里好像有点奇怪哎？！照这么说的话，常引用去接受函数返回值的情况，不是跟一个普通变量去接受返回值的情况一模一样了吗？对，是的，没错！你的想法是对的！，下面两行代码其实会生成相同的汇编指令：
```C++
struct Test {
  long a, b, c;
};

Test Demo1() {
  Test t{1, 2, 3};
  return t;
}

void Demo2() {
  const Test &t1 = Demo1();
  // 汇编指令等价于
  const Test t2 = Demo1();
}
```
同理，如果返回值是通过寄存器传递的也是一样所以，上面两个例子中，无论是t1还是t2，本质都是一个普通的局部变量，它们有内存实体，并且生命周期跟随栈空间，因此都是 lvalue。这是本文第四个重点！！「引用本身是 lvalue」。也就是说，函数返回值是 rvalue（有可能是 prvalue，也有可能是 xvalue），但如果你用引用来接收了，它就会变成 lvalue。
## 总结
- 对于非平凡类型，为了保证对象的行为完整性，函数返回值会单独作为一个临时对象，如果需要在栈上使用，那么会拷贝给栈上的变量。
- 为了希望这片临时空间能够被代码捕获到，于是允许了用常引用来绑定函数返回值。但如果这时返回值仍然保持 xvalue 的特性的话，会引入野指针问题，违背了「引用临时空间」的原意，因此不得不将这种情况改成 lvalue，让常引用所引用的空间跟随其所在的栈空间来「延长」声明周期。
- 又因为常引用有const修饰，不能修改对象，因此引入了「右值引用」，当用右值引用绑定函数返回值时，行为跟常引用是一致的，可以减少一次 xvalue 的生成，「延长」声明周期，同时还可以修改对象。
- 又发现还是直接用变量来接收函数返回值更加直观、符合直觉，而这种情况下 xvalue 的生成并没有太大的必要，因此又规定了「复制省略」，来优化这一次复制。（优化之后，用变量接收函数返回值和用右值引用接收函数返回值就完全没有区别了；而用 const 变量接收函数返回值跟用常引用接收函数返回值也没有区别了。）
# 移动语义
C++在设计时应当很单纯地认为 value 分两类：一类是变量，一类是值。变量它有内存实体，可以出现在赋值语句的左边，所以称为「左值」；值没有内存实体，只能出现在赋值语句的右边，所以称为「右值」。

但在实现时，却受到了 C 语言特性的约束（更准确来说是硬件的约束），造成我们不能把所有的右值都按照统一的方式来传递，所以才按照 C 语言处理返回值的方式强行划分出了 prvalue 和 xvalue，其作用就是用来指导析构函数的调用，以实现对象系统的自闭环。

C 语言原本就比较面相硬件，所以它的处理是对于机器来说更加合理的。而 C++则希望能提供一套对程序员更加友好的「语义」，所以它在「语义」的设计上是对人更加合理的，就比如这里的常引用，其实就是想成为一个「不可变的替身」。但又必须向下兼容 C 的解析方式，因此做了一系列的语法糖。而语法糖背后又会触发底层硬件不同处理方式的问题，所以又不得不为了区分，而强行引入奇怪的概念（比如这里的 xvalue）。

原本「找补」到这里（划分出了 xvalue 和常引用的概念后）基本已经可以子闭环了。但 C++偏偏就是非常倔强，又“贴心”地给程序员提供了「移动语义」，让当前的这个闭环瞬间被打破，然后又不得不建立一个新的理论闭环。
- 当用常引用接收函数返回值时，临时空间不会立即释放，而是跟随常引用成为了栈上的变量
## 右值引用
以 C++14 及以前的标准来说，我们发现，如果直接用一个变量来接收返回值，会多一次临时对象的拷贝和析构，用常引用虽然可以减少这一次拷贝，但常引用是用const修饰的，不可修改（如果要修改的话，还是得再去拷贝构造一个新的变量）。而为了解决这个问题，C++引入了「右值引用」。

其实这个语法完完全全就是为了解决函数返回值问题的，但为什么叫「右值引用」呢？我们在前面解释过，从语义上来说，返回值可以理解为都是 rvalue（可能是 prvalue，可能是 xvalue），因此用来接收 rvalue 的引用，就被叫做了 rvalue-reference，翻译为「右值引用」。但大家一定一定要知道的是，这是「语义」上的解释，实际只要有引用来接收函数返回值的话，它就会变成 lvalue。
从行为上来说，右值引用接收函数返回值和用常引用接收函数返回值的情况几乎完全相同，区别仅仅在于，右值引用不需要const修饰，因此可以更改。相比直接用变量来接收的情况，少了一次 xvalue 的中间值，也就减少了一次复制和析构。那么结论也就呼之欲出了：右值引用从语义上来说，是对右值的引用，但一旦完成了这种引用，其实整个过程就不会出现右值了，而是用一个左值来保存返回值，这就是我们为什么一直强调说「右值引用本身是左值」了。
## Copy Elision
C++ -fno-elide-constructors这个编译参数，其实它就是用于关闭编译器的自动复制省略的。在 C++17 以前，虽然语言标准是没有定义复制省略的，但编译器早早就发现了这个问题，于是做了一些定制化的优化（称为返回值优化，Return Value Optimization，或 RVO），这个参数就是关闭 RVO，完全按照语言标准来进行编译。而在 C++17 标准中，定义了复制省略的方式，因此编译器就必须按照语言标准定义的那样来处理返回值了，所以在 C++17 标准下，这个编译参数也就不再生效了。
## 移动语义的诞生
原本，右值引用概念的引入就是为了做返回值优化的，但有了 Copy Elision（以下简称 CE）以后，仿佛右值引用在这个场景下了一个菜鸡，但这并不意味着右值引用将会成为历史语法而惨遭淘汰。因为它还有另一个重要的用途——移动语义。
移动语义原本是为了解决资源复用问题的，我们来看下面这个实例：
```C++
class String {
 public:
  String();
  ~String();

  String(const String &);

 private:
  char *buf_;
};

// 由于算法本身不是本例程的重点，因此忽略掉一切扩容和优化问题，简单书写
String::String(): buf_(new char[1024]) {}
String::~String() {
  if (buf != nullptr) {
    delete [] buf_;
  }
}

String::String(const String &str) : buf_(new char[1024]) {
  std::memcpy(buf_, str.buf_, 1024);
}

void Demo1() {
  String str1;
  // 这里对str1做了一些操作，比如说添加了一些数据之类的
  return str1;
}

void Demo2() {
  String str = Demo1(); // 会触发一次拷贝构造
}
```
注意在上例中，我们用一个简单的字符串处理类来说明问题。Demo2中，用str来接收Demo1的返回值，这里会触发 CE，直接用Demo1中的局部变量来拷贝构造这里的str。拷贝构造会调用拷贝构造函数，而我们可以看到，拷贝构造函数中是一次内存的深复制。也就是说，我们构造str会先分配一片空间，然后把str1中的buf_对应的数据拷贝到了str的buf_中，然后跟随着Demo1的结束，刚才str1的这片空间会被释放掉（析构函数中有delete []）。

这平白多一次内部的数据复制，就成为了 C++希望优化的点。假如说，新的对象能够「直接拾取」原有对象的内部空间，岂不是可以节约资源，减少复制？于是 C++引入了「移动构造函数」和「移动赋值函数」，就是说，当你用了一个「马上就不用的对象」来构造新对象的时候，就调用这个移动构造函数，里面应当执行浅复制，来延长内部资源的寿命。

那么，怎么区分「马上就不用的对象」和「一会还要继续用的对象」呢？看这里所谓「马上就不用的对象」是不是很符合 xvalue 的定义？那我就看看，如果我是用一个 xvalue 来构造新对象的话，我就复用资源；而如果是一个普通的 lvalue 的话，那说明它后面还有用，我就复制资源。那如何表示这个参数只接受 xvalue 呢？有三种方法：1.用变量接收；2.用常引用接收；3.用右值引用接收。

那么这里，C++又从「语义」上做了区分。当右值引用做函数参数时，认为优先匹配函数返回值。什么意思呢？就是对于重载函数的情况，如果我们**直接用函数返回值作为实参的话，优先匹配右值引用的重载**。用例子来说就是：
```C++
#include <iostream>

struct Test {};

Test Demo1() {
  Test t;
  return t;
}

void f(const Test &) {
  std::cout << 1 << std::endl;
}

void f(Test &&) {
  std::cout << 2 << std::endl;
}

void Demo2() {
  Test t;

  f(t); // 1
  f(Demo1()); // 2
}
```
这里有 2 个f函数的重载，对于f(t)这种调用来说，由于t本身是普通变量，不是直接函数返回值，那么这种情况只能命中常引用的版本，所以会打印1。而对于f(Demo1())这种调用来说，两个版本的f都可以匹配，但由于我们刚才提到的优先原则，如果存在右值引用的重载版本，遇到直接用函数返回值作为形参的这种情况，优先匹配右值引用的重载，所以会打印2。

大家注意，这里的这种优先原则并没有什么道理可言，就是语言标准强行规定的，用于区分你是变量传入，还是函数返回值直接传入。所以，有了这个原则，我们就可以完善刚才的移动构造函数了：
```c++
class String {
 public:
  String();
  ~String();

  String(const String &);
  String(String &&); // 移动构造函数

 private:
  char *buf_;
};

String::String(String &&str): buf_(str.buf_) { // 直接浅复制
  str.buf_ = nullptr;
}
// 【其他函数实现省略，可以看前面的例程】

void Demo2() {
  String str = Demo1(); // 调用移动构造函数
}
```
有了这个例子我们就知道了，右值引用最大的价值已经不在于优化返回值了，而是用于标记实参是否是直接的函数返回值。
！！重点来了！！ 有些教程资料可能会这么解释：函数返回值是右值，所以有右值引用接收，所以表「移动」语义的函数参数是右值引用。乍一看这个说法好像没问题，但其实经不起推敲，因为其实整个过程没有出现任何一个右值。对于String的移动构造函数来说，str是右值引用，在它的内部就是一个普通的变量，当我们在Demo2中用他来接收Demo1返回值的时候，命中了「右值引用接收函数返回值」这一情况，根据我们之前的分析，此时str是 lvalue。所以整个过程是没有出现一个 rvalue 的。

这就是笔者反复强调，C++的「语义」和「实际处理」的区别。所以这里从语义上来说函数返回值是 rvalue，包括常数也是一种 rvalue，所以右值引用做函数参数时，用于「接收」一个 rvalue。那么这里更加强调的是语义上的「接收」，这里希望接收一个右值。但右值引用本身其实就是一个栈上的普通变量，它是 lvalue。

笔者更希望大家能够看到它的本质，右值引用做函数参数是为了优先匹配直接传入函数返回值的情况，从而跟常引用做参数来进行区分。匹配之后会按照返回值转出参的这种方式，成为一个栈上的普通变量，自然就是 lvalue。

而通常情况下，用右值引用接收一个对象，是为了复用它的资源，来进行浅复制的。就好像，我们把原本的资源「移动」到了新的对象当中去，因此称之为「移动语义」。含有移动语义的构造函数就称为「移动构造函数」、含有移动语义的赋值函数就称为「移动赋值函数」。所以大家一定要清楚，这里的「移动」是「语义」上的，并没有真的移动，一般就是用来做浅复制的。当然了，你确实可以用右值引用做参数但是不做「移动」的事情（就比如说我们之前的例子中那个f函数一样），所以更加说明了这是「语义」上的，而实际只是一个软约束。

这样一来这个值类型体系总该闭环了吧？兄弟你还是太天真了，接下来就是整个体系里最复杂的一个环节——std::move。

## std::move
刚才我们解释了如果用一个右值（函数返回值、函数返回值的一部分、或者常数）做参数时，会命中右值引用的重载版本，从而实现移动语义，做浅复制，来节省资源。

但如果我们想对一个不是右值的量做同样的事情呢？这里还是用上一节的String为例：
```C++
void Demo2() {
  String str1;

  String str2 = str1; // 这里会调用拷贝构造，因为str1是左值
}
```
如果我希望，用str1构造str2时，不用拷贝构造，而是用移动构造呢？或者说，虽然str1是个左值，但我仍然希望复用它里面的资源给到新的对象，这怎么办？这就要用到魔法操作了。我们知道，如果要进行移动语义，那么就需要用右值引用来接收。但现在str1是个左值，我们要是能给他强行「掰右」的话，不就可以「欺骗」编译器，把它当做右值来处理了嘛。反正移动语义本身就是个软约束，又不会真的去 check 入参的左右性。

所以，我们的魔法操作就是，把这个str1，伪装成右值，骗过编译器去触发右值引用的重载函数。像这样：
```C++
void Demo2() {
  String str1;

  String str2 = static_cast<String &&>(str1); // 强制转成右值引用，去触发移动构造函数
}
```
这里多说一嘴，定义新变量时后面的等号并不是赋值，而是构造参数的语法糖，也就是说上面等价于

String str2(static_cast<String &&>(str1)); // 构造参数，所以是用来匹配函数参数的
上面的这个操作由于过于魔幻，因此 STL 提供了一个工具函数来封装这个魔法操作，由于它的目的是为了触发移动语义，因此这个函数被命名为std::move，下面是它的实现：
```C++
template <typename T>
constexpr std::remove_reference_t<T> &&move(T &&ref) noexcept {
  return static_cast<std::remove_reference_t<T> &&>(ref);
}
```
因此，刚才的代码也可以写作：
```C++
void Demo2() {
  String str1;

  String str2 = std::move(str1); // 强制转成右值引用，去触发移动语义
}
```
那么这里请读者一定一定要把握一个原则，**std::move的本质是为了伪装，它并不能改变变量的左右性**。也就是说，std::move(str1)并不能把str变成 rvalue，它本身是个变量，那么它就是 lvalue，一直都是。move的作用仅仅在于，构造str2的时候能触发移动构造函数，仅此而已，其他的什么都没变。

那么也就是说，尽管我们用了「移动语义」来构造了str2，但其实str1还是存在的，该是什么样还是什么样，并不会真的被「移动」。而此时的str2是str1的浅复制版本，原本的话它们的buf_会指向同一片空间的，但因为我们在移动构造函数中强制把原来的对象buf_给置空了，因此这里str1内部会出现空指针。所以这里有一次印证了「移动语义是软约束」这件事，使用之后行为如何，会不会出问题，完全取决我们代码怎么写的。

## 总结
还有一个概念笔者一直都没有提，那就是 glvalue（广义左值，Generalized Left-side-hand Value），lvalue 和 xvalue 合称 glvalue，原因就是他们都有内存实体。但其实这个概念并不常用，主要是因为 xvalue 虽然有内存实体，但是无法直接取地址，因此在主框架的设计中，还是把 xvalue 当做 rvalue 来处理了。

C++之所以会出现这么多难搞的值类别，就是为了在兼容 C 方式的同时，提供一种更高级的语义封装。所以 C++纠结就纠结在这里，一方面希望提供一些高级的语法，让程序员可以屏蔽掉一些底层的概念。另一方面反倒又引入了奇怪的概念让程序员不得不去深入理解底层。所以笔者自己对 C++的经验就是，学习的时候要「深」，一定要搞清底层；而实际使用的时候要「高」，应当使用更加符合直觉的高级语法来屏蔽底层实现。

本篇文章并没有直接去按理论列举 C++有哪些值类型，分别是什么定义。而是带着大家从汇编指令出发，一点一点的去猜测和体会这样设计的初衷和底层原理，希望能够给读者提供一些不同角度的理解和不一样的思路。
# 参考链接
- https://www.zhihu.com/question/428340896/answer/2913419725
