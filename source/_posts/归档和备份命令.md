---
title: 归档和备份命令
date: 2020-11-19 18:58:46
subtitle:
categories:
tags:
cover: css/images/tar.jpg
---
**<font size=4>1.压缩命令</font>**
**(a) gzip**
格式:`gzip [选项] [file]`,注意这不会保留原文件,默认输出为原文件加'.gz'后,同样解压缩也不会保留原压缩文件,注意只能对文件而不能对文件夹压缩,要走出这个误区

|选项|说明|
|:-:|:-:|
|-c|把输出写入到标注输出,并保留原始文件,注意要生成压缩文件,必须重定向到一个文件,这个选项就是这么令人费解|
|-d|解压缩,等价于gunzip|
|-f|强制压缩,即使原始文件已经被压缩|
|-h|显示用法信息|
|-k|保留原文件|
|-l|列出每个被压缩文件的压缩数据|
|-r|若命令的一个或多个参数是目录,则递归地压缩目录中的文件|
|-t|测试压缩文件的完整性|
|-v|显示压缩过程的信息|
|-[number]|设置压缩指数,[number]为1(最快,最小压缩)到9(最慢,最大压缩),默认为6|

例子:
`gunzip -c foo.txt.gz | less`这可以不解压直接查看内容

**(b) bzip2**
bzip2程序程序和gzip一样,但是不支持`-r`递归选项,同时它压缩率更大,速度更慢

**<font size=4>2.归档:tar</font>**
.tar为普通的tar包,.tgz为压缩过的tar包
格式:`tar [options] [destination] [target]`

|options|作用|
|:-:|:-:|
|c|Create创建新归档文件,存在则覆盖|
|t|Table列表,磁带文件名列表|
|d|磁带与文件系统的不同|
|r|添加文件至磁带末尾|
|u|只添加更新的文件|
|x|extract抽取,抽取文件|
|v|verbose冗长|
|f|必须指定归档文件名,必须包含该选项|
|z|gzip算法压缩|
|j|bzip2算法压缩|

`--wildcards`
提取某个文件而不是全部(见例子)时一般不支持文件通配符,可通过--wildcards来支持,如:
`tar xf xx.tar --wildcards 'home/me/dir-\*/file'`
`--file-from(-T)`
这个选项导致tar命令从一个文件而不是命令行来读入它的路径名列表,可以是标准输入,例如:
`find ~ -name 'file-A'| tar cf - --files-from= -| gzip >playground.tgz`
注意上面这个例子中第一个'-'表示标准输出,第二个则是标准输入(广泛用于其他程序),上面可以不用第二个管道,直接加个z选项即可,如下:
`find playground -name 'file-A' | tar czf playground.tgz -T -`
b.举例:
`tar cvf my.tar *.[ch] makefile`不压缩创建
`tar xvf tar_file -C destination_direectory`提取文件至指定文件夹
`tar xf my.tar home/file`只提取归档文件某一文件(前提归档文件里必须有)

**<font size=4>3.归档和压缩二合一:zip</font>**
格式:`zip [options] [destination] [origin]`
<font color=#FF0000>对于目录必须加-r选项,否则只是空目录</font>,它最优化决定是否压缩文件
`-@选项`
用来接受从标准输入的列表,例:
`find playground -name "fileA" | zip -@ file-A.zip`
例子:
`unzip -l playground.zip playground/fileA`列出指定一个文件夹
`unzip playground.zip playground/fileA`提取指定一个文件夹

**<font size=4>4.同步rsync</font>**
格式:`rsync [options] [source] [destination]`
rsync会比较两者差异,最小化的复制修改以同步
这里source和destination是下列选项之一:
·一个本地文件或目录
·一个远端文件或目录,以[user@]host:path的形式存在
·一个远端rsync服务器,由rsync://[user@]host[:port]/path指定
source和destination至少有一个本地文件,不支持远端到远端
**4.1远程同步**
(1)SSH协议
rsync默认使用ssh协议,如果想传递ssh命令的附加参数,必须使用-e选项,如:
`rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination`
(2)rsync协议
如果另一台服务器安装并运行了rsync守护程序,则可以用该协议(默认端口873),具体写法是服务器与目标目录间使用冒号分割:
`rsync -av source/ 192.168.122.32::module/destination`
上面地址中的module并不是实际路径名,而是rsync守护程序指定的一个资源名,由管理员分配。
如果想知道rsync守护程序分配的所有module列表,可以执行下面命令:
`rsync rsync://192.168.122.32`
除了双冒号,也可以直接使用rsync://协议指定地址:
`rsync -av source/ rsync://192.168.122.32/module/destination`
**4.2增量备份**
除了源目录与目标目录直接比较,rsync还支持使用基准目录,即将源目录与基准目录之间变动的部分,同步到目标目录。
具体做法,第一次同步是全量备份,所有文件在基准目录里同步一份。以后每一次同步都是增量备份,只同步源目录与基准目录之间有变动的部分,将这部分保存在一个新的目标目录。这个新的目标目录之中,也是包含所有文件,但实际上,只有那些变动过的文件是存在于该目录,其他没有变动的文件都是指向基准目录文件的硬链接。
--link-dest参数用来指定同步时的基准目录:
`rsync -a --delete --link-dest /compare/path source/path /target/path`
下面是个备份用户的主目录脚本:
```bash
#!/bin/bash
set -o errexit
set -o nounset
set -o pipefail

readonly SOURCE_DIR="$(HOME)"
readonly BACKUP_DIR="/mnt/data/backups"
readonly DATETIME="$(date '+%Y-%m-%d_%H:%M:%S')"
readonly BACKUP_PATH="${BACKUP_DIR}/${DATETIME}"
readonly LATEST_LINK="${BACKUP_DIR}/latest"

mkdir -p "${BACKUP_DIR}"

rsync -av --delete \
	"${SOURCE_DIR}/" \
	--link-dest "${LATEST_LINK}" \
	--exclude=".cache" \
	"${BACKUP_PATH}"

#注意删除硬链接,只有最后为1时,才真正删除,因为i真正备份里有个指向链接,所以不会删除真正的文件
rm -rf "${LATEST_LINK}"
#注意下面是软连接,也就是说基准文件为最新的备份文件
#我的疑惑,为啥非要用中间目录,直接比较不行吗?不是脱裤放屁吗?
ln -s "${BACKUP_PATH}" "${LATEST_LINK}"
```

|选项|含义|
|:-:|:-:|
|-a|不仅递归同步,还可以同步元信息(比如修改时间、权限等),软连接也会同步过去|
|--append|参数指定文件接着上次中断的地方,继续传输|
|--append-verify|与--append参数类似,但会对传输完成后的文件进行一次校验,如果校验失败,将重新发送整个文件|
|-b|指定在删除或更新目标目录已经存在的文件时,将该文件更名后进行备份,默认行为是删除。更名规则是由--suffix参数指定的文件后缀名,默认是'\~'|
|--backup-dir|参数指定文件备份时存放的目录,比如`--backup-dir=/path/to/backups`|
|--bwlimit|参数指定带宽限制,默认是kb/s,比如`--bwlimit=100`|
|-c|默认情况下,rsync只检查文件的大小和最后修改日期是否发生变化,如果发生变化,就重新传输,使用这个参数以后,则通过判断文件内容的校验和,决定是否重新传输|
|-delete|参数删除只存在与目标目录,不存在于源目标文件,即保证目标目录是源目标的镜像|
|-e|参数指定使用SSH协议传输数据|
|--exclude|指定排除不进行同步的文件,详细用法见下|
|--exclude-from|参数指定一个本地文件,里面是需要排除的文件模式,每个模式一行|
|--existing、--ignore-non-existing|参数表示不同步目标目录中不存在的文件和目录|
|-h|略|
|-i|参数表示输出源目录与目标目录之间文件差异详细情况|
|--ignore-existing|参数表示只要该文件在目标目录中已经存在,就跳过去,不再同步这些文件|
|--include|一般与--exclude结合使用,同步时要包括的文件|
|--link-dest|参数指定增量备份的基准目录|
|-m|指定不同步空目录|
|--max-size|参数设置传输的最大文件的大小限制,比如不超过200kb`--max-size='200k'`|
|--min-size|参数设置传输的最大文件的大小限制,比如不小于200kb`--min-size='200k'`|
|-n|模拟将要执行的操作,而不真的执行,配合-v参数使用看哪些内容同步过去|
|-P|--progress和--partial这两个参数的结合|
|--partial|允许恢复中断中断的传输。不使用该参数时,rsync会删除传输到一般被打断的文件,使用该参数后,传输到一般的文件也会同步到目标目录,下次同步时再恢复中断的传输,一般要与--append或--append-verify配合使用|
|--partial-dir|参数指定将传输到一半的文件保存到一个临时目录,比如`--partial-dir=rsync-partial`,一般要与--append或--append-verify配合使用|
|--progress|表示显示进度|
|-r|表示递归|
|--remove-source-files|表示传输成功后,删除源文件|
|--size-only|表示只同步大小有变化的文件,不考虑文件修改时间的的差异|
|--suffix|参数指定文件名备份时,对文件名添加的后缀,默认是\~|
|-u|表示同步时跳过目标目录中修改时间更新的文件,即不同步这些有更新的时间戳文件|
|-v,-vv,-vvv|表示输出细节,v越多越详细|
|--version|略|
|-z|指定同步时压缩数据|

**4.3 --exclude和--include参数示范**
```bash
rsync -av --exclude='*.txt' source/ destination
rsync -av --exclude '*.txt' source/ destination
rsync -av --exclude 'file.txt' --exclude 'dir1/*' source/ destination
rsync -av --exclude={'file1.txt','dir1/*'} source/ destination
rsync -av --exclude-from='exclude-file.txt' source/ destination
rsync -av --include="*.txt" --exclude='*' source/ destination
```
