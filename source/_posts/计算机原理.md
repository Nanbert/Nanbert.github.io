---
title: 计算机原理
date: 2020-08-04 08:15:20
subtitle:
categories:
tags:
cover:
---
1.位运算相关
```
a&(b|c)=(a&b)|(a&c)
a|(b&c)=(a|b)&(a|c)
a^a=0 a^(a+1)=1(a为偶数)
a=n&(n-1)(移除n最后一个1)
diff=(n&(n-1))^n=n&(-n) (获取最后一个1)
(n^(-1))+1=-n(有符号数取反加一为其相反数)
(var^(var>>31))-(var>>31) (32位取绝对值)
```
2.位移运算
左移:<<,丢弃高位,低位补0
逻辑右移:>>,左端补0(c语言,对于无符号数,为逻辑右移)
算术右移:>>,左端补最高有效位的值(c语言,对于有符号数,为算术右移)
3.无符号与有符号的转换
a.C语言两者之间的转换，保持位模式不变,只是改变解码规则,最高位的解释由负到正,除了最高位的解释变化，其余位不变，设那些的权重和为k。
所以有符号补码的解释为-2^(w-1)+k,而无符号解释为2^(w-1)+k,w表示位数,所以两者相差2^w, 对于位模式(只考虑负数,即超过有符号表示范围的正数)相同的有以下结论:
无符号数=有符号负数+2^w
有符号负数=无符号数-2^w
有符号负数的绝对值+无符号数=2^w
b.无符号与有符号比较,c语言会都转换无符号
4.数字位的扩展
a.低位无符号向高位转换时,只要简单把多出来的位置为0
b.低位有符号向高位有符号扩展时,为保持表示的数值不变,多出的位与原来符号位保持一致,很好想,0好说,多出来的位为0即保持数不变,1的话即是负数，多出的位都置为1,记住2^w-2^(w-1)=2^(w-1),这样多出来的权重和就是没多出位之前最高的负权重(用脑子一想就知道了)
c.低位有符号向高位无符号扩展时,C语言是这样处理,先进行低位有符号到高位有符号扩展,即b,在进行有符号到无符号的同位转换,即3中的方法
5.截断位
截断都是直接去除多出的位,C中不支持这种转换
a.截断后表示无符号,低位表示的数=高位数mod2^(低位数),很好想,去除的位数权重和肯定是2^(低位数)的倍数,低位表示的数肯定小于2^(低位数)(因为,低位表示的数最大值为2^(低位数)-1)
b.截断后表示有符号,比较弱智的想法是,先转无符号,在此基础上进行无符号到有符号的转换.
3.trick
a.-1用补码表示为全1位
b.0用补码表示为全0位
c.非负数x,-x的w位补码表示就是2^w-x,而反码则是[111...1]-x,（这两个表达式都当成无符号来进行位表示。反码也可以这么理解2^w-1-x）

2.取模的算式
```
(a+b) mod P = [(a mod P)+(b mod P)]mod P
(a*b) mod P = [(a mod P)*(b mod P)]mod P
```
