---
title: 计算机原理
date: 2020-08-04 08:15:20
subtitle:
categories:
tags:
cover:
---
1.位运算相关
```
a&(b|c)=(a&b)|(a&c)
a|(b&c)=(a|b)&(a|c)
a^a=0 a^(a+1)=1(a为偶数)
a=n&(n-1)(移除n最后一个1)
diff=(n&(n-1))^n=n&(-n) (获取最后一个1)
(n^(-1))+1=-n(有符号数取反加一为其相反数)
(var^(var>>31))-(var>>31) (32位取绝对值)
```
2.位移运算
左移:<<,丢弃高位,低位补0
逻辑右移:>>,左端补0(c语言,对于无符号数,为逻辑右移)
算术右移:>>,左端补最高有效位的值(c语言,对于有符号数,为算术右移)
3.无符号与有符号的转换
a.C语言两者之间的转换，保持位模式不变,只是改变解码规则,最高位的解释由负到正,除了最高位的解释变化，其余位不变，设那些的权重和为k。
所以有符号补码的解释为-2^(w-1)+k,而无符号解释为2^(w-1)+k,w表示位数,所以两者相差2^w, 对于位模式(只考虑负数,即超过有符号表示范围的正数)相同的有以下结论:
无符号数=有符号负数+2^w
有符号负数=无符号数-2^w
有符号负数的绝对值+无符号数=2^w
b.无符号与有符号比较,c语言会都转换无符号

3.trick
a.-1用补码表示为全1位
b.0用补码表示为全0位
c.非负数x,-x的w位补码表示就是2^w-x,而反码则是[111...1]-x,（这两个表达式都当成无符号来进行位表示。反码也可以这么理解2^w-1-x）

2.取模的算式
```
(a+b) mod P = [(a mod P)+(b mod P)]mod P
(a*b) mod P = [(a mod P)*(b mod P)]mod P
```
