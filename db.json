{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"source/images/CIA.png","path":"images/CIA.png","modified":0,"renderable":0},{"_id":"source/images/DHCP.png","path":"images/DHCP.png","modified":0,"renderable":0},{"_id":"source/images/IP.png","path":"images/IP.png","modified":0,"renderable":0},{"_id":"source/images/IP_fra.png","path":"images/IP_fra.png","modified":0,"renderable":0},{"_id":"source/images/LAN.png","path":"images/LAN.png","modified":0,"renderable":0},{"_id":"source/images/NAT.png","path":"images/NAT.png","modified":0,"renderable":0},{"_id":"source/images/TCP.png","path":"images/TCP.png","modified":0,"renderable":0},{"_id":"source/images/TCP_IP.png","path":"images/TCP_IP.png","modified":0,"renderable":0},{"_id":"source/images/UDP.png","path":"images/UDP.png","modified":0,"renderable":0},{"_id":"source/images/about.jpg","path":"images/about.jpg","modified":0,"renderable":0},{"_id":"source/images/abstractFactory.png","path":"images/abstractFactory.png","modified":0,"renderable":0},{"_id":"source/images/archieve.jpg","path":"images/archieve.jpg","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"source/images/awk.jpg","path":"images/awk.jpg","modified":0,"renderable":0},{"_id":"source/images/bash.jpg","path":"images/bash.jpg","modified":0,"renderable":0},{"_id":"source/images/byebye.png","path":"images/byebye.png","modified":0,"renderable":0},{"_id":"source/images/cable.png","path":"images/cable.png","modified":0,"renderable":0},{"_id":"source/images/category.jpg","path":"images/category.jpg","modified":0,"renderable":0},{"_id":"source/images/character.png","path":"images/character.png","modified":0,"renderable":0},{"_id":"source/images/computer_bin.jpg","path":"images/computer_bin.jpg","modified":0,"renderable":0},{"_id":"source/images/cover.jpg","path":"images/cover.jpg","modified":0,"renderable":0},{"_id":"source/images/curl.png","path":"images/curl.png","modified":0,"renderable":0},{"_id":"source/images/decorator.jpg","path":"images/decorator.jpg","modified":0,"renderable":0},{"_id":"source/images/decorator.png","path":"images/decorator.png","modified":0,"renderable":0},{"_id":"source/images/decorator_cover.jpg","path":"images/decorator_cover.jpg","modified":0,"renderable":0},{"_id":"source/images/default.png","path":"images/default.png","modified":0,"renderable":0},{"_id":"source/images/delay.png","path":"images/delay.png","modified":0,"renderable":0},{"_id":"source/images/docker.png","path":"images/docker.png","modified":0,"renderable":0},{"_id":"source/images/dockerfile.jpg","path":"images/dockerfile.jpg","modified":0,"renderable":0},{"_id":"source/images/dsl.png","path":"images/dsl.png","modified":0,"renderable":0},{"_id":"source/images/extend.jpg","path":"images/extend.jpg","modified":0,"renderable":0},{"_id":"source/images/factoryMethodExp.png","path":"images/factoryMethodExp.png","modified":0,"renderable":0},{"_id":"source/images/factoryMethodNormal.png","path":"images/factoryMethodNormal.png","modified":0,"renderable":0},{"_id":"source/images/factoryPattern.png","path":"images/factoryPattern.png","modified":0,"renderable":0},{"_id":"source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":0},{"_id":"source/images/fiber.png","path":"images/fiber.png","modified":0,"renderable":0},{"_id":"source/images/file_descriptor.png","path":"images/file_descriptor.png","modified":0,"renderable":0},{"_id":"source/images/file_descriptor1.png","path":"images/file_descriptor1.png","modified":0,"renderable":0},{"_id":"source/images/file_descriptor2.png","path":"images/file_descriptor2.png","modified":0,"renderable":0},{"_id":"source/images/file_permission.jpg","path":"images/file_permission.jpg","modified":0,"renderable":0},{"_id":"source/images/filesystem.jpg","path":"images/filesystem.jpg","modified":0,"renderable":0},{"_id":"source/images/find.jpg","path":"images/find.jpg","modified":0,"renderable":0},{"_id":"source/images/fix.jpg","path":"images/fix.jpg","modified":0,"renderable":0},{"_id":"source/images/flameLinux1.jpg","path":"images/flameLinux1.jpg","modified":0,"renderable":0},{"_id":"source/images/flameLinux2.jpg","path":"images/flameLinux2.jpg","modified":0,"renderable":0},{"_id":"source/images/flameLinux3.jpg","path":"images/flameLinux3.jpg","modified":0,"renderable":0},{"_id":"source/images/flameLinux4.jpg","path":"images/flameLinux4.jpg","modified":0,"renderable":0},{"_id":"source/images/fluid.png","path":"images/fluid.png","modified":0,"renderable":0},{"_id":"source/images/gcc.jpg","path":"images/gcc.jpg","modified":0,"renderable":0},{"_id":"source/images/gdb.png","path":"images/gdb.png","modified":0,"renderable":0},{"_id":"source/images/git.jpg","path":"images/git.jpg","modified":0,"renderable":0},{"_id":"source/images/handshake.png","path":"images/handshake.png","modified":0,"renderable":0},{"_id":"source/images/hello_world.jpg","path":"images/hello_world.jpg","modified":0,"renderable":0},{"_id":"source/images/httpRequest.png","path":"images/httpRequest.png","modified":0,"renderable":0},{"_id":"source/images/knifes.jpg","path":"images/knifes.jpg","modified":0,"renderable":0},{"_id":"source/images/layer.png","path":"images/layer.png","modified":0,"renderable":0},{"_id":"source/images/linuxCmd.jpeg","path":"images/linuxCmd.jpeg","modified":0,"renderable":0},{"_id":"source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":0},{"_id":"source/images/makeFile.png","path":"images/makeFile.png","modified":0,"renderable":0},{"_id":"source/images/makefile.png","path":"images/makefile.png","modified":0,"renderable":0},{"_id":"source/images/network.png","path":"images/network.png","modified":0,"renderable":0},{"_id":"source/images/openssh.png","path":"images/openssh.png","modified":0,"renderable":0},{"_id":"source/images/police_beian.png","path":"images/police_beian.png","modified":0,"renderable":0},{"_id":"source/images/regex.jpg","path":"images/regex.jpg","modified":0,"renderable":0},{"_id":"source/images/rep.png","path":"images/rep.png","modified":0,"renderable":0},{"_id":"source/images/rust.png","path":"images/rust.png","modified":0,"renderable":0},{"_id":"source/images/rust_borrow.jpg","path":"images/rust_borrow.jpg","modified":0,"renderable":0},{"_id":"source/images/sed.jpeg","path":"images/sed.jpeg","modified":0,"renderable":0},{"_id":"source/images/sed.png","path":"images/sed.png","modified":0,"renderable":0},{"_id":"source/images/sed1.png","path":"images/sed1.png","modified":0,"renderable":0},{"_id":"source/images/shell_example.jpg","path":"images/shell_example.jpg","modified":0,"renderable":0},{"_id":"source/images/simpleFactory.png","path":"images/simpleFactory.png","modified":0,"renderable":0},{"_id":"source/images/sort_algori.png","path":"images/sort_algori.png","modified":0,"renderable":0},{"_id":"source/images/spike.jpg","path":"images/spike.jpg","modified":0,"renderable":0},{"_id":"source/images/stream.jpg","path":"images/stream.jpg","modified":0,"renderable":0},{"_id":"source/images/tag.jpg","path":"images/tag.jpg","modified":0,"renderable":0},{"_id":"source/images/tar.jpg","path":"images/tar.jpg","modified":0,"renderable":0},{"_id":"source/images/througput.png","path":"images/througput.png","modified":0,"renderable":0},{"_id":"source/images/tokio.png","path":"images/tokio.png","modified":0,"renderable":0},{"_id":"source/images/tp.png","path":"images/tp.png","modified":0,"renderable":0},{"_id":"source/images/tunneling.png","path":"images/tunneling.png","modified":0,"renderable":0},{"_id":"source/images/vim.png","path":"images/vim.png","modified":0,"renderable":0},{"_id":"source/images/wireless.png","path":"images/wireless.png","modified":0,"renderable":0},{"_id":"source/images/zsh.png","path":"images/zsh.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/images/observer.jpeg","path":"images/observer.jpeg","modified":0,"renderable":0},{"_id":"source/images/Cpp.jpeg","path":"images/Cpp.jpeg","modified":0,"renderable":0},{"_id":"source/images/STL.webp","path":"images/STL.webp","modified":0,"renderable":0},{"_id":"source/images/html.jpg","path":"images/html.jpg","modified":0,"renderable":0},{"_id":"source/images/linuxFile.webp","path":"images/linuxFile.webp","modified":0,"renderable":0},{"_id":"source/images/mariadb.jpeg","path":"images/mariadb.jpeg","modified":0,"renderable":0},{"_id":"source/images/processThread.png","path":"images/processThread.png","modified":0,"renderable":0},{"_id":"source/images/timer.jpeg","path":"images/timer.jpeg","modified":0,"renderable":0},{"_id":"source/images/python_set.png","path":"images/python_set.png","modified":0,"renderable":0},{"_id":"source/images/compile_process.png","path":"images/compile_process.png","modified":0,"renderable":0},{"_id":"source/images/python_basic.png","path":"images/python_basic.png","modified":0,"renderable":0},{"_id":"source/images/units_translate.jpg","path":"images/units_translate.jpg","modified":0,"renderable":0},{"_id":"source/images/template.jpg","path":"images/template.jpg","modified":0,"renderable":0},{"_id":"source/images/cmake.png","path":"images/cmake.png","modified":0,"renderable":0},{"_id":"source/images/cpp_eco.jpg","path":"images/cpp_eco.jpg","modified":0,"renderable":0},{"_id":"source/images/ffmpeg.jpeg","path":"images/ffmpeg.jpeg","modified":0,"renderable":0},{"_id":"source/images/linuc_network.png","path":"images/linuc_network.png","modified":0,"renderable":0},{"_id":"source/images/linux_performance.jpeg","path":"images/linux_performance.jpeg","modified":0,"renderable":0},{"_id":"source/images/performance.jpeg","path":"images/performance.jpeg","modified":0,"renderable":0},{"_id":"source/images/observer_exp.png","path":"images/observer_exp.png","modified":0,"renderable":0},{"_id":"source/images/observer_normal.png","path":"images/observer_normal.png","modified":0,"renderable":0},{"_id":"source/images/sheBao1.jpg","path":"images/sheBao1.jpg","modified":0,"renderable":0},{"_id":"source/images/sheBao2.jpg","path":"images/sheBao2.jpg","modified":0,"renderable":0},{"_id":"source/images/sheBao3.jpg","path":"images/sheBao3.jpg","modified":0,"renderable":0},{"_id":"source/images/enjoyLife.jpg","path":"images/enjoyLife.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/categories/index.md","hash":"32af0b20c5051f2a4d5570d72ce44e2077446e8e","modified":1702362541375},{"_id":"source/_posts/Arch_Linux问题解决经验.md","hash":"a37dc3d8f3b09b748ce72f810a780e151c25c887","modified":1702362541371},{"_id":"source/_posts/AWK.md","hash":"60952dc2d46252639c6d27e7decffbc6f49f23fb","modified":1702362541371},{"_id":"source/_posts/C-标准库.md","hash":"e2bf1bf99dcdb0e9c7a127d4abfb6c914fdba862","modified":1713386756540},{"_id":"source/_posts/C-小知识.md","hash":"574a214c30d15dfc8a0aa5b8d57b83cf454d515a","modified":1723060361399},{"_id":"source/_posts/GDB.md","hash":"4d69283c6dcce5f44ab62d31e8290c8c87419009","modified":1714419596669},{"_id":"source/_posts/Linux文件.md","hash":"771a933e81a2a7ef762ae7b0de63e9bcfaaa828b","modified":1703075946923},{"_id":"source/_posts/Find命令.md","hash":"bc36d6732aa22c79a64636bb4adfb3298e445d04","modified":1702362541371},{"_id":"source/_posts/Dockerfile.md","hash":"a37cc5dee30809719e39f49b0aa40457a2f1b9f5","modified":1702362541371},{"_id":"source/_posts/Linux文件权限.md","hash":"004930e8bdd52dd8620564590696d0bd725c179f","modified":1702362541371},{"_id":"source/_posts/Linux命令.md","hash":"55bb83e864adaf0ad146747b892c990dbbddc1aa","modified":1728263925225},{"_id":"source/_posts/MariaDB.md","hash":"54aedabb643fdd7fe53beb3580f8511c7d26dfad","modified":1724364269715},{"_id":"source/_posts/XML.md","hash":"8d97517079e9424fe5ddfef771ffb981780f12fd","modified":1702362541371},{"_id":"source/_posts/Make及gcc.md","hash":"8d94617026f0415a4f058983b1b8f9c5918f45c1","modified":1702362541371},{"_id":"source/_posts/Make.md","hash":"c5c509cb58bc72e65ed5444e95c8be745b685137","modified":1702362541371},{"_id":"source/_posts/gcc编译器及编译原理.md","hash":"386659b52490c797ec029d610143ff1c5c015200","modified":1712265127838},{"_id":"source/_posts/TCP-IP.md","hash":"f4232bde6b6c764417e96edfffcded5de81156c6","modified":1728274858863},{"_id":"source/_posts/git.md","hash":"72781c7b7077c765e887519193c8a4be7e2eede1","modified":1705610203573},{"_id":"source/_posts/go基础.md","hash":"14ed1d6b35d851fcbd78ef4ef97fe215b17c65f5","modified":1702362541371},{"_id":"source/_posts/git及github.md","hash":"c205c6f0c4ac7c3b8776ecb63595690859229490","modified":1702362541371},{"_id":"source/_posts/hello-world.md","hash":"2b9895716604bc407e6cae3afe207fca04357960","modified":1702362541371},{"_id":"source/_posts/grep与正则表达式.md","hash":"01d50f94adc7bcbd1b2fdd3fa82b2ccf4eeb1aaf","modified":1728262140958},{"_id":"source/_posts/docker.md","hash":"08e7e6feed1585164703f303f419e5b33c2dc51d","modified":1702362541371},{"_id":"source/_posts/html及markdown.md","hash":"4b721384effbe0ce9b26a5221478f2f34dd6fdbe","modified":1703076075400},{"_id":"source/_posts/rust学习——unsafe.md","hash":"8ead3ce6e33a9a8901ec342bced99d7fe2e742a9","modified":1702362541371},{"_id":"source/_posts/openSSH.md","hash":"90a88710c00295404c8637c4979b5b840b1da2fd","modified":1714512321319},{"_id":"source/_posts/rust学习——Cargo.md","hash":"f6f9674f9718d0cd9f0c1125527c018feddd81db","modified":1702362541371},{"_id":"source/_posts/curl和https.md","hash":"00fe0d33364e5c191ffe4bfa5c03254f458701cf","modified":1714511044582},{"_id":"source/_posts/rust学习——字符串.md","hash":"b05e53c2d8ecf868fce74d2ddbf48d07ab99d72c","modified":1702362541371},{"_id":"source/_posts/rust学习——所有权及引用.md","hash":"eda35d548542dc1cb6a07ad901c3148d8d1ab46b","modified":1702362541371},{"_id":"source/_posts/rust学习——变量.md","hash":"093d5ec699a305a9ec8ec8974745756ce8f7b138","modified":1702362541371},{"_id":"source/_posts/rust学习——控制.md","hash":"74d16dc2ee2705349c8891ec02cb0465de4ce4ef","modified":1702362541371},{"_id":"source/_posts/rust学习——多线程.md","hash":"e95536f16363ec97c678db228823375a98d5d5c5","modified":1702362541371},{"_id":"source/_posts/rust学习——杂项.md","hash":"e3309e2095f529678d04395ae04eeefc29024a34","modified":1702362541371},{"_id":"source/_posts/rust学习——智能指针.md","hash":"10c9c57d4bc92d1910e92f7fca0301e7efb9e10a","modified":1702362541371},{"_id":"source/_posts/rust学习——标准库.md","hash":"3c124abed09ef7f617328ffd93ce9557bdf0a2fd","modified":1702362541371},{"_id":"source/_posts/rust学习——异步.md","hash":"4cccf30ea272f41f618579b1646e65d4f9ca7f57","modified":1702362541371},{"_id":"source/_posts/rust学习——模式匹配.md","hash":"b779892331dba002a0084540174aa9c576a24fa4","modified":1702362541371},{"_id":"source/images/favicon.png","hash":"c3c4eb798776fe6479810f3ccf1f064135cb708c","modified":1702362541375},{"_id":"source/images/factoryMethodNormal.png","hash":"fc91eb445ef9ab45d9163d74c7f830de38e67b7d","modified":1702362541375},{"_id":"source/images/file_descriptor.png","hash":"449a22551bf22492316f1c90d24dc6c07808fbd4","modified":1702362541375},{"_id":"source/images/factoryMethodExp.png","hash":"4e0536d71647853e6453162308424ae3e882d939","modified":1702362541375},{"_id":"source/images/fiber.png","hash":"7901090e03617d543d5b54a5a156ef8e21cb305a","modified":1702362541375},{"_id":"source/images/file_descriptor1.png","hash":"91b7312a0cce0defc2d5ca8c8503c398f1083d5a","modified":1702362541375},{"_id":"source/images/file_descriptor2.png","hash":"01489b5ba5b6f172cd3811d7798512c7a2651bc2","modified":1702362541375},{"_id":"source/images/factoryPattern.png","hash":"51b54f4792f80e5a77028573fe28f132b400c572","modified":1702362541375},{"_id":"source/images/file_permission.jpg","hash":"1c5c349f360bb5ba85a00a4ff8f455c5741f0229","modified":1702362541375},{"_id":"source/images/extend.jpg","hash":"d292788a079104df054baaf052ef3a6a315ffcdf","modified":1702362541375},{"_id":"source/images/find.jpg","hash":"e3dbab74d40a0a948b975e2d21a7a8fbba010c3b","modified":1702362541375},{"_id":"source/images/filesystem.jpg","hash":"951570be6c105bd6f5958d875d86d1af704f91bb","modified":1702362541375},{"_id":"source/images/fix.jpg","hash":"ed5e2c5f083f6c7870253074fe695ed6c9736e14","modified":1702362541375},{"_id":"source/images/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1702362541375},{"_id":"source/images/httpRequest.png","hash":"43f9f6ddbc2a6618e17a6289eac74f2e5cc58cc2","modified":1702362541375},{"_id":"source/images/knifes.jpg","hash":"a39c4235039a0de5a89db6f842924a0fd4650e80","modified":1702362541375},{"_id":"source/images/linuxCmd.jpeg","hash":"062de8d0a7244ac93b7d7887c9ac106fbacdb2b5","modified":1702362541375},{"_id":"source/images/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1702362541375},{"_id":"source/images/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1702362541375},{"_id":"source/images/network.png","hash":"a2f09a3840eebf51309204d6cd11a3bbd40ca5d0","modified":1702362541375},{"_id":"source/images/openssh.png","hash":"f20d5faa11304891cd7d0214ad523ec63123f2f1","modified":1702362541375},{"_id":"source/images/makeFile.png","hash":"fb1d5eeae1917384bb9265af2907e245b83cc8d3","modified":1702362541375},{"_id":"source/images/regex.jpg","hash":"877c4a7fded934656ef43c4a854137c025b8c853","modified":1702362541375},{"_id":"source/images/sed.png","hash":"451df5f37f97c352b856f9ff7585d7f57be4a861","modified":1702362541375},{"_id":"source/images/rust_borrow.jpg","hash":"7fc3c3b342f6127bd8f41c9d5e52b5fb50b8f424","modified":1702362541375},{"_id":"source/images/sed1.png","hash":"df33cd372a819740b404d404905736399e7c67cb","modified":1702362541375},{"_id":"source/images/sed.jpeg","hash":"41645dd43592631b04b0ff79d83dbbc0a3969dcf","modified":1702362541375},{"_id":"source/images/shell_example.jpg","hash":"26cbd81ec04e8975a06e398ff81129d19ec38d0e","modified":1702362541375},{"_id":"source/images/simpleFactory.png","hash":"6a8978dc2c10baa3e2794c725aad9b5ebbd3e9de","modified":1702362541375},{"_id":"source/images/througput.png","hash":"03c2d3b8516ccb867a4cedafff6e7e24dd5e8281","modified":1702362541375},{"_id":"source/images/stream.jpg","hash":"6b00a4e48fd8fca89c47a9d0aa30eced480f8411","modified":1702362541375},{"_id":"source/_posts/rust学习——泛型与特征.md","hash":"98388383f35fdbda1c9d37bc428e82a7617c9082","modified":1702362541371},{"_id":"source/images/tar.jpg","hash":"f4c6e9abfbe2aaf377a62c9ba113c7bdb89e4873","modified":1702362541375},{"_id":"source/images/zsh.png","hash":"97a2a9035fa95f60e861c7a4608fff2447bdf5a7","modified":1702362541375},{"_id":"source/images/tokio.png","hash":"59016addb683eda65266a0a1dcff36ce0b70a5f2","modified":1702362541375},{"_id":"source/images/gcc.jpg","hash":"aff48ef70fe79c7bfdcff4331684a49b8357c85e","modified":1702362541375},{"_id":"source/images/handshake.png","hash":"4600bcb5f4a996386c493586b03187f449f4f4b4","modified":1702362541375},{"_id":"source/images/layer.png","hash":"aa4208beb6e96496762d0fdc1a93842a3fe61b65","modified":1702362541375},{"_id":"source/images/hello_world.jpg","hash":"a65cd6cd3529d2937dc64ebb01fa546b7f16485b","modified":1702362541375},{"_id":"source/images/rep.png","hash":"948d6c4e73cb9cb4e127f28d24887e6a8f4f05e4","modified":1702362541375},{"_id":"source/_posts/rust学习——测试.md","hash":"576f932f0c1c22e9a43ff6365e335415cd84270b","modified":1702362541371},{"_id":"source/_posts/rust学习——生命周期.md","hash":"c25c10662118f4c13f63a7f35eedb2220ac55992","modified":1702362541371},{"_id":"source/_posts/rust学习——输入输出.md","hash":"1e1e42b9882c4815a33b1be4e392798e850e654e","modified":1702362541371},{"_id":"source/_posts/rust学习——迭代器-md.md","hash":"096ae4227f2f1317451a6d7e7ce85d6fcc024c58","modified":1702362541371},{"_id":"source/_posts/rust学习——错误处理.md","hash":"a1c26022244796df1d30e692e7252d6e05147a95","modified":1702362541371},{"_id":"source/_posts/rust学习——闭包与迭代器.md","hash":"f61cad6a0223727941c2ba0c685a4512e99dfb07","modified":1702362541371},{"_id":"source/_posts/sed.md","hash":"354c8f66f4ed3e4c24fee2d842d83d08fadf49d1","modified":1702362541371},{"_id":"source/_posts/shell例子.md","hash":"139a4d33e99b2f3f9867a82a748c8028efb262ef","modified":1702362541371},{"_id":"source/_posts/shell基本概念.md","hash":"2476aeca2186245f4248b7575a9101d7eb2e9183","modified":1702362541371},{"_id":"source/_posts/shell相关.md","hash":"afd5156ed15d32941b67c694081bd80993596a71","modified":1702362541371},{"_id":"source/_posts/tokio.md","hash":"43499c6ab8e9bb225efc76b18fc29884f77fb2b5","modified":1702362541371},{"_id":"source/_posts/vi及vim.md","hash":"69fe02b94b3091ccbd8a3adabc820988698dbc3c","modified":1721246265346},{"_id":"source/_posts/zsh.md","hash":"f8dfe465a342ad3807bf357ac580a22bd906a96e","modified":1702362541371},{"_id":"source/_posts/三剑客sed_awk_grep.md","hash":"18de215d3b6bd09f414f346a2e04a0697277780f","modified":1702362541371},{"_id":"source/_posts/字符相关.md","hash":"882cd7ece08dfd2b9abee2461abb54bb69155112","modified":1712310012042},{"_id":"source/_posts/定时器.md","hash":"3cd75ea2fea614000bc5fe54689ae22b05ee85f2","modified":1703073686873},{"_id":"source/_posts/归档和备份命令.md","hash":"18d46c036ec235b96055d9b4b75d62007f628c74","modified":1702362541371},{"_id":"source/_posts/数据结构笔记1.md","hash":"d228a42e4093bd404556d545b184b9f71f4c8de8","modified":1702362541371},{"_id":"source/_posts/文件系统与存储.md","hash":"ec9afea4205bc1cf2f518876dbf330d07032663c","modified":1702362541371},{"_id":"source/_posts/文本处理瑞士军刀-小而强悍.md","hash":"83238240be75b5f7cf015b4f114f017dbc5e7d18","modified":1714333303627},{"_id":"source/_posts/文本处理瑞士军刀-扩展.md","hash":"cc599e3fde1fbdb07e7e2e140a3683996b3846ec","modified":1702362541371},{"_id":"source/_posts/类相关知识.md","hash":"04c6d54c18b4099ca28ef22017567dfea20b3b00","modified":1702362541371},{"_id":"source/_posts/计算机原理.md","hash":"b33cc0c1ecb21cf96c1ad30c19f9ce8f75465721","modified":1702362541371},{"_id":"source/_posts/计算机网络基础.md","hash":"6aa120c27010d09d293522fd8a045b60e9665b8b","modified":1702362541371},{"_id":"source/_posts/设计模式-工厂模式.md","hash":"9bb33f7b700a359845c0924df866c810bfd6721f","modified":1702362541371},{"_id":"source/_posts/设计模式-装饰者模式.md","hash":"00facf0f9ee3138a5a27631ee50f8289c8c0e312","modified":1702362541371},{"_id":"source/_posts/设计模式-观察者模式.md","hash":"98a69f4e8834241e3338a1303ff750342f9d7a3b","modified":1702363686678},{"_id":"source/_posts/输入与输出.md","hash":"b95a439f575670a9b3c4de8ec9afe6999a0098ba","modified":1702362541371},{"_id":"source/_posts/输入输出流.md","hash":"1c667059b9bdf1a1ed6c530e4c0b81d3dd3059fd","modified":1702362541371},{"_id":"source/_posts/进程与线程.md","hash":"76724dd5d70772b1f655848d8fdaba9e5df020b0","modified":1710793191515},{"_id":"source/about/index.md","hash":"99555f4bfd8ecf83bede10091c55a939bd3a55ac","modified":1702362541375},{"_id":"source/images/2022-11-27 15-18-56屏幕截图.png","hash":"77977ba7499439ef83111bdbf13977a1509ccdc8","modified":1702362541375},{"_id":"source/images/CIA.png","hash":"d5c731925b25c37fe522e8f53b9dc5fa4bf3fd00","modified":1702362541375},{"_id":"source/images/DHCP.png","hash":"05269c2bccad26b9e77f61fff36a2731d85c7d6a","modified":1702362541375},{"_id":"source/images/LAN.png","hash":"447db6fa20be2f10f08a0d5b18f0220ba8e31ee2","modified":1702362541375},{"_id":"source/images/TCP_IP.png","hash":"6ef39b79a8a438f7b2cb9ba490cd8e3a206383f7","modified":1702362541375},{"_id":"source/images/UDP.png","hash":"5efaad9a992dc3ddb03ab598172caba16c8fa5e2","modified":1702362541375},{"_id":"source/images/avatar.png","hash":"f20fb18c46ab0c3a703ce759079a4f5221d9be6d","modified":1702362541375},{"_id":"source/images/awk.jpg","hash":"ba4067dbb8a8e656ce1a829bd67f0e723b8aff03","modified":1702362541375},{"_id":"source/images/bash.jpg","hash":"abf4d0ccca18f8fa78de17467c702285701ec609","modified":1702362541375},{"_id":"source/images/cable.png","hash":"15dfd985c4a7735e824fe38f45471f131ea8f29e","modified":1702362541375},{"_id":"source/images/character.png","hash":"49f9fa4943352947ba956ea6617e957c655ed448","modified":1702362541375},{"_id":"source/images/computer_bin.jpg","hash":"1ccc06f31a153c464dc31e6cd8f7afb53803ea3c","modified":1702362541375},{"_id":"source/images/curl.png","hash":"07715a8464d83e66b735391fe3f18e95a24ac787","modified":1702362541375},{"_id":"source/images/decorator.png","hash":"bc2936978b64538df745d6094a8a0d4ad906cc5c","modified":1702362541375},{"_id":"source/images/delay.png","hash":"1463ae11704a33b5484024432f81d8951075dd42","modified":1702362541375},{"_id":"source/images/docker.png","hash":"8a8d3040e83b6ae9defff1ecc038aed82cb56b25","modified":1702362541375},{"_id":"source/images/dockerfile.jpg","hash":"6c9a0107e80530cb15ad83b5c42771336583313e","modified":1702362541375},{"_id":"source/images/dsl.png","hash":"5bee06dfab8922f4c029337b8b2930a018326bcc","modified":1702362541375},{"_id":"source/images/tp.png","hash":"e580f7abad7034ec5505375e75da8d3436c6ec71","modified":1702362541375},{"_id":"source/images/tunneling.png","hash":"b5b2835806525e9827b076f45b2913b87c9eb86c","modified":1702362541375},{"_id":"source/images/wireless.png","hash":"1ff7159270f63fb53c972b1cd7aeff78d407081b","modified":1702362541375},{"_id":"source/images/git.jpg","hash":"af7f1d46052116f657e7587cfb87b55d62c726b2","modified":1702362541375},{"_id":"source/images/gdb.png","hash":"971fd8a25104590f27517022b8eb81d82c994226","modified":1702362541375},{"_id":"source/images/IP_fra.png","hash":"942b814f67d0f33d82063e4e24b4a79ef2eaa492","modified":1702362541375},{"_id":"source/images/TCP.png","hash":"e0f76bd0cddc4b4e1ee8caf22c0b99e27ff7862a","modified":1702362541375},{"_id":"source/images/abstractFactory.png","hash":"fcc40c376a9e38416adefb4fffb6ed4ecbdaa4de","modified":1702362541375},{"_id":"source/images/archieve.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1702362541375},{"_id":"source/images/byebye.png","hash":"b07315b940a7549fdc1a36f4b58d102438b7bf7c","modified":1702362541375},{"_id":"source/images/decorator_cover.jpg","hash":"410636948b4ad3de8f107e98fe72c6129d0b4258","modified":1702362541375},{"_id":"source/images/flameLinux4.jpg","hash":"01a998b3b9b698cfabb77197a7f5469c8dd4ee36","modified":1702362541375},{"_id":"source/images/flameLinux3.jpg","hash":"a5590196afcac408d04a8b876f89d35c734a1193","modified":1702362541375},{"_id":"source/images/flameLinux2.jpg","hash":"9bf4e40ee5d1267c654d9656395854d4a5cb9972","modified":1702362541375},{"_id":"source/images/sort_algori.png","hash":"e9acf18ccb4c41d3f65f02ffb1d4cfdf3b20e324","modified":1702362541375},{"_id":"source/images/IP.png","hash":"f019103388a5643551653208b73d7d73704e5898","modified":1702362541375},{"_id":"source/images/NAT.png","hash":"636745cca2e5492a564014d1398f1926140a07f4","modified":1702362541375},{"_id":"source/images/cover.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1702362541375},{"_id":"source/images/flameLinux1.jpg","hash":"da8a467bb0eb60ee76cfd6ce51b4a15f9ad292a6","modified":1702362541375},{"_id":"source/images/about.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1702362541375},{"_id":"source/images/category.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1702362541375},{"_id":"source/images/decorator.jpg","hash":"f16d4c22092c2046704814366a21a7faaef0332b","modified":1702362541375},{"_id":"source/images/vim.png","hash":"c4e533fd3e371933192f1546dc53d50b94619dd4","modified":1702362541375},{"_id":"source/images/makefile.png","hash":"ed2a578ad3a8a2205ab6933b4ef3c2dca3f3b9cc","modified":1702362541375},{"_id":"source/images/tag.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1702362541375},{"_id":"source/images/spike.jpg","hash":"71913cf82f3fe417787f6f6f2389f2938d452997","modified":1702362541375},{"_id":"source/images/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1702362541375},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1702362541361},{"_id":"source/images/rust.png","hash":"5930f64f82a1706bd074e2cc5bdbd8aef6177324","modified":1702362541375},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"49f681a203eecfa7127ac22edc13bd3b49693d0a","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"cdde6c6d6a1bdf9fb965313e21d92cf6213582b6","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"f09a5019ba2182c64c4bd0b07355ad1f708b6a55","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"75ab6958d929e92566ca580d0b8bd0eeae10649a","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"0047666f996c54017e06668b5242ed8a311ebce0","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"3fc0875fa162719f8183ccc15502895e1b4f6c7d","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"8e434eecde934bbbc98c2e618c16210f5622f4dc","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1702362541365},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"2ee54e5695f6d6f3585d94412f27b02060cb2463","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"ecf3488566b374d564ae985c61e08562ba908023","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"2748ed2be99e088350f83de96fc1af42d1f5bd93","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1702362541361},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1702362541365},{"_id":"public/local-search.xml","hash":"fb5bde0de1fcd5d3546391f123ee71b4511938df","modified":1739195801112},{"_id":"public/categories/index.html","hash":"fa7e0d89fd9723f9125e48465637a120e8cfdb08","modified":1703076078387},{"_id":"public/about/index.html","hash":"1d653117b1d1da36c31618c9fec73e33123a847f","modified":1702362829540},{"_id":"public/2023/12/12/hello-world/index.html","hash":"576dc6c38ae4e47bdb2a6f0533949b904f9c6342","modified":1704831227432},{"_id":"public/2023/10/31/定时器/index.html","hash":"245ca824649a1c50b10368db8881b67bcfdb6161","modified":1703076078387},{"_id":"public/2023/09/03/进程与线程/index.html","hash":"fad6300c974a11212e26eddb7f860604a7545205","modified":1711800645263},{"_id":"public/2023/07/08/设计模式-观察者模式/index.html","hash":"352fbd59ff40b2e76286e4a2ec04ed591b320468","modified":1702363773171},{"_id":"public/2023/06/26/设计模式-装饰者模式/index.html","hash":"b14359b252e1d0fa89ca852373a6196a2d3ffcd1","modified":1702362829540},{"_id":"public/2023/06/24/设计模式-工厂模式/index.html","hash":"153fd9710fe96d33747a19f1679c9509dfa3b7ae","modified":1702362829540},{"_id":"public/2022/10/02/计算机网络基础/index.html","hash":"9803cb5fb98b1be4b503b8d9b12d8aa186773706","modified":1702362829540},{"_id":"public/2022/06/27/tokio/index.html","hash":"fa1755450cd1047907b3f178c9352f765e42de5a","modified":1702363773171},{"_id":"public/2022/06/20/rust学习——异步/index.html","hash":"e6e74f4c4a72684a12a989a0947de2b59e2180ee","modified":1702362829540},{"_id":"public/2022/10/03/TCP-IP/index.html","hash":"759013a8d6d3c3c41c79531f92cac433f5dc3f12","modified":1728274877038},{"_id":"public/2022/06/18/rust学习——测试/index.html","hash":"85eac401cebfaa979407b5e03adae8b6c50c1eb0","modified":1702362829540},{"_id":"public/2022/06/18/rust学习——unsafe/index.html","hash":"eedf3e1b43c24a9eed58600a0be5e68191b3c430","modified":1702362829540},{"_id":"public/2022/06/05/rust学习——智能指针/index.html","hash":"aa295a8e2c77c9004382a6d5ae580ec4a509de4b","modified":1702362829540},{"_id":"public/2022/06/04/rust学习——多线程/index.html","hash":"ade27b71b9872d7bd02e48f0c9f461860124f4cc","modified":1702362829540},{"_id":"public/2022/06/03/rust学习——闭包与迭代器/index.html","hash":"0a2bb8eb941d0fc1a0ec4e67e8be68db1163134a","modified":1702362829540},{"_id":"public/2022/05/26/rust学习——生命周期/index.html","hash":"810412e57b7d84f62bdfafb5ec1de9986d28b42e","modified":1702362829540},{"_id":"public/2022/05/22/rust学习——错误处理/index.html","hash":"8d3c0e2559b7dd3acb72eddaee312b6e5674c5b5","modified":1702362829540},{"_id":"public/2022/05/19/rust学习——标准库/index.html","hash":"7a85c165a956c091fdb4ea7c9614bf5e149f1db0","modified":1702362829540},{"_id":"public/2022/05/15/rust学习——所有权及引用/index.html","hash":"2de455a7a945ca7a08d9eac67c545aa6314e7054","modified":1702362829540},{"_id":"public/2022/05/21/rust学习——泛型与特征/index.html","hash":"627ac851a8bfcc0dd09e3bda56984f76335d8698","modified":1702362829540},{"_id":"public/2022/05/13/rust学习——迭代器-md/index.html","hash":"35b0fcfa1be549f8b939861dc0e2865be7a021a5","modified":1702362829540},{"_id":"public/2022/04/13/rust学习——输入输出/index.html","hash":"624182b49389a605f37b849e173b68169bd0d041","modified":1702362829540},{"_id":"public/2022/04/13/rust学习——杂项/index.html","hash":"c4db0030624acc9d9da45ff7308bd0c6a5ca6f9f","modified":1702362829540},{"_id":"public/2022/04/11/rust学习——模式匹配/index.html","hash":"132b6f0c689d6189af081c38fabd52b7d5eea6bd","modified":1702362829540},{"_id":"public/2022/04/11/rust学习——控制/index.html","hash":"daa30ce7503662e8def5a46226f2d671ff5a27ba","modified":1702362829540},{"_id":"public/2022/04/10/rust学习——字符串/index.html","hash":"8e7827eaf01619ef76b0b47af615d4766380cbf6","modified":1702362829540},{"_id":"public/2022/04/09/rust学习——变量/index.html","hash":"4eb1013d775845a49dc897d9a0ee110ff4fb2a70","modified":1702362829540},{"_id":"public/2022/04/09/rust学习——Cargo/index.html","hash":"c5b2de92f4b5c43cdc22dadbe5e0962895b01e08","modified":1702362829540},{"_id":"public/2022/04/04/Dockerfile/index.html","hash":"41fdbda1606b8dbd87316c6c8e83fd893694604e","modified":1702363773171},{"_id":"public/2022/04/04/docker/index.html","hash":"09dbe79a97eea10e629097975f5f4aed084dd02d","modified":1702362829540},{"_id":"public/2022/03/22/文本处理瑞士军刀-扩展/index.html","hash":"a035b57bdf09be42faf56f294153347cd99331ef","modified":1702362829540},{"_id":"public/2022/03/15/curl和https/index.html","hash":"1e113ec8cb3ab1d239dd542f2764356f41077e6c","modified":1716753879320},{"_id":"public/2022/02/03/zsh/index.html","hash":"e81947b30145726b60c33e3e82619a83fa78c8a1","modified":1702362829540},{"_id":"public/2021/10/21/文件系统与存储/index.html","hash":"ff6149e515831c782feb79a8f56eec748f6ac74d","modified":1702362829540},{"_id":"public/2021/10/20/Linux文件权限/index.html","hash":"f77b22ccb404487e32f4e6e1617438be3eb2f46f","modified":1702362829540},{"_id":"public/2021/10/15/shell基本概念/index.html","hash":"921f51667c456065fda096fb65c6e6471e5bd0e9","modified":1702362829540},{"_id":"public/2021/03/31/git/index.html","hash":"be6c05619c7f8aeaac12b38c1579f6d9a28a3667","modified":1705610221673},{"_id":"public/2021/03/11/输入输出流/index.html","hash":"798273b7ccf819ea91af39260365d453efdcedcd","modified":1702362829540},{"_id":"public/2021/01/24/AWK/index.html","hash":"1d3afe8b7d77c92137fee117c66664d98f2e2582","modified":1702362829540},{"_id":"public/2020/12/31/Arch_Linux问题解决经验/index.html","hash":"c922ed69d2afa319c08bde0584aeae0246638c3a","modified":1702362829540},{"_id":"public/2020/12/21/openSSH/index.html","hash":"2f9d6cc7d3bcc814495c1d489d88728b8aab9f28","modified":1716753879320},{"_id":"public/2020/12/19/gcc编译器及编译原理/index.html","hash":"2a56b2aaeedfc83997f6450fa8a1f7dedd79ff76","modified":1716753879320},{"_id":"public/2020/11/21/文本处理瑞士军刀-小而强悍/index.html","hash":"948b709b00fa07aecaebac1055150ea4fad77a41","modified":1716753879320},{"_id":"public/2020/11/20/grep与正则表达式/index.html","hash":"3a568ea59cdb66115144e11194c2e2476b414f24","modified":1728274877038},{"_id":"public/2020/11/19/归档和备份命令/index.html","hash":"004a87d0303f60d9afc1136f5881c50c281e532b","modified":1702362829540},{"_id":"public/2020/11/18/Find命令/index.html","hash":"50fbf35133b11a124b61d0d0682bddc9752be09f","modified":1702362829540},{"_id":"public/2020/08/04/计算机原理/index.html","hash":"018cb2fafcdd767d391de553b7b010ab64d70144","modified":1703076078387},{"_id":"public/2020/06/21/go基础/index.html","hash":"5870e5dd5ef595b177203f43fd59ba2278e9d989","modified":1702362829540},{"_id":"public/2020/06/09/git及github/index.html","hash":"c544c4c0611ad798ad994bd80ad034776b1b2e29","modified":1702363896596},{"_id":"public/2020/05/19/XML/index.html","hash":"de6cdb15a19e34645d298dfc3d28d38cb7f64cca","modified":1702362829540},{"_id":"public/2020/04/29/输入与输出/index.html","hash":"24ab563eecd02aa64af2d935e2e9b36caa31a5fa","modified":1702362829540},{"_id":"public/2020/01/17/Make/index.html","hash":"dce81d326987464eed5558e1a30b1d59ee13f78a","modified":1703076078387},{"_id":"public/2020/01/17/Make及gcc/index.html","hash":"cd29d346de1c1318ff3f5de91e738f2ab3ed1678","modified":1702362829540},{"_id":"public/2020/01/16/GDB/index.html","hash":"7768548b78c3aef274e005039ac95537f5f81422","modified":1716753879320},{"_id":"public/2019/11/18/MariaDB/index.html","hash":"76b0ec15cbc3f1873aebacf6697f9c281cd83317","modified":1724364272532},{"_id":"public/2019/08/10/C-标准库/index.html","hash":"349713b1a6eded42ee28acdaf4f5227cfe8d3a6f","modified":1716753879320},{"_id":"public/2019/08/09/数据结构笔记1/index.html","hash":"51f6d10453152e90dfced6d9cd63d28278b24163","modified":1702362829540},{"_id":"public/2019/07/20/shell例子/index.html","hash":"4532341437e1dc56d93fbc4be7ada36f05361cb8","modified":1703076078387},{"_id":"public/2019/07/20/shell相关/index.html","hash":"16cfccf8ad3d68b024a01a4191e7dab2f1b98de0","modified":1702362829540},{"_id":"public/2019/07/20/类相关知识/index.html","hash":"c9f9442ade5a1028558dd68e007ddaa49165c17d","modified":1702362829540},{"_id":"public/2019/07/19/字符相关/index.html","hash":"d5a236d1367f563aea9669bb9b4c576e1803b552","modified":1716753879320},{"_id":"public/2019/07/18/sed/index.html","hash":"0e7f4515851b62c1815fea054c738e72f5d29154","modified":1703076078387},{"_id":"public/2019/07/18/三剑客sed_awk_grep/index.html","hash":"319b1bdf656e527cea74025303505d16ec9ecc10","modified":1702362829540},{"_id":"public/2019/07/18/C-小知识/index.html","hash":"3072a2ff2dc072586fe77a18c7ee0e58067ea4f2","modified":1723154657761},{"_id":"public/2019/07/18/vi及vim/index.html","hash":"cfcec4b2fc0c6a864a33472da34ab73ca04b2ee9","modified":1723154657761},{"_id":"public/2019/07/18/Linux文件/index.html","hash":"b466abc6f4cabb8a60eb94347b1e5d1dac002198","modified":1703076078387},{"_id":"public/2019/07/18/Linux命令/index.html","hash":"533d65bfb869ce17233454439867989d1d8e5c09","modified":1728274877038},{"_id":"public/2019/07/18/html及markdown/index.html","hash":"b6f782feee27f48853cf6e66e2a486fe5d51e282","modified":1703076078387},{"_id":"public/archives/index.html","hash":"b022b4d4a06a50d7366f8e34c8c98d35a5e11fb8","modified":1739195801112},{"_id":"public/archives/page/2/index.html","hash":"1ccf27978502a072cb4be9e5f37930511cbb18a5","modified":1739195801112},{"_id":"public/archives/page/3/index.html","hash":"8fa9a58a3b84fa8ed0ff2c9cfb429688449f346f","modified":1739195801112},{"_id":"public/archives/page/4/index.html","hash":"8fddd8b342ec686ad94fddee63c90db488fd0663","modified":1739195801112},{"_id":"public/archives/page/5/index.html","hash":"b1c50807cecd2d2d3ca0f893c3c7f544dba5b51e","modified":1739195801112},{"_id":"public/archives/page/6/index.html","hash":"9398febada5976aa279061a9261f31d24e4d4704","modified":1702362829540},{"_id":"public/archives/page/7/index.html","hash":"63df5da239068a082fbffd23bc03e8807ae436ae","modified":1702362829540},{"_id":"public/archives/2019/index.html","hash":"d751df7b19e50bec05abef13b0c76ab77d43e9e5","modified":1739195801112},{"_id":"public/archives/2019/page/2/index.html","hash":"764d1262bc35094d6d6e4924bdd8980c4051a28b","modified":1702363896596},{"_id":"public/archives/2019/07/index.html","hash":"0dd1198135d45ffcd87433d0a12f00066a14309d","modified":1739195801112},{"_id":"public/archives/2019/07/page/2/index.html","hash":"533196d1740502fd295016cb7843564f213258a9","modified":1702363896596},{"_id":"public/archives/2019/08/index.html","hash":"2a7e407273960853726e85e40bffeb4a1562a3b2","modified":1739195801112},{"_id":"public/archives/2019/11/index.html","hash":"0ff7209035be1a7b484aaff60d5034e24803a522","modified":1739195801112},{"_id":"public/archives/2020/index.html","hash":"86bf5e5d011edb01aea8f008df58fffa42f7aaff","modified":1739195801112},{"_id":"public/archives/2020/page/2/index.html","hash":"2ea771b079b86bd503c691a3b671771ccd4cabcf","modified":1702363896596},{"_id":"public/archives/2020/01/index.html","hash":"72c559ecc2463824cfd7d1d0464fe31190d2db74","modified":1739195801112},{"_id":"public/archives/2020/04/index.html","hash":"1063d4d519a26f3f6c77c176d424287b4a6e2099","modified":1702363896596},{"_id":"public/archives/2020/05/index.html","hash":"a1d482abf4aeeb4d5522b9dd88f0b8d796c89b04","modified":1702363896596},{"_id":"public/archives/2020/06/index.html","hash":"6d37ab5e38bc68c2d2d36f1ede89ef5a2d87f91d","modified":1702363896596},{"_id":"public/archives/2020/08/index.html","hash":"85cefcb8e391de16d194a9d5b014170173d931b3","modified":1739195801112},{"_id":"public/archives/2020/11/index.html","hash":"90acfe0d09a79ddf3de36b5ef5835b13be9be59d","modified":1739195801112},{"_id":"public/archives/2020/12/index.html","hash":"83d7fd7006eb4780ac3b6c3688c7452f656f2d67","modified":1739195801112},{"_id":"public/archives/2021/index.html","hash":"c8847ecebf996251b70f37bed17754b909e1fbd6","modified":1739195801112},{"_id":"public/archives/2021/01/index.html","hash":"bc730881a3ab88db9eaa169e7b4be70c9a9c5c7e","modified":1739195801112},{"_id":"public/archives/2021/03/index.html","hash":"d488c250d1316783bde2b1437ec2dfe06e0017f5","modified":1739195801112},{"_id":"public/archives/2021/10/index.html","hash":"9c1d6701ef69d19ac087223f2ef0d17728c29cc7","modified":1739195801112},{"_id":"public/archives/2022/index.html","hash":"69d797b38c2a63990f27ccff093afc4664f6f251","modified":1739195801112},{"_id":"public/archives/2022/page/2/index.html","hash":"43f9bff61c965a42f96a95eff31d8aa828ad96f3","modified":1702362829540},{"_id":"public/archives/2022/page/3/index.html","hash":"af99d2ab9824a54f15472a3e8b546724e99eba49","modified":1702362829540},{"_id":"public/archives/2022/02/index.html","hash":"857316d46ead17f956ee0b422dabbfddfef1ffa0","modified":1739195801112},{"_id":"public/archives/2022/03/index.html","hash":"81d464dba9c8571a4fa13813ac084acd0b7d8b79","modified":1739195801112},{"_id":"public/archives/2022/04/index.html","hash":"9c8eb88269ae880c801aa6a43c3579711cb4c464","modified":1739195801112},{"_id":"public/archives/2022/05/index.html","hash":"a8ffd5b1dcac8199e2c8e700e592ffb4ccc21b8a","modified":1702362829540},{"_id":"public/archives/2022/06/index.html","hash":"f63b466f4fcd043c75a7e1ee4865bab0fcd18955","modified":1739195801112},{"_id":"public/archives/2022/10/index.html","hash":"3b748218f696168490a85f39f8abc258534cd744","modified":1739195801112},{"_id":"public/archives/2023/index.html","hash":"32a910e9bdef6d2e38bc936da2334b9814d81c2c","modified":1739195801112},{"_id":"public/archives/2023/06/index.html","hash":"6b634e54aaabd96b25778b272bc18960600e5958","modified":1739195801112},{"_id":"public/archives/2023/07/index.html","hash":"fb18fc63e041dea1bbef6f7afd53f40fef944c4a","modified":1739195801112},{"_id":"public/archives/2023/09/index.html","hash":"11c7c66bae600af3a267ac4a0463821386885dc2","modified":1739195801112},{"_id":"public/archives/2023/10/index.html","hash":"4033b4b6168e10dd6575473b5d253acf18c780ce","modified":1739195801112},{"_id":"public/archives/2023/12/index.html","hash":"b85b207bda53f99c27b5d71a1aea373c9fdb88ca","modified":1739195801112},{"_id":"public/categories/C/index.html","hash":"cafa61bc50fe372d1e6930e6339933f0536975af","modified":1703076078387},{"_id":"public/categories/Linux/index.html","hash":"f89761a094385fc2fa6b03c29fa919b669680695","modified":1703076078387},{"_id":"public/categories/html/index.html","hash":"2ea0f8128b8aafcfbc7eca7d799b5fc66e68cc44","modified":1702362829540},{"_id":"public/categories/文本处理/index.html","hash":"1cede59039fce023dc5232e5a0e1b3e3742bee59","modified":1703076078387},{"_id":"public/index.html","hash":"3d7f61c9ec28dca16ecfc1a9d172fe4e7a9251aa","modified":1739196330263},{"_id":"public/page/2/index.html","hash":"7bfaea6a9d65117d3c904c09320eda500dab9765","modified":1739195801112},{"_id":"public/page/3/index.html","hash":"33b3b3f24f0b164dd16b5ab016cfd27856431f3a","modified":1739195801112},{"_id":"public/page/4/index.html","hash":"cca91f2c9d6f5f3ec459431b350865603ea89db5","modified":1739195801112},{"_id":"public/page/5/index.html","hash":"e36a9ff76fb0144f9580cba254d1fd707d0dc2ac","modified":1739195801112},{"_id":"public/page/6/index.html","hash":"da07b5dff4e47f62d645a8484cf3aad31bbffe2b","modified":1702362829540},{"_id":"public/page/7/index.html","hash":"29fe99e51725045c73c4c9d362d7045218ca522c","modified":1702362829540},{"_id":"public/tags/命令/index.html","hash":"e749139e58d8327abc0a12530d15c6aa2602a326","modified":1702362829540},{"_id":"public/tags/文件/index.html","hash":"039166ee1bb90f8f70529e2bc34a9fab005d8f5d","modified":1702362829540},{"_id":"public/tags/字符/index.html","hash":"c375267247d359089beb87caec6c02e84a5589a9","modified":1702362829540},{"_id":"public/404.html","hash":"dfb6bf3e4d6745897e413fb5d0272b508b8b303b","modified":1702362829540},{"_id":"public/tags/index.html","hash":"0321409f52ec1b89308de4d67a14594d08d8eece","modified":1702362829540},{"_id":"public/links/index.html","hash":"cb016d162e38ffb73380cc957b68e41887bc4458","modified":1702362829540},{"_id":"public/images/througput.png","hash":"03c2d3b8516ccb867a4cedafff6e7e24dd5e8281","modified":1702362829540},{"_id":"public/images/stream.jpg","hash":"6b00a4e48fd8fca89c47a9d0aa30eced480f8411","modified":1702362829540},{"_id":"public/images/2022-11-27 15-18-56屏幕截图.png","hash":"77977ba7499439ef83111bdbf13977a1509ccdc8","modified":1702362829540},{"_id":"public/images/CIA.png","hash":"d5c731925b25c37fe522e8f53b9dc5fa4bf3fd00","modified":1702362829540},{"_id":"public/images/DHCP.png","hash":"05269c2bccad26b9e77f61fff36a2731d85c7d6a","modified":1702362829540},{"_id":"public/images/LAN.png","hash":"447db6fa20be2f10f08a0d5b18f0220ba8e31ee2","modified":1702362829540},{"_id":"public/images/TCP_IP.png","hash":"6ef39b79a8a438f7b2cb9ba490cd8e3a206383f7","modified":1702362829540},{"_id":"public/images/UDP.png","hash":"5efaad9a992dc3ddb03ab598172caba16c8fa5e2","modified":1702362829540},{"_id":"public/images/avatar.png","hash":"f20fb18c46ab0c3a703ce759079a4f5221d9be6d","modified":1702362829540},{"_id":"public/images/awk.jpg","hash":"ba4067dbb8a8e656ce1a829bd67f0e723b8aff03","modified":1702362829540},{"_id":"public/images/bash.jpg","hash":"abf4d0ccca18f8fa78de17467c702285701ec609","modified":1702362829540},{"_id":"public/images/cable.png","hash":"15dfd985c4a7735e824fe38f45471f131ea8f29e","modified":1702362829540},{"_id":"public/images/character.png","hash":"49f9fa4943352947ba956ea6617e957c655ed448","modified":1702362829540},{"_id":"public/images/computer_bin.jpg","hash":"1ccc06f31a153c464dc31e6cd8f7afb53803ea3c","modified":1702362829540},{"_id":"public/images/curl.png","hash":"07715a8464d83e66b735391fe3f18e95a24ac787","modified":1702362829540},{"_id":"public/images/decorator.png","hash":"bc2936978b64538df745d6094a8a0d4ad906cc5c","modified":1702362829540},{"_id":"public/images/delay.png","hash":"1463ae11704a33b5484024432f81d8951075dd42","modified":1702362829540},{"_id":"public/images/docker.png","hash":"8a8d3040e83b6ae9defff1ecc038aed82cb56b25","modified":1702362829540},{"_id":"public/images/dockerfile.jpg","hash":"6c9a0107e80530cb15ad83b5c42771336583313e","modified":1702362829540},{"_id":"public/images/dsl.png","hash":"5bee06dfab8922f4c029337b8b2930a018326bcc","modified":1702362829540},{"_id":"public/images/extend.jpg","hash":"d292788a079104df054baaf052ef3a6a315ffcdf","modified":1702362829540},{"_id":"public/images/factoryMethodExp.png","hash":"4e0536d71647853e6453162308424ae3e882d939","modified":1702362829540},{"_id":"public/images/factoryMethodNormal.png","hash":"fc91eb445ef9ab45d9163d74c7f830de38e67b7d","modified":1702362829540},{"_id":"public/images/factoryPattern.png","hash":"51b54f4792f80e5a77028573fe28f132b400c572","modified":1702362829540},{"_id":"public/images/favicon.png","hash":"c3c4eb798776fe6479810f3ccf1f064135cb708c","modified":1702362829540},{"_id":"public/images/fiber.png","hash":"7901090e03617d543d5b54a5a156ef8e21cb305a","modified":1702362829540},{"_id":"public/images/file_descriptor.png","hash":"449a22551bf22492316f1c90d24dc6c07808fbd4","modified":1702362829540},{"_id":"public/images/file_descriptor2.png","hash":"01489b5ba5b6f172cd3811d7798512c7a2651bc2","modified":1702362829540},{"_id":"public/images/file_descriptor1.png","hash":"91b7312a0cce0defc2d5ca8c8503c398f1083d5a","modified":1702362829540},{"_id":"public/images/file_permission.jpg","hash":"1c5c349f360bb5ba85a00a4ff8f455c5741f0229","modified":1702362829540},{"_id":"public/images/filesystem.jpg","hash":"951570be6c105bd6f5958d875d86d1af704f91bb","modified":1702362829540},{"_id":"public/images/find.jpg","hash":"e3dbab74d40a0a948b975e2d21a7a8fbba010c3b","modified":1702362829540},{"_id":"public/images/fix.jpg","hash":"ed5e2c5f083f6c7870253074fe695ed6c9736e14","modified":1702362829540},{"_id":"public/images/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1702362829540},{"_id":"public/images/httpRequest.png","hash":"43f9f6ddbc2a6618e17a6289eac74f2e5cc58cc2","modified":1702362829540},{"_id":"public/images/knifes.jpg","hash":"a39c4235039a0de5a89db6f842924a0fd4650e80","modified":1702362829540},{"_id":"public/images/linuxCmd.jpeg","hash":"062de8d0a7244ac93b7d7887c9ac106fbacdb2b5","modified":1702362829540},{"_id":"public/images/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1702362829540},{"_id":"public/images/makeFile.png","hash":"fb1d5eeae1917384bb9265af2907e245b83cc8d3","modified":1702362829540},{"_id":"public/images/network.png","hash":"a2f09a3840eebf51309204d6cd11a3bbd40ca5d0","modified":1702362829540},{"_id":"public/images/openssh.png","hash":"f20d5faa11304891cd7d0214ad523ec63123f2f1","modified":1702362829540},{"_id":"public/images/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1702362829540},{"_id":"public/images/regex.jpg","hash":"877c4a7fded934656ef43c4a854137c025b8c853","modified":1702362829540},{"_id":"public/images/rust_borrow.jpg","hash":"7fc3c3b342f6127bd8f41c9d5e52b5fb50b8f424","modified":1702362829540},{"_id":"public/images/sed.jpeg","hash":"41645dd43592631b04b0ff79d83dbbc0a3969dcf","modified":1702362829540},{"_id":"public/images/sed.png","hash":"451df5f37f97c352b856f9ff7585d7f57be4a861","modified":1702362829540},{"_id":"public/images/sed1.png","hash":"df33cd372a819740b404d404905736399e7c67cb","modified":1702362829540},{"_id":"public/images/shell_example.jpg","hash":"26cbd81ec04e8975a06e398ff81129d19ec38d0e","modified":1702362829540},{"_id":"public/images/simpleFactory.png","hash":"6a8978dc2c10baa3e2794c725aad9b5ebbd3e9de","modified":1702362829540},{"_id":"public/images/tar.jpg","hash":"f4c6e9abfbe2aaf377a62c9ba113c7bdb89e4873","modified":1702362829540},{"_id":"public/images/tokio.png","hash":"59016addb683eda65266a0a1dcff36ce0b70a5f2","modified":1702362829540},{"_id":"public/images/zsh.png","hash":"97a2a9035fa95f60e861c7a4608fff2447bdf5a7","modified":1702362829540},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1702362829540},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1702362829540},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1702362829540},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1702362829540},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1702362829540},{"_id":"public/images/IP_fra.png","hash":"942b814f67d0f33d82063e4e24b4a79ef2eaa492","modified":1702362829540},{"_id":"public/images/TCP.png","hash":"e0f76bd0cddc4b4e1ee8caf22c0b99e27ff7862a","modified":1702362829540},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1702362829540},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1702362829540},{"_id":"public/css/main.css","hash":"28678339ba896d2106aa4b58124e93d3709ad161","modified":1702362829540},{"_id":"public/css/highlight.css","hash":"6e2f8edcc875b4d8e0cf5f2610e6e908bf9b51b1","modified":1702362829540},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1702362829540},{"_id":"public/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1702362829540},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1702362829540},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1702362829540},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1702362829540},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1702362829540},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1702362829540},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1702362829540},{"_id":"public/images/abstractFactory.png","hash":"fcc40c376a9e38416adefb4fffb6ed4ecbdaa4de","modified":1702362829540},{"_id":"public/images/archieve.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1702362829540},{"_id":"public/images/byebye.png","hash":"b07315b940a7549fdc1a36f4b58d102438b7bf7c","modified":1702362829540},{"_id":"public/images/decorator_cover.jpg","hash":"410636948b4ad3de8f107e98fe72c6129d0b4258","modified":1702362829540},{"_id":"public/images/gcc.jpg","hash":"aff48ef70fe79c7bfdcff4331684a49b8357c85e","modified":1702362829540},{"_id":"public/images/handshake.png","hash":"4600bcb5f4a996386c493586b03187f449f4f4b4","modified":1702362829540},{"_id":"public/images/hello_world.jpg","hash":"a65cd6cd3529d2937dc64ebb01fa546b7f16485b","modified":1702362829540},{"_id":"public/images/layer.png","hash":"aa4208beb6e96496762d0fdc1a93842a3fe61b65","modified":1702362829540},{"_id":"public/images/rep.png","hash":"948d6c4e73cb9cb4e127f28d24887e6a8f4f05e4","modified":1702362829540},{"_id":"public/images/tp.png","hash":"e580f7abad7034ec5505375e75da8d3436c6ec71","modified":1702362829540},{"_id":"public/images/tunneling.png","hash":"b5b2835806525e9827b076f45b2913b87c9eb86c","modified":1702362829540},{"_id":"public/images/wireless.png","hash":"1ff7159270f63fb53c972b1cd7aeff78d407081b","modified":1702362829540},{"_id":"public/images/IP.png","hash":"f019103388a5643551653208b73d7d73704e5898","modified":1702362829540},{"_id":"public/images/NAT.png","hash":"636745cca2e5492a564014d1398f1926140a07f4","modified":1702362829540},{"_id":"public/images/cover.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1702362829540},{"_id":"public/images/gdb.png","hash":"971fd8a25104590f27517022b8eb81d82c994226","modified":1702362829540},{"_id":"public/images/git.jpg","hash":"af7f1d46052116f657e7587cfb87b55d62c726b2","modified":1702362829540},{"_id":"public/images/about.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1702362829540},{"_id":"public/images/category.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1702362829540},{"_id":"public/images/decorator.jpg","hash":"f16d4c22092c2046704814366a21a7faaef0332b","modified":1702362829540},{"_id":"public/images/flameLinux2.jpg","hash":"9bf4e40ee5d1267c654d9656395854d4a5cb9972","modified":1702362829540},{"_id":"public/images/flameLinux3.jpg","hash":"a5590196afcac408d04a8b876f89d35c734a1193","modified":1702362829540},{"_id":"public/images/flameLinux4.jpg","hash":"01a998b3b9b698cfabb77197a7f5469c8dd4ee36","modified":1702362829540},{"_id":"public/images/sort_algori.png","hash":"e9acf18ccb4c41d3f65f02ffb1d4cfdf3b20e324","modified":1702362829540},{"_id":"public/images/flameLinux1.jpg","hash":"da8a467bb0eb60ee76cfd6ce51b4a15f9ad292a6","modified":1702362829540},{"_id":"public/images/vim.png","hash":"c4e533fd3e371933192f1546dc53d50b94619dd4","modified":1702362829540},{"_id":"public/images/tag.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1702362829540},{"_id":"public/images/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1702362829540},{"_id":"public/images/makefile.png","hash":"ed2a578ad3a8a2205ab6933b4ef3c2dca3f3b9cc","modified":1702362829540},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1702362829540},{"_id":"public/images/spike.jpg","hash":"71913cf82f3fe417787f6f6f2389f2938d452997","modified":1702362829540},{"_id":"public/images/rust.png","hash":"5930f64f82a1706bd074e2cc5bdbd8aef6177324","modified":1702362829540},{"_id":"source/images/observer.jpeg","hash":"4d9fcd970c7aad4cfcfadd6491731d53b3cb2117","modified":1702363594488},{"_id":"public/images/observer.jpeg","hash":"4d9fcd970c7aad4cfcfadd6491731d53b3cb2117","modified":1702363773171},{"_id":"source/images/STL.webp","hash":"6fff3a74f7355e7e29f27e5b7d6911b6e207ad4a","modified":1703074946033},{"_id":"source/images/mariadb.jpeg","hash":"2f241ec257e13a7f2018a6a60c6fd75f7041cb38","modified":1703074269070},{"_id":"source/images/processThread.png","hash":"4fab289c5abd467426e76897030ffddf6656037b","modified":1702364470941},{"_id":"source/images/timer.jpeg","hash":"910842eedb84818b1c763b52e883d669076b1e66","modified":1703073624463},{"_id":"source/images/linuxFile.webp","hash":"8c2d21cfbc787880c1e560dc5cb05e823b9daec0","modified":1703075886080},{"_id":"source/images/html.jpg","hash":"548245ed85fb0eaea1d72de46121f36bd7a616ed","modified":1703076040170},{"_id":"source/images/Cpp.jpeg","hash":"2c61615ce308c6c92b791bd0ee48ddb7c4faae79","modified":1703075446010},{"_id":"public/images/STL.webp","hash":"6fff3a74f7355e7e29f27e5b7d6911b6e207ad4a","modified":1703076078387},{"_id":"public/images/mariadb.jpeg","hash":"2f241ec257e13a7f2018a6a60c6fd75f7041cb38","modified":1703076078387},{"_id":"public/images/processThread.png","hash":"4fab289c5abd467426e76897030ffddf6656037b","modified":1703076078387},{"_id":"public/images/timer.jpeg","hash":"910842eedb84818b1c763b52e883d669076b1e66","modified":1703076078387},{"_id":"public/images/linuxFile.webp","hash":"8c2d21cfbc787880c1e560dc5cb05e823b9daec0","modified":1703076078387},{"_id":"public/images/html.jpg","hash":"548245ed85fb0eaea1d72de46121f36bd7a616ed","modified":1703076078387},{"_id":"public/images/Cpp.jpeg","hash":"2c61615ce308c6c92b791bd0ee48ddb7c4faae79","modified":1703076078387},{"_id":"source/_posts/python基础.md","hash":"9d2a0021ba4125030a84162c671bd8c26a155a00","modified":1705610547513},{"_id":"public/2024/01/10/python基础/index.html","hash":"35f4bdcd9cf7474b8abe73031c571bf6f8a55d96","modified":1711800645263},{"_id":"public/archives/2024/index.html","hash":"fda737cf4aa4cb99524b03017fc355d93699f243","modified":1739195801112},{"_id":"public/archives/2024/01/index.html","hash":"2e58a97d61ba68c5f188eae6b867332ad2de4e44","modified":1739195801112},{"_id":"source/images/python_set.png","hash":"7f1008f514a9f935f742621894990fa2c9f24d93","modified":1705357881708},{"_id":"public/images/python_set.png","hash":"7f1008f514a9f935f742621894990fa2c9f24d93","modified":1705609257223},{"_id":"source/_posts/C-Template.md","hash":"d914a1ecf9cc401023a66d6a18bde35be8f56b5e","modified":1718658823673},{"_id":"source/images/python_basic.png","hash":"cf4f545cf730a21b7303c66cd217c32e60eb9dc3","modified":1705610486573},{"_id":"source/_posts/translation-unit.md","hash":"a75598b94dc4bad44eeadd5efbfe649b13636ea0","modified":1711800642445},{"_id":"source/images/units_translate.jpg","hash":"9b634ca49a985f8d7b4fc50cb71784c3533d0e71","modified":1711791341941},{"_id":"source/images/compile_process.png","hash":"465dffd6f887455e8a99b1b7ece5ed61f2437a2f","modified":1711792361041},{"_id":"public/2024/03/30/translation-unit/index.html","hash":"8dc521bfe2392295381305cb528c2615996e5d70","modified":1716753879320},{"_id":"public/2024/03/24/C-Template/index.html","hash":"8d570c2ebeb93f61f3b697dbece07c31b72b5d92","modified":1720998664713},{"_id":"public/archives/2024/03/index.html","hash":"881cb18bf89a34c59c2fc846103901d0bad346c8","modified":1739195801112},{"_id":"public/images/python_basic.png","hash":"cf4f545cf730a21b7303c66cd217c32e60eb9dc3","modified":1711800645263},{"_id":"public/images/units_translate.jpg","hash":"9b634ca49a985f8d7b4fc50cb71784c3533d0e71","modified":1711800645263},{"_id":"public/images/compile_process.png","hash":"465dffd6f887455e8a99b1b7ece5ed61f2437a2f","modified":1711800645263},{"_id":"source/images/template.jpg","hash":"39f2682a2647b0b39dbbfec52a5d1ba9285878a1","modified":1711801039418},{"_id":"public/images/template.jpg","hash":"39f2682a2647b0b39dbbfec52a5d1ba9285878a1","modified":1711801177638},{"_id":"source/_posts/Linux命令-网络.md","hash":"ea525875bcf136df0848d595b08f6e11b2edb58e","modified":1718029681751},{"_id":"source/_posts/C-性能篇.md","hash":"df61b9588c55136f6fb4e560dd5799941a390726","modified":1718029569935},{"_id":"source/_posts/cmake.md","hash":"9dd39ec54eb09dc675d2745dd0e6238dd7d31d03","modified":1729256867787},{"_id":"source/_posts/ffmpeg.md","hash":"c5baf6ed7eba9856f5bd645688219f352dd4ff1d","modified":1728275030515},{"_id":"source/_posts/c-tools.md","hash":"194742e9262ce79480f0146085d4a63d11c16df2","modified":1718029515815},{"_id":"source/_posts/Linux命令-资源性能篇.md","hash":"c92bb0cd75de9fc724548a517e1b931881f325be","modified":1723155891870},{"_id":"public/2024/04/29/Linux命令-网络/index.html","hash":"96db059125264b72b7b9338da21159b12ea00c2e","modified":1739195801112},{"_id":"public/2024/04/18/C-性能篇/index.html","hash":"926019838f12e1f38fef259dddb293b8646ae19d","modified":1718029719706},{"_id":"public/2024/04/07/ffmpeg/index.html","hash":"7b767132b77fe1d84c6dc7c33ffa9226e3f4be7b","modified":1728275033222},{"_id":"public/2024/04/26/Linux命令-资源性能篇/index.html","hash":"f9ee5ed40d0cb7791928dfcf45b229177d5068d5","modified":1723155900581},{"_id":"public/2024/04/05/cmake/index.html","hash":"46f23e359282ffd9a29a1fbf7aed78c2f2ed1be4","modified":1729603679568},{"_id":"public/2024/04/05/c-tools/index.html","hash":"7b03971e08dd4856ea54762d97efaba305066148","modified":1718029719706},{"_id":"public/archives/2024/04/index.html","hash":"972fef088d6ff1407fba1d27336140b478bc6fec","modified":1739195801112},{"_id":"source/images/ffmpeg.jpeg","hash":"240d29d3e815db4e112b57b23e91f0763df6f0cd","modified":1718028703191},{"_id":"source/images/cmake.png","hash":"204d2329950ec46a37531c056e61a2161f3c8320","modified":1718028653961},{"_id":"source/images/cpp_eco.jpg","hash":"69c79da6958c9df664fcc5aabade050769348448","modified":1718028489908},{"_id":"source/images/linux_performance.jpeg","hash":"4aaf3fbecb24c7dfa10474ff8c0834c2ce29aed8","modified":1718028901845},{"_id":"source/images/performance.jpeg","hash":"455376bb948fb1ed9fe779b1c6a7ee8db64c901a","modified":1718028839618},{"_id":"source/images/linuc_network.png","hash":"fbf3608185572a0bfc070a435ee92775f61674d9","modified":1718028983638},{"_id":"public/images/cmake.png","hash":"204d2329950ec46a37531c056e61a2161f3c8320","modified":1718029719706},{"_id":"public/images/ffmpeg.jpeg","hash":"240d29d3e815db4e112b57b23e91f0763df6f0cd","modified":1718029719706},{"_id":"public/images/cpp_eco.jpg","hash":"69c79da6958c9df664fcc5aabade050769348448","modified":1718029719706},{"_id":"public/images/linux_performance.jpeg","hash":"4aaf3fbecb24c7dfa10474ff8c0834c2ce29aed8","modified":1718029719706},{"_id":"public/images/linuc_network.png","hash":"fbf3608185572a0bfc070a435ee92775f61674d9","modified":1718029719706},{"_id":"public/images/performance.jpeg","hash":"455376bb948fb1ed9fe779b1c6a7ee8db64c901a","modified":1718029719706},{"_id":"source/images/observer_normal.png","hash":"5e70bc19d1293c433adcd57947dc5cf6ceccea99","modified":1724362671019},{"_id":"source/images/observer_exp.png","hash":"390687b226a8ba9999808faa42ae2ebcf59028fe","modified":1724362752829},{"_id":"public/images/observer_normal.png","hash":"5e70bc19d1293c433adcd57947dc5cf6ceccea99","modified":1724362813177},{"_id":"public/images/observer_exp.png","hash":"390687b226a8ba9999808faa42ae2ebcf59028fe","modified":1724362813177},{"_id":"source/_posts/生活Tip.md","hash":"f7b318978593ae5f55f4a2e7b9c301e7cc52b9a0","modified":1739196325797},{"_id":"source/images/sheBao2.jpg","hash":"d1f495446ffa360bffda5d1e2087cf5beb7a7b24","modified":1739194856993},{"_id":"source/images/sheBao1.jpg","hash":"f19c674647208f6e3745d117ac5fc6fba53501c3","modified":1739194837757},{"_id":"source/images/sheBao3.jpg","hash":"c445f78f379bb8c3e9a7badd1a11eaa235f77803","modified":1739194874160},{"_id":"public/2025/02/10/生活Tip/index.html","hash":"e787b48b58e56ff2d51c7a1e7ddac5bc37ac69a1","modified":1739196330263},{"_id":"public/archives/2025/index.html","hash":"41671e7a41330fbbccd243c695d73800504db2b5","modified":1739195801112},{"_id":"public/archives/2025/02/index.html","hash":"23fe36fd68ff3c2444b87b49a9afc15528fa6060","modified":1739195801112},{"_id":"public/images/sheBao3.jpg","hash":"c445f78f379bb8c3e9a7badd1a11eaa235f77803","modified":1739195801112},{"_id":"public/images/sheBao1.jpg","hash":"f19c674647208f6e3745d117ac5fc6fba53501c3","modified":1739195801112},{"_id":"public/images/sheBao2.jpg","hash":"d1f495446ffa360bffda5d1e2087cf5beb7a7b24","modified":1739195801112},{"_id":"source/images/enjoyLife.jpg","hash":"3bf588742fc36b78d1465fc5a224cc89be8dca40","modified":1739196176811},{"_id":"public/images/enjoyLife.jpg","hash":"3bf588742fc36b78d1465fc5a224cc89be8dca40","modified":1739196330263}],"Category":[{"name":"C++","_id":"clq1yvi6t0006gwq2h3en0fay"},{"name":"Linux","_id":"clq1yvi6w000egwq2gjb3bhsk"},{"name":"html","_id":"clq1yvi730015gwq2cifbe99j"},{"name":"文本处理","_id":"clq1yvi77001qgwq2fo4e8zsh"}],"Data":[],"Page":[{"title":"categories","date":"2019-07-17T13:02:37.000Z","subtitle":null,"cover":null,"type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-07-17 21:02:37\nsubtitle:\ncover:\ntype: categories\n---\n","updated":"2023-12-12T06:29:01.375Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clq1yvi6o0000gwq2dlkh0ho2","content":"","excerpt":"","more":""},{"title":"Nanbert Don De Niro -- 南伯湛","date":"2023-12-12T04:48:50.000Z","banner_img":"/images/spike.jpg","index_img":"/images/spike.jpg","_content":"\n路漫漫其修远兮，吾将上下而求索\n如何环游世界而不工作\n南京航空航天大学 研究僧\n心地善良的爱国好少年\n","source":"about/index.md","raw":"---\ntitle: Nanbert Don De Niro -- 南伯湛\ndate: 2023-12-12 12:48:50\nbanner_img: /images/spike.jpg\nindex_img: /images/spike.jpg\n---\n\n路漫漫其修远兮，吾将上下而求索\n如何环游世界而不工作\n南京航空航天大学 研究僧\n心地善良的爱国好少年\n","updated":"2023-12-12T06:29:01.375Z","path":"about/index.html","comments":1,"layout":"page","_id":"clq1yvi6r0002gwq213ze5ha1","content":"<p>路漫漫其修远兮，吾将上下而求索<br>如何环游世界而不工作<br>南京航空航天大学 研究僧<br>心地善良的爱国好少年</p>\n","excerpt":"","more":"<p>路漫漫其修远兮，吾将上下而求索<br>如何环游世界而不工作<br>南京航空航天大学 研究僧<br>心地善良的爱国好少年</p>\n"}],"Post":[{"title":"AWK","date":"2021-01-24T09:08:06.000Z","subtitle":null,"index_img":"/images/awk.jpg","banner_img":"/images/awk.jpg","_content":"### 语法\n`awk [-v var=value] [-F re] [--] 'pattern n{action}' var=value files`\n`awk [-v var=value] [-F re] [--] -f scriptfile [file] var=value files`\n**注:**-v指定的变量定义在BEGIN之前,BEGIN过程中不能访问有关文件或命令行的任何变量(除了环境变量)\n### awk选项总结\n\n|options|describe\n|:-:|:-:|\n|-F|改变字段分割符,默认为空格|\n|-f|跟随脚本中的文件名|\n|-v|跟随var=value,作用域在BEGIN之前|\n|-mf [N]|指定处理的数据文件中最大字段数|\n|-mr [N]|指定处理的数据文件中最大行数|\n|-W keyword|指定gawk的兼容模式或警告等级|\n\n### awk内置变量\n\n|variable|describe|\n|:-:|:-:|\n|ARGV|命令行参数的数组,不包括脚本本身(-f选项也不包括),下标从0开始(一般为awk),一般大于0的下标都是输入的文件名,最后一个是ARGC-1|\n|ARGC|ARGV数组个数|\n|ARGIND|当前输入文件在ARGV的索引值|\n|CONVFMT|用于数字的字符串转换格式(%.6g)|\n|ENVIRON|环境变量数组,下标是环境变量名|\n|FILENAME|当前输入文件名称|\n|FNR|当前输入文件的记录(行)个数|\n|FS|字段分隔符,最好在BEGIN的时候定义|\n|ERRNO|当getline或close失败时的描述信息|\n|FIELDWIDTHS|见该小结|\n|IGNORECASE|如果不为0,模式匹配不区分大小写|\n|NF|每段记录(即行)的字段数(即单词)|\n|NR|行号|\n|OFMT|数值的输出格式,默认为\"%.6g\"|\n|OFS|输出字段分割符,默认为\" \"|\n|ORS|输出的记录分割符,默认为\"\\n\"|\n|RLENGTH|被函数match匹配的字符串长度|\n|RS|记录分隔符|\n|RT|如果RS为正则表达式，RT则代表当前行所匹配的值|\n|RSTART|被函数match匹配的字符串的开始|\n|SUBSEP|下标分割符(\\034)|\n|$0|整行内容|\n\n### awk内置函数\n\n|算术函数|描述|\n|:-:|:-:|\n|cos(x)|返回x的余弦|\n|exp(x)|返回e的x次幂|\n|sin(x)|返回x的正弦|\n|int(x)|返回x的整数部分的值|\n|log(x)|返回x的自然对数(以e为底)|\n|sqrt(x)|返回x的平方根|\n|atan2(y,x)|返回y/x的反正切|\n|rand()|返回0-1之间的随机数|\n|srand(x)|建立rand()的新的种子数。如果没有指定种子数,就用当天的时间。返回旧的种子值|\n|字符串函数|描述|\n|gsub(r,s,t)|在字符串t中用字符串s替换和正则表达式r匹配的所有字符串。返回替换的个数。如果没有给出t,默认$0|\n|gensub(r,s,h,t)|如果h以g或G开始的字符串，则对于在t中的r,用s进行全局替换。否则，h是一个数据：替换第h次出现的r.该函数返回新值，t本身不会改变，t默认为$0|\n|sprintf(fmt,expr-list)|根据格式字符串fmt返回格式化后的expr-list,fmt格式见printf那里|\n|index(s,t)|返回子串t在字符串s中的位置,如果没有指定s,则返回0|\n|length(s)|返回字符串s的长度,当没有给出s时,返回$0的长度|\n|match(s,r)|如果正则表达式r在s中出现,则返回出现的起始位置;如果没有,则返回0|\n|spllit(s,a,sep)|使用字段分隔符sep将字符串s分解到数组a的元素中,返回元素个数。如果没有给出sep,则使用FS。数组分割和字段分隔采用相同的方式|\n|sub(r,s,t)|在字符串t中用s替换正则表达式r的首次匹配。如果成功则返回1,否则返回0,,如果没有给出t,默认为$0|\n|substr(s,p,n)|返回字符串s中从位置p开始最大长度为n的子串。如果没有给出n,返回从p开始剩余的字符串。|\n|systime()|返回用秒表示的天的当前的时间,从UNIX元年开始算|\n|strftime(format,timestamp)|依照format格式化timestamp。timestamp默认为当前|\n|tolower(s)|将字符串s中的所有大写字符转换为小写,并返回新串|\n|toupper(s)|将字符串s中的小写字符转换为大写,并返回新串|\n### 模式汇总\n\n|格式|含义|\n|:-:|:-:|\n|BEGIN {statements}|在输入被读取之前,statements执行一次,**注意BEGIN里一些内建变量可能为空(如FILENAME)**|\n|END {statements}|当所有输入被读取完毕之后,statements执行一次|\n|expression {statements}|每碰到一个使expression为真的输入行,statements就执行.expression为真指的是其值非零或非空|\n|/regular expression/ {statements}|当输入行有一段字符串可以被正则表达式匹配,则执行statements|\n|compound pattern {statements}|一个复合模式将表达式用&&,||,!,以及括号组合起来;当复合模式为真时,statements执行|\n|pattern1,pattern2 {statements}|一个范围模式匹配多个输入行,这些输入行从匹配pattern1的开始,到匹配pattern2的行结束(包括这两行),对这其中的每一行执行statements|\n\n### 字符串匹配模式\n\n|格式|含义|\n|:-:|:-:|\n|/regexpr/|当当前输入行包含一段能够被regexexpr匹配的子字符串时,该模式匹配|\n|expression ~ /regexpr/|如果expression的字符串值包含一段能够被regexpr匹配的子字符串时,该模式被匹配,返回该字符串,否则返回（待测试）|\n|expression !~ /regexpr/|与上述相反|\n\n### 正则和字符串中的转移序列\n\n|序列|意义|\n|:-:|:-:|\n|`\\a`|报警字符|\n|`\\b`|退格|\n|`\\f`|换页|\n|`\\n`|换行|\n|`\\r`|回车|\n|`\\t`|制表符|\n|`\\v`|垂直制表符|\n|`\\ddd`|八进制数ddd, ddd含有1到3个数字,每个数字的值在0到7 之间|\n|`\\xbex`|十六进制|\n\n### 数组\nawk中的数组不需要声明定义,都是关联数组\n- 赋值一个数组`array[0]=1;array[1]=2`\n- 删除一个元素`delete array[subscript]`\n- 删除一个数组`delete array`\n- `i in a`如果a[i]存在,则表达式为1,否则为0\n- 遍历数组\n```bash\n#var是arr的每个下标\nfor (var in arr)\n{\n\tstatements\n}\n```\n### 字符串\n- 字符串的连接`\"pre\"str\"suf\"`不需要加号\n### 自定义函数\n自定义函数的参数为值传递，不改变遍历本身，但是数组例外,函数体内出现的任何变量都是全局变量，想要使用局部变量，只能放在参数列表中（参数列表中没有实际参数对应的参数都将作为局部变量使用）\n```bash\nfunction name(patameter-list){\n\tstatements\n}\n```\n### awk处理多行记录,主要改变分隔符\n`BEGIN { FS=\"\\n\";RS=\"\"}`,RS代表空行\n### `awk 'script' x=1 test1 x=2 test2`,awk可以这样传递变量\n### BEGIN与END\n特殊的模式BEGIN在第一个输入文件的第一行之前被匹配,END在最后一个输入文件的最后一行被处理之后匹配。\n### next与exit\nnext使awk抓取下一行,并返回到脚本底部;exit会使awk执行END,如果已经在END,则结束程序\n### nextfile\nnextfile语句和next类似，但它是更高层次上的操作。当执行nextfile时，当前的数据文件将被放弃，操作从脚本顶端开始，并使用下一个文件的第一个记录。\n### 输入分隔符\n内建变量 FS 的默认值是 \" \", 也就是一个空格符. 当 FS 具有这个特定值时, 输入字段按照 空格和 (或) 制表符分割, 前导的空格与制表符会被丢弃, 所以下面三行数据中, 其每一行的第 1 个字段都相同:\n```bash\n field1\n \tfield1\nfield1 field2\n```\n然而, 当 FS 是其他值时, 前导的空格与制表符不会被丢弃.  把一个字符串赋值给内建变量 FS 就可以改变字段分隔符. 如果字符串的长度多于一个字 符, 那么它会被当成一个正则表达式. 当前输入行中, 与该正则表达式匹配的最左, 最长, 非空且\n不重叠的子字符串变成字段分隔符, 举例来说,\n`BEGIN { FS = \",[ \\t]*|[ \\t]+\" }`\n如果某个子串由一个后面跟着空格或制表符的逗号组成, 或者没有逗号, 只有空格与制表符, 那 么这个子串就是字段分隔符.  如果 FS 被设置成单个字符 (除了空格符), 那么这个字符就变成字段分隔符. 这个约定使得\n把正则表达式元字符当作字段分隔符来用, 变得很容易:\nFS = \"|\"\n把 | 变成字段分隔符\n<font color=#FF0000>不管FS的值是什么,换行符总是多行记录的字段分隔符之一 </font>,如果RS被设置成\"\"(即空行为记录分割符),则默认的字段分隔符就是空格,制表及换行;如果FS是\\n,则换行符既是唯一分隔符\n#### FIELDWIDTHS\n该变量可以用来分隔出现在固定宽度列中的数据。这些数据可能或不可能由空白字符来风格字段的值  \n`FIELDWIDTHS= \"5 6 8 3\"`\n这里的记录有4个字段：$1有5个字符宽度，$2有6个字符的宽度等等。为FS指定一个值将恢复常规机制。通常使用FS=FS恢复，无需保存到额外变量中。\n### print与printf\n\n|格式|含义|\n|:-:|:-:|\n|print|将$0打印到标准输出|\n|print expression,expression,...|打印各个expression,expression之间由OFS分开,由ORS终止|\n|print expression,expression,...\\>filename|输出至filename|\n|print expression,expression,...\\>filename|追加到filename,不覆盖之前内容|\n|print expression,expression,... | command|输出作为命令command标准输入|\n|close(filename),close(command)|断开print与filename(或command)之间的连接,同一命令想要两次之间毫无关联,必须先close|\n|fflush(filename/cmd)|刷新缓存|\n|system(command)|执行command;函数的返回值是command的退出状态|\n\nprintf主要可以指定格式,以上都能用printf替换,如:`printf(format,expression,expression,...) > filename`末尾不会自动添加换行符\nprintf格式控制符(每一个格式说明符都以%开始,以转换字符结束)\n\n|字符|表达式将被打印成|\n|C|ASCII 字符|\n|d|十进制整数|\n|e|[-]d.dddddde[+-]dd|\n|E|[-]d.ddddddE[+-]dd|\n|f|[-]ddd.dddddd|\n|g|照e或f进行转换, 选择较短的那个, 无意义的零会被抑制|\n|G|照E或f进行转换, 选择较短的那个, 无意义的零会被抑制|\n|i|十进制|\n|O|无符号八进制数|\n|s|字符串|\n|x|无符号十六进制数|\n|X|无符号十六进制数,字母大写|\n|%|打印一个百分号 %, 不会有参数被吸收|\n\n|修饰符|含义|\n|:-:|:-:|\n|-|表达式在它的域内左对齐|\n|width|为了达到规定的宽度,必要时填充空格，前导0表示用0填充|\n|.prec|字符串最大宽度, 或十进制数的小数部分的位数|\n\n|fmt|$1|printf(fmt,$1)|\n|:-:|:-:|:-:|\n|%c|97|a|\n|%d|97.5|97|\n|%5d|97.5|  97|\n|%e|97.5|9.750000e+01|\n|%f|97.5|97.500000|\n|%7.2f|97.5|  97.50|\n|%g|97.5|97.5|\n|%.6g|97.5|97.5|\n|%o|97|141|\n|%06o|97|000141|\n|%x|97|61|\n|%s|January|`|January|`|\n|%10s|January|`|   January|`|\n|%-10s|January|`|January   |`|\n|%.3s|January|`Jan`|\n|%10.3s|January|`|       Jan|`|\n|%-10.3s|January|`|Jan      |`|\n|%%|January|%|\n### 管道的奇怪用法(好好理解到底啥是管道)\n```bash\n{\n\t#注意sort命令用引号括起来,当成字符串\n\tprint xx | \"sort -t'\\t' +1rn\"\n\t#上面的管道名就是\"sort -t'\\t' +1rn\"\n\tclose(\"sort -t'\\t' +1rn\")\n}\n```\n假设有以下文件\n```\nFrance\t211\t55\tEurope\nJapan\t144\t120\tAsia\nGermany\t96\t61\tEurope\nEngland\t94\t56\tEurope\nUSSR\t8649\t275\tAsia\nCanada\t3852\t25\tNorth America\nChina\t3705\t1032\tAsia\nUSA\t3615\t237\tNorth America\nBrazil\t3286\t134\tSouth America\nIndia\t1267\t746\tAsia\nMexico\t762\t78\tNorth America\n```\n以下程序会简单排序\n```bash\n# prep1 - prepare countries by continent and pop. den.\nBEGIN { FS = \"\\t\" }\n{ \n\tprintf(\"%s:%s:%d:%d:%.1f\\n\",\n\t$4, $1, $3, $2, 1000*$3/$2) | \"sort -t: -k 1,1 -k 5rn\"\n}\n```\n\n### getline函数\n- 描述:函数getline可以从当前输入行,或文件,或管道,读取输入.getline抓取下一个记录,按照通常的方式把记录分割成一个个的字段.它会设置NF,NR,和FNR;如果存在一个记录,返回1,若遇到文件末尾,返回0,发生错误时返回-1(例如打开文件失败).\n- `getline x`读取下一条记录到变量x中，并递增NR与FNR,不会对记录进行分隔，不会设置NF\n- `getline <\"file\"`从文件file读取输入.它不会对NR与FNR产生影响, 但是会执行字段分割,并且设置NF.\n- `getline x <\"file\"`从file读取下一条记录,存到变量x中.记录不会被分割成字段,变量NF,NR,与FNR都不会被修改.\n\n|表达式|被设置的变量|\n|:-:|:-:|\n|getline|\\$0,NF,NR,FNR|\n|getline var|var,NR,FNR|\n|getline \\<file|\\$0,NF|\n|getline var\\<file|var|\n|`cmd|getline`|\\$0,NF|\n|`cmd|getline var`|var|\n\n例子：\n```bash\n#必须判断大于0,否则文件不存在则就是死循环\nwhile (getline x<file >0)\n\tprint x\n\tnext\nwhile (\"who\"|getline)\n\tn++\n```\n\n13.例子\na.将每一行的字段逆序打印\n```bash\n{\n\tfor (i=NF;i>0;i=i-1) printf(\"%s \",$i)\n\tprintf(\"\\n\")\n}\n```\n### awk的正则表达式\n- awk的圆括号用法有点异样:`(r1)(r2)`若匹配xy,其中x匹配r1,y匹配r2。\n  举例:`(Asian|European|North American) (male|female) (black|blue)bird`12种组合\n### shell中包含awk\n - 见例子1\n### awk程序搜索路径\n awk允许你指定一个名为AWKPATH的环境变量，它定义了awk程序的文件搜索路径，默认路径为:/usr/local/share/awk。当前路径永远最优先,如果文件名包含`/`将不执行查找\n### 例子\n```bash\n# field -打印每个文件的指定字段顺序\n# usage: field n n n ... file file file ...\nawk '\n#开始时,寻找数字,并使之清空,这样他们就不会被当成文件名\nBEGIN {\nfor (i = 1; ARGV[i] ~ /^[0-9]+$/; i++) { # collect numbers\nfld[++nf] = ARGV[i]\nARGV[i] = \"\"\n}\nif (i >= ARGC)\n# no file names so force stdin\nARGV[ARGC++] = \"-\"\n}\n{\nfor (i = 1; i <= nf; i++)\nprintf(\"%s%s\", $fld[i], i < nf ? \" \" : \"\\n\")\n}\n' $*\n```\n```bash\n#交互式awk脚本\nBEGIN {\n\tmaxnum = ARGC > 1 ? ARGV[1] : 10\n\t# default size is 10\n\tARGV[1] = \"-\"# read standard input subsequently\n\tsrand()# reset rand from time of day\n\tdo {\n\t\tn1 = randint(maxnum)\n\t\tn2 = randint(maxnum)\n\t\tprintf(\"%g + %g = ? \", n1, n2)\n\t\twhile ((input = getline) > 0)\n\t\t\tif ($0 == n1 + n2) {\n\t\t\t\tprint \"Right!\"\n\t\t\t\tbreak\n\t\t\t} else if ($0 == \"\") {\n\t\t\t\tprint n1 + n2\n\t\t\t\tbreak\n\t\t\t} else\n\t\t\t\tprintf(\"wrong, try again: \")\n\t\t} while (input > 0)\n}\nfunction randint(n) { return int(rand()*n)+1 }\n```\n- 去除字符串`gsub(/\"([^\"]|\\\\\")*\"/, \"\", line)`\n- 去除正则表达式`gsub(/\\/([^\\/]|\\\\\\/)+\\//, \"\", line)`\n- 去除注释`sub(/#.*/, \"\", line)`\n","source":"_posts/AWK.md","raw":"---\ntitle: AWK\ndate: 2021-01-24 17:08:06\nsubtitle:\ncategories:\ntags:\nindex_img: /images/awk.jpg\nbanner_img: /images/awk.jpg\n---\n### 语法\n`awk [-v var=value] [-F re] [--] 'pattern n{action}' var=value files`\n`awk [-v var=value] [-F re] [--] -f scriptfile [file] var=value files`\n**注:**-v指定的变量定义在BEGIN之前,BEGIN过程中不能访问有关文件或命令行的任何变量(除了环境变量)\n### awk选项总结\n\n|options|describe\n|:-:|:-:|\n|-F|改变字段分割符,默认为空格|\n|-f|跟随脚本中的文件名|\n|-v|跟随var=value,作用域在BEGIN之前|\n|-mf [N]|指定处理的数据文件中最大字段数|\n|-mr [N]|指定处理的数据文件中最大行数|\n|-W keyword|指定gawk的兼容模式或警告等级|\n\n### awk内置变量\n\n|variable|describe|\n|:-:|:-:|\n|ARGV|命令行参数的数组,不包括脚本本身(-f选项也不包括),下标从0开始(一般为awk),一般大于0的下标都是输入的文件名,最后一个是ARGC-1|\n|ARGC|ARGV数组个数|\n|ARGIND|当前输入文件在ARGV的索引值|\n|CONVFMT|用于数字的字符串转换格式(%.6g)|\n|ENVIRON|环境变量数组,下标是环境变量名|\n|FILENAME|当前输入文件名称|\n|FNR|当前输入文件的记录(行)个数|\n|FS|字段分隔符,最好在BEGIN的时候定义|\n|ERRNO|当getline或close失败时的描述信息|\n|FIELDWIDTHS|见该小结|\n|IGNORECASE|如果不为0,模式匹配不区分大小写|\n|NF|每段记录(即行)的字段数(即单词)|\n|NR|行号|\n|OFMT|数值的输出格式,默认为\"%.6g\"|\n|OFS|输出字段分割符,默认为\" \"|\n|ORS|输出的记录分割符,默认为\"\\n\"|\n|RLENGTH|被函数match匹配的字符串长度|\n|RS|记录分隔符|\n|RT|如果RS为正则表达式，RT则代表当前行所匹配的值|\n|RSTART|被函数match匹配的字符串的开始|\n|SUBSEP|下标分割符(\\034)|\n|$0|整行内容|\n\n### awk内置函数\n\n|算术函数|描述|\n|:-:|:-:|\n|cos(x)|返回x的余弦|\n|exp(x)|返回e的x次幂|\n|sin(x)|返回x的正弦|\n|int(x)|返回x的整数部分的值|\n|log(x)|返回x的自然对数(以e为底)|\n|sqrt(x)|返回x的平方根|\n|atan2(y,x)|返回y/x的反正切|\n|rand()|返回0-1之间的随机数|\n|srand(x)|建立rand()的新的种子数。如果没有指定种子数,就用当天的时间。返回旧的种子值|\n|字符串函数|描述|\n|gsub(r,s,t)|在字符串t中用字符串s替换和正则表达式r匹配的所有字符串。返回替换的个数。如果没有给出t,默认$0|\n|gensub(r,s,h,t)|如果h以g或G开始的字符串，则对于在t中的r,用s进行全局替换。否则，h是一个数据：替换第h次出现的r.该函数返回新值，t本身不会改变，t默认为$0|\n|sprintf(fmt,expr-list)|根据格式字符串fmt返回格式化后的expr-list,fmt格式见printf那里|\n|index(s,t)|返回子串t在字符串s中的位置,如果没有指定s,则返回0|\n|length(s)|返回字符串s的长度,当没有给出s时,返回$0的长度|\n|match(s,r)|如果正则表达式r在s中出现,则返回出现的起始位置;如果没有,则返回0|\n|spllit(s,a,sep)|使用字段分隔符sep将字符串s分解到数组a的元素中,返回元素个数。如果没有给出sep,则使用FS。数组分割和字段分隔采用相同的方式|\n|sub(r,s,t)|在字符串t中用s替换正则表达式r的首次匹配。如果成功则返回1,否则返回0,,如果没有给出t,默认为$0|\n|substr(s,p,n)|返回字符串s中从位置p开始最大长度为n的子串。如果没有给出n,返回从p开始剩余的字符串。|\n|systime()|返回用秒表示的天的当前的时间,从UNIX元年开始算|\n|strftime(format,timestamp)|依照format格式化timestamp。timestamp默认为当前|\n|tolower(s)|将字符串s中的所有大写字符转换为小写,并返回新串|\n|toupper(s)|将字符串s中的小写字符转换为大写,并返回新串|\n### 模式汇总\n\n|格式|含义|\n|:-:|:-:|\n|BEGIN {statements}|在输入被读取之前,statements执行一次,**注意BEGIN里一些内建变量可能为空(如FILENAME)**|\n|END {statements}|当所有输入被读取完毕之后,statements执行一次|\n|expression {statements}|每碰到一个使expression为真的输入行,statements就执行.expression为真指的是其值非零或非空|\n|/regular expression/ {statements}|当输入行有一段字符串可以被正则表达式匹配,则执行statements|\n|compound pattern {statements}|一个复合模式将表达式用&&,||,!,以及括号组合起来;当复合模式为真时,statements执行|\n|pattern1,pattern2 {statements}|一个范围模式匹配多个输入行,这些输入行从匹配pattern1的开始,到匹配pattern2的行结束(包括这两行),对这其中的每一行执行statements|\n\n### 字符串匹配模式\n\n|格式|含义|\n|:-:|:-:|\n|/regexpr/|当当前输入行包含一段能够被regexexpr匹配的子字符串时,该模式匹配|\n|expression ~ /regexpr/|如果expression的字符串值包含一段能够被regexpr匹配的子字符串时,该模式被匹配,返回该字符串,否则返回（待测试）|\n|expression !~ /regexpr/|与上述相反|\n\n### 正则和字符串中的转移序列\n\n|序列|意义|\n|:-:|:-:|\n|`\\a`|报警字符|\n|`\\b`|退格|\n|`\\f`|换页|\n|`\\n`|换行|\n|`\\r`|回车|\n|`\\t`|制表符|\n|`\\v`|垂直制表符|\n|`\\ddd`|八进制数ddd, ddd含有1到3个数字,每个数字的值在0到7 之间|\n|`\\xbex`|十六进制|\n\n### 数组\nawk中的数组不需要声明定义,都是关联数组\n- 赋值一个数组`array[0]=1;array[1]=2`\n- 删除一个元素`delete array[subscript]`\n- 删除一个数组`delete array`\n- `i in a`如果a[i]存在,则表达式为1,否则为0\n- 遍历数组\n```bash\n#var是arr的每个下标\nfor (var in arr)\n{\n\tstatements\n}\n```\n### 字符串\n- 字符串的连接`\"pre\"str\"suf\"`不需要加号\n### 自定义函数\n自定义函数的参数为值传递，不改变遍历本身，但是数组例外,函数体内出现的任何变量都是全局变量，想要使用局部变量，只能放在参数列表中（参数列表中没有实际参数对应的参数都将作为局部变量使用）\n```bash\nfunction name(patameter-list){\n\tstatements\n}\n```\n### awk处理多行记录,主要改变分隔符\n`BEGIN { FS=\"\\n\";RS=\"\"}`,RS代表空行\n### `awk 'script' x=1 test1 x=2 test2`,awk可以这样传递变量\n### BEGIN与END\n特殊的模式BEGIN在第一个输入文件的第一行之前被匹配,END在最后一个输入文件的最后一行被处理之后匹配。\n### next与exit\nnext使awk抓取下一行,并返回到脚本底部;exit会使awk执行END,如果已经在END,则结束程序\n### nextfile\nnextfile语句和next类似，但它是更高层次上的操作。当执行nextfile时，当前的数据文件将被放弃，操作从脚本顶端开始，并使用下一个文件的第一个记录。\n### 输入分隔符\n内建变量 FS 的默认值是 \" \", 也就是一个空格符. 当 FS 具有这个特定值时, 输入字段按照 空格和 (或) 制表符分割, 前导的空格与制表符会被丢弃, 所以下面三行数据中, 其每一行的第 1 个字段都相同:\n```bash\n field1\n \tfield1\nfield1 field2\n```\n然而, 当 FS 是其他值时, 前导的空格与制表符不会被丢弃.  把一个字符串赋值给内建变量 FS 就可以改变字段分隔符. 如果字符串的长度多于一个字 符, 那么它会被当成一个正则表达式. 当前输入行中, 与该正则表达式匹配的最左, 最长, 非空且\n不重叠的子字符串变成字段分隔符, 举例来说,\n`BEGIN { FS = \",[ \\t]*|[ \\t]+\" }`\n如果某个子串由一个后面跟着空格或制表符的逗号组成, 或者没有逗号, 只有空格与制表符, 那 么这个子串就是字段分隔符.  如果 FS 被设置成单个字符 (除了空格符), 那么这个字符就变成字段分隔符. 这个约定使得\n把正则表达式元字符当作字段分隔符来用, 变得很容易:\nFS = \"|\"\n把 | 变成字段分隔符\n<font color=#FF0000>不管FS的值是什么,换行符总是多行记录的字段分隔符之一 </font>,如果RS被设置成\"\"(即空行为记录分割符),则默认的字段分隔符就是空格,制表及换行;如果FS是\\n,则换行符既是唯一分隔符\n#### FIELDWIDTHS\n该变量可以用来分隔出现在固定宽度列中的数据。这些数据可能或不可能由空白字符来风格字段的值  \n`FIELDWIDTHS= \"5 6 8 3\"`\n这里的记录有4个字段：$1有5个字符宽度，$2有6个字符的宽度等等。为FS指定一个值将恢复常规机制。通常使用FS=FS恢复，无需保存到额外变量中。\n### print与printf\n\n|格式|含义|\n|:-:|:-:|\n|print|将$0打印到标准输出|\n|print expression,expression,...|打印各个expression,expression之间由OFS分开,由ORS终止|\n|print expression,expression,...\\>filename|输出至filename|\n|print expression,expression,...\\>filename|追加到filename,不覆盖之前内容|\n|print expression,expression,... | command|输出作为命令command标准输入|\n|close(filename),close(command)|断开print与filename(或command)之间的连接,同一命令想要两次之间毫无关联,必须先close|\n|fflush(filename/cmd)|刷新缓存|\n|system(command)|执行command;函数的返回值是command的退出状态|\n\nprintf主要可以指定格式,以上都能用printf替换,如:`printf(format,expression,expression,...) > filename`末尾不会自动添加换行符\nprintf格式控制符(每一个格式说明符都以%开始,以转换字符结束)\n\n|字符|表达式将被打印成|\n|C|ASCII 字符|\n|d|十进制整数|\n|e|[-]d.dddddde[+-]dd|\n|E|[-]d.ddddddE[+-]dd|\n|f|[-]ddd.dddddd|\n|g|照e或f进行转换, 选择较短的那个, 无意义的零会被抑制|\n|G|照E或f进行转换, 选择较短的那个, 无意义的零会被抑制|\n|i|十进制|\n|O|无符号八进制数|\n|s|字符串|\n|x|无符号十六进制数|\n|X|无符号十六进制数,字母大写|\n|%|打印一个百分号 %, 不会有参数被吸收|\n\n|修饰符|含义|\n|:-:|:-:|\n|-|表达式在它的域内左对齐|\n|width|为了达到规定的宽度,必要时填充空格，前导0表示用0填充|\n|.prec|字符串最大宽度, 或十进制数的小数部分的位数|\n\n|fmt|$1|printf(fmt,$1)|\n|:-:|:-:|:-:|\n|%c|97|a|\n|%d|97.5|97|\n|%5d|97.5|  97|\n|%e|97.5|9.750000e+01|\n|%f|97.5|97.500000|\n|%7.2f|97.5|  97.50|\n|%g|97.5|97.5|\n|%.6g|97.5|97.5|\n|%o|97|141|\n|%06o|97|000141|\n|%x|97|61|\n|%s|January|`|January|`|\n|%10s|January|`|   January|`|\n|%-10s|January|`|January   |`|\n|%.3s|January|`Jan`|\n|%10.3s|January|`|       Jan|`|\n|%-10.3s|January|`|Jan      |`|\n|%%|January|%|\n### 管道的奇怪用法(好好理解到底啥是管道)\n```bash\n{\n\t#注意sort命令用引号括起来,当成字符串\n\tprint xx | \"sort -t'\\t' +1rn\"\n\t#上面的管道名就是\"sort -t'\\t' +1rn\"\n\tclose(\"sort -t'\\t' +1rn\")\n}\n```\n假设有以下文件\n```\nFrance\t211\t55\tEurope\nJapan\t144\t120\tAsia\nGermany\t96\t61\tEurope\nEngland\t94\t56\tEurope\nUSSR\t8649\t275\tAsia\nCanada\t3852\t25\tNorth America\nChina\t3705\t1032\tAsia\nUSA\t3615\t237\tNorth America\nBrazil\t3286\t134\tSouth America\nIndia\t1267\t746\tAsia\nMexico\t762\t78\tNorth America\n```\n以下程序会简单排序\n```bash\n# prep1 - prepare countries by continent and pop. den.\nBEGIN { FS = \"\\t\" }\n{ \n\tprintf(\"%s:%s:%d:%d:%.1f\\n\",\n\t$4, $1, $3, $2, 1000*$3/$2) | \"sort -t: -k 1,1 -k 5rn\"\n}\n```\n\n### getline函数\n- 描述:函数getline可以从当前输入行,或文件,或管道,读取输入.getline抓取下一个记录,按照通常的方式把记录分割成一个个的字段.它会设置NF,NR,和FNR;如果存在一个记录,返回1,若遇到文件末尾,返回0,发生错误时返回-1(例如打开文件失败).\n- `getline x`读取下一条记录到变量x中，并递增NR与FNR,不会对记录进行分隔，不会设置NF\n- `getline <\"file\"`从文件file读取输入.它不会对NR与FNR产生影响, 但是会执行字段分割,并且设置NF.\n- `getline x <\"file\"`从file读取下一条记录,存到变量x中.记录不会被分割成字段,变量NF,NR,与FNR都不会被修改.\n\n|表达式|被设置的变量|\n|:-:|:-:|\n|getline|\\$0,NF,NR,FNR|\n|getline var|var,NR,FNR|\n|getline \\<file|\\$0,NF|\n|getline var\\<file|var|\n|`cmd|getline`|\\$0,NF|\n|`cmd|getline var`|var|\n\n例子：\n```bash\n#必须判断大于0,否则文件不存在则就是死循环\nwhile (getline x<file >0)\n\tprint x\n\tnext\nwhile (\"who\"|getline)\n\tn++\n```\n\n13.例子\na.将每一行的字段逆序打印\n```bash\n{\n\tfor (i=NF;i>0;i=i-1) printf(\"%s \",$i)\n\tprintf(\"\\n\")\n}\n```\n### awk的正则表达式\n- awk的圆括号用法有点异样:`(r1)(r2)`若匹配xy,其中x匹配r1,y匹配r2。\n  举例:`(Asian|European|North American) (male|female) (black|blue)bird`12种组合\n### shell中包含awk\n - 见例子1\n### awk程序搜索路径\n awk允许你指定一个名为AWKPATH的环境变量，它定义了awk程序的文件搜索路径，默认路径为:/usr/local/share/awk。当前路径永远最优先,如果文件名包含`/`将不执行查找\n### 例子\n```bash\n# field -打印每个文件的指定字段顺序\n# usage: field n n n ... file file file ...\nawk '\n#开始时,寻找数字,并使之清空,这样他们就不会被当成文件名\nBEGIN {\nfor (i = 1; ARGV[i] ~ /^[0-9]+$/; i++) { # collect numbers\nfld[++nf] = ARGV[i]\nARGV[i] = \"\"\n}\nif (i >= ARGC)\n# no file names so force stdin\nARGV[ARGC++] = \"-\"\n}\n{\nfor (i = 1; i <= nf; i++)\nprintf(\"%s%s\", $fld[i], i < nf ? \" \" : \"\\n\")\n}\n' $*\n```\n```bash\n#交互式awk脚本\nBEGIN {\n\tmaxnum = ARGC > 1 ? ARGV[1] : 10\n\t# default size is 10\n\tARGV[1] = \"-\"# read standard input subsequently\n\tsrand()# reset rand from time of day\n\tdo {\n\t\tn1 = randint(maxnum)\n\t\tn2 = randint(maxnum)\n\t\tprintf(\"%g + %g = ? \", n1, n2)\n\t\twhile ((input = getline) > 0)\n\t\t\tif ($0 == n1 + n2) {\n\t\t\t\tprint \"Right!\"\n\t\t\t\tbreak\n\t\t\t} else if ($0 == \"\") {\n\t\t\t\tprint n1 + n2\n\t\t\t\tbreak\n\t\t\t} else\n\t\t\t\tprintf(\"wrong, try again: \")\n\t\t} while (input > 0)\n}\nfunction randint(n) { return int(rand()*n)+1 }\n```\n- 去除字符串`gsub(/\"([^\"]|\\\\\")*\"/, \"\", line)`\n- 去除正则表达式`gsub(/\\/([^\\/]|\\\\\\/)+\\//, \"\", line)`\n- 去除注释`sub(/#.*/, \"\", line)`\n","slug":"AWK","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi6p0001gwq2g9cr6cu9","content":"<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>awk [-v var=value] [-F re] [--] &#39;pattern n&#123;action&#125;&#39; var=value files</code><br><code>awk [-v var=value] [-F re] [--] -f scriptfile [file] var=value files</code><br><strong>注:</strong>-v指定的变量定义在BEGIN之前,BEGIN过程中不能访问有关文件或命令行的任何变量(除了环境变量)</p>\n<h3 id=\"awk选项总结\"><a href=\"#awk选项总结\" class=\"headerlink\" title=\"awk选项总结\"></a>awk选项总结</h3><table>\n<thead>\n<tr>\n<th align=\"center\">options</th>\n<th align=\"center\">describe</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-F</td>\n<td align=\"center\">改变字段分割符,默认为空格</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">跟随脚本中的文件名</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">跟随var&#x3D;value,作用域在BEGIN之前</td>\n</tr>\n<tr>\n<td align=\"center\">-mf [N]</td>\n<td align=\"center\">指定处理的数据文件中最大字段数</td>\n</tr>\n<tr>\n<td align=\"center\">-mr [N]</td>\n<td align=\"center\">指定处理的数据文件中最大行数</td>\n</tr>\n<tr>\n<td align=\"center\">-W keyword</td>\n<td align=\"center\">指定gawk的兼容模式或警告等级</td>\n</tr>\n</tbody></table>\n<h3 id=\"awk内置变量\"><a href=\"#awk内置变量\" class=\"headerlink\" title=\"awk内置变量\"></a>awk内置变量</h3><table>\n<thead>\n<tr>\n<th align=\"center\">variable</th>\n<th align=\"center\">describe</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ARGV</td>\n<td align=\"center\">命令行参数的数组,不包括脚本本身(-f选项也不包括),下标从0开始(一般为awk),一般大于0的下标都是输入的文件名,最后一个是ARGC-1</td>\n</tr>\n<tr>\n<td align=\"center\">ARGC</td>\n<td align=\"center\">ARGV数组个数</td>\n</tr>\n<tr>\n<td align=\"center\">ARGIND</td>\n<td align=\"center\">当前输入文件在ARGV的索引值</td>\n</tr>\n<tr>\n<td align=\"center\">CONVFMT</td>\n<td align=\"center\">用于数字的字符串转换格式(%.6g)</td>\n</tr>\n<tr>\n<td align=\"center\">ENVIRON</td>\n<td align=\"center\">环境变量数组,下标是环境变量名</td>\n</tr>\n<tr>\n<td align=\"center\">FILENAME</td>\n<td align=\"center\">当前输入文件名称</td>\n</tr>\n<tr>\n<td align=\"center\">FNR</td>\n<td align=\"center\">当前输入文件的记录(行)个数</td>\n</tr>\n<tr>\n<td align=\"center\">FS</td>\n<td align=\"center\">字段分隔符,最好在BEGIN的时候定义</td>\n</tr>\n<tr>\n<td align=\"center\">ERRNO</td>\n<td align=\"center\">当getline或close失败时的描述信息</td>\n</tr>\n<tr>\n<td align=\"center\">FIELDWIDTHS</td>\n<td align=\"center\">见该小结</td>\n</tr>\n<tr>\n<td align=\"center\">IGNORECASE</td>\n<td align=\"center\">如果不为0,模式匹配不区分大小写</td>\n</tr>\n<tr>\n<td align=\"center\">NF</td>\n<td align=\"center\">每段记录(即行)的字段数(即单词)</td>\n</tr>\n<tr>\n<td align=\"center\">NR</td>\n<td align=\"center\">行号</td>\n</tr>\n<tr>\n<td align=\"center\">OFMT</td>\n<td align=\"center\">数值的输出格式,默认为”%.6g”</td>\n</tr>\n<tr>\n<td align=\"center\">OFS</td>\n<td align=\"center\">输出字段分割符,默认为” “</td>\n</tr>\n<tr>\n<td align=\"center\">ORS</td>\n<td align=\"center\">输出的记录分割符,默认为”\\n”</td>\n</tr>\n<tr>\n<td align=\"center\">RLENGTH</td>\n<td align=\"center\">被函数match匹配的字符串长度</td>\n</tr>\n<tr>\n<td align=\"center\">RS</td>\n<td align=\"center\">记录分隔符</td>\n</tr>\n<tr>\n<td align=\"center\">RT</td>\n<td align=\"center\">如果RS为正则表达式，RT则代表当前行所匹配的值</td>\n</tr>\n<tr>\n<td align=\"center\">RSTART</td>\n<td align=\"center\">被函数match匹配的字符串的开始</td>\n</tr>\n<tr>\n<td align=\"center\">SUBSEP</td>\n<td align=\"center\">下标分割符(\\034)</td>\n</tr>\n<tr>\n<td align=\"center\">$0</td>\n<td align=\"center\">整行内容</td>\n</tr>\n</tbody></table>\n<h3 id=\"awk内置函数\"><a href=\"#awk内置函数\" class=\"headerlink\" title=\"awk内置函数\"></a>awk内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">算术函数</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">cos(x)</td>\n<td align=\"center\">返回x的余弦</td>\n</tr>\n<tr>\n<td align=\"center\">exp(x)</td>\n<td align=\"center\">返回e的x次幂</td>\n</tr>\n<tr>\n<td align=\"center\">sin(x)</td>\n<td align=\"center\">返回x的正弦</td>\n</tr>\n<tr>\n<td align=\"center\">int(x)</td>\n<td align=\"center\">返回x的整数部分的值</td>\n</tr>\n<tr>\n<td align=\"center\">log(x)</td>\n<td align=\"center\">返回x的自然对数(以e为底)</td>\n</tr>\n<tr>\n<td align=\"center\">sqrt(x)</td>\n<td align=\"center\">返回x的平方根</td>\n</tr>\n<tr>\n<td align=\"center\">atan2(y,x)</td>\n<td align=\"center\">返回y&#x2F;x的反正切</td>\n</tr>\n<tr>\n<td align=\"center\">rand()</td>\n<td align=\"center\">返回0-1之间的随机数</td>\n</tr>\n<tr>\n<td align=\"center\">srand(x)</td>\n<td align=\"center\">建立rand()的新的种子数。如果没有指定种子数,就用当天的时间。返回旧的种子值</td>\n</tr>\n<tr>\n<td align=\"center\">字符串函数</td>\n<td align=\"center\">描述</td>\n</tr>\n<tr>\n<td align=\"center\">gsub(r,s,t)</td>\n<td align=\"center\">在字符串t中用字符串s替换和正则表达式r匹配的所有字符串。返回替换的个数。如果没有给出t,默认$0</td>\n</tr>\n<tr>\n<td align=\"center\">gensub(r,s,h,t)</td>\n<td align=\"center\">如果h以g或G开始的字符串，则对于在t中的r,用s进行全局替换。否则，h是一个数据：替换第h次出现的r.该函数返回新值，t本身不会改变，t默认为$0</td>\n</tr>\n<tr>\n<td align=\"center\">sprintf(fmt,expr-list)</td>\n<td align=\"center\">根据格式字符串fmt返回格式化后的expr-list,fmt格式见printf那里</td>\n</tr>\n<tr>\n<td align=\"center\">index(s,t)</td>\n<td align=\"center\">返回子串t在字符串s中的位置,如果没有指定s,则返回0</td>\n</tr>\n<tr>\n<td align=\"center\">length(s)</td>\n<td align=\"center\">返回字符串s的长度,当没有给出s时,返回$0的长度</td>\n</tr>\n<tr>\n<td align=\"center\">match(s,r)</td>\n<td align=\"center\">如果正则表达式r在s中出现,则返回出现的起始位置;如果没有,则返回0</td>\n</tr>\n<tr>\n<td align=\"center\">spllit(s,a,sep)</td>\n<td align=\"center\">使用字段分隔符sep将字符串s分解到数组a的元素中,返回元素个数。如果没有给出sep,则使用FS。数组分割和字段分隔采用相同的方式</td>\n</tr>\n<tr>\n<td align=\"center\">sub(r,s,t)</td>\n<td align=\"center\">在字符串t中用s替换正则表达式r的首次匹配。如果成功则返回1,否则返回0,,如果没有给出t,默认为$0</td>\n</tr>\n<tr>\n<td align=\"center\">substr(s,p,n)</td>\n<td align=\"center\">返回字符串s中从位置p开始最大长度为n的子串。如果没有给出n,返回从p开始剩余的字符串。</td>\n</tr>\n<tr>\n<td align=\"center\">systime()</td>\n<td align=\"center\">返回用秒表示的天的当前的时间,从UNIX元年开始算</td>\n</tr>\n<tr>\n<td align=\"center\">strftime(format,timestamp)</td>\n<td align=\"center\">依照format格式化timestamp。timestamp默认为当前</td>\n</tr>\n<tr>\n<td align=\"center\">tolower(s)</td>\n<td align=\"center\">将字符串s中的所有大写字符转换为小写,并返回新串</td>\n</tr>\n<tr>\n<td align=\"center\">toupper(s)</td>\n<td align=\"center\">将字符串s中的小写字符转换为大写,并返回新串</td>\n</tr>\n</tbody></table>\n<h3 id=\"模式汇总\"><a href=\"#模式汇总\" class=\"headerlink\" title=\"模式汇总\"></a>模式汇总</h3><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">BEGIN {statements}</td>\n<td align=\"center\">在输入被读取之前,statements执行一次,<strong>注意BEGIN里一些内建变量可能为空(如FILENAME)</strong></td>\n</tr>\n<tr>\n<td align=\"center\">END {statements}</td>\n<td align=\"center\">当所有输入被读取完毕之后,statements执行一次</td>\n</tr>\n<tr>\n<td align=\"center\">expression {statements}</td>\n<td align=\"center\">每碰到一个使expression为真的输入行,statements就执行.expression为真指的是其值非零或非空</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;regular expression&#x2F; {statements}</td>\n<td align=\"center\">当输入行有一段字符串可以被正则表达式匹配,则执行statements</td>\n</tr>\n<tr>\n<td align=\"center\">compound pattern {statements}</td>\n<td align=\"center\">一个复合模式将表达式用&amp;&amp;,</td>\n</tr>\n<tr>\n<td align=\"center\">pattern1,pattern2 {statements}</td>\n<td align=\"center\">一个范围模式匹配多个输入行,这些输入行从匹配pattern1的开始,到匹配pattern2的行结束(包括这两行),对这其中的每一行执行statements</td>\n</tr>\n</tbody></table>\n<h3 id=\"字符串匹配模式\"><a href=\"#字符串匹配模式\" class=\"headerlink\" title=\"字符串匹配模式\"></a>字符串匹配模式</h3><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;regexpr&#x2F;</td>\n<td align=\"center\">当当前输入行包含一段能够被regexexpr匹配的子字符串时,该模式匹配</td>\n</tr>\n<tr>\n<td align=\"center\">expression ~ &#x2F;regexpr&#x2F;</td>\n<td align=\"center\">如果expression的字符串值包含一段能够被regexpr匹配的子字符串时,该模式被匹配,返回该字符串,否则返回（待测试）</td>\n</tr>\n<tr>\n<td align=\"center\">expression !~ &#x2F;regexpr&#x2F;</td>\n<td align=\"center\">与上述相反</td>\n</tr>\n</tbody></table>\n<h3 id=\"正则和字符串中的转移序列\"><a href=\"#正则和字符串中的转移序列\" class=\"headerlink\" title=\"正则和字符串中的转移序列\"></a>正则和字符串中的转移序列</h3><table>\n<thead>\n<tr>\n<th align=\"center\">序列</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>\\a</code></td>\n<td align=\"center\">报警字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\b</code></td>\n<td align=\"center\">退格</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\f</code></td>\n<td align=\"center\">换页</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\n</code></td>\n<td align=\"center\">换行</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\r</code></td>\n<td align=\"center\">回车</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\t</code></td>\n<td align=\"center\">制表符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\v</code></td>\n<td align=\"center\">垂直制表符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\ddd</code></td>\n<td align=\"center\">八进制数ddd, ddd含有1到3个数字,每个数字的值在0到7 之间</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\xbex</code></td>\n<td align=\"center\">十六进制</td>\n</tr>\n</tbody></table>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>awk中的数组不需要声明定义,都是关联数组</p>\n<ul>\n<li>赋值一个数组<code>array[0]=1;array[1]=2</code></li>\n<li>删除一个元素<code>delete array[subscript]</code></li>\n<li>删除一个数组<code>delete array</code></li>\n<li><code>i in a</code>如果a[i]存在,则表达式为1,否则为0</li>\n<li>遍历数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#var是arr的每个下标</span><br><span class=\"hljs-keyword\">for</span> (var <span class=\"hljs-keyword\">in</span> arr)<br>&#123;<br>\tstatements<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><ul>\n<li>字符串的连接<code>&quot;pre&quot;str&quot;suf&quot;</code>不需要加号</li>\n</ul>\n<h3 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h3><p>自定义函数的参数为值传递，不改变遍历本身，但是数组例外,函数体内出现的任何变量都是全局变量，想要使用局部变量，只能放在参数列表中（参数列表中没有实际参数对应的参数都将作为局部变量使用）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">function</span> name(patameter-list)&#123;<br>\tstatements<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"awk处理多行记录-主要改变分隔符\"><a href=\"#awk处理多行记录-主要改变分隔符\" class=\"headerlink\" title=\"awk处理多行记录,主要改变分隔符\"></a>awk处理多行记录,主要改变分隔符</h3><p><code>BEGIN &#123; FS=&quot;\\n&quot;;RS=&quot;&quot;&#125;</code>,RS代表空行</p>\n<h3 id=\"awk-script-x-1-test1-x-2-test2-awk可以这样传递变量\"><a href=\"#awk-script-x-1-test1-x-2-test2-awk可以这样传递变量\" class=\"headerlink\" title=\"awk &#39;script&#39; x=1 test1 x=2 test2,awk可以这样传递变量\"></a><code>awk &#39;script&#39; x=1 test1 x=2 test2</code>,awk可以这样传递变量</h3><h3 id=\"BEGIN与END\"><a href=\"#BEGIN与END\" class=\"headerlink\" title=\"BEGIN与END\"></a>BEGIN与END</h3><p>特殊的模式BEGIN在第一个输入文件的第一行之前被匹配,END在最后一个输入文件的最后一行被处理之后匹配。</p>\n<h3 id=\"next与exit\"><a href=\"#next与exit\" class=\"headerlink\" title=\"next与exit\"></a>next与exit</h3><p>next使awk抓取下一行,并返回到脚本底部;exit会使awk执行END,如果已经在END,则结束程序</p>\n<h3 id=\"nextfile\"><a href=\"#nextfile\" class=\"headerlink\" title=\"nextfile\"></a>nextfile</h3><p>nextfile语句和next类似，但它是更高层次上的操作。当执行nextfile时，当前的数据文件将被放弃，操作从脚本顶端开始，并使用下一个文件的第一个记录。</p>\n<h3 id=\"输入分隔符\"><a href=\"#输入分隔符\" class=\"headerlink\" title=\"输入分隔符\"></a>输入分隔符</h3><p>内建变量 FS 的默认值是 “ “, 也就是一个空格符. 当 FS 具有这个特定值时, 输入字段按照 空格和 (或) 制表符分割, 前导的空格与制表符会被丢弃, 所以下面三行数据中, 其每一行的第 1 个字段都相同:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"> field1<br> \tfield1<br>field1 field2<br></code></pre></td></tr></table></figure>\n<p>然而, 当 FS 是其他值时, 前导的空格与制表符不会被丢弃.  把一个字符串赋值给内建变量 FS 就可以改变字段分隔符. 如果字符串的长度多于一个字 符, 那么它会被当成一个正则表达式. 当前输入行中, 与该正则表达式匹配的最左, 最长, 非空且<br>不重叠的子字符串变成字段分隔符, 举例来说,<br><code>BEGIN &#123; FS = &quot;,[ \\t]*|[ \\t]+&quot; &#125;</code><br>如果某个子串由一个后面跟着空格或制表符的逗号组成, 或者没有逗号, 只有空格与制表符, 那 么这个子串就是字段分隔符.  如果 FS 被设置成单个字符 (除了空格符), 那么这个字符就变成字段分隔符. 这个约定使得<br>把正则表达式元字符当作字段分隔符来用, 变得很容易:<br>FS &#x3D; “|”<br>把 | 变成字段分隔符<br><font color=#FF0000>不管FS的值是什么,换行符总是多行记录的字段分隔符之一 </font>,如果RS被设置成””(即空行为记录分割符),则默认的字段分隔符就是空格,制表及换行;如果FS是\\n,则换行符既是唯一分隔符</p>\n<h4 id=\"FIELDWIDTHS\"><a href=\"#FIELDWIDTHS\" class=\"headerlink\" title=\"FIELDWIDTHS\"></a>FIELDWIDTHS</h4><p>该变量可以用来分隔出现在固定宽度列中的数据。这些数据可能或不可能由空白字符来风格字段的值<br><code>FIELDWIDTHS= &quot;5 6 8 3&quot;</code><br>这里的记录有4个字段：$1有5个字符宽度，$2有6个字符的宽度等等。为FS指定一个值将恢复常规机制。通常使用FS&#x3D;FS恢复，无需保存到额外变量中。</p>\n<h3 id=\"print与printf\"><a href=\"#print与printf\" class=\"headerlink\" title=\"print与printf\"></a>print与printf</h3><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">print</td>\n<td align=\"center\">将$0打印到标准输出</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…</td>\n<td align=\"center\">打印各个expression,expression之间由OFS分开,由ORS终止</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…&gt;filename</td>\n<td align=\"center\">输出至filename</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…&gt;filename</td>\n<td align=\"center\">追加到filename,不覆盖之前内容</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…</td>\n<td align=\"center\">command</td>\n</tr>\n<tr>\n<td align=\"center\">close(filename),close(command)</td>\n<td align=\"center\">断开print与filename(或command)之间的连接,同一命令想要两次之间毫无关联,必须先close</td>\n</tr>\n<tr>\n<td align=\"center\">fflush(filename&#x2F;cmd)</td>\n<td align=\"center\">刷新缓存</td>\n</tr>\n<tr>\n<td align=\"center\">system(command)</td>\n<td align=\"center\">执行command;函数的返回值是command的退出状态</td>\n</tr>\n</tbody></table>\n<p>printf主要可以指定格式,以上都能用printf替换,如:<code>printf(format,expression,expression,...) &gt; filename</code>末尾不会自动添加换行符<br>printf格式控制符(每一个格式说明符都以%开始,以转换字符结束)</p>\n<p>|字符|表达式将被打印成|<br>|C|ASCII 字符|<br>|d|十进制整数|<br>|e|[-]d.dddddde[+-]dd|<br>|E|[-]d.ddddddE[+-]dd|<br>|f|[-]ddd.dddddd|<br>|g|照e或f进行转换, 选择较短的那个, 无意义的零会被抑制|<br>|G|照E或f进行转换, 选择较短的那个, 无意义的零会被抑制|<br>|i|十进制|<br>|O|无符号八进制数|<br>|s|字符串|<br>|x|无符号十六进制数|<br>|X|无符号十六进制数,字母大写|<br>|%|打印一个百分号 %, 不会有参数被吸收|</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-</td>\n<td align=\"center\">表达式在它的域内左对齐</td>\n</tr>\n<tr>\n<td align=\"center\">width</td>\n<td align=\"center\">为了达到规定的宽度,必要时填充空格，前导0表示用0填充</td>\n</tr>\n<tr>\n<td align=\"center\">.prec</td>\n<td align=\"center\">字符串最大宽度, 或十进制数的小数部分的位数</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">fmt</th>\n<th align=\"center\">$1</th>\n<th align=\"center\">printf(fmt,$1)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">%c</td>\n<td align=\"center\">97</td>\n<td align=\"center\">a</td>\n</tr>\n<tr>\n<td align=\"center\">%d</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97</td>\n</tr>\n<tr>\n<td align=\"center\">%5d</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97</td>\n</tr>\n<tr>\n<td align=\"center\">%e</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">9.750000e+01</td>\n</tr>\n<tr>\n<td align=\"center\">%f</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.500000</td>\n</tr>\n<tr>\n<td align=\"center\">%7.2f</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.50</td>\n</tr>\n<tr>\n<td align=\"center\">%g</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.5</td>\n</tr>\n<tr>\n<td align=\"center\">%.6g</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.5</td>\n</tr>\n<tr>\n<td align=\"center\">%o</td>\n<td align=\"center\">97</td>\n<td align=\"center\">141</td>\n</tr>\n<tr>\n<td align=\"center\">%06o</td>\n<td align=\"center\">97</td>\n<td align=\"center\">000141</td>\n</tr>\n<tr>\n<td align=\"center\">%x</td>\n<td align=\"center\">97</td>\n<td align=\"center\">61</td>\n</tr>\n<tr>\n<td align=\"center\">%s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%10s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%-10s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%.3s</td>\n<td align=\"center\">January</td>\n<td align=\"center\"><code>Jan</code></td>\n</tr>\n<tr>\n<td align=\"center\">%10.3s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%-10.3s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%%</td>\n<td align=\"center\">January</td>\n<td align=\"center\">%</td>\n</tr>\n</tbody></table>\n<h3 id=\"管道的奇怪用法-好好理解到底啥是管道\"><a href=\"#管道的奇怪用法-好好理解到底啥是管道\" class=\"headerlink\" title=\"管道的奇怪用法(好好理解到底啥是管道)\"></a>管道的奇怪用法(好好理解到底啥是管道)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t<span class=\"hljs-comment\">#注意sort命令用引号括起来,当成字符串</span><br>\t<span class=\"hljs-built_in\">print</span> xx | <span class=\"hljs-string\">&quot;sort -t&#x27;\\t&#x27; +1rn&quot;</span><br>\t<span class=\"hljs-comment\">#上面的管道名就是&quot;sort -t&#x27;\\t&#x27; +1rn&quot;</span><br>\tclose(<span class=\"hljs-string\">&quot;sort -t&#x27;\\t&#x27; +1rn&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>假设有以下文件</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">France</span>\t<span class=\"hljs-number\">211</span>\t<span class=\"hljs-number\">55</span>\tEurope<br><span class=\"hljs-attribute\">Japan</span>\t<span class=\"hljs-number\">144</span>\t<span class=\"hljs-number\">120</span>\tAsia<br><span class=\"hljs-attribute\">Germany</span>\t<span class=\"hljs-number\">96</span>\t<span class=\"hljs-number\">61</span>\tEurope<br><span class=\"hljs-attribute\">England</span>\t<span class=\"hljs-number\">94</span>\t<span class=\"hljs-number\">56</span>\tEurope<br><span class=\"hljs-attribute\">USSR</span>\t<span class=\"hljs-number\">8649</span>\t<span class=\"hljs-number\">275</span>\tAsia<br><span class=\"hljs-attribute\">Canada</span>\t<span class=\"hljs-number\">3852</span>\t<span class=\"hljs-number\">25</span>\tNorth America<br><span class=\"hljs-attribute\">China</span>\t<span class=\"hljs-number\">3705</span>\t<span class=\"hljs-number\">1032</span>\tAsia<br><span class=\"hljs-attribute\">USA</span>\t<span class=\"hljs-number\">3615</span>\t<span class=\"hljs-number\">237</span>\tNorth America<br><span class=\"hljs-attribute\">Brazil</span>\t<span class=\"hljs-number\">3286</span>\t<span class=\"hljs-number\">134</span>\tSouth America<br><span class=\"hljs-attribute\">India</span>\t<span class=\"hljs-number\">1267</span>\t<span class=\"hljs-number\">746</span>\tAsia<br><span class=\"hljs-attribute\">Mexico</span>\t<span class=\"hljs-number\">762</span>\t<span class=\"hljs-number\">78</span>\tNorth America<br></code></pre></td></tr></table></figure>\n<p>以下程序会简单排序</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># prep1 - prepare countries by continent and pop. den.</span><br>BEGIN &#123; FS = <span class=\"hljs-string\">&quot;\\t&quot;</span> &#125;<br>&#123; <br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s:%s:%d:%d:%.1f\\n&quot;</span>,<br>\t<span class=\"hljs-variable\">$4</span>, <span class=\"hljs-variable\">$1</span>, <span class=\"hljs-variable\">$3</span>, <span class=\"hljs-variable\">$2</span>, 1000*<span class=\"hljs-variable\">$3</span>/<span class=\"hljs-variable\">$2</span>) | <span class=\"hljs-string\">&quot;sort -t: -k 1,1 -k 5rn&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"getline函数\"><a href=\"#getline函数\" class=\"headerlink\" title=\"getline函数\"></a>getline函数</h3><ul>\n<li>描述:函数getline可以从当前输入行,或文件,或管道,读取输入.getline抓取下一个记录,按照通常的方式把记录分割成一个个的字段.它会设置NF,NR,和FNR;如果存在一个记录,返回1,若遇到文件末尾,返回0,发生错误时返回-1(例如打开文件失败).</li>\n<li><code>getline x</code>读取下一条记录到变量x中，并递增NR与FNR,不会对记录进行分隔，不会设置NF</li>\n<li><code>getline &lt;&quot;file&quot;</code>从文件file读取输入.它不会对NR与FNR产生影响, 但是会执行字段分割,并且设置NF.</li>\n<li><code>getline x &lt;&quot;file&quot;</code>从file读取下一条记录,存到变量x中.记录不会被分割成字段,变量NF,NR,与FNR都不会被修改.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表达式</th>\n<th align=\"center\">被设置的变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">getline</td>\n<td align=\"center\">$0,NF,NR,FNR</td>\n</tr>\n<tr>\n<td align=\"center\">getline var</td>\n<td align=\"center\">var,NR,FNR</td>\n</tr>\n<tr>\n<td align=\"center\">getline &lt;file</td>\n<td align=\"center\">$0,NF</td>\n</tr>\n<tr>\n<td align=\"center\">getline var&lt;file</td>\n<td align=\"center\">var</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;cmd</td>\n<td align=\"center\">getline&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;cmd</td>\n<td align=\"center\">getline var&#96;</td>\n</tr>\n</tbody></table>\n<p>例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#必须判断大于0,否则文件不存在则就是死循环</span><br><span class=\"hljs-keyword\">while</span> (getline x&lt;file &gt;0)<br>\t<span class=\"hljs-built_in\">print</span> x<br>\tnext<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-string\">&quot;who&quot;</span>|getline)<br>\tn++<br></code></pre></td></tr></table></figure>\n\n<p>13.例子<br>a.将每一行的字段逆序打印</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t<span class=\"hljs-keyword\">for</span> (i=NF;i&gt;0;i=i-1) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s &quot;</span>,<span class=\"hljs-variable\">$i</span>)<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"awk的正则表达式\"><a href=\"#awk的正则表达式\" class=\"headerlink\" title=\"awk的正则表达式\"></a>awk的正则表达式</h3><ul>\n<li>awk的圆括号用法有点异样:<code>(r1)(r2)</code>若匹配xy,其中x匹配r1,y匹配r2。<br>举例:<code>(Asian|European|North American) (male|female) (black|blue)bird</code>12种组合</li>\n</ul>\n<h3 id=\"shell中包含awk\"><a href=\"#shell中包含awk\" class=\"headerlink\" title=\"shell中包含awk\"></a>shell中包含awk</h3><ul>\n<li>见例子1</li>\n</ul>\n<h3 id=\"awk程序搜索路径\"><a href=\"#awk程序搜索路径\" class=\"headerlink\" title=\"awk程序搜索路径\"></a>awk程序搜索路径</h3><p> awk允许你指定一个名为AWKPATH的环境变量，它定义了awk程序的文件搜索路径，默认路径为:&#x2F;usr&#x2F;local&#x2F;share&#x2F;awk。当前路径永远最优先,如果文件名包含<code>/</code>将不执行查找</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># field -打印每个文件的指定字段顺序</span><br><span class=\"hljs-comment\"># usage: field n n n ... file file file ...</span><br>awk <span class=\"hljs-string\">&#x27;</span><br><span class=\"hljs-string\">#开始时,寻找数字,并使之清空,这样他们就不会被当成文件名</span><br><span class=\"hljs-string\">BEGIN &#123;</span><br><span class=\"hljs-string\">for (i = 1; ARGV[i] ~ /^[0-9]+$/; i++) &#123; # collect numbers</span><br><span class=\"hljs-string\">fld[++nf] = ARGV[i]</span><br><span class=\"hljs-string\">ARGV[i] = &quot;&quot;</span><br><span class=\"hljs-string\">&#125;</span><br><span class=\"hljs-string\">if (i &gt;= ARGC)</span><br><span class=\"hljs-string\"># no file names so force stdin</span><br><span class=\"hljs-string\">ARGV[ARGC++] = &quot;-&quot;</span><br><span class=\"hljs-string\">&#125;</span><br><span class=\"hljs-string\">&#123;</span><br><span class=\"hljs-string\">for (i = 1; i &lt;= nf; i++)</span><br><span class=\"hljs-string\">printf(&quot;%s%s&quot;, $fld[i], i &lt; nf ? &quot; &quot; : &quot;\\n&quot;)</span><br><span class=\"hljs-string\">&#125;</span><br><span class=\"hljs-string\">&#x27;</span> $*<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#交互式awk脚本</span><br>BEGIN &#123;<br>\tmaxnum = ARGC &gt; 1 ? ARGV[1] : 10<br>\t<span class=\"hljs-comment\"># default size is 10</span><br>\tARGV[1] = <span class=\"hljs-string\">&quot;-&quot;</span><span class=\"hljs-comment\"># read standard input subsequently</span><br>\tsrand()<span class=\"hljs-comment\"># reset rand from time of day</span><br>\t<span class=\"hljs-keyword\">do</span> &#123;<br>\t\tn1 = randint(maxnum)<br>\t\tn2 = randint(maxnum)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%g + %g = ? &quot;</span>, n1, n2)<br>\t\t<span class=\"hljs-keyword\">while</span> ((input = getline) &gt; <span class=\"hljs-number\">0</span>)<br>\t\t\tif (<span class=\"hljs-variable\">$0</span> == n1 + n2) &#123;<br>\t\t\t\tprint &quot;Right!&quot;<br>\t\t\t\tbreak<br>\t\t\t&#125; else if (<span class=\"hljs-variable\">$0</span> == &quot;&quot;) &#123;<br>\t\t\t\tprint n1 + n2<br>\t\t\t\tbreak<br>\t\t\t&#125; else<br>\t\t\t\tprintf(&quot;wrong, try again: &quot;)<br>\t\t&#125; while (input &gt; <span class=\"hljs-number\">0</span>)<br>&#125;<br>function randint(n) &#123; return int(rand()*n)+<span class=\"hljs-number\">1</span> &#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>去除字符串<code>gsub(/&quot;([^&quot;]|\\\\&quot;)*&quot;/, &quot;&quot;, line)</code></li>\n<li>去除正则表达式<code>gsub(/\\/([^\\/]|\\\\\\/)+\\//, &quot;&quot;, line)</code></li>\n<li>去除注释<code>sub(/#.*/, &quot;&quot;, line)</code></li>\n</ul>\n","excerpt":"","more":"<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>awk [-v var=value] [-F re] [--] &#39;pattern n&#123;action&#125;&#39; var=value files</code><br><code>awk [-v var=value] [-F re] [--] -f scriptfile [file] var=value files</code><br><strong>注:</strong>-v指定的变量定义在BEGIN之前,BEGIN过程中不能访问有关文件或命令行的任何变量(除了环境变量)</p>\n<h3 id=\"awk选项总结\"><a href=\"#awk选项总结\" class=\"headerlink\" title=\"awk选项总结\"></a>awk选项总结</h3><table>\n<thead>\n<tr>\n<th align=\"center\">options</th>\n<th align=\"center\">describe</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-F</td>\n<td align=\"center\">改变字段分割符,默认为空格</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">跟随脚本中的文件名</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">跟随var&#x3D;value,作用域在BEGIN之前</td>\n</tr>\n<tr>\n<td align=\"center\">-mf [N]</td>\n<td align=\"center\">指定处理的数据文件中最大字段数</td>\n</tr>\n<tr>\n<td align=\"center\">-mr [N]</td>\n<td align=\"center\">指定处理的数据文件中最大行数</td>\n</tr>\n<tr>\n<td align=\"center\">-W keyword</td>\n<td align=\"center\">指定gawk的兼容模式或警告等级</td>\n</tr>\n</tbody></table>\n<h3 id=\"awk内置变量\"><a href=\"#awk内置变量\" class=\"headerlink\" title=\"awk内置变量\"></a>awk内置变量</h3><table>\n<thead>\n<tr>\n<th align=\"center\">variable</th>\n<th align=\"center\">describe</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ARGV</td>\n<td align=\"center\">命令行参数的数组,不包括脚本本身(-f选项也不包括),下标从0开始(一般为awk),一般大于0的下标都是输入的文件名,最后一个是ARGC-1</td>\n</tr>\n<tr>\n<td align=\"center\">ARGC</td>\n<td align=\"center\">ARGV数组个数</td>\n</tr>\n<tr>\n<td align=\"center\">ARGIND</td>\n<td align=\"center\">当前输入文件在ARGV的索引值</td>\n</tr>\n<tr>\n<td align=\"center\">CONVFMT</td>\n<td align=\"center\">用于数字的字符串转换格式(%.6g)</td>\n</tr>\n<tr>\n<td align=\"center\">ENVIRON</td>\n<td align=\"center\">环境变量数组,下标是环境变量名</td>\n</tr>\n<tr>\n<td align=\"center\">FILENAME</td>\n<td align=\"center\">当前输入文件名称</td>\n</tr>\n<tr>\n<td align=\"center\">FNR</td>\n<td align=\"center\">当前输入文件的记录(行)个数</td>\n</tr>\n<tr>\n<td align=\"center\">FS</td>\n<td align=\"center\">字段分隔符,最好在BEGIN的时候定义</td>\n</tr>\n<tr>\n<td align=\"center\">ERRNO</td>\n<td align=\"center\">当getline或close失败时的描述信息</td>\n</tr>\n<tr>\n<td align=\"center\">FIELDWIDTHS</td>\n<td align=\"center\">见该小结</td>\n</tr>\n<tr>\n<td align=\"center\">IGNORECASE</td>\n<td align=\"center\">如果不为0,模式匹配不区分大小写</td>\n</tr>\n<tr>\n<td align=\"center\">NF</td>\n<td align=\"center\">每段记录(即行)的字段数(即单词)</td>\n</tr>\n<tr>\n<td align=\"center\">NR</td>\n<td align=\"center\">行号</td>\n</tr>\n<tr>\n<td align=\"center\">OFMT</td>\n<td align=\"center\">数值的输出格式,默认为”%.6g”</td>\n</tr>\n<tr>\n<td align=\"center\">OFS</td>\n<td align=\"center\">输出字段分割符,默认为” “</td>\n</tr>\n<tr>\n<td align=\"center\">ORS</td>\n<td align=\"center\">输出的记录分割符,默认为”\\n”</td>\n</tr>\n<tr>\n<td align=\"center\">RLENGTH</td>\n<td align=\"center\">被函数match匹配的字符串长度</td>\n</tr>\n<tr>\n<td align=\"center\">RS</td>\n<td align=\"center\">记录分隔符</td>\n</tr>\n<tr>\n<td align=\"center\">RT</td>\n<td align=\"center\">如果RS为正则表达式，RT则代表当前行所匹配的值</td>\n</tr>\n<tr>\n<td align=\"center\">RSTART</td>\n<td align=\"center\">被函数match匹配的字符串的开始</td>\n</tr>\n<tr>\n<td align=\"center\">SUBSEP</td>\n<td align=\"center\">下标分割符(\\034)</td>\n</tr>\n<tr>\n<td align=\"center\">$0</td>\n<td align=\"center\">整行内容</td>\n</tr>\n</tbody></table>\n<h3 id=\"awk内置函数\"><a href=\"#awk内置函数\" class=\"headerlink\" title=\"awk内置函数\"></a>awk内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">算术函数</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">cos(x)</td>\n<td align=\"center\">返回x的余弦</td>\n</tr>\n<tr>\n<td align=\"center\">exp(x)</td>\n<td align=\"center\">返回e的x次幂</td>\n</tr>\n<tr>\n<td align=\"center\">sin(x)</td>\n<td align=\"center\">返回x的正弦</td>\n</tr>\n<tr>\n<td align=\"center\">int(x)</td>\n<td align=\"center\">返回x的整数部分的值</td>\n</tr>\n<tr>\n<td align=\"center\">log(x)</td>\n<td align=\"center\">返回x的自然对数(以e为底)</td>\n</tr>\n<tr>\n<td align=\"center\">sqrt(x)</td>\n<td align=\"center\">返回x的平方根</td>\n</tr>\n<tr>\n<td align=\"center\">atan2(y,x)</td>\n<td align=\"center\">返回y&#x2F;x的反正切</td>\n</tr>\n<tr>\n<td align=\"center\">rand()</td>\n<td align=\"center\">返回0-1之间的随机数</td>\n</tr>\n<tr>\n<td align=\"center\">srand(x)</td>\n<td align=\"center\">建立rand()的新的种子数。如果没有指定种子数,就用当天的时间。返回旧的种子值</td>\n</tr>\n<tr>\n<td align=\"center\">字符串函数</td>\n<td align=\"center\">描述</td>\n</tr>\n<tr>\n<td align=\"center\">gsub(r,s,t)</td>\n<td align=\"center\">在字符串t中用字符串s替换和正则表达式r匹配的所有字符串。返回替换的个数。如果没有给出t,默认$0</td>\n</tr>\n<tr>\n<td align=\"center\">gensub(r,s,h,t)</td>\n<td align=\"center\">如果h以g或G开始的字符串，则对于在t中的r,用s进行全局替换。否则，h是一个数据：替换第h次出现的r.该函数返回新值，t本身不会改变，t默认为$0</td>\n</tr>\n<tr>\n<td align=\"center\">sprintf(fmt,expr-list)</td>\n<td align=\"center\">根据格式字符串fmt返回格式化后的expr-list,fmt格式见printf那里</td>\n</tr>\n<tr>\n<td align=\"center\">index(s,t)</td>\n<td align=\"center\">返回子串t在字符串s中的位置,如果没有指定s,则返回0</td>\n</tr>\n<tr>\n<td align=\"center\">length(s)</td>\n<td align=\"center\">返回字符串s的长度,当没有给出s时,返回$0的长度</td>\n</tr>\n<tr>\n<td align=\"center\">match(s,r)</td>\n<td align=\"center\">如果正则表达式r在s中出现,则返回出现的起始位置;如果没有,则返回0</td>\n</tr>\n<tr>\n<td align=\"center\">spllit(s,a,sep)</td>\n<td align=\"center\">使用字段分隔符sep将字符串s分解到数组a的元素中,返回元素个数。如果没有给出sep,则使用FS。数组分割和字段分隔采用相同的方式</td>\n</tr>\n<tr>\n<td align=\"center\">sub(r,s,t)</td>\n<td align=\"center\">在字符串t中用s替换正则表达式r的首次匹配。如果成功则返回1,否则返回0,,如果没有给出t,默认为$0</td>\n</tr>\n<tr>\n<td align=\"center\">substr(s,p,n)</td>\n<td align=\"center\">返回字符串s中从位置p开始最大长度为n的子串。如果没有给出n,返回从p开始剩余的字符串。</td>\n</tr>\n<tr>\n<td align=\"center\">systime()</td>\n<td align=\"center\">返回用秒表示的天的当前的时间,从UNIX元年开始算</td>\n</tr>\n<tr>\n<td align=\"center\">strftime(format,timestamp)</td>\n<td align=\"center\">依照format格式化timestamp。timestamp默认为当前</td>\n</tr>\n<tr>\n<td align=\"center\">tolower(s)</td>\n<td align=\"center\">将字符串s中的所有大写字符转换为小写,并返回新串</td>\n</tr>\n<tr>\n<td align=\"center\">toupper(s)</td>\n<td align=\"center\">将字符串s中的小写字符转换为大写,并返回新串</td>\n</tr>\n</tbody></table>\n<h3 id=\"模式汇总\"><a href=\"#模式汇总\" class=\"headerlink\" title=\"模式汇总\"></a>模式汇总</h3><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">BEGIN {statements}</td>\n<td align=\"center\">在输入被读取之前,statements执行一次,<strong>注意BEGIN里一些内建变量可能为空(如FILENAME)</strong></td>\n</tr>\n<tr>\n<td align=\"center\">END {statements}</td>\n<td align=\"center\">当所有输入被读取完毕之后,statements执行一次</td>\n</tr>\n<tr>\n<td align=\"center\">expression {statements}</td>\n<td align=\"center\">每碰到一个使expression为真的输入行,statements就执行.expression为真指的是其值非零或非空</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;regular expression&#x2F; {statements}</td>\n<td align=\"center\">当输入行有一段字符串可以被正则表达式匹配,则执行statements</td>\n</tr>\n<tr>\n<td align=\"center\">compound pattern {statements}</td>\n<td align=\"center\">一个复合模式将表达式用&amp;&amp;,</td>\n</tr>\n<tr>\n<td align=\"center\">pattern1,pattern2 {statements}</td>\n<td align=\"center\">一个范围模式匹配多个输入行,这些输入行从匹配pattern1的开始,到匹配pattern2的行结束(包括这两行),对这其中的每一行执行statements</td>\n</tr>\n</tbody></table>\n<h3 id=\"字符串匹配模式\"><a href=\"#字符串匹配模式\" class=\"headerlink\" title=\"字符串匹配模式\"></a>字符串匹配模式</h3><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;regexpr&#x2F;</td>\n<td align=\"center\">当当前输入行包含一段能够被regexexpr匹配的子字符串时,该模式匹配</td>\n</tr>\n<tr>\n<td align=\"center\">expression ~ &#x2F;regexpr&#x2F;</td>\n<td align=\"center\">如果expression的字符串值包含一段能够被regexpr匹配的子字符串时,该模式被匹配,返回该字符串,否则返回（待测试）</td>\n</tr>\n<tr>\n<td align=\"center\">expression !~ &#x2F;regexpr&#x2F;</td>\n<td align=\"center\">与上述相反</td>\n</tr>\n</tbody></table>\n<h3 id=\"正则和字符串中的转移序列\"><a href=\"#正则和字符串中的转移序列\" class=\"headerlink\" title=\"正则和字符串中的转移序列\"></a>正则和字符串中的转移序列</h3><table>\n<thead>\n<tr>\n<th align=\"center\">序列</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>\\a</code></td>\n<td align=\"center\">报警字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\b</code></td>\n<td align=\"center\">退格</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\f</code></td>\n<td align=\"center\">换页</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\n</code></td>\n<td align=\"center\">换行</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\r</code></td>\n<td align=\"center\">回车</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\t</code></td>\n<td align=\"center\">制表符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\v</code></td>\n<td align=\"center\">垂直制表符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\ddd</code></td>\n<td align=\"center\">八进制数ddd, ddd含有1到3个数字,每个数字的值在0到7 之间</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\xbex</code></td>\n<td align=\"center\">十六进制</td>\n</tr>\n</tbody></table>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>awk中的数组不需要声明定义,都是关联数组</p>\n<ul>\n<li>赋值一个数组<code>array[0]=1;array[1]=2</code></li>\n<li>删除一个元素<code>delete array[subscript]</code></li>\n<li>删除一个数组<code>delete array</code></li>\n<li><code>i in a</code>如果a[i]存在,则表达式为1,否则为0</li>\n<li>遍历数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#var是arr的每个下标</span><br><span class=\"hljs-keyword\">for</span> (var <span class=\"hljs-keyword\">in</span> arr)<br>&#123;<br>\tstatements<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><ul>\n<li>字符串的连接<code>&quot;pre&quot;str&quot;suf&quot;</code>不需要加号</li>\n</ul>\n<h3 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h3><p>自定义函数的参数为值传递，不改变遍历本身，但是数组例外,函数体内出现的任何变量都是全局变量，想要使用局部变量，只能放在参数列表中（参数列表中没有实际参数对应的参数都将作为局部变量使用）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">function</span> name(patameter-list)&#123;<br>\tstatements<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"awk处理多行记录-主要改变分隔符\"><a href=\"#awk处理多行记录-主要改变分隔符\" class=\"headerlink\" title=\"awk处理多行记录,主要改变分隔符\"></a>awk处理多行记录,主要改变分隔符</h3><p><code>BEGIN &#123; FS=&quot;\\n&quot;;RS=&quot;&quot;&#125;</code>,RS代表空行</p>\n<h3 id=\"awk-script-x-1-test1-x-2-test2-awk可以这样传递变量\"><a href=\"#awk-script-x-1-test1-x-2-test2-awk可以这样传递变量\" class=\"headerlink\" title=\"awk &#39;script&#39; x=1 test1 x=2 test2,awk可以这样传递变量\"></a><code>awk &#39;script&#39; x=1 test1 x=2 test2</code>,awk可以这样传递变量</h3><h3 id=\"BEGIN与END\"><a href=\"#BEGIN与END\" class=\"headerlink\" title=\"BEGIN与END\"></a>BEGIN与END</h3><p>特殊的模式BEGIN在第一个输入文件的第一行之前被匹配,END在最后一个输入文件的最后一行被处理之后匹配。</p>\n<h3 id=\"next与exit\"><a href=\"#next与exit\" class=\"headerlink\" title=\"next与exit\"></a>next与exit</h3><p>next使awk抓取下一行,并返回到脚本底部;exit会使awk执行END,如果已经在END,则结束程序</p>\n<h3 id=\"nextfile\"><a href=\"#nextfile\" class=\"headerlink\" title=\"nextfile\"></a>nextfile</h3><p>nextfile语句和next类似，但它是更高层次上的操作。当执行nextfile时，当前的数据文件将被放弃，操作从脚本顶端开始，并使用下一个文件的第一个记录。</p>\n<h3 id=\"输入分隔符\"><a href=\"#输入分隔符\" class=\"headerlink\" title=\"输入分隔符\"></a>输入分隔符</h3><p>内建变量 FS 的默认值是 “ “, 也就是一个空格符. 当 FS 具有这个特定值时, 输入字段按照 空格和 (或) 制表符分割, 前导的空格与制表符会被丢弃, 所以下面三行数据中, 其每一行的第 1 个字段都相同:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"> field1<br> \tfield1<br>field1 field2<br></code></pre></td></tr></table></figure>\n<p>然而, 当 FS 是其他值时, 前导的空格与制表符不会被丢弃.  把一个字符串赋值给内建变量 FS 就可以改变字段分隔符. 如果字符串的长度多于一个字 符, 那么它会被当成一个正则表达式. 当前输入行中, 与该正则表达式匹配的最左, 最长, 非空且<br>不重叠的子字符串变成字段分隔符, 举例来说,<br><code>BEGIN &#123; FS = &quot;,[ \\t]*|[ \\t]+&quot; &#125;</code><br>如果某个子串由一个后面跟着空格或制表符的逗号组成, 或者没有逗号, 只有空格与制表符, 那 么这个子串就是字段分隔符.  如果 FS 被设置成单个字符 (除了空格符), 那么这个字符就变成字段分隔符. 这个约定使得<br>把正则表达式元字符当作字段分隔符来用, 变得很容易:<br>FS &#x3D; “|”<br>把 | 变成字段分隔符<br><font color=#FF0000>不管FS的值是什么,换行符总是多行记录的字段分隔符之一 </font>,如果RS被设置成””(即空行为记录分割符),则默认的字段分隔符就是空格,制表及换行;如果FS是\\n,则换行符既是唯一分隔符</p>\n<h4 id=\"FIELDWIDTHS\"><a href=\"#FIELDWIDTHS\" class=\"headerlink\" title=\"FIELDWIDTHS\"></a>FIELDWIDTHS</h4><p>该变量可以用来分隔出现在固定宽度列中的数据。这些数据可能或不可能由空白字符来风格字段的值<br><code>FIELDWIDTHS= &quot;5 6 8 3&quot;</code><br>这里的记录有4个字段：$1有5个字符宽度，$2有6个字符的宽度等等。为FS指定一个值将恢复常规机制。通常使用FS&#x3D;FS恢复，无需保存到额外变量中。</p>\n<h3 id=\"print与printf\"><a href=\"#print与printf\" class=\"headerlink\" title=\"print与printf\"></a>print与printf</h3><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">print</td>\n<td align=\"center\">将$0打印到标准输出</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…</td>\n<td align=\"center\">打印各个expression,expression之间由OFS分开,由ORS终止</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…&gt;filename</td>\n<td align=\"center\">输出至filename</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…&gt;filename</td>\n<td align=\"center\">追加到filename,不覆盖之前内容</td>\n</tr>\n<tr>\n<td align=\"center\">print expression,expression,…</td>\n<td align=\"center\">command</td>\n</tr>\n<tr>\n<td align=\"center\">close(filename),close(command)</td>\n<td align=\"center\">断开print与filename(或command)之间的连接,同一命令想要两次之间毫无关联,必须先close</td>\n</tr>\n<tr>\n<td align=\"center\">fflush(filename&#x2F;cmd)</td>\n<td align=\"center\">刷新缓存</td>\n</tr>\n<tr>\n<td align=\"center\">system(command)</td>\n<td align=\"center\">执行command;函数的返回值是command的退出状态</td>\n</tr>\n</tbody></table>\n<p>printf主要可以指定格式,以上都能用printf替换,如:<code>printf(format,expression,expression,...) &gt; filename</code>末尾不会自动添加换行符<br>printf格式控制符(每一个格式说明符都以%开始,以转换字符结束)</p>\n<p>|字符|表达式将被打印成|<br>|C|ASCII 字符|<br>|d|十进制整数|<br>|e|[-]d.dddddde[+-]dd|<br>|E|[-]d.ddddddE[+-]dd|<br>|f|[-]ddd.dddddd|<br>|g|照e或f进行转换, 选择较短的那个, 无意义的零会被抑制|<br>|G|照E或f进行转换, 选择较短的那个, 无意义的零会被抑制|<br>|i|十进制|<br>|O|无符号八进制数|<br>|s|字符串|<br>|x|无符号十六进制数|<br>|X|无符号十六进制数,字母大写|<br>|%|打印一个百分号 %, 不会有参数被吸收|</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-</td>\n<td align=\"center\">表达式在它的域内左对齐</td>\n</tr>\n<tr>\n<td align=\"center\">width</td>\n<td align=\"center\">为了达到规定的宽度,必要时填充空格，前导0表示用0填充</td>\n</tr>\n<tr>\n<td align=\"center\">.prec</td>\n<td align=\"center\">字符串最大宽度, 或十进制数的小数部分的位数</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">fmt</th>\n<th align=\"center\">$1</th>\n<th align=\"center\">printf(fmt,$1)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">%c</td>\n<td align=\"center\">97</td>\n<td align=\"center\">a</td>\n</tr>\n<tr>\n<td align=\"center\">%d</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97</td>\n</tr>\n<tr>\n<td align=\"center\">%5d</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97</td>\n</tr>\n<tr>\n<td align=\"center\">%e</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">9.750000e+01</td>\n</tr>\n<tr>\n<td align=\"center\">%f</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.500000</td>\n</tr>\n<tr>\n<td align=\"center\">%7.2f</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.50</td>\n</tr>\n<tr>\n<td align=\"center\">%g</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.5</td>\n</tr>\n<tr>\n<td align=\"center\">%.6g</td>\n<td align=\"center\">97.5</td>\n<td align=\"center\">97.5</td>\n</tr>\n<tr>\n<td align=\"center\">%o</td>\n<td align=\"center\">97</td>\n<td align=\"center\">141</td>\n</tr>\n<tr>\n<td align=\"center\">%06o</td>\n<td align=\"center\">97</td>\n<td align=\"center\">000141</td>\n</tr>\n<tr>\n<td align=\"center\">%x</td>\n<td align=\"center\">97</td>\n<td align=\"center\">61</td>\n</tr>\n<tr>\n<td align=\"center\">%s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%10s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%-10s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%.3s</td>\n<td align=\"center\">January</td>\n<td align=\"center\"><code>Jan</code></td>\n</tr>\n<tr>\n<td align=\"center\">%10.3s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%-10.3s</td>\n<td align=\"center\">January</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">%%</td>\n<td align=\"center\">January</td>\n<td align=\"center\">%</td>\n</tr>\n</tbody></table>\n<h3 id=\"管道的奇怪用法-好好理解到底啥是管道\"><a href=\"#管道的奇怪用法-好好理解到底啥是管道\" class=\"headerlink\" title=\"管道的奇怪用法(好好理解到底啥是管道)\"></a>管道的奇怪用法(好好理解到底啥是管道)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t<span class=\"hljs-comment\">#注意sort命令用引号括起来,当成字符串</span><br>\t<span class=\"hljs-built_in\">print</span> xx | <span class=\"hljs-string\">&quot;sort -t&#x27;\\t&#x27; +1rn&quot;</span><br>\t<span class=\"hljs-comment\">#上面的管道名就是&quot;sort -t&#x27;\\t&#x27; +1rn&quot;</span><br>\tclose(<span class=\"hljs-string\">&quot;sort -t&#x27;\\t&#x27; +1rn&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>假设有以下文件</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">France</span>\t<span class=\"hljs-number\">211</span>\t<span class=\"hljs-number\">55</span>\tEurope<br><span class=\"hljs-attribute\">Japan</span>\t<span class=\"hljs-number\">144</span>\t<span class=\"hljs-number\">120</span>\tAsia<br><span class=\"hljs-attribute\">Germany</span>\t<span class=\"hljs-number\">96</span>\t<span class=\"hljs-number\">61</span>\tEurope<br><span class=\"hljs-attribute\">England</span>\t<span class=\"hljs-number\">94</span>\t<span class=\"hljs-number\">56</span>\tEurope<br><span class=\"hljs-attribute\">USSR</span>\t<span class=\"hljs-number\">8649</span>\t<span class=\"hljs-number\">275</span>\tAsia<br><span class=\"hljs-attribute\">Canada</span>\t<span class=\"hljs-number\">3852</span>\t<span class=\"hljs-number\">25</span>\tNorth America<br><span class=\"hljs-attribute\">China</span>\t<span class=\"hljs-number\">3705</span>\t<span class=\"hljs-number\">1032</span>\tAsia<br><span class=\"hljs-attribute\">USA</span>\t<span class=\"hljs-number\">3615</span>\t<span class=\"hljs-number\">237</span>\tNorth America<br><span class=\"hljs-attribute\">Brazil</span>\t<span class=\"hljs-number\">3286</span>\t<span class=\"hljs-number\">134</span>\tSouth America<br><span class=\"hljs-attribute\">India</span>\t<span class=\"hljs-number\">1267</span>\t<span class=\"hljs-number\">746</span>\tAsia<br><span class=\"hljs-attribute\">Mexico</span>\t<span class=\"hljs-number\">762</span>\t<span class=\"hljs-number\">78</span>\tNorth America<br></code></pre></td></tr></table></figure>\n<p>以下程序会简单排序</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># prep1 - prepare countries by continent and pop. den.</span><br>BEGIN &#123; FS = <span class=\"hljs-string\">&quot;\\t&quot;</span> &#125;<br>&#123; <br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s:%s:%d:%d:%.1f\\n&quot;</span>,<br>\t<span class=\"hljs-variable\">$4</span>, <span class=\"hljs-variable\">$1</span>, <span class=\"hljs-variable\">$3</span>, <span class=\"hljs-variable\">$2</span>, 1000*<span class=\"hljs-variable\">$3</span>/<span class=\"hljs-variable\">$2</span>) | <span class=\"hljs-string\">&quot;sort -t: -k 1,1 -k 5rn&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"getline函数\"><a href=\"#getline函数\" class=\"headerlink\" title=\"getline函数\"></a>getline函数</h3><ul>\n<li>描述:函数getline可以从当前输入行,或文件,或管道,读取输入.getline抓取下一个记录,按照通常的方式把记录分割成一个个的字段.它会设置NF,NR,和FNR;如果存在一个记录,返回1,若遇到文件末尾,返回0,发生错误时返回-1(例如打开文件失败).</li>\n<li><code>getline x</code>读取下一条记录到变量x中，并递增NR与FNR,不会对记录进行分隔，不会设置NF</li>\n<li><code>getline &lt;&quot;file&quot;</code>从文件file读取输入.它不会对NR与FNR产生影响, 但是会执行字段分割,并且设置NF.</li>\n<li><code>getline x &lt;&quot;file&quot;</code>从file读取下一条记录,存到变量x中.记录不会被分割成字段,变量NF,NR,与FNR都不会被修改.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表达式</th>\n<th align=\"center\">被设置的变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">getline</td>\n<td align=\"center\">$0,NF,NR,FNR</td>\n</tr>\n<tr>\n<td align=\"center\">getline var</td>\n<td align=\"center\">var,NR,FNR</td>\n</tr>\n<tr>\n<td align=\"center\">getline &lt;file</td>\n<td align=\"center\">$0,NF</td>\n</tr>\n<tr>\n<td align=\"center\">getline var&lt;file</td>\n<td align=\"center\">var</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;cmd</td>\n<td align=\"center\">getline&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;cmd</td>\n<td align=\"center\">getline var&#96;</td>\n</tr>\n</tbody></table>\n<p>例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#必须判断大于0,否则文件不存在则就是死循环</span><br><span class=\"hljs-keyword\">while</span> (getline x&lt;file &gt;0)<br>\t<span class=\"hljs-built_in\">print</span> x<br>\tnext<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-string\">&quot;who&quot;</span>|getline)<br>\tn++<br></code></pre></td></tr></table></figure>\n\n<p>13.例子<br>a.将每一行的字段逆序打印</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t<span class=\"hljs-keyword\">for</span> (i=NF;i&gt;0;i=i-1) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s &quot;</span>,<span class=\"hljs-variable\">$i</span>)<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"awk的正则表达式\"><a href=\"#awk的正则表达式\" class=\"headerlink\" title=\"awk的正则表达式\"></a>awk的正则表达式</h3><ul>\n<li>awk的圆括号用法有点异样:<code>(r1)(r2)</code>若匹配xy,其中x匹配r1,y匹配r2。<br>举例:<code>(Asian|European|North American) (male|female) (black|blue)bird</code>12种组合</li>\n</ul>\n<h3 id=\"shell中包含awk\"><a href=\"#shell中包含awk\" class=\"headerlink\" title=\"shell中包含awk\"></a>shell中包含awk</h3><ul>\n<li>见例子1</li>\n</ul>\n<h3 id=\"awk程序搜索路径\"><a href=\"#awk程序搜索路径\" class=\"headerlink\" title=\"awk程序搜索路径\"></a>awk程序搜索路径</h3><p> awk允许你指定一个名为AWKPATH的环境变量，它定义了awk程序的文件搜索路径，默认路径为:&#x2F;usr&#x2F;local&#x2F;share&#x2F;awk。当前路径永远最优先,如果文件名包含<code>/</code>将不执行查找</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># field -打印每个文件的指定字段顺序</span><br><span class=\"hljs-comment\"># usage: field n n n ... file file file ...</span><br>awk <span class=\"hljs-string\">&#x27;</span><br><span class=\"hljs-string\">#开始时,寻找数字,并使之清空,这样他们就不会被当成文件名</span><br><span class=\"hljs-string\">BEGIN &#123;</span><br><span class=\"hljs-string\">for (i = 1; ARGV[i] ~ /^[0-9]+$/; i++) &#123; # collect numbers</span><br><span class=\"hljs-string\">fld[++nf] = ARGV[i]</span><br><span class=\"hljs-string\">ARGV[i] = &quot;&quot;</span><br><span class=\"hljs-string\">&#125;</span><br><span class=\"hljs-string\">if (i &gt;= ARGC)</span><br><span class=\"hljs-string\"># no file names so force stdin</span><br><span class=\"hljs-string\">ARGV[ARGC++] = &quot;-&quot;</span><br><span class=\"hljs-string\">&#125;</span><br><span class=\"hljs-string\">&#123;</span><br><span class=\"hljs-string\">for (i = 1; i &lt;= nf; i++)</span><br><span class=\"hljs-string\">printf(&quot;%s%s&quot;, $fld[i], i &lt; nf ? &quot; &quot; : &quot;\\n&quot;)</span><br><span class=\"hljs-string\">&#125;</span><br><span class=\"hljs-string\">&#x27;</span> $*<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#交互式awk脚本</span><br>BEGIN &#123;<br>\tmaxnum = ARGC &gt; 1 ? ARGV[1] : 10<br>\t<span class=\"hljs-comment\"># default size is 10</span><br>\tARGV[1] = <span class=\"hljs-string\">&quot;-&quot;</span><span class=\"hljs-comment\"># read standard input subsequently</span><br>\tsrand()<span class=\"hljs-comment\"># reset rand from time of day</span><br>\t<span class=\"hljs-keyword\">do</span> &#123;<br>\t\tn1 = randint(maxnum)<br>\t\tn2 = randint(maxnum)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%g + %g = ? &quot;</span>, n1, n2)<br>\t\t<span class=\"hljs-keyword\">while</span> ((input = getline) &gt; <span class=\"hljs-number\">0</span>)<br>\t\t\tif (<span class=\"hljs-variable\">$0</span> == n1 + n2) &#123;<br>\t\t\t\tprint &quot;Right!&quot;<br>\t\t\t\tbreak<br>\t\t\t&#125; else if (<span class=\"hljs-variable\">$0</span> == &quot;&quot;) &#123;<br>\t\t\t\tprint n1 + n2<br>\t\t\t\tbreak<br>\t\t\t&#125; else<br>\t\t\t\tprintf(&quot;wrong, try again: &quot;)<br>\t\t&#125; while (input &gt; <span class=\"hljs-number\">0</span>)<br>&#125;<br>function randint(n) &#123; return int(rand()*n)+<span class=\"hljs-number\">1</span> &#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>去除字符串<code>gsub(/&quot;([^&quot;]|\\\\&quot;)*&quot;/, &quot;&quot;, line)</code></li>\n<li>去除正则表达式<code>gsub(/\\/([^\\/]|\\\\\\/)+\\//, &quot;&quot;, line)</code></li>\n<li>去除注释<code>sub(/#.*/, &quot;&quot;, line)</code></li>\n</ul>\n"},{"title":"Arch Linux问题解决","date":"2020-12-31T06:59:37.000Z","subtitle":null,"index_img":"/images/fix.jpg","banner_img":"/images/fix.jpg","_content":"1.广通无线网卡问题\n`lspci`查看那个shit一样的网卡名字\"BCM43142\"\n`sudo pacman -S linux-headers`装这个东西\n`sudo pacman -S broadcom-wl-dkms`安装这个屎样的驱动\n你可能会说,没网下个屁啊\n打开archwiki的package页面搜索包,点想要的包,在右边有个小字download from mirrors,点他下载离线包,sudo pacman -U 那个包\n最新包可能出现问题,降级的时候要连linux那个包一块降级,linux和linux-headers版本号要对应上,\n2.降级问题\n最新包可能出现问题,先在/var/cache/pacman/pkg/那个目录下找缓存的文件\n找不到再从网上找。\n也可以用downgrade工具,没用过就不说它了\n3.背光灯问题\n/etc/modprobe.d/sony-laptop.conf 索尼背光灯设置文件\n4.制作启动盘\n直接用如下命令制作,deepin官网的也不行\n`df`查看启动U盘的设备号\n`sudo dd bs=4M if=deepin-desktop-community-1010-amd64.iso of=/dev/sdb status=progress && sync`\n注意:如果u盘表现异常,一插有两个部分(一个部分只有几百兆),制作不会成功.也无法直接格式化,此时可以借助deepin官网启动盘制作,先格式化,再按上述操作\n5.pacman更新过程中崩溃,断电\na.先制作启动盘(按上述方法)\nb.assistant键进入,选择U盘启动(bios里外部设备启动要打开)\nc.`iwctl`进入无线网配置\n(1)查看无线设备\n`device list`\n(2)扫描无线网\n`station wlan0 scan`\n(3)列出网络名\n`station wlan0 get-networks`\n(4)根据设备(wlan0)连接wifi名称\n`station wlan0 connect CMCC-A9wF`并输入密码(75ij3tw7)\n(5)\nexit退出\nd.挂载根文件系统,proc,sys和dev\n`mount /dev/sda[x] /mnt;mount -t proc proc /mnt/proc;mount --rbind /sys /mnt/sys;mount --rbind /dev /mnt/dev`\ne.有锁的话,删除锁\n`rm /mnt/var/lib/pacman/db.lck`要加/mnt绝对路径\nf.查找损坏包\n`pacman --sysroot /mnt -S $(pacman --sysroot /mnt -Qnq)`\n损坏包会有`vim: /usr/xxx/xxx exists in filesystem`,这里vim就是损坏包\n注意如果没有损坏包,就不要执行上述命令,因为他是重装所有包,这里只是检查以下\ng.把上述命令重定向到一个文件,用vim修改成每一行如`rm -f /mnt/usr/xxx/xxx`\n列模式修改(选中按c即可)':'前面的所有字符为`rm -f /mnt`(要加/mnt,绝对路径),全局替换掉所有'exists in filesystem'为空\nh.`chmod +x`赋予那个重定向文件执行权限,`./(那个文件)`\ni.更新或安装损坏包,\n`pacman --sysroot /mnt -S (package)`\nj.如果找不到镜像,重装下列包\n`pacman --sysroot /mnt -S mkinitcpio systemd linux`\n6.无线问题\n`如果无线标志都没出来`网卡重装,回到本博客开头的第一个问题\n`如果标志出来,收不到任何无线网`重装`wpa_supplicant`\n7.wps界面不显示中文\n卸载,用yay重装wps-office-cn版本,提示你可选依赖，装上所有可选依赖\n8.\ngdm进不去,重装gtk,gdm,gnome,xorg,gnome相关的全部删除\n9.yay包降级\n在wiki上找到那个包,在右边点击View Changes,选择想要的版本,点击下载,然后进入下载的解压缩文件,输入命令makepkg,sudo pacman -U xx.tar*\n10.自动挂载手机\n安装`gvfs-mtp`和`gvfs-gphoto2`\n11.gnome的压缩软件->file-roller\n12.lantern缺少的依赖->'libappindicator-gtk2/3'\n13.ubuntu虚拟机安装增强功能需要`build-essential gcc make perl linux-image-xx-generic`\n- 声音要先放网易云才能有,且要一直放的trouble,装`pipewire pipewire-pulse pipewire-alsa pipewire-jack pipewire-media-session`\n14.鼠标大小\ndconf write /org/gnome/desktop/interface/cursor-size 42\n","source":"_posts/Arch_Linux问题解决经验.md","raw":"---\ntitle: Arch Linux问题解决\ndate: 2020-12-31 14:59:37\nsubtitle:\ncategories:\ntags:\nindex_img: /images/fix.jpg\nbanner_img: /images/fix.jpg\n---\n1.广通无线网卡问题\n`lspci`查看那个shit一样的网卡名字\"BCM43142\"\n`sudo pacman -S linux-headers`装这个东西\n`sudo pacman -S broadcom-wl-dkms`安装这个屎样的驱动\n你可能会说,没网下个屁啊\n打开archwiki的package页面搜索包,点想要的包,在右边有个小字download from mirrors,点他下载离线包,sudo pacman -U 那个包\n最新包可能出现问题,降级的时候要连linux那个包一块降级,linux和linux-headers版本号要对应上,\n2.降级问题\n最新包可能出现问题,先在/var/cache/pacman/pkg/那个目录下找缓存的文件\n找不到再从网上找。\n也可以用downgrade工具,没用过就不说它了\n3.背光灯问题\n/etc/modprobe.d/sony-laptop.conf 索尼背光灯设置文件\n4.制作启动盘\n直接用如下命令制作,deepin官网的也不行\n`df`查看启动U盘的设备号\n`sudo dd bs=4M if=deepin-desktop-community-1010-amd64.iso of=/dev/sdb status=progress && sync`\n注意:如果u盘表现异常,一插有两个部分(一个部分只有几百兆),制作不会成功.也无法直接格式化,此时可以借助deepin官网启动盘制作,先格式化,再按上述操作\n5.pacman更新过程中崩溃,断电\na.先制作启动盘(按上述方法)\nb.assistant键进入,选择U盘启动(bios里外部设备启动要打开)\nc.`iwctl`进入无线网配置\n(1)查看无线设备\n`device list`\n(2)扫描无线网\n`station wlan0 scan`\n(3)列出网络名\n`station wlan0 get-networks`\n(4)根据设备(wlan0)连接wifi名称\n`station wlan0 connect CMCC-A9wF`并输入密码(75ij3tw7)\n(5)\nexit退出\nd.挂载根文件系统,proc,sys和dev\n`mount /dev/sda[x] /mnt;mount -t proc proc /mnt/proc;mount --rbind /sys /mnt/sys;mount --rbind /dev /mnt/dev`\ne.有锁的话,删除锁\n`rm /mnt/var/lib/pacman/db.lck`要加/mnt绝对路径\nf.查找损坏包\n`pacman --sysroot /mnt -S $(pacman --sysroot /mnt -Qnq)`\n损坏包会有`vim: /usr/xxx/xxx exists in filesystem`,这里vim就是损坏包\n注意如果没有损坏包,就不要执行上述命令,因为他是重装所有包,这里只是检查以下\ng.把上述命令重定向到一个文件,用vim修改成每一行如`rm -f /mnt/usr/xxx/xxx`\n列模式修改(选中按c即可)':'前面的所有字符为`rm -f /mnt`(要加/mnt,绝对路径),全局替换掉所有'exists in filesystem'为空\nh.`chmod +x`赋予那个重定向文件执行权限,`./(那个文件)`\ni.更新或安装损坏包,\n`pacman --sysroot /mnt -S (package)`\nj.如果找不到镜像,重装下列包\n`pacman --sysroot /mnt -S mkinitcpio systemd linux`\n6.无线问题\n`如果无线标志都没出来`网卡重装,回到本博客开头的第一个问题\n`如果标志出来,收不到任何无线网`重装`wpa_supplicant`\n7.wps界面不显示中文\n卸载,用yay重装wps-office-cn版本,提示你可选依赖，装上所有可选依赖\n8.\ngdm进不去,重装gtk,gdm,gnome,xorg,gnome相关的全部删除\n9.yay包降级\n在wiki上找到那个包,在右边点击View Changes,选择想要的版本,点击下载,然后进入下载的解压缩文件,输入命令makepkg,sudo pacman -U xx.tar*\n10.自动挂载手机\n安装`gvfs-mtp`和`gvfs-gphoto2`\n11.gnome的压缩软件->file-roller\n12.lantern缺少的依赖->'libappindicator-gtk2/3'\n13.ubuntu虚拟机安装增强功能需要`build-essential gcc make perl linux-image-xx-generic`\n- 声音要先放网易云才能有,且要一直放的trouble,装`pipewire pipewire-pulse pipewire-alsa pipewire-jack pipewire-media-session`\n14.鼠标大小\ndconf write /org/gnome/desktop/interface/cursor-size 42\n","slug":"Arch_Linux问题解决经验","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi6r0003gwq2g9a7dzlt","content":"<p>1.广通无线网卡问题<br><code>lspci</code>查看那个shit一样的网卡名字”BCM43142”<br><code>sudo pacman -S linux-headers</code>装这个东西<br><code>sudo pacman -S broadcom-wl-dkms</code>安装这个屎样的驱动<br>你可能会说,没网下个屁啊<br>打开archwiki的package页面搜索包,点想要的包,在右边有个小字download from mirrors,点他下载离线包,sudo pacman -U 那个包<br>最新包可能出现问题,降级的时候要连linux那个包一块降级,linux和linux-headers版本号要对应上,<br>2.降级问题<br>最新包可能出现问题,先在&#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F;那个目录下找缓存的文件<br>找不到再从网上找。<br>也可以用downgrade工具,没用过就不说它了<br>3.背光灯问题<br>&#x2F;etc&#x2F;modprobe.d&#x2F;sony-laptop.conf 索尼背光灯设置文件<br>4.制作启动盘<br>直接用如下命令制作,deepin官网的也不行<br><code>df</code>查看启动U盘的设备号<br><code>sudo dd bs=4M if=deepin-desktop-community-1010-amd64.iso of=/dev/sdb status=progress &amp;&amp; sync</code><br>注意:如果u盘表现异常,一插有两个部分(一个部分只有几百兆),制作不会成功.也无法直接格式化,此时可以借助deepin官网启动盘制作,先格式化,再按上述操作<br>5.pacman更新过程中崩溃,断电<br>a.先制作启动盘(按上述方法)<br>b.assistant键进入,选择U盘启动(bios里外部设备启动要打开)<br>c.<code>iwctl</code>进入无线网配置<br>(1)查看无线设备<br><code>device list</code><br>(2)扫描无线网<br><code>station wlan0 scan</code><br>(3)列出网络名<br><code>station wlan0 get-networks</code><br>(4)根据设备(wlan0)连接wifi名称<br><code>station wlan0 connect CMCC-A9wF</code>并输入密码(75ij3tw7)<br>(5)<br>exit退出<br>d.挂载根文件系统,proc,sys和dev<br><code>mount /dev/sda[x] /mnt;mount -t proc proc /mnt/proc;mount --rbind /sys /mnt/sys;mount --rbind /dev /mnt/dev</code><br>e.有锁的话,删除锁<br><code>rm /mnt/var/lib/pacman/db.lck</code>要加&#x2F;mnt绝对路径<br>f.查找损坏包<br><code>pacman --sysroot /mnt -S $(pacman --sysroot /mnt -Qnq)</code><br>损坏包会有<code>vim: /usr/xxx/xxx exists in filesystem</code>,这里vim就是损坏包<br>注意如果没有损坏包,就不要执行上述命令,因为他是重装所有包,这里只是检查以下<br>g.把上述命令重定向到一个文件,用vim修改成每一行如<code>rm -f /mnt/usr/xxx/xxx</code><br>列模式修改(选中按c即可)’:’前面的所有字符为<code>rm -f /mnt</code>(要加&#x2F;mnt,绝对路径),全局替换掉所有’exists in filesystem’为空<br>h.<code>chmod +x</code>赋予那个重定向文件执行权限,<code>./(那个文件)</code><br>i.更新或安装损坏包,<br><code>pacman --sysroot /mnt -S (package)</code><br>j.如果找不到镜像,重装下列包<br><code>pacman --sysroot /mnt -S mkinitcpio systemd linux</code><br>6.无线问题<br><code>如果无线标志都没出来</code>网卡重装,回到本博客开头的第一个问题<br><code>如果标志出来,收不到任何无线网</code>重装<code>wpa_supplicant</code><br>7.wps界面不显示中文<br>卸载,用yay重装wps-office-cn版本,提示你可选依赖，装上所有可选依赖<br>8.<br>gdm进不去,重装gtk,gdm,gnome,xorg,gnome相关的全部删除<br>9.yay包降级<br>在wiki上找到那个包,在右边点击View Changes,选择想要的版本,点击下载,然后进入下载的解压缩文件,输入命令makepkg,sudo pacman -U xx.tar*<br>10.自动挂载手机<br>安装<code>gvfs-mtp</code>和<code>gvfs-gphoto2</code><br>11.gnome的压缩软件-&gt;file-roller<br>12.lantern缺少的依赖-&gt;’libappindicator-gtk2&#x2F;3’<br>13.ubuntu虚拟机安装增强功能需要<code>build-essential gcc make perl linux-image-xx-generic</code></p>\n<ul>\n<li>声音要先放网易云才能有,且要一直放的trouble,装<code>pipewire pipewire-pulse pipewire-alsa pipewire-jack pipewire-media-session</code><br>14.鼠标大小<br>dconf write &#x2F;org&#x2F;gnome&#x2F;desktop&#x2F;interface&#x2F;cursor-size 42</li>\n</ul>\n","excerpt":"","more":"<p>1.广通无线网卡问题<br><code>lspci</code>查看那个shit一样的网卡名字”BCM43142”<br><code>sudo pacman -S linux-headers</code>装这个东西<br><code>sudo pacman -S broadcom-wl-dkms</code>安装这个屎样的驱动<br>你可能会说,没网下个屁啊<br>打开archwiki的package页面搜索包,点想要的包,在右边有个小字download from mirrors,点他下载离线包,sudo pacman -U 那个包<br>最新包可能出现问题,降级的时候要连linux那个包一块降级,linux和linux-headers版本号要对应上,<br>2.降级问题<br>最新包可能出现问题,先在&#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F;那个目录下找缓存的文件<br>找不到再从网上找。<br>也可以用downgrade工具,没用过就不说它了<br>3.背光灯问题<br>&#x2F;etc&#x2F;modprobe.d&#x2F;sony-laptop.conf 索尼背光灯设置文件<br>4.制作启动盘<br>直接用如下命令制作,deepin官网的也不行<br><code>df</code>查看启动U盘的设备号<br><code>sudo dd bs=4M if=deepin-desktop-community-1010-amd64.iso of=/dev/sdb status=progress &amp;&amp; sync</code><br>注意:如果u盘表现异常,一插有两个部分(一个部分只有几百兆),制作不会成功.也无法直接格式化,此时可以借助deepin官网启动盘制作,先格式化,再按上述操作<br>5.pacman更新过程中崩溃,断电<br>a.先制作启动盘(按上述方法)<br>b.assistant键进入,选择U盘启动(bios里外部设备启动要打开)<br>c.<code>iwctl</code>进入无线网配置<br>(1)查看无线设备<br><code>device list</code><br>(2)扫描无线网<br><code>station wlan0 scan</code><br>(3)列出网络名<br><code>station wlan0 get-networks</code><br>(4)根据设备(wlan0)连接wifi名称<br><code>station wlan0 connect CMCC-A9wF</code>并输入密码(75ij3tw7)<br>(5)<br>exit退出<br>d.挂载根文件系统,proc,sys和dev<br><code>mount /dev/sda[x] /mnt;mount -t proc proc /mnt/proc;mount --rbind /sys /mnt/sys;mount --rbind /dev /mnt/dev</code><br>e.有锁的话,删除锁<br><code>rm /mnt/var/lib/pacman/db.lck</code>要加&#x2F;mnt绝对路径<br>f.查找损坏包<br><code>pacman --sysroot /mnt -S $(pacman --sysroot /mnt -Qnq)</code><br>损坏包会有<code>vim: /usr/xxx/xxx exists in filesystem</code>,这里vim就是损坏包<br>注意如果没有损坏包,就不要执行上述命令,因为他是重装所有包,这里只是检查以下<br>g.把上述命令重定向到一个文件,用vim修改成每一行如<code>rm -f /mnt/usr/xxx/xxx</code><br>列模式修改(选中按c即可)’:’前面的所有字符为<code>rm -f /mnt</code>(要加&#x2F;mnt,绝对路径),全局替换掉所有’exists in filesystem’为空<br>h.<code>chmod +x</code>赋予那个重定向文件执行权限,<code>./(那个文件)</code><br>i.更新或安装损坏包,<br><code>pacman --sysroot /mnt -S (package)</code><br>j.如果找不到镜像,重装下列包<br><code>pacman --sysroot /mnt -S mkinitcpio systemd linux</code><br>6.无线问题<br><code>如果无线标志都没出来</code>网卡重装,回到本博客开头的第一个问题<br><code>如果标志出来,收不到任何无线网</code>重装<code>wpa_supplicant</code><br>7.wps界面不显示中文<br>卸载,用yay重装wps-office-cn版本,提示你可选依赖，装上所有可选依赖<br>8.<br>gdm进不去,重装gtk,gdm,gnome,xorg,gnome相关的全部删除<br>9.yay包降级<br>在wiki上找到那个包,在右边点击View Changes,选择想要的版本,点击下载,然后进入下载的解压缩文件,输入命令makepkg,sudo pacman -U xx.tar*<br>10.自动挂载手机<br>安装<code>gvfs-mtp</code>和<code>gvfs-gphoto2</code><br>11.gnome的压缩软件-&gt;file-roller<br>12.lantern缺少的依赖-&gt;’libappindicator-gtk2&#x2F;3’<br>13.ubuntu虚拟机安装增强功能需要<code>build-essential gcc make perl linux-image-xx-generic</code></p>\n<ul>\n<li>声音要先放网易云才能有,且要一直放的trouble,装<code>pipewire pipewire-pulse pipewire-alsa pipewire-jack pipewire-media-session</code><br>14.鼠标大小<br>dconf write &#x2F;org&#x2F;gnome&#x2F;desktop&#x2F;interface&#x2F;cursor-size 42</li>\n</ul>\n"},{"title":"C++小知识","date":"2019-07-18T09:14:17.000Z","subtitle":null,"index_img":"/images/Cpp.jpeg","banner_img":"/images/Cpp.jpeg","_content":"## 指针与应用  \n.初始化要求不同，引用创建的同时必须初始化，而指针不必，可以重新赋值。\n.可修改性不同，引用一旦被初始化，就不可更改，而指针可以指向另一个变量\n.不存在NULL引用，指针可以，指针更灵活，但风险也大\n.指针是一个实体，引用是一个别名\n.内存上，指针有分配的存储空间，而应用则不用\n## tips\n- c++无符号右移高位都补0\n- `auto dp = vector<vector<int>>(length, vector<int>(length));`可以这样声明数组\n- 八进制整型常量以\"0\"开头如:0123\n- 十六进制以\"0x(X)\"开头\n- 长整型以\"L(l)\"结尾\n- 无符号型以\"U(u)\"结尾\n- 默认数据类型为int型,默认实型为double型,若要表示float型在结尾加\"F(f)\"\n- register+类型+变量名,存放在寄存器,加快调用\n## lambda\n格式:`[capture list] (parameter list) -> return type {function body}`,capture list可以为空，里面一般是包含此lambda的函数的(非static)局部变量,该函数外的变量可以在函数体内直接用,return type可以省略。\n\n## 技巧\n### 使用初始化列表比较大小\n**差：**`small = min(x,min(y,z));`\n**好：**`small = min({x,y,z,k});`\n### 解构\n```C++\npair<int,int> cur = {1,2};\nauto [x,y] = cur;\n```\n### debug宏\n```C++\n#definde deb(x) cout<< #x << \" = \" << x\nint ten = 10;\ndeb(ten); //prints \"ten = 10\"\n```\n### 支持多参数的debug宏\n```C++\n#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename ...Args>\nvoid logger(string vars, Args&&... values) {\n    cout << vars << \" = \";\n    string delim = \"\";\n    (..., (cout << delim << values, delim = \", \"));\n}\n\nint xx = 3, yy = 10, xxyy = 103;\ndeb(xx); // prints \"xx = 3\"\ndeb(xx, yy, xxyy); // prints \"xx, yy, xxyy = 3, 10, 103\"\n```\n### 读写容器和多变量\n```C++\ntemplate <typename... T>\nvoid read(T &...args) {\n    ((cin >> args), ...);\n}\n\ntemplate <typename... T>\nvoid write(string delimiter, T &&...args) {\n    ((cout << args << delimiter), ...);\n}\n\ntemplate <typename T>\nvoid readContainer(T &t) {\n    for (auto &e : t) {\n        read(e);\n    }\n}\n\ntemplate <typename T>\nvoid writeContainer(string delimiter, T &t) {\n    for (const auto &e : t) {\n        write(delimiter, e);\n    }\n    write(\"\\n\");\n}\n// Question: read three space seprated integers and print them in different lines.\n\tint x, y, z;\n\tread(x, y, z);\n\twrite(\"\\n\", x, y, z);\n\n// even works with variable data types :)\n\tint n;\n\tstring s;\n\tread(n, s);\n\twrite(\" \", s, \"has length\", n, \"\\n\");\n\n// Question: read an array of `N` integers and print it to the output console.\n\tint N;\n\tread(N);\n\tvector<int> arr(N);\n\treadContainer(arr);\n\twriteContainer(\" \", arr); // output: arr[0] arr[1] arr[2] ... arr[N - 1]\n\twriteContainer(\"\\n\", arr);\n\t/**\n\t* output:\n\t* arr[0]\n\t* arr[1]\n\t* arr[2]\n\t* ...\n\t* ...\n\t* ...\n\t* arr[N - 1]\n\t*/\n```\n### debug函数\n```C++\ntemplate<typename ...T>\nvoid printer(T&&... args) {\n    ((cout << args << \" \"), ...);\n}\n\nint age = 25;\nstring name = \"Rachit\";\nprinter(\"I am\", name, ',', age, \"years old\");\n// ^ This prints the following\n// I am Rachit, 25 years old\ntemplate<typename F>\nauto debug_func(const F& func) {\n    return [func](auto &&...args) { // forward reference\n        cout << \"input = \";\n        printer(args...);\n        auto res = func(forward<decltype(args)>(args)...);\n        cout << \"res = \" << res << endl;\n        return res;\n    };\n}\n\ndebug_func(pow)(2, 3);\n// ^ this automatically prints\n// input = 2 3 res = 8\n```\n### 默认构造\n默认第一个类型的构造函数，第一个类型必须有构造函数，可以用monostate来作第一个参数，类似空指针\n## span(c++20)\nspan(std::string_view类似)是对数组的引用，可以对C风格的数组引用，可以使用vector的部分风格，例如下\n```C\nvoid read(span<int> r) // read into the range of integers r\n{\n    cout<<r.size()<<endl;//100\n}\n\nint a[100];\nread(a);        // better: let the compiler figure out the number of elements\n```\n## string_view和span<char>\nstring_view只读，span<char>可变\n## [[maybe_unused]]\n可以使用该attribute，声明条件用到的参数\n`Value* find(const set<Value>& s, const Value& v, [[maybe_unused]] Hint hint)`\n`[[maybe_unused]] int x = value`\n## zstring或not_null<zstring>来表明C字符串\n`int length(const char* p)`=>`int length(zstring p)`\n`int length(not_null<zstring>)`\n## 不变参数用模板\n```C\nint sum(...)\n{\n    // ...\n    while (/*...*/)\n        result += va_arg(list, int); // BAD, assumes it will be passed ints\n    // ...\n}\n\nsum(3, 2); // ok\nsum(3.14159, 2.71828); // BAD, undefined\n\ntemplate<class ...Args>\nauto sum(Args... args) // GOOD, and much more flexible\n{\n    return (... + args); // note: C++17 \"fold expression\"\n}\n\nsum(3, 2); // ok: 5\nsum(3.14159, 2.71828); // ok: ~5.85987\n```\n## 原始指针只表示内存地址，owner表示所有权\n```C++\ntemplate<typename T>\nclass X2 {\npublic:\n    owner<T*> p;  // OK: p is owning\n    T* q;         // OK: q is not owning\n    // ...\n};\n```\n## C和C++互相调用\n- 从C++调用C:\n    - in C:\n    double sqrt(double);\n    - in C++:\n    extern \"C\" double sqrt(double);\n    sqrt(2);\n- 从C调用C++:\n    - in C:\n    X call_f(struct Y*, int);\n    - in C++:\n    extern \"C\" X call_f(Y* p, int i)\n    {\n    return p->f(i);   // possibly a virtual function call\n    }\n## c++23的print\n```C++\n#include <print>\nint main()\n{\n    std::print(\"Hello World! {}, {}, {}\\n\", 3, 4ll, \"aa\");\n    // print \"Hello World! 3 4 aa\"\n}\n```\n\n## c++20的`<=>`\n```C++\n(3 <=> 5) == 0; // false\n('a' <=> 'a') == 0; // true\n(3 <=> 5) < 0; // true\n(7 <=> 5) < 0; // false\n```\n强大的default\n```C++\n# include <compare>\nstruct Obj {\nint x;\nchar y;\nshort z[2];\nauto operator<=>(const Obj&) const = default;\n// if x == other.x, then compare y\n// if y == other.y, then compare z\n// if z[0] == other.z[0], then compare z[1]\n};\n```\n\n## c++20的有符号与无符号的比较\n```C++\nbool cmp_equal(T1 a, T2 b)\nbool cmp_not_equal(T1 a, T2 b)\nbool cmp_less(T1 a, T2 b)\nbool cmp_greater(T1 a, T2 b)\nbool cmp_less_equal(T1 a, T2 b)\nbool cmp_greater_equal(T1 a, T2 b)\n# include <utility>\nunsigned a = 4;\nint b = -3;\nbool v1 = (a > b); // false!!!, see next slides\nbool v2 = std::cmp_greater(a, b); // true\n```\n## C++17 enum class支持attributes\n```c++\nenum class Color { RED, GREEN, BLUE [[deprecated]] };\nauto x = Color::BLUE; // compiler warning\n```\n## 函数属性\n\n|关键字|最低标准|含义|\n|:-:|:-:|:-:|\n|`[[noreturn]]`|c++11|表示函数不返回|\n|`[[deprecated]],[[deprecated(\"reason\")]]`|c++14|表示将会弃用函数，产生编译告警|\n|`[[nodiscard]]`|c++17|见下|\n|`[[nodiscard(\"reason\")]]`|c++20|如果返回值没被使用，会产生告警|\n|`[[maybe_unused]]`|c++17|未使用的变量不产生告警|\n\n```C++\n[[noreturn]] void f() { std::exit(0); }\n[[deprecated]] void my_rand() { ... }\n[[nodiscard]] bool g(int& x) {\nupdate(x);\nbool status = ...;\nreturn status;\n}\nvoid h([[maybe_unused]] x) {\n#if !defined(SKIP_COMPUTATION)\n... use x ...\n#endif\n}\n//----------------------------------------------------------------------\nmy_rand(); // WARNING \"deprecated\"\ng(y); // WARNING \"discard return value\"\nint z = g(); // no warning\nh(3); // no warning if SKIP_COMPUTATION is defined\n```\n\n## 宏\n### 使用条件\n不建议使用宏，一般在以下情况使用宏\n- 条件编译： 不同架构、编译器等\n- 多语言混编\n- 复杂名字代替\n### 内置宏\n```C++\n# include <iostream>\nvoid f(int p) {\nstd::cout << __FILE__ << \":\" << __LINE__; // print 'source.cpp:4'\nstd::cout << __FUNCTION__; // print 'f'\nstd::cout << __func__; // print 'f'\n}\n// see template lectures\ntemplate<typename T>\nfloat g(T p) {\nstd::cout << __PRETTY_FUNCTION__; // print 'float g(T) [T = int]'\nreturn 0.0f;\n}\nvoid g1() { g(3); }\n```\nC++20在<source_location>提供了函数方法来代替这些宏。\n```C++\n# include <source_location>\nvoid f(std::source_location s = std::source_location::current()) {\ncout << \"function: \" << s.function_name() << \", line \" << s.line();\n} // column(),file_name() also support\nf(); // print: \"function: f, line 6\"\n```\n- `__DATE__`:输出编译的开始日期以'mmm dd yyyy'格式\n- `__TIME__`:输出编译的开始时间\n### 常见的条件编译\n可见网址![](https://sourceforge.net/p/predef/wiki/Home/)\n可见网址![](https://abseil.io/docs/cpp/platforms/macros)\n\n|语法|含义|\n|:-:|:-:|\n|`#if defined( cplusplus)`| C++ code|\n|`#if cplusplus == 199711L`| ISO C++ 1998/2003,仅限于linux,MSVC的2011和2014也是该值|\n|`#if cplusplus == 201103L`| ISO C++ 2011,仅限于linux|\n|`#if cplusplus == 201402L`| ISO C++ 2014,仅限于linux|\n|`#if cplusplus == 201703L`| ISO C++ 2017|\n|`#if defined( GNUG )`| The compiler is gcc/g++ |\n|`#if defined( clang )`| The compiler is clang/clang++|\n|`#if defined( MSC VER)`| The compiler is Microsoft Visual C++|\n|`#if defined( WIN64)`| OS is Windows 64-bit|\n|`#if defined( linux )`| OS is Linux|\n|`#if defined( APPLE )`| OS is Mac OS|\n|`#if defined( MINGW32 )`| OS is MinGW 32-bit|\n\n### 其他\n- `#`:等价于加个双引号\n```C++\n# define STRING_MACRO(string) #string\ncout << STRING_MACRO(hello); // equivalent to \"hello\"\n# define INFO_MACRO(my_func) \\\n{ \\\nmy_func \\\ncout << \"call \" << #my_func << \" at \" \\\n<< __FILE__ << \":\" __LINE__; \\\n}\nvoid g(int) {}\nINFO_MACRO( g(3) ) // print: \"call g(3) at my_file.cpp:7\"\n```\n- `#error \"text\"`:编译器遇到时会输出error\n- `#warning \"text\"`:编译器遇到时会输出warning\n- `##`：连接字符串\n```C++\n# define FUNC_GEN_A(tokenA, tokenB) \\\nvoid tokenA##tokenB() {}\n# define FUNC_GEN_B(tokenA, tokenB) \\\nvoid tokenA##_##tokenB() {}\nFUNC_GEN_A(my, function)\nFUNC_GEN_B(my, function)\nmyfunction(); // ok, from FUNC_GEN_A\nmy_function(); // ok, from FUNC_GEN_B\n```\n- `__VA_ARGS__`:多参数宏\n```C++\nvoid f(int a) { printf(\"%d\", a); }\nvoid f(int a, int b) { printf(\"%d %d\", a, b); }\nvoid f(int a, int b, int c) { printf(\"%d %d %d\", a, b, c); }\n# define PRINT(...) \\\nf( VA ARGS );\nPRINT(1, 2)\nPRINT(1, 2, 3) \n```\n- `#if __has_include(<iostream>)`：c++17判断是否存在头文件\n```C++\n# if __has_include(<iostream>)\n# include <iostream>\n# endif\n```\n- `#if __cpp_constexpr`:C++20引入，判断编译器是否支持某特性，还有许多其它的宏\n```C++\n# if __cpp_constexpr\nconstexpr int square(int x) { return x * x; }\n# endif\n```\n- `#pragma`:调用某个指令，依赖于编译器\n### 技巧\n**数字转字符串**\n```C++\n# define TO_LITERAL_AUX(x) #x\n# define TO_LITERAL(x) TO_LITERAL_AUX(x)\nint main() {\nint x1 = 3 * 10;\nint y1 = __LINE__ + 4;\nchar x2[] = TO_LITERAL(3);\nchar y2[] = TO_LITERAL(__LINE__);//这里你知道为啥包一层了把，有些并不是无意义的包\n}\n```\n\n## Bitfield\n```C++\nstruct S1 {\nint b1 : 10; // range [0, 1023]\nint b2 : 10; // range [0, 1023]\nint b3 : 8; // range [0, 255]\n}; // sizeof(S1): 4 bytes\nstruct S2 {\nint b1 : 10;\nint : 0; // reset: force the next field\nint b2 : 10; // to start at bit 32\n}; // sizeof(S1): 8 bytes\n```\n\n## type_info\n```C++\nstruct A {\nvirtual void f() {}\n};\nstruct B : A {};\nA a;\nB b;\nA& a1 = b; // implicit upcasting\ncout << typeid(a).name(); // print \"1A\"\ncout << typeid(b).name(); // print \"1B\"\ncout << typeid(a1).name(); // print \"1B\"\n```\n## 未定义行为\n### Pointer\n- Dereferencing a NULL pointer\n- Dereferencing a pointer returned by a \"new\" allocation of size zero\n- Using pointers to objects whose lifetime has ended (for instance, stack allocated objects or deleted objects)\n- Dereferencing a pointer that has not yet been definitely initialized\n- Performing pointer arithmetic that yields a result outside the boundaries (either above or below) of an array.\n- Dereferencing the pointer at a location beyond the end of an array.\n- Converting pointers to objects of incompatible types\n- Using memcpy to copy overlapping buffers.\n### buffer overflows\n- Reading or writing to an object or array at an offset that is negative, or beyond the size of that object (stack/heap overflow)\n### Integer Overflows\n- Signed integer overflow\n- Evaluating an expression that is not mathematically defined\n- Left-shifting values by a negative amount (right shifts by negative amounts are implementation defined)\n- Shifting values by an amount greater than or equal to the number of bits in the number (e.g. int64_t i = 1; i <<= 72 is undefined)\n### Types, Cast and Const\n- Casting a numeric value into a value that can't be represented by the target type (either directly or via static_cast)\n- Using an automatic variable before it has been definitely assigned (e.g., int i; i++; cout << i;)\n- Using the value of any object of type other than volatile or sig_atomic_t at the receipt of a signal\n- Attempting to modify a string literal or any other const object during its lifetime\n- Concatenating a narrow with a wide string literal during preprocessing\n### Function and Template\n- Not returning a value from a value-returning function (directly or by flowing off from a try-block)\n- Multiple different definitions for the same entity (class, template, enumeration, inline function, static member function, etc.)\n- Infinite recursion in the instantiation of templates\n- Calling a function using different parameters or linkage to the parameters and linkage that the function is defined as using.\n### OOP\n- Cascading destructions of objects with static storage duration\n- The result of assigning to partially overlapping objects\n- Recursively re-entering a function during the initialization of its static objects\n- Making virtual function calls to pure virtual functions of an object from its constructor or destructor\n- Referring to nonstatic members of objects that have not been constructed or have already been destructed\n### Source file and Preprocessing\n- A non-empty source file that doesn't end with a newline, or ends with a backslash (prior to C++11)\n- A backslash followed by a character that is not part of the specified escape codes in a character or string constant (this is implementation-defined in C++11).\n- Exceeding implementation limits (number of nested blocks, number of functions in a program, available stack space ...)\n- Preprocessor numeric values that can't be represented by a long int\n- Preprocessing directive on the left side of a function-like macro definition\n- Dynamically generating the defined token in a #if expression\n### to be classified\n- Calling exit during the destruction of a program with static storage duration\n## c_str2num\n高性能转换\n```C++\ntemplate<int N, unsigned MUL, int INDEX = 0>\nstruct fastStringToIntStr;\ninline unsigned fastStringToUnsigned(const char* str, int length) {\nswitch(length) {\ncase 10: return fastStringToIntStr<10, 1000000000>::aux(str);\ncase 9: return fastStringToIntStr< 9, 100000000>::aux(str);\ncase 8: return fastStringToIntStr< 8, 10000000>::aux(str);\ncase 7: return fastStringToIntStr< 7, 1000000>::aux(str);\ncase 6: return fastStringToIntStr< 6, 100000>::aux(str);\ncase 5: return fastStringToIntStr< 5, 10000>::aux(str);\ncase 4: return fastStringToIntStr< 4, 1000>::aux(str);\ncase 3: return fastStringToIntStr< 3, 100>::aux(str);\ncase 2: return fastStringToIntStr< 2, 10>::aux(str);\ncase 1: return fastStringToIntStr< 1, 1>::aux(str);\ndefault: return 0;\n}\n}\ntemplate<int N, unsigned MUL, int INDEX>\nstruct fastStringToIntStr {\nstatic inline unsigned aux(const char* str) {\nreturn static_cast<unsigned>(str[INDEX] - '0') * MUL +\nfastStringToIntStr<N - 1, MUL / 10, INDEX + 1>::aux(str);\n}\n};\ntemplate<unsigned MUL, int INDEX>\nstruct fastStringToIntStr<1, MUL, INDEX> {\nstatic inline unsigned aux(const char* str) {\nreturn static_cast<unsigned>(str[INDEX] - '0');\n}\n};\n```\n## 删除vector某个元素\n```\nswap(v[3], v[v.size()-1]);\nv.pop_back();\n```\n## 批量删除vector元素\n以下方法都是类似于把元素移到末尾，然后统一删除\n- 删除所有值为42的：`v.erase(remove(v.begin(), v.end(), 42), v.end());`\n- 删除所有值大于0的:\n```C++\nvector<int> v;\nv.erase(remove_if(v.begin(), v.end(), [](int x) {\n    return x > 0;\n}), v.end());\n```\n- c++20\n```C++\nvector<int> v;\nerase(v, 42);       // 删除所有值为 42 的元素\nerase_if(v, [](int x) {\n    return x > 0;   // 删除所有值大于 0 的元素\n});\n```\n## 维护有序的vector\n`s.insert(lower_bound(s.begin(),s.end(),3), 3)`\n","source":"_posts/C-小知识.md","raw":"---\ntitle: C++小知识\ndate: 2019-07-18 17:14:17\nsubtitle:\ncategories: C++\ntags:\nindex_img: /images/Cpp.jpeg\nbanner_img: /images/Cpp.jpeg\n---\n## 指针与应用  \n.初始化要求不同，引用创建的同时必须初始化，而指针不必，可以重新赋值。\n.可修改性不同，引用一旦被初始化，就不可更改，而指针可以指向另一个变量\n.不存在NULL引用，指针可以，指针更灵活，但风险也大\n.指针是一个实体，引用是一个别名\n.内存上，指针有分配的存储空间，而应用则不用\n## tips\n- c++无符号右移高位都补0\n- `auto dp = vector<vector<int>>(length, vector<int>(length));`可以这样声明数组\n- 八进制整型常量以\"0\"开头如:0123\n- 十六进制以\"0x(X)\"开头\n- 长整型以\"L(l)\"结尾\n- 无符号型以\"U(u)\"结尾\n- 默认数据类型为int型,默认实型为double型,若要表示float型在结尾加\"F(f)\"\n- register+类型+变量名,存放在寄存器,加快调用\n## lambda\n格式:`[capture list] (parameter list) -> return type {function body}`,capture list可以为空，里面一般是包含此lambda的函数的(非static)局部变量,该函数外的变量可以在函数体内直接用,return type可以省略。\n\n## 技巧\n### 使用初始化列表比较大小\n**差：**`small = min(x,min(y,z));`\n**好：**`small = min({x,y,z,k});`\n### 解构\n```C++\npair<int,int> cur = {1,2};\nauto [x,y] = cur;\n```\n### debug宏\n```C++\n#definde deb(x) cout<< #x << \" = \" << x\nint ten = 10;\ndeb(ten); //prints \"ten = 10\"\n```\n### 支持多参数的debug宏\n```C++\n#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename ...Args>\nvoid logger(string vars, Args&&... values) {\n    cout << vars << \" = \";\n    string delim = \"\";\n    (..., (cout << delim << values, delim = \", \"));\n}\n\nint xx = 3, yy = 10, xxyy = 103;\ndeb(xx); // prints \"xx = 3\"\ndeb(xx, yy, xxyy); // prints \"xx, yy, xxyy = 3, 10, 103\"\n```\n### 读写容器和多变量\n```C++\ntemplate <typename... T>\nvoid read(T &...args) {\n    ((cin >> args), ...);\n}\n\ntemplate <typename... T>\nvoid write(string delimiter, T &&...args) {\n    ((cout << args << delimiter), ...);\n}\n\ntemplate <typename T>\nvoid readContainer(T &t) {\n    for (auto &e : t) {\n        read(e);\n    }\n}\n\ntemplate <typename T>\nvoid writeContainer(string delimiter, T &t) {\n    for (const auto &e : t) {\n        write(delimiter, e);\n    }\n    write(\"\\n\");\n}\n// Question: read three space seprated integers and print them in different lines.\n\tint x, y, z;\n\tread(x, y, z);\n\twrite(\"\\n\", x, y, z);\n\n// even works with variable data types :)\n\tint n;\n\tstring s;\n\tread(n, s);\n\twrite(\" \", s, \"has length\", n, \"\\n\");\n\n// Question: read an array of `N` integers and print it to the output console.\n\tint N;\n\tread(N);\n\tvector<int> arr(N);\n\treadContainer(arr);\n\twriteContainer(\" \", arr); // output: arr[0] arr[1] arr[2] ... arr[N - 1]\n\twriteContainer(\"\\n\", arr);\n\t/**\n\t* output:\n\t* arr[0]\n\t* arr[1]\n\t* arr[2]\n\t* ...\n\t* ...\n\t* ...\n\t* arr[N - 1]\n\t*/\n```\n### debug函数\n```C++\ntemplate<typename ...T>\nvoid printer(T&&... args) {\n    ((cout << args << \" \"), ...);\n}\n\nint age = 25;\nstring name = \"Rachit\";\nprinter(\"I am\", name, ',', age, \"years old\");\n// ^ This prints the following\n// I am Rachit, 25 years old\ntemplate<typename F>\nauto debug_func(const F& func) {\n    return [func](auto &&...args) { // forward reference\n        cout << \"input = \";\n        printer(args...);\n        auto res = func(forward<decltype(args)>(args)...);\n        cout << \"res = \" << res << endl;\n        return res;\n    };\n}\n\ndebug_func(pow)(2, 3);\n// ^ this automatically prints\n// input = 2 3 res = 8\n```\n### 默认构造\n默认第一个类型的构造函数，第一个类型必须有构造函数，可以用monostate来作第一个参数，类似空指针\n## span(c++20)\nspan(std::string_view类似)是对数组的引用，可以对C风格的数组引用，可以使用vector的部分风格，例如下\n```C\nvoid read(span<int> r) // read into the range of integers r\n{\n    cout<<r.size()<<endl;//100\n}\n\nint a[100];\nread(a);        // better: let the compiler figure out the number of elements\n```\n## string_view和span<char>\nstring_view只读，span<char>可变\n## [[maybe_unused]]\n可以使用该attribute，声明条件用到的参数\n`Value* find(const set<Value>& s, const Value& v, [[maybe_unused]] Hint hint)`\n`[[maybe_unused]] int x = value`\n## zstring或not_null<zstring>来表明C字符串\n`int length(const char* p)`=>`int length(zstring p)`\n`int length(not_null<zstring>)`\n## 不变参数用模板\n```C\nint sum(...)\n{\n    // ...\n    while (/*...*/)\n        result += va_arg(list, int); // BAD, assumes it will be passed ints\n    // ...\n}\n\nsum(3, 2); // ok\nsum(3.14159, 2.71828); // BAD, undefined\n\ntemplate<class ...Args>\nauto sum(Args... args) // GOOD, and much more flexible\n{\n    return (... + args); // note: C++17 \"fold expression\"\n}\n\nsum(3, 2); // ok: 5\nsum(3.14159, 2.71828); // ok: ~5.85987\n```\n## 原始指针只表示内存地址，owner表示所有权\n```C++\ntemplate<typename T>\nclass X2 {\npublic:\n    owner<T*> p;  // OK: p is owning\n    T* q;         // OK: q is not owning\n    // ...\n};\n```\n## C和C++互相调用\n- 从C++调用C:\n    - in C:\n    double sqrt(double);\n    - in C++:\n    extern \"C\" double sqrt(double);\n    sqrt(2);\n- 从C调用C++:\n    - in C:\n    X call_f(struct Y*, int);\n    - in C++:\n    extern \"C\" X call_f(Y* p, int i)\n    {\n    return p->f(i);   // possibly a virtual function call\n    }\n## c++23的print\n```C++\n#include <print>\nint main()\n{\n    std::print(\"Hello World! {}, {}, {}\\n\", 3, 4ll, \"aa\");\n    // print \"Hello World! 3 4 aa\"\n}\n```\n\n## c++20的`<=>`\n```C++\n(3 <=> 5) == 0; // false\n('a' <=> 'a') == 0; // true\n(3 <=> 5) < 0; // true\n(7 <=> 5) < 0; // false\n```\n强大的default\n```C++\n# include <compare>\nstruct Obj {\nint x;\nchar y;\nshort z[2];\nauto operator<=>(const Obj&) const = default;\n// if x == other.x, then compare y\n// if y == other.y, then compare z\n// if z[0] == other.z[0], then compare z[1]\n};\n```\n\n## c++20的有符号与无符号的比较\n```C++\nbool cmp_equal(T1 a, T2 b)\nbool cmp_not_equal(T1 a, T2 b)\nbool cmp_less(T1 a, T2 b)\nbool cmp_greater(T1 a, T2 b)\nbool cmp_less_equal(T1 a, T2 b)\nbool cmp_greater_equal(T1 a, T2 b)\n# include <utility>\nunsigned a = 4;\nint b = -3;\nbool v1 = (a > b); // false!!!, see next slides\nbool v2 = std::cmp_greater(a, b); // true\n```\n## C++17 enum class支持attributes\n```c++\nenum class Color { RED, GREEN, BLUE [[deprecated]] };\nauto x = Color::BLUE; // compiler warning\n```\n## 函数属性\n\n|关键字|最低标准|含义|\n|:-:|:-:|:-:|\n|`[[noreturn]]`|c++11|表示函数不返回|\n|`[[deprecated]],[[deprecated(\"reason\")]]`|c++14|表示将会弃用函数，产生编译告警|\n|`[[nodiscard]]`|c++17|见下|\n|`[[nodiscard(\"reason\")]]`|c++20|如果返回值没被使用，会产生告警|\n|`[[maybe_unused]]`|c++17|未使用的变量不产生告警|\n\n```C++\n[[noreturn]] void f() { std::exit(0); }\n[[deprecated]] void my_rand() { ... }\n[[nodiscard]] bool g(int& x) {\nupdate(x);\nbool status = ...;\nreturn status;\n}\nvoid h([[maybe_unused]] x) {\n#if !defined(SKIP_COMPUTATION)\n... use x ...\n#endif\n}\n//----------------------------------------------------------------------\nmy_rand(); // WARNING \"deprecated\"\ng(y); // WARNING \"discard return value\"\nint z = g(); // no warning\nh(3); // no warning if SKIP_COMPUTATION is defined\n```\n\n## 宏\n### 使用条件\n不建议使用宏，一般在以下情况使用宏\n- 条件编译： 不同架构、编译器等\n- 多语言混编\n- 复杂名字代替\n### 内置宏\n```C++\n# include <iostream>\nvoid f(int p) {\nstd::cout << __FILE__ << \":\" << __LINE__; // print 'source.cpp:4'\nstd::cout << __FUNCTION__; // print 'f'\nstd::cout << __func__; // print 'f'\n}\n// see template lectures\ntemplate<typename T>\nfloat g(T p) {\nstd::cout << __PRETTY_FUNCTION__; // print 'float g(T) [T = int]'\nreturn 0.0f;\n}\nvoid g1() { g(3); }\n```\nC++20在<source_location>提供了函数方法来代替这些宏。\n```C++\n# include <source_location>\nvoid f(std::source_location s = std::source_location::current()) {\ncout << \"function: \" << s.function_name() << \", line \" << s.line();\n} // column(),file_name() also support\nf(); // print: \"function: f, line 6\"\n```\n- `__DATE__`:输出编译的开始日期以'mmm dd yyyy'格式\n- `__TIME__`:输出编译的开始时间\n### 常见的条件编译\n可见网址![](https://sourceforge.net/p/predef/wiki/Home/)\n可见网址![](https://abseil.io/docs/cpp/platforms/macros)\n\n|语法|含义|\n|:-:|:-:|\n|`#if defined( cplusplus)`| C++ code|\n|`#if cplusplus == 199711L`| ISO C++ 1998/2003,仅限于linux,MSVC的2011和2014也是该值|\n|`#if cplusplus == 201103L`| ISO C++ 2011,仅限于linux|\n|`#if cplusplus == 201402L`| ISO C++ 2014,仅限于linux|\n|`#if cplusplus == 201703L`| ISO C++ 2017|\n|`#if defined( GNUG )`| The compiler is gcc/g++ |\n|`#if defined( clang )`| The compiler is clang/clang++|\n|`#if defined( MSC VER)`| The compiler is Microsoft Visual C++|\n|`#if defined( WIN64)`| OS is Windows 64-bit|\n|`#if defined( linux )`| OS is Linux|\n|`#if defined( APPLE )`| OS is Mac OS|\n|`#if defined( MINGW32 )`| OS is MinGW 32-bit|\n\n### 其他\n- `#`:等价于加个双引号\n```C++\n# define STRING_MACRO(string) #string\ncout << STRING_MACRO(hello); // equivalent to \"hello\"\n# define INFO_MACRO(my_func) \\\n{ \\\nmy_func \\\ncout << \"call \" << #my_func << \" at \" \\\n<< __FILE__ << \":\" __LINE__; \\\n}\nvoid g(int) {}\nINFO_MACRO( g(3) ) // print: \"call g(3) at my_file.cpp:7\"\n```\n- `#error \"text\"`:编译器遇到时会输出error\n- `#warning \"text\"`:编译器遇到时会输出warning\n- `##`：连接字符串\n```C++\n# define FUNC_GEN_A(tokenA, tokenB) \\\nvoid tokenA##tokenB() {}\n# define FUNC_GEN_B(tokenA, tokenB) \\\nvoid tokenA##_##tokenB() {}\nFUNC_GEN_A(my, function)\nFUNC_GEN_B(my, function)\nmyfunction(); // ok, from FUNC_GEN_A\nmy_function(); // ok, from FUNC_GEN_B\n```\n- `__VA_ARGS__`:多参数宏\n```C++\nvoid f(int a) { printf(\"%d\", a); }\nvoid f(int a, int b) { printf(\"%d %d\", a, b); }\nvoid f(int a, int b, int c) { printf(\"%d %d %d\", a, b, c); }\n# define PRINT(...) \\\nf( VA ARGS );\nPRINT(1, 2)\nPRINT(1, 2, 3) \n```\n- `#if __has_include(<iostream>)`：c++17判断是否存在头文件\n```C++\n# if __has_include(<iostream>)\n# include <iostream>\n# endif\n```\n- `#if __cpp_constexpr`:C++20引入，判断编译器是否支持某特性，还有许多其它的宏\n```C++\n# if __cpp_constexpr\nconstexpr int square(int x) { return x * x; }\n# endif\n```\n- `#pragma`:调用某个指令，依赖于编译器\n### 技巧\n**数字转字符串**\n```C++\n# define TO_LITERAL_AUX(x) #x\n# define TO_LITERAL(x) TO_LITERAL_AUX(x)\nint main() {\nint x1 = 3 * 10;\nint y1 = __LINE__ + 4;\nchar x2[] = TO_LITERAL(3);\nchar y2[] = TO_LITERAL(__LINE__);//这里你知道为啥包一层了把，有些并不是无意义的包\n}\n```\n\n## Bitfield\n```C++\nstruct S1 {\nint b1 : 10; // range [0, 1023]\nint b2 : 10; // range [0, 1023]\nint b3 : 8; // range [0, 255]\n}; // sizeof(S1): 4 bytes\nstruct S2 {\nint b1 : 10;\nint : 0; // reset: force the next field\nint b2 : 10; // to start at bit 32\n}; // sizeof(S1): 8 bytes\n```\n\n## type_info\n```C++\nstruct A {\nvirtual void f() {}\n};\nstruct B : A {};\nA a;\nB b;\nA& a1 = b; // implicit upcasting\ncout << typeid(a).name(); // print \"1A\"\ncout << typeid(b).name(); // print \"1B\"\ncout << typeid(a1).name(); // print \"1B\"\n```\n## 未定义行为\n### Pointer\n- Dereferencing a NULL pointer\n- Dereferencing a pointer returned by a \"new\" allocation of size zero\n- Using pointers to objects whose lifetime has ended (for instance, stack allocated objects or deleted objects)\n- Dereferencing a pointer that has not yet been definitely initialized\n- Performing pointer arithmetic that yields a result outside the boundaries (either above or below) of an array.\n- Dereferencing the pointer at a location beyond the end of an array.\n- Converting pointers to objects of incompatible types\n- Using memcpy to copy overlapping buffers.\n### buffer overflows\n- Reading or writing to an object or array at an offset that is negative, or beyond the size of that object (stack/heap overflow)\n### Integer Overflows\n- Signed integer overflow\n- Evaluating an expression that is not mathematically defined\n- Left-shifting values by a negative amount (right shifts by negative amounts are implementation defined)\n- Shifting values by an amount greater than or equal to the number of bits in the number (e.g. int64_t i = 1; i <<= 72 is undefined)\n### Types, Cast and Const\n- Casting a numeric value into a value that can't be represented by the target type (either directly or via static_cast)\n- Using an automatic variable before it has been definitely assigned (e.g., int i; i++; cout << i;)\n- Using the value of any object of type other than volatile or sig_atomic_t at the receipt of a signal\n- Attempting to modify a string literal or any other const object during its lifetime\n- Concatenating a narrow with a wide string literal during preprocessing\n### Function and Template\n- Not returning a value from a value-returning function (directly or by flowing off from a try-block)\n- Multiple different definitions for the same entity (class, template, enumeration, inline function, static member function, etc.)\n- Infinite recursion in the instantiation of templates\n- Calling a function using different parameters or linkage to the parameters and linkage that the function is defined as using.\n### OOP\n- Cascading destructions of objects with static storage duration\n- The result of assigning to partially overlapping objects\n- Recursively re-entering a function during the initialization of its static objects\n- Making virtual function calls to pure virtual functions of an object from its constructor or destructor\n- Referring to nonstatic members of objects that have not been constructed or have already been destructed\n### Source file and Preprocessing\n- A non-empty source file that doesn't end with a newline, or ends with a backslash (prior to C++11)\n- A backslash followed by a character that is not part of the specified escape codes in a character or string constant (this is implementation-defined in C++11).\n- Exceeding implementation limits (number of nested blocks, number of functions in a program, available stack space ...)\n- Preprocessor numeric values that can't be represented by a long int\n- Preprocessing directive on the left side of a function-like macro definition\n- Dynamically generating the defined token in a #if expression\n### to be classified\n- Calling exit during the destruction of a program with static storage duration\n## c_str2num\n高性能转换\n```C++\ntemplate<int N, unsigned MUL, int INDEX = 0>\nstruct fastStringToIntStr;\ninline unsigned fastStringToUnsigned(const char* str, int length) {\nswitch(length) {\ncase 10: return fastStringToIntStr<10, 1000000000>::aux(str);\ncase 9: return fastStringToIntStr< 9, 100000000>::aux(str);\ncase 8: return fastStringToIntStr< 8, 10000000>::aux(str);\ncase 7: return fastStringToIntStr< 7, 1000000>::aux(str);\ncase 6: return fastStringToIntStr< 6, 100000>::aux(str);\ncase 5: return fastStringToIntStr< 5, 10000>::aux(str);\ncase 4: return fastStringToIntStr< 4, 1000>::aux(str);\ncase 3: return fastStringToIntStr< 3, 100>::aux(str);\ncase 2: return fastStringToIntStr< 2, 10>::aux(str);\ncase 1: return fastStringToIntStr< 1, 1>::aux(str);\ndefault: return 0;\n}\n}\ntemplate<int N, unsigned MUL, int INDEX>\nstruct fastStringToIntStr {\nstatic inline unsigned aux(const char* str) {\nreturn static_cast<unsigned>(str[INDEX] - '0') * MUL +\nfastStringToIntStr<N - 1, MUL / 10, INDEX + 1>::aux(str);\n}\n};\ntemplate<unsigned MUL, int INDEX>\nstruct fastStringToIntStr<1, MUL, INDEX> {\nstatic inline unsigned aux(const char* str) {\nreturn static_cast<unsigned>(str[INDEX] - '0');\n}\n};\n```\n## 删除vector某个元素\n```\nswap(v[3], v[v.size()-1]);\nv.pop_back();\n```\n## 批量删除vector元素\n以下方法都是类似于把元素移到末尾，然后统一删除\n- 删除所有值为42的：`v.erase(remove(v.begin(), v.end(), 42), v.end());`\n- 删除所有值大于0的:\n```C++\nvector<int> v;\nv.erase(remove_if(v.begin(), v.end(), [](int x) {\n    return x > 0;\n}), v.end());\n```\n- c++20\n```C++\nvector<int> v;\nerase(v, 42);       // 删除所有值为 42 的元素\nerase_if(v, [](int x) {\n    return x > 0;   // 删除所有值大于 0 的元素\n});\n```\n## 维护有序的vector\n`s.insert(lower_bound(s.begin(),s.end(),3), 3)`\n","slug":"C-小知识","published":1,"updated":"2024-08-07T19:52:41.399Z","_id":"clq1yvi6s0004gwq2b0ingkra","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"指针与应用\"><a href=\"#指针与应用\" class=\"headerlink\" title=\"指针与应用\"></a>指针与应用</h2><p>.初始化要求不同，引用创建的同时必须初始化，而指针不必，可以重新赋值。<br>.可修改性不同，引用一旦被初始化，就不可更改，而指针可以指向另一个变量<br>.不存在NULL引用，指针可以，指针更灵活，但风险也大<br>.指针是一个实体，引用是一个别名<br>.内存上，指针有分配的存储空间，而应用则不用</p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ul>\n<li>c++无符号右移高位都补0</li>\n<li><code>auto dp = vector&lt;vector&lt;int&gt;&gt;(length, vector&lt;int&gt;(length));</code>可以这样声明数组</li>\n<li>八进制整型常量以”0”开头如:0123</li>\n<li>十六进制以”0x(X)”开头</li>\n<li>长整型以”L(l)”结尾</li>\n<li>无符号型以”U(u)”结尾</li>\n<li>默认数据类型为int型,默认实型为double型,若要表示float型在结尾加”F(f)”</li>\n<li>register+类型+变量名,存放在寄存器,加快调用</li>\n</ul>\n<h2 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h2><p>格式:<code>[capture list] (parameter list) -&gt; return type &#123;function body&#125;</code>,capture list可以为空，里面一般是包含此lambda的函数的(非static)局部变量,该函数外的变量可以在函数体内直接用,return type可以省略。</p>\n<h2 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h2><h3 id=\"使用初始化列表比较大小\"><a href=\"#使用初始化列表比较大小\" class=\"headerlink\" title=\"使用初始化列表比较大小\"></a>使用初始化列表比较大小</h3><p><strong>差：</strong><code>small = min(x,min(y,z));</code><br><strong>好：</strong><code>small = min(&#123;x,y,z,k&#125;);</code></p>\n<h3 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">pair&lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; cur = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>&#125;;<br><span class=\"hljs-keyword\">auto</span> [x,y] = cur;<br></code></pre></td></tr></table></figure>\n<h3 id=\"debug宏\"><a href=\"#debug宏\" class=\"headerlink\" title=\"debug宏\"></a>debug宏</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#definde deb(x) cout&lt;&lt; #x &lt;&lt; <span class=\"hljs-string\">&quot; = &quot;</span> &lt;&lt; x</span><br><span class=\"hljs-type\">int</span> ten = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-built_in\">deb</span>(ten); <span class=\"hljs-comment\">//prints &quot;ten = 10&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"支持多参数的debug宏\"><a href=\"#支持多参数的debug宏\" class=\"headerlink\" title=\"支持多参数的debug宏\"></a>支持多参数的debug宏</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> deb(...) logger(#__VA_ARGS__, __VA_ARGS__)</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> ...Args&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">logger</span><span class=\"hljs-params\">(string vars, Args&amp;&amp;... values)</span> </span>&#123;<br>    cout &lt;&lt; vars &lt;&lt; <span class=\"hljs-string\">&quot; = &quot;</span>;<br>    string delim = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    (..., (cout &lt;&lt; delim &lt;&lt; values, delim = <span class=\"hljs-string\">&quot;, &quot;</span>));<br>&#125;<br><br><span class=\"hljs-type\">int</span> xx = <span class=\"hljs-number\">3</span>, yy = <span class=\"hljs-number\">10</span>, xxyy = <span class=\"hljs-number\">103</span>;<br><span class=\"hljs-built_in\">deb</span>(xx); <span class=\"hljs-comment\">// prints &quot;xx = 3&quot;</span><br><span class=\"hljs-built_in\">deb</span>(xx, yy, xxyy); <span class=\"hljs-comment\">// prints &quot;xx, yy, xxyy = 3, 10, 103&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"读写容器和多变量\"><a href=\"#读写容器和多变量\" class=\"headerlink\" title=\"读写容器和多变量\"></a>读写容器和多变量</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span>... T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(T &amp;...args)</span> </span>&#123;<br>    ((cin &gt;&gt; args), ...);<br>&#125;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span>... T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">write</span><span class=\"hljs-params\">(string delimiter, T &amp;&amp;...args)</span> </span>&#123;<br>    ((cout &lt;&lt; args &lt;&lt; delimiter), ...);<br>&#125;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">readContainer</span><span class=\"hljs-params\">(T &amp;t)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;e : t) &#123;<br>        <span class=\"hljs-built_in\">read</span>(e);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">writeContainer</span><span class=\"hljs-params\">(string delimiter, T &amp;t)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;e : t) &#123;<br>        <span class=\"hljs-built_in\">write</span>(delimiter, e);<br>    &#125;<br>    <span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>&#125;<br><span class=\"hljs-comment\">// Question: read three space seprated integers and print them in different lines.</span><br>\t<span class=\"hljs-type\">int</span> x, y, z;<br>\t<span class=\"hljs-built_in\">read</span>(x, y, z);<br>\t<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>, x, y, z);<br><br><span class=\"hljs-comment\">// even works with variable data types :)</span><br>\t<span class=\"hljs-type\">int</span> n;<br>\tstring s;<br>\t<span class=\"hljs-built_in\">read</span>(n, s);<br>\t<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot; &quot;</span>, s, <span class=\"hljs-string\">&quot;has length&quot;</span>, n, <span class=\"hljs-string\">&quot;\\n&quot;</span>);<br><br><span class=\"hljs-comment\">// Question: read an array of `N` integers and print it to the output console.</span><br>\t<span class=\"hljs-type\">int</span> N;<br>\t<span class=\"hljs-built_in\">read</span>(N);<br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(N)</span></span>;<br>\t<span class=\"hljs-built_in\">readContainer</span>(arr);<br>\t<span class=\"hljs-built_in\">writeContainer</span>(<span class=\"hljs-string\">&quot; &quot;</span>, arr); <span class=\"hljs-comment\">// output: arr[0] arr[1] arr[2] ... arr[N - 1]</span><br>\t<span class=\"hljs-built_in\">writeContainer</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>, arr);<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* output:</span><br><span class=\"hljs-comment\">\t* arr[0]</span><br><span class=\"hljs-comment\">\t* arr[1]</span><br><span class=\"hljs-comment\">\t* arr[2]</span><br><span class=\"hljs-comment\">\t* ...</span><br><span class=\"hljs-comment\">\t* ...</span><br><span class=\"hljs-comment\">\t* ...</span><br><span class=\"hljs-comment\">\t* arr[N - 1]</span><br><span class=\"hljs-comment\">\t*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"debug函数\"><a href=\"#debug函数\" class=\"headerlink\" title=\"debug函数\"></a>debug函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> ...T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printer</span><span class=\"hljs-params\">(T&amp;&amp;... args)</span> </span>&#123;<br>    ((cout &lt;&lt; args &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>), ...);<br>&#125;<br><br><span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">25</span>;<br>string name = <span class=\"hljs-string\">&quot;Rachit&quot;</span>;<br><span class=\"hljs-built_in\">printer</span>(<span class=\"hljs-string\">&quot;I am&quot;</span>, name, <span class=\"hljs-string\">&#x27;,&#x27;</span>, age, <span class=\"hljs-string\">&quot;years old&quot;</span>);<br><span class=\"hljs-comment\">// ^ This prints the following</span><br><span class=\"hljs-comment\">// I am Rachit, 25 years old</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> F&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">debug_func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> F&amp; func)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> [func](<span class=\"hljs-keyword\">auto</span> &amp;&amp;...args) &#123; <span class=\"hljs-comment\">// forward reference</span><br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;input = &quot;</span>;<br>        <span class=\"hljs-built_in\">printer</span>(args...);<br>        <span class=\"hljs-keyword\">auto</span> res = <span class=\"hljs-built_in\">func</span>(forward&lt;<span class=\"hljs-keyword\">decltype</span>(args)&gt;(args)...);<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;res = &quot;</span> &lt;&lt; res &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-built_in\">debug_func</span>(pow)(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><span class=\"hljs-comment\">// ^ this automatically prints</span><br><span class=\"hljs-comment\">// input = 2 3 res = 8</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"默认构造\"><a href=\"#默认构造\" class=\"headerlink\" title=\"默认构造\"></a>默认构造</h3><p>默认第一个类型的构造函数，第一个类型必须有构造函数，可以用monostate来作第一个参数，类似空指针</p>\n<h2 id=\"span-c-20\"><a href=\"#span-c-20\" class=\"headerlink\" title=\"span(c++20)\"></a>span(c++20)</h2><p>span(std::string_view类似)是对数组的引用，可以对C风格的数组引用，可以使用vector的部分风格，例如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">read</span><span class=\"hljs-params\">(span&lt;<span class=\"hljs-type\">int</span>&gt; r)</span> <span class=\"hljs-comment\">// read into the range of integers r</span><br>&#123;<br>    <span class=\"hljs-built_in\">cout</span>&lt;&lt;r.size()&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<span class=\"hljs-comment\">//100</span><br>&#125;<br><br><span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">100</span>];<br>read(a);        <span class=\"hljs-comment\">// better: let the compiler figure out the number of elements</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"string-view和span\"><a href=\"#string-view和span\" class=\"headerlink\" title=\"string_view和span\"></a>string_view和span<char></h2><p>string_view只读，span<char>可变</p>\n<h2 id=\"maybe-unused\"><a href=\"#maybe-unused\" class=\"headerlink\" title=\"[[maybe_unused]]\"></a>[[maybe_unused]]</h2><p>可以使用该attribute，声明条件用到的参数<br><code>Value* find(const set&lt;Value&gt;&amp; s, const Value&amp; v, [[maybe_unused]] Hint hint)</code><br><code>[[maybe_unused]] int x = value</code></p>\n<h2 id=\"zstring或not-null来表明C字符串\"><a href=\"#zstring或not-null来表明C字符串\" class=\"headerlink\" title=\"zstring或not_null来表明C字符串\"></a>zstring或not_null<zstring>来表明C字符串</h2><p><code>int length(const char* p)</code>&#x3D;&gt;<code>int length(zstring p)</code><br><code>int length(not_null&lt;zstring&gt;)</code></p>\n<h2 id=\"不变参数用模板\"><a href=\"#不变参数用模板\" class=\"headerlink\" title=\"不变参数用模板\"></a>不变参数用模板</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">sum</span><span class=\"hljs-params\">(...)</span><br>&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-comment\">/*...*/</span>)<br>        result += va_arg(<span class=\"hljs-built_in\">list</span>, <span class=\"hljs-type\">int</span>); <span class=\"hljs-comment\">// BAD, assumes it will be passed ints</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br>sum(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ok</span><br>sum(<span class=\"hljs-number\">3.14159</span>, <span class=\"hljs-number\">2.71828</span>); <span class=\"hljs-comment\">// BAD, undefined</span><br><br>template&lt;class ...Args&gt;<br><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title function_\">sum</span><span class=\"hljs-params\">(Args... args)</span> <span class=\"hljs-comment\">// GOOD, and much more flexible</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> (... + args); <span class=\"hljs-comment\">// note: C++17 &quot;fold expression&quot;</span><br>&#125;<br><br>sum(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ok: 5</span><br>sum(<span class=\"hljs-number\">3.14159</span>, <span class=\"hljs-number\">2.71828</span>); <span class=\"hljs-comment\">// ok: ~5.85987</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"原始指针只表示内存地址，owner表示所有权\"><a href=\"#原始指针只表示内存地址，owner表示所有权\" class=\"headerlink\" title=\"原始指针只表示内存地址，owner表示所有权\"></a>原始指针只表示内存地址，owner表示所有权</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">X2</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    owner&lt;T*&gt; p;  <span class=\"hljs-comment\">// OK: p is owning</span><br>    T* q;         <span class=\"hljs-comment\">// OK: q is not owning</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"C和C-互相调用\"><a href=\"#C和C-互相调用\" class=\"headerlink\" title=\"C和C++互相调用\"></a>C和C++互相调用</h2><ul>\n<li>从C++调用C:<ul>\n<li>in C:<br>  double sqrt(double);</li>\n<li>in C++:<br>  extern “C” double sqrt(double);<br>  sqrt(2);</li>\n</ul>\n</li>\n<li>从C调用C++:<ul>\n<li>in C:<br>  X call_f(struct Y*, int);</li>\n<li>in C++:<br>  extern “C” X call_f(Y* p, int i)<br>  {<br>  return p-&gt;f(i);   &#x2F;&#x2F; possibly a virtual function call<br>  }</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"c-23的print\"><a href=\"#c-23的print\" class=\"headerlink\" title=\"c++23的print\"></a>c++23的print</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;print&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello World! &#123;&#125;, &#123;&#125;, &#123;&#125;\\n&quot;</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4ll</span>, <span class=\"hljs-string\">&quot;aa&quot;</span>);<br>    <span class=\"hljs-comment\">// print &quot;Hello World! 3 4 aa&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"c-20的\"><a href=\"#c-20的\" class=\"headerlink\" title=\"c++20的&lt;=&gt;\"></a>c++20的<code>&lt;=&gt;</code></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">(<span class=\"hljs-number\">3</span> &lt;=&gt; <span class=\"hljs-number\">5</span>) == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// false</span><br>(<span class=\"hljs-string\">&#x27;a&#x27;</span> &lt;=&gt; <span class=\"hljs-string\">&#x27;a&#x27;</span>) == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span><br>(<span class=\"hljs-number\">3</span> &lt;=&gt; <span class=\"hljs-number\">5</span>) &lt; <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span><br>(<span class=\"hljs-number\">7</span> &lt;=&gt; <span class=\"hljs-number\">5</span>) &lt; <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<p>强大的default</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;compare&gt;</span></span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Obj</span> &#123;<br><span class=\"hljs-type\">int</span> x;<br><span class=\"hljs-type\">char</span> y;<br><span class=\"hljs-type\">short</span> z[<span class=\"hljs-number\">2</span>];<br><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">operator</span>&lt;=&gt;(<span class=\"hljs-type\">const</span> Obj&amp;) <span class=\"hljs-type\">const</span> = <span class=\"hljs-keyword\">default</span>;<br><span class=\"hljs-comment\">// if x == other.x, then compare y</span><br><span class=\"hljs-comment\">// if y == other.y, then compare z</span><br><span class=\"hljs-comment\">// if z[0] == other.z[0], then compare z[1]</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"c-20的有符号与无符号的比较\"><a href=\"#c-20的有符号与无符号的比较\" class=\"headerlink\" title=\"c++20的有符号与无符号的比较\"></a>c++20的有符号与无符号的比较</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_not_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_less</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_greater</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_less_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_greater_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> a </span>= <span class=\"hljs-number\">4</span>;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">-3</span>;<br><span class=\"hljs-type\">bool</span> v1 = (a &gt; b); <span class=\"hljs-comment\">// false!!!, see next slides</span><br><span class=\"hljs-type\">bool</span> v2 = std::<span class=\"hljs-built_in\">cmp_greater</span>(a, b); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"C-17-enum-class支持attributes\"><a href=\"#C-17-enum-class支持attributes\" class=\"headerlink\" title=\"C++17 enum class支持attributes\"></a>C++17 enum class支持attributes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">enum class</span> <span class=\"hljs-title class_\">Color</span> &#123; RED, GREEN, BLUE [[deprecated]] &#125;;<br><span class=\"hljs-keyword\">auto</span> x = Color::BLUE; <span class=\"hljs-comment\">// compiler warning</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数属性\"><a href=\"#函数属性\" class=\"headerlink\" title=\"函数属性\"></a>函数属性</h2><table>\n<thead>\n<tr>\n<th align=\"center\">关键字</th>\n<th align=\"center\">最低标准</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>[[noreturn]]</code></td>\n<td align=\"center\">c++11</td>\n<td align=\"center\">表示函数不返回</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[deprecated]],[[deprecated(&quot;reason&quot;)]]</code></td>\n<td align=\"center\">c++14</td>\n<td align=\"center\">表示将会弃用函数，产生编译告警</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[nodiscard]]</code></td>\n<td align=\"center\">c++17</td>\n<td align=\"center\">见下</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[nodiscard(&quot;reason&quot;)]]</code></td>\n<td align=\"center\">c++20</td>\n<td align=\"center\">如果返回值没被使用，会产生告警</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[maybe_unused]]</code></td>\n<td align=\"center\">c++17</td>\n<td align=\"center\">未使用的变量不产生告警</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">[[noreturn]] <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123; std::<span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>); &#125;<br>[[deprecated]] <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">my_rand</span><span class=\"hljs-params\">()</span> </span>&#123; ... &#125;<br>[[nodiscard]] <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; x)</span> </span>&#123;<br><span class=\"hljs-built_in\">update</span>(x);<br><span class=\"hljs-type\">bool</span> status = ...;<br><span class=\"hljs-keyword\">return</span> status;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h</span><span class=\"hljs-params\">([[maybe_unused]] x)</span> </span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> !defined(SKIP_COMPUTATION)</span><br>... use x ...<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><span class=\"hljs-comment\">//----------------------------------------------------------------------</span><br><span class=\"hljs-built_in\">my_rand</span>(); <span class=\"hljs-comment\">// WARNING &quot;deprecated&quot;</span><br><span class=\"hljs-built_in\">g</span>(y); <span class=\"hljs-comment\">// WARNING &quot;discard return value&quot;</span><br><span class=\"hljs-type\">int</span> z = <span class=\"hljs-built_in\">g</span>(); <span class=\"hljs-comment\">// no warning</span><br><span class=\"hljs-built_in\">h</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// no warning if SKIP_COMPUTATION is defined</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h2><h3 id=\"使用条件\"><a href=\"#使用条件\" class=\"headerlink\" title=\"使用条件\"></a>使用条件</h3><p>不建议使用宏，一般在以下情况使用宏</p>\n<ul>\n<li>条件编译： 不同架构、编译器等</li>\n<li>多语言混编</li>\n<li>复杂名字代替</li>\n</ul>\n<h3 id=\"内置宏\"><a href=\"#内置宏\" class=\"headerlink\" title=\"内置宏\"></a>内置宏</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p)</span> </span>&#123;<br>std::cout &lt;&lt; __FILE__ &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span> &lt;&lt; __LINE__; <span class=\"hljs-comment\">// print &#x27;source.cpp:4&#x27;</span><br>std::cout &lt;&lt; __FUNCTION__; <span class=\"hljs-comment\">// print &#x27;f&#x27;</span><br>std::cout &lt;&lt; __func__; <span class=\"hljs-comment\">// print &#x27;f&#x27;</span><br>&#125;<br><span class=\"hljs-comment\">// see template lectures</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(T p)</span> </span>&#123;<br>std::cout &lt;&lt; __PRETTY_FUNCTION__; <span class=\"hljs-comment\">// print &#x27;float g(T) [T = int]&#x27;</span><br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0f</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g1</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-built_in\">g</span>(<span class=\"hljs-number\">3</span>); &#125;<br></code></pre></td></tr></table></figure>\n<p>C++20在<source_location>提供了函数方法来代替这些宏。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;source_location&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(std::source_location s = std::source_location::current())</span> </span>&#123;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;function: &quot;</span> &lt;&lt; s.<span class=\"hljs-built_in\">function_name</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, line &quot;</span> &lt;&lt; s.<span class=\"hljs-built_in\">line</span>();<br>&#125; <span class=\"hljs-comment\">// column(),file_name() also support</span><br><span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">// print: &quot;function: f, line 6&quot;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>__DATE__</code>:输出编译的开始日期以’mmm dd yyyy’格式</li>\n<li><code>__TIME__</code>:输出编译的开始时间</li>\n</ul>\n<h3 id=\"常见的条件编译\"><a href=\"#常见的条件编译\" class=\"headerlink\" title=\"常见的条件编译\"></a>常见的条件编译</h3><p>可见网址<img src=\"https://sourceforge.net/p/predef/wiki/Home/\"><br>可见网址<img src=\"https://abseil.io/docs/cpp/platforms/macros\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">语法</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>#if defined( cplusplus)</code></td>\n<td align=\"center\">C++ code</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 199711L</code></td>\n<td align=\"center\">ISO C++ 1998&#x2F;2003,仅限于linux,MSVC的2011和2014也是该值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 201103L</code></td>\n<td align=\"center\">ISO C++ 2011,仅限于linux</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 201402L</code></td>\n<td align=\"center\">ISO C++ 2014,仅限于linux</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 201703L</code></td>\n<td align=\"center\">ISO C++ 2017</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( GNUG )</code></td>\n<td align=\"center\">The compiler is gcc&#x2F;g++</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( clang )</code></td>\n<td align=\"center\">The compiler is clang&#x2F;clang++</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( MSC VER)</code></td>\n<td align=\"center\">The compiler is Microsoft Visual C++</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( WIN64)</code></td>\n<td align=\"center\">OS is Windows 64-bit</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( linux )</code></td>\n<td align=\"center\">OS is Linux</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( APPLE )</code></td>\n<td align=\"center\">OS is Mac OS</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( MINGW32 )</code></td>\n<td align=\"center\">OS is MinGW 32-bit</td>\n</tr>\n</tbody></table>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><code>#</code>:等价于加个双引号<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> STRING_MACRO(string) #string</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">STRING_MACRO</span>(hello); <span class=\"hljs-comment\">// equivalent to &quot;hello&quot;</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> INFO_MACRO(my_func) \\</span><br><span class=\"hljs-meta\">&#123; \\</span><br><span class=\"hljs-meta\">my_func \\</span><br><span class=\"hljs-meta\">cout &lt;&lt; <span class=\"hljs-string\">&quot;call &quot;</span> &lt;&lt; #my_func &lt;&lt; <span class=\"hljs-string\">&quot; at &quot;</span> \\</span><br><span class=\"hljs-meta\">&lt;&lt; __FILE__ &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span> __LINE__; \\</span><br><span class=\"hljs-meta\">&#125;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span> </span>&#123;&#125;<br><span class=\"hljs-built_in\">INFO_MACRO</span>( <span class=\"hljs-built_in\">g</span>(<span class=\"hljs-number\">3</span>) ) <span class=\"hljs-comment\">// print: &quot;call g(3) at my_file.cpp:7&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><code>#error &quot;text&quot;</code>:编译器遇到时会输出error</li>\n<li><code>#warning &quot;text&quot;</code>:编译器遇到时会输出warning</li>\n<li><code>##</code>：连接字符串<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> FUNC_GEN_A(tokenA, tokenB) \\</span><br><span class=\"hljs-meta\">void tokenA##tokenB() &#123;&#125;</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> FUNC_GEN_B(tokenA, tokenB) \\</span><br><span class=\"hljs-meta\">void tokenA##_##tokenB() &#123;&#125;</span><br><span class=\"hljs-built_in\">FUNC_GEN_A</span>(my, function)<br><span class=\"hljs-built_in\">FUNC_GEN_B</span>(my, function)<br><span class=\"hljs-built_in\">myfunction</span>(); <span class=\"hljs-comment\">// ok, from FUNC_GEN_A</span><br><span class=\"hljs-built_in\">my_function</span>(); <span class=\"hljs-comment\">// ok, from FUNC_GEN_B</span><br></code></pre></td></tr></table></figure></li>\n<li><code>__VA_ARGS__</code>:多参数宏<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span> </span>&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, a); &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d&quot;</span>, a, b); &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c)</span> </span>&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d %d&quot;</span>, a, b, c); &#125;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> PRINT(...) \\</span><br><span class=\"hljs-meta\">f( VA ARGS );</span><br><span class=\"hljs-built_in\">PRINT</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)<br><span class=\"hljs-built_in\">PRINT</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) <br></code></pre></td></tr></table></figure></li>\n<li><code>#if __has_include(&lt;iostream&gt;)</code>：c++17判断是否存在头文件<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">if</span> __has_include(<span class=\"hljs-string\">&lt;iostream&gt;</span>)</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure></li>\n<li><code>#if __cpp_constexpr</code>:C++20引入，判断编译器是否支持某特性，还有许多其它的宏<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">if</span> __cpp_constexpr</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">square</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> x * x; &#125;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure></li>\n<li><code>#pragma</code>:调用某个指令，依赖于编译器</li>\n</ul>\n<h3 id=\"技巧-1\"><a href=\"#技巧-1\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><p><strong>数字转字符串</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> TO_LITERAL_AUX(x) #x</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> TO_LITERAL(x) TO_LITERAL_AUX(x)</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-type\">int</span> x1 = <span class=\"hljs-number\">3</span> * <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> y1 = __LINE__ + <span class=\"hljs-number\">4</span>;<br><span class=\"hljs-type\">char</span> x2[] = <span class=\"hljs-built_in\">TO_LITERAL</span>(<span class=\"hljs-number\">3</span>);<br><span class=\"hljs-type\">char</span> y2[] = <span class=\"hljs-built_in\">TO_LITERAL</span>(__LINE__);<span class=\"hljs-comment\">//这里你知道为啥包一层了把，有些并不是无意义的包</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Bitfield\"><a href=\"#Bitfield\" class=\"headerlink\" title=\"Bitfield\"></a>Bitfield</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S1</span> &#123;<br><span class=\"hljs-type\">int</span> b1 : <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// range [0, 1023]</span><br><span class=\"hljs-type\">int</span> b2 : <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// range [0, 1023]</span><br><span class=\"hljs-type\">int</span> b3 : <span class=\"hljs-number\">8</span>; <span class=\"hljs-comment\">// range [0, 255]</span><br>&#125;; <span class=\"hljs-comment\">// sizeof(S1): 4 bytes</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S2</span> &#123;<br><span class=\"hljs-type\">int</span> b1 : <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> : <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// reset: force the next field</span><br><span class=\"hljs-type\">int</span> b2 : <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// to start at bit 32</span><br>&#125;; <span class=\"hljs-comment\">// sizeof(S1): 8 bytes</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"type-info\"><a href=\"#type-info\" class=\"headerlink\" title=\"type_info\"></a>type_info</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">B</span> : A &#123;&#125;;<br>A a;<br>B b;<br>A&amp; a1 = b; <span class=\"hljs-comment\">// implicit upcasting</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(a).<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &quot;1A&quot;</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(b).<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &quot;1B&quot;</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(a1).<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &quot;1B&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"未定义行为\"><a href=\"#未定义行为\" class=\"headerlink\" title=\"未定义行为\"></a>未定义行为</h2><h3 id=\"Pointer\"><a href=\"#Pointer\" class=\"headerlink\" title=\"Pointer\"></a>Pointer</h3><ul>\n<li>Dereferencing a NULL pointer</li>\n<li>Dereferencing a pointer returned by a “new” allocation of size zero</li>\n<li>Using pointers to objects whose lifetime has ended (for instance, stack allocated objects or deleted objects)</li>\n<li>Dereferencing a pointer that has not yet been definitely initialized</li>\n<li>Performing pointer arithmetic that yields a result outside the boundaries (either above or below) of an array.</li>\n<li>Dereferencing the pointer at a location beyond the end of an array.</li>\n<li>Converting pointers to objects of incompatible types</li>\n<li>Using memcpy to copy overlapping buffers.</li>\n</ul>\n<h3 id=\"buffer-overflows\"><a href=\"#buffer-overflows\" class=\"headerlink\" title=\"buffer overflows\"></a>buffer overflows</h3><ul>\n<li>Reading or writing to an object or array at an offset that is negative, or beyond the size of that object (stack&#x2F;heap overflow)</li>\n</ul>\n<h3 id=\"Integer-Overflows\"><a href=\"#Integer-Overflows\" class=\"headerlink\" title=\"Integer Overflows\"></a>Integer Overflows</h3><ul>\n<li>Signed integer overflow</li>\n<li>Evaluating an expression that is not mathematically defined</li>\n<li>Left-shifting values by a negative amount (right shifts by negative amounts are implementation defined)</li>\n<li>Shifting values by an amount greater than or equal to the number of bits in the number (e.g. int64_t i &#x3D; 1; i &lt;&lt;&#x3D; 72 is undefined)</li>\n</ul>\n<h3 id=\"Types-Cast-and-Const\"><a href=\"#Types-Cast-and-Const\" class=\"headerlink\" title=\"Types, Cast and Const\"></a>Types, Cast and Const</h3><ul>\n<li>Casting a numeric value into a value that can’t be represented by the target type (either directly or via static_cast)</li>\n<li>Using an automatic variable before it has been definitely assigned (e.g., int i; i++; cout &lt;&lt; i;)</li>\n<li>Using the value of any object of type other than volatile or sig_atomic_t at the receipt of a signal</li>\n<li>Attempting to modify a string literal or any other const object during its lifetime</li>\n<li>Concatenating a narrow with a wide string literal during preprocessing</li>\n</ul>\n<h3 id=\"Function-and-Template\"><a href=\"#Function-and-Template\" class=\"headerlink\" title=\"Function and Template\"></a>Function and Template</h3><ul>\n<li>Not returning a value from a value-returning function (directly or by flowing off from a try-block)</li>\n<li>Multiple different definitions for the same entity (class, template, enumeration, inline function, static member function, etc.)</li>\n<li>Infinite recursion in the instantiation of templates</li>\n<li>Calling a function using different parameters or linkage to the parameters and linkage that the function is defined as using.</li>\n</ul>\n<h3 id=\"OOP\"><a href=\"#OOP\" class=\"headerlink\" title=\"OOP\"></a>OOP</h3><ul>\n<li>Cascading destructions of objects with static storage duration</li>\n<li>The result of assigning to partially overlapping objects</li>\n<li>Recursively re-entering a function during the initialization of its static objects</li>\n<li>Making virtual function calls to pure virtual functions of an object from its constructor or destructor</li>\n<li>Referring to nonstatic members of objects that have not been constructed or have already been destructed</li>\n</ul>\n<h3 id=\"Source-file-and-Preprocessing\"><a href=\"#Source-file-and-Preprocessing\" class=\"headerlink\" title=\"Source file and Preprocessing\"></a>Source file and Preprocessing</h3><ul>\n<li>A non-empty source file that doesn’t end with a newline, or ends with a backslash (prior to C++11)</li>\n<li>A backslash followed by a character that is not part of the specified escape codes in a character or string constant (this is implementation-defined in C++11).</li>\n<li>Exceeding implementation limits (number of nested blocks, number of functions in a program, available stack space …)</li>\n<li>Preprocessor numeric values that can’t be represented by a long int</li>\n<li>Preprocessing directive on the left side of a function-like macro definition</li>\n<li>Dynamically generating the defined token in a #if expression</li>\n</ul>\n<h3 id=\"to-be-classified\"><a href=\"#to-be-classified\" class=\"headerlink\" title=\"to be classified\"></a>to be classified</h3><ul>\n<li>Calling exit during the destruction of a program with static storage duration</li>\n</ul>\n<h2 id=\"c-str2num\"><a href=\"#c-str2num\" class=\"headerlink\" title=\"c_str2num\"></a>c_str2num</h2><p>高性能转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">unsigned</span> MUL, <span class=\"hljs-type\">int</span> INDEX = <span class=\"hljs-number\">0</span>&gt;<br><span class=\"hljs-keyword\">struct</span> fastStringToIntStr;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-title\">fastStringToUnsigned</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str, <span class=\"hljs-type\">int</span> length)</span> </span>&#123;<br><span class=\"hljs-keyword\">switch</span>(length) &#123;<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">10</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1000000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">9</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">100000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">8</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">7</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">6</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">100000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">5</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">100</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">unsigned</span> MUL, <span class=\"hljs-type\">int</span> INDEX&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">fastStringToIntStr</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-title\">aux</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">unsigned</span>&gt;(str[INDEX] - <span class=\"hljs-string\">&#x27;0&#x27;</span>) * MUL +<br>fastStringToIntStr&lt;N - <span class=\"hljs-number\">1</span>, MUL / <span class=\"hljs-number\">10</span>, INDEX + <span class=\"hljs-number\">1</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br>&#125;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">unsigned</span> MUL, <span class=\"hljs-type\">int</span> INDEX&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">fastStringToIntStr</span>&lt;<span class=\"hljs-number\">1</span>, MUL, INDEX&gt; &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-title\">aux</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">unsigned</span>&gt;(str[INDEX] - <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"删除vector某个元素\"><a href=\"#删除vector某个元素\" class=\"headerlink\" title=\"删除vector某个元素\"></a>删除vector某个元素</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">swap</span>(v[<span class=\"hljs-number\">3</span>], v[v.size()-<span class=\"hljs-number\">1</span>]);<br>v<span class=\"hljs-selector-class\">.pop_back</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"批量删除vector元素\"><a href=\"#批量删除vector元素\" class=\"headerlink\" title=\"批量删除vector元素\"></a>批量删除vector元素</h2><p>以下方法都是类似于把元素移到末尾，然后统一删除</p>\n<ul>\n<li>删除所有值为42的：<code>v.erase(remove(v.begin(), v.end(), 42), v.end());</code></li>\n<li>删除所有值大于0的:<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">vector&lt;<span class=\"hljs-type\">int</span>&gt; v;<br>v.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-built_in\">remove_if</span>(v.<span class=\"hljs-built_in\">begin</span>(), v.<span class=\"hljs-built_in\">end</span>(), [](<span class=\"hljs-type\">int</span> x) &#123;<br>    <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span>;<br>&#125;), v.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></table></figure></li>\n<li>c++20<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">vector&lt;<span class=\"hljs-type\">int</span>&gt; v;<br><span class=\"hljs-built_in\">erase</span>(v, <span class=\"hljs-number\">42</span>);       <span class=\"hljs-comment\">// 删除所有值为 42 的元素</span><br><span class=\"hljs-built_in\">erase_if</span>(v, [](<span class=\"hljs-type\">int</span> x) &#123;<br>    <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span>;   <span class=\"hljs-comment\">// 删除所有值大于 0 的元素</span><br>&#125;);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"维护有序的vector\"><a href=\"#维护有序的vector\" class=\"headerlink\" title=\"维护有序的vector\"></a>维护有序的vector</h2><p><code>s.insert(lower_bound(s.begin(),s.end(),3), 3)</code></p>\n","excerpt":"","more":"<h2 id=\"指针与应用\"><a href=\"#指针与应用\" class=\"headerlink\" title=\"指针与应用\"></a>指针与应用</h2><p>.初始化要求不同，引用创建的同时必须初始化，而指针不必，可以重新赋值。<br>.可修改性不同，引用一旦被初始化，就不可更改，而指针可以指向另一个变量<br>.不存在NULL引用，指针可以，指针更灵活，但风险也大<br>.指针是一个实体，引用是一个别名<br>.内存上，指针有分配的存储空间，而应用则不用</p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ul>\n<li>c++无符号右移高位都补0</li>\n<li><code>auto dp = vector&lt;vector&lt;int&gt;&gt;(length, vector&lt;int&gt;(length));</code>可以这样声明数组</li>\n<li>八进制整型常量以”0”开头如:0123</li>\n<li>十六进制以”0x(X)”开头</li>\n<li>长整型以”L(l)”结尾</li>\n<li>无符号型以”U(u)”结尾</li>\n<li>默认数据类型为int型,默认实型为double型,若要表示float型在结尾加”F(f)”</li>\n<li>register+类型+变量名,存放在寄存器,加快调用</li>\n</ul>\n<h2 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h2><p>格式:<code>[capture list] (parameter list) -&gt; return type &#123;function body&#125;</code>,capture list可以为空，里面一般是包含此lambda的函数的(非static)局部变量,该函数外的变量可以在函数体内直接用,return type可以省略。</p>\n<h2 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h2><h3 id=\"使用初始化列表比较大小\"><a href=\"#使用初始化列表比较大小\" class=\"headerlink\" title=\"使用初始化列表比较大小\"></a>使用初始化列表比较大小</h3><p><strong>差：</strong><code>small = min(x,min(y,z));</code><br><strong>好：</strong><code>small = min(&#123;x,y,z,k&#125;);</code></p>\n<h3 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">pair&lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; cur = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>&#125;;<br><span class=\"hljs-keyword\">auto</span> [x,y] = cur;<br></code></pre></td></tr></table></figure>\n<h3 id=\"debug宏\"><a href=\"#debug宏\" class=\"headerlink\" title=\"debug宏\"></a>debug宏</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#definde deb(x) cout&lt;&lt; #x &lt;&lt; <span class=\"hljs-string\">&quot; = &quot;</span> &lt;&lt; x</span><br><span class=\"hljs-type\">int</span> ten = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-built_in\">deb</span>(ten); <span class=\"hljs-comment\">//prints &quot;ten = 10&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"支持多参数的debug宏\"><a href=\"#支持多参数的debug宏\" class=\"headerlink\" title=\"支持多参数的debug宏\"></a>支持多参数的debug宏</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> deb(...) logger(#__VA_ARGS__, __VA_ARGS__)</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> ...Args&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">logger</span><span class=\"hljs-params\">(string vars, Args&amp;&amp;... values)</span> </span>&#123;<br>    cout &lt;&lt; vars &lt;&lt; <span class=\"hljs-string\">&quot; = &quot;</span>;<br>    string delim = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    (..., (cout &lt;&lt; delim &lt;&lt; values, delim = <span class=\"hljs-string\">&quot;, &quot;</span>));<br>&#125;<br><br><span class=\"hljs-type\">int</span> xx = <span class=\"hljs-number\">3</span>, yy = <span class=\"hljs-number\">10</span>, xxyy = <span class=\"hljs-number\">103</span>;<br><span class=\"hljs-built_in\">deb</span>(xx); <span class=\"hljs-comment\">// prints &quot;xx = 3&quot;</span><br><span class=\"hljs-built_in\">deb</span>(xx, yy, xxyy); <span class=\"hljs-comment\">// prints &quot;xx, yy, xxyy = 3, 10, 103&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"读写容器和多变量\"><a href=\"#读写容器和多变量\" class=\"headerlink\" title=\"读写容器和多变量\"></a>读写容器和多变量</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span>... T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(T &amp;...args)</span> </span>&#123;<br>    ((cin &gt;&gt; args), ...);<br>&#125;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span>... T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">write</span><span class=\"hljs-params\">(string delimiter, T &amp;&amp;...args)</span> </span>&#123;<br>    ((cout &lt;&lt; args &lt;&lt; delimiter), ...);<br>&#125;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">readContainer</span><span class=\"hljs-params\">(T &amp;t)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;e : t) &#123;<br>        <span class=\"hljs-built_in\">read</span>(e);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">writeContainer</span><span class=\"hljs-params\">(string delimiter, T &amp;t)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;e : t) &#123;<br>        <span class=\"hljs-built_in\">write</span>(delimiter, e);<br>    &#125;<br>    <span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>&#125;<br><span class=\"hljs-comment\">// Question: read three space seprated integers and print them in different lines.</span><br>\t<span class=\"hljs-type\">int</span> x, y, z;<br>\t<span class=\"hljs-built_in\">read</span>(x, y, z);<br>\t<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>, x, y, z);<br><br><span class=\"hljs-comment\">// even works with variable data types :)</span><br>\t<span class=\"hljs-type\">int</span> n;<br>\tstring s;<br>\t<span class=\"hljs-built_in\">read</span>(n, s);<br>\t<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot; &quot;</span>, s, <span class=\"hljs-string\">&quot;has length&quot;</span>, n, <span class=\"hljs-string\">&quot;\\n&quot;</span>);<br><br><span class=\"hljs-comment\">// Question: read an array of `N` integers and print it to the output console.</span><br>\t<span class=\"hljs-type\">int</span> N;<br>\t<span class=\"hljs-built_in\">read</span>(N);<br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(N)</span></span>;<br>\t<span class=\"hljs-built_in\">readContainer</span>(arr);<br>\t<span class=\"hljs-built_in\">writeContainer</span>(<span class=\"hljs-string\">&quot; &quot;</span>, arr); <span class=\"hljs-comment\">// output: arr[0] arr[1] arr[2] ... arr[N - 1]</span><br>\t<span class=\"hljs-built_in\">writeContainer</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>, arr);<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* output:</span><br><span class=\"hljs-comment\">\t* arr[0]</span><br><span class=\"hljs-comment\">\t* arr[1]</span><br><span class=\"hljs-comment\">\t* arr[2]</span><br><span class=\"hljs-comment\">\t* ...</span><br><span class=\"hljs-comment\">\t* ...</span><br><span class=\"hljs-comment\">\t* ...</span><br><span class=\"hljs-comment\">\t* arr[N - 1]</span><br><span class=\"hljs-comment\">\t*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"debug函数\"><a href=\"#debug函数\" class=\"headerlink\" title=\"debug函数\"></a>debug函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> ...T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printer</span><span class=\"hljs-params\">(T&amp;&amp;... args)</span> </span>&#123;<br>    ((cout &lt;&lt; args &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>), ...);<br>&#125;<br><br><span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">25</span>;<br>string name = <span class=\"hljs-string\">&quot;Rachit&quot;</span>;<br><span class=\"hljs-built_in\">printer</span>(<span class=\"hljs-string\">&quot;I am&quot;</span>, name, <span class=\"hljs-string\">&#x27;,&#x27;</span>, age, <span class=\"hljs-string\">&quot;years old&quot;</span>);<br><span class=\"hljs-comment\">// ^ This prints the following</span><br><span class=\"hljs-comment\">// I am Rachit, 25 years old</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> F&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">debug_func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> F&amp; func)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> [func](<span class=\"hljs-keyword\">auto</span> &amp;&amp;...args) &#123; <span class=\"hljs-comment\">// forward reference</span><br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;input = &quot;</span>;<br>        <span class=\"hljs-built_in\">printer</span>(args...);<br>        <span class=\"hljs-keyword\">auto</span> res = <span class=\"hljs-built_in\">func</span>(forward&lt;<span class=\"hljs-keyword\">decltype</span>(args)&gt;(args)...);<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;res = &quot;</span> &lt;&lt; res &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-built_in\">debug_func</span>(pow)(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><span class=\"hljs-comment\">// ^ this automatically prints</span><br><span class=\"hljs-comment\">// input = 2 3 res = 8</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"默认构造\"><a href=\"#默认构造\" class=\"headerlink\" title=\"默认构造\"></a>默认构造</h3><p>默认第一个类型的构造函数，第一个类型必须有构造函数，可以用monostate来作第一个参数，类似空指针</p>\n<h2 id=\"span-c-20\"><a href=\"#span-c-20\" class=\"headerlink\" title=\"span(c++20)\"></a>span(c++20)</h2><p>span(std::string_view类似)是对数组的引用，可以对C风格的数组引用，可以使用vector的部分风格，例如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">read</span><span class=\"hljs-params\">(span&lt;<span class=\"hljs-type\">int</span>&gt; r)</span> <span class=\"hljs-comment\">// read into the range of integers r</span><br>&#123;<br>    <span class=\"hljs-built_in\">cout</span>&lt;&lt;r.size()&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<span class=\"hljs-comment\">//100</span><br>&#125;<br><br><span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">100</span>];<br>read(a);        <span class=\"hljs-comment\">// better: let the compiler figure out the number of elements</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"string-view和span\"><a href=\"#string-view和span\" class=\"headerlink\" title=\"string_view和span\"></a>string_view和span<char></h2><p>string_view只读，span<char>可变</p>\n<h2 id=\"maybe-unused\"><a href=\"#maybe-unused\" class=\"headerlink\" title=\"[[maybe_unused]]\"></a>[[maybe_unused]]</h2><p>可以使用该attribute，声明条件用到的参数<br><code>Value* find(const set&lt;Value&gt;&amp; s, const Value&amp; v, [[maybe_unused]] Hint hint)</code><br><code>[[maybe_unused]] int x = value</code></p>\n<h2 id=\"zstring或not-null来表明C字符串\"><a href=\"#zstring或not-null来表明C字符串\" class=\"headerlink\" title=\"zstring或not_null来表明C字符串\"></a>zstring或not_null<zstring>来表明C字符串</h2><p><code>int length(const char* p)</code>&#x3D;&gt;<code>int length(zstring p)</code><br><code>int length(not_null&lt;zstring&gt;)</code></p>\n<h2 id=\"不变参数用模板\"><a href=\"#不变参数用模板\" class=\"headerlink\" title=\"不变参数用模板\"></a>不变参数用模板</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">sum</span><span class=\"hljs-params\">(...)</span><br>&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-comment\">/*...*/</span>)<br>        result += va_arg(<span class=\"hljs-built_in\">list</span>, <span class=\"hljs-type\">int</span>); <span class=\"hljs-comment\">// BAD, assumes it will be passed ints</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br>sum(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ok</span><br>sum(<span class=\"hljs-number\">3.14159</span>, <span class=\"hljs-number\">2.71828</span>); <span class=\"hljs-comment\">// BAD, undefined</span><br><br>template&lt;class ...Args&gt;<br><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title function_\">sum</span><span class=\"hljs-params\">(Args... args)</span> <span class=\"hljs-comment\">// GOOD, and much more flexible</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> (... + args); <span class=\"hljs-comment\">// note: C++17 &quot;fold expression&quot;</span><br>&#125;<br><br>sum(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ok: 5</span><br>sum(<span class=\"hljs-number\">3.14159</span>, <span class=\"hljs-number\">2.71828</span>); <span class=\"hljs-comment\">// ok: ~5.85987</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"原始指针只表示内存地址，owner表示所有权\"><a href=\"#原始指针只表示内存地址，owner表示所有权\" class=\"headerlink\" title=\"原始指针只表示内存地址，owner表示所有权\"></a>原始指针只表示内存地址，owner表示所有权</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">X2</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    owner&lt;T*&gt; p;  <span class=\"hljs-comment\">// OK: p is owning</span><br>    T* q;         <span class=\"hljs-comment\">// OK: q is not owning</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"C和C-互相调用\"><a href=\"#C和C-互相调用\" class=\"headerlink\" title=\"C和C++互相调用\"></a>C和C++互相调用</h2><ul>\n<li>从C++调用C:<ul>\n<li>in C:<br>  double sqrt(double);</li>\n<li>in C++:<br>  extern “C” double sqrt(double);<br>  sqrt(2);</li>\n</ul>\n</li>\n<li>从C调用C++:<ul>\n<li>in C:<br>  X call_f(struct Y*, int);</li>\n<li>in C++:<br>  extern “C” X call_f(Y* p, int i)<br>  {<br>  return p-&gt;f(i);   &#x2F;&#x2F; possibly a virtual function call<br>  }</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"c-23的print\"><a href=\"#c-23的print\" class=\"headerlink\" title=\"c++23的print\"></a>c++23的print</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;print&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello World! &#123;&#125;, &#123;&#125;, &#123;&#125;\\n&quot;</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4ll</span>, <span class=\"hljs-string\">&quot;aa&quot;</span>);<br>    <span class=\"hljs-comment\">// print &quot;Hello World! 3 4 aa&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"c-20的\"><a href=\"#c-20的\" class=\"headerlink\" title=\"c++20的&lt;=&gt;\"></a>c++20的<code>&lt;=&gt;</code></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">(<span class=\"hljs-number\">3</span> &lt;=&gt; <span class=\"hljs-number\">5</span>) == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// false</span><br>(<span class=\"hljs-string\">&#x27;a&#x27;</span> &lt;=&gt; <span class=\"hljs-string\">&#x27;a&#x27;</span>) == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span><br>(<span class=\"hljs-number\">3</span> &lt;=&gt; <span class=\"hljs-number\">5</span>) &lt; <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span><br>(<span class=\"hljs-number\">7</span> &lt;=&gt; <span class=\"hljs-number\">5</span>) &lt; <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<p>强大的default</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;compare&gt;</span></span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Obj</span> &#123;<br><span class=\"hljs-type\">int</span> x;<br><span class=\"hljs-type\">char</span> y;<br><span class=\"hljs-type\">short</span> z[<span class=\"hljs-number\">2</span>];<br><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">operator</span>&lt;=&gt;(<span class=\"hljs-type\">const</span> Obj&amp;) <span class=\"hljs-type\">const</span> = <span class=\"hljs-keyword\">default</span>;<br><span class=\"hljs-comment\">// if x == other.x, then compare y</span><br><span class=\"hljs-comment\">// if y == other.y, then compare z</span><br><span class=\"hljs-comment\">// if z[0] == other.z[0], then compare z[1]</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"c-20的有符号与无符号的比较\"><a href=\"#c-20的有符号与无符号的比较\" class=\"headerlink\" title=\"c++20的有符号与无符号的比较\"></a>c++20的有符号与无符号的比较</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_not_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_less</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_greater</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_less_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp_greater_equal</span><span class=\"hljs-params\">(T1 a, T2 b)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> a </span>= <span class=\"hljs-number\">4</span>;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">-3</span>;<br><span class=\"hljs-type\">bool</span> v1 = (a &gt; b); <span class=\"hljs-comment\">// false!!!, see next slides</span><br><span class=\"hljs-type\">bool</span> v2 = std::<span class=\"hljs-built_in\">cmp_greater</span>(a, b); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"C-17-enum-class支持attributes\"><a href=\"#C-17-enum-class支持attributes\" class=\"headerlink\" title=\"C++17 enum class支持attributes\"></a>C++17 enum class支持attributes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">enum class</span> <span class=\"hljs-title class_\">Color</span> &#123; RED, GREEN, BLUE [[deprecated]] &#125;;<br><span class=\"hljs-keyword\">auto</span> x = Color::BLUE; <span class=\"hljs-comment\">// compiler warning</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数属性\"><a href=\"#函数属性\" class=\"headerlink\" title=\"函数属性\"></a>函数属性</h2><table>\n<thead>\n<tr>\n<th align=\"center\">关键字</th>\n<th align=\"center\">最低标准</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>[[noreturn]]</code></td>\n<td align=\"center\">c++11</td>\n<td align=\"center\">表示函数不返回</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[deprecated]],[[deprecated(&quot;reason&quot;)]]</code></td>\n<td align=\"center\">c++14</td>\n<td align=\"center\">表示将会弃用函数，产生编译告警</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[nodiscard]]</code></td>\n<td align=\"center\">c++17</td>\n<td align=\"center\">见下</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[nodiscard(&quot;reason&quot;)]]</code></td>\n<td align=\"center\">c++20</td>\n<td align=\"center\">如果返回值没被使用，会产生告警</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[[maybe_unused]]</code></td>\n<td align=\"center\">c++17</td>\n<td align=\"center\">未使用的变量不产生告警</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">[[noreturn]] <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123; std::<span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>); &#125;<br>[[deprecated]] <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">my_rand</span><span class=\"hljs-params\">()</span> </span>&#123; ... &#125;<br>[[nodiscard]] <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; x)</span> </span>&#123;<br><span class=\"hljs-built_in\">update</span>(x);<br><span class=\"hljs-type\">bool</span> status = ...;<br><span class=\"hljs-keyword\">return</span> status;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h</span><span class=\"hljs-params\">([[maybe_unused]] x)</span> </span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> !defined(SKIP_COMPUTATION)</span><br>... use x ...<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><span class=\"hljs-comment\">//----------------------------------------------------------------------</span><br><span class=\"hljs-built_in\">my_rand</span>(); <span class=\"hljs-comment\">// WARNING &quot;deprecated&quot;</span><br><span class=\"hljs-built_in\">g</span>(y); <span class=\"hljs-comment\">// WARNING &quot;discard return value&quot;</span><br><span class=\"hljs-type\">int</span> z = <span class=\"hljs-built_in\">g</span>(); <span class=\"hljs-comment\">// no warning</span><br><span class=\"hljs-built_in\">h</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// no warning if SKIP_COMPUTATION is defined</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h2><h3 id=\"使用条件\"><a href=\"#使用条件\" class=\"headerlink\" title=\"使用条件\"></a>使用条件</h3><p>不建议使用宏，一般在以下情况使用宏</p>\n<ul>\n<li>条件编译： 不同架构、编译器等</li>\n<li>多语言混编</li>\n<li>复杂名字代替</li>\n</ul>\n<h3 id=\"内置宏\"><a href=\"#内置宏\" class=\"headerlink\" title=\"内置宏\"></a>内置宏</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p)</span> </span>&#123;<br>std::cout &lt;&lt; __FILE__ &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span> &lt;&lt; __LINE__; <span class=\"hljs-comment\">// print &#x27;source.cpp:4&#x27;</span><br>std::cout &lt;&lt; __FUNCTION__; <span class=\"hljs-comment\">// print &#x27;f&#x27;</span><br>std::cout &lt;&lt; __func__; <span class=\"hljs-comment\">// print &#x27;f&#x27;</span><br>&#125;<br><span class=\"hljs-comment\">// see template lectures</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(T p)</span> </span>&#123;<br>std::cout &lt;&lt; __PRETTY_FUNCTION__; <span class=\"hljs-comment\">// print &#x27;float g(T) [T = int]&#x27;</span><br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0f</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g1</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-built_in\">g</span>(<span class=\"hljs-number\">3</span>); &#125;<br></code></pre></td></tr></table></figure>\n<p>C++20在<source_location>提供了函数方法来代替这些宏。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;source_location&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(std::source_location s = std::source_location::current())</span> </span>&#123;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;function: &quot;</span> &lt;&lt; s.<span class=\"hljs-built_in\">function_name</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, line &quot;</span> &lt;&lt; s.<span class=\"hljs-built_in\">line</span>();<br>&#125; <span class=\"hljs-comment\">// column(),file_name() also support</span><br><span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">// print: &quot;function: f, line 6&quot;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>__DATE__</code>:输出编译的开始日期以’mmm dd yyyy’格式</li>\n<li><code>__TIME__</code>:输出编译的开始时间</li>\n</ul>\n<h3 id=\"常见的条件编译\"><a href=\"#常见的条件编译\" class=\"headerlink\" title=\"常见的条件编译\"></a>常见的条件编译</h3><p>可见网址<img src=\"https://sourceforge.net/p/predef/wiki/Home/\"><br>可见网址<img src=\"https://abseil.io/docs/cpp/platforms/macros\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">语法</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>#if defined( cplusplus)</code></td>\n<td align=\"center\">C++ code</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 199711L</code></td>\n<td align=\"center\">ISO C++ 1998&#x2F;2003,仅限于linux,MSVC的2011和2014也是该值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 201103L</code></td>\n<td align=\"center\">ISO C++ 2011,仅限于linux</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 201402L</code></td>\n<td align=\"center\">ISO C++ 2014,仅限于linux</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if cplusplus == 201703L</code></td>\n<td align=\"center\">ISO C++ 2017</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( GNUG )</code></td>\n<td align=\"center\">The compiler is gcc&#x2F;g++</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( clang )</code></td>\n<td align=\"center\">The compiler is clang&#x2F;clang++</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( MSC VER)</code></td>\n<td align=\"center\">The compiler is Microsoft Visual C++</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( WIN64)</code></td>\n<td align=\"center\">OS is Windows 64-bit</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( linux )</code></td>\n<td align=\"center\">OS is Linux</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( APPLE )</code></td>\n<td align=\"center\">OS is Mac OS</td>\n</tr>\n<tr>\n<td align=\"center\"><code>#if defined( MINGW32 )</code></td>\n<td align=\"center\">OS is MinGW 32-bit</td>\n</tr>\n</tbody></table>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><code>#</code>:等价于加个双引号<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> STRING_MACRO(string) #string</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">STRING_MACRO</span>(hello); <span class=\"hljs-comment\">// equivalent to &quot;hello&quot;</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> INFO_MACRO(my_func) \\</span><br><span class=\"hljs-meta\">&#123; \\</span><br><span class=\"hljs-meta\">my_func \\</span><br><span class=\"hljs-meta\">cout &lt;&lt; <span class=\"hljs-string\">&quot;call &quot;</span> &lt;&lt; #my_func &lt;&lt; <span class=\"hljs-string\">&quot; at &quot;</span> \\</span><br><span class=\"hljs-meta\">&lt;&lt; __FILE__ &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span> __LINE__; \\</span><br><span class=\"hljs-meta\">&#125;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span> </span>&#123;&#125;<br><span class=\"hljs-built_in\">INFO_MACRO</span>( <span class=\"hljs-built_in\">g</span>(<span class=\"hljs-number\">3</span>) ) <span class=\"hljs-comment\">// print: &quot;call g(3) at my_file.cpp:7&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><code>#error &quot;text&quot;</code>:编译器遇到时会输出error</li>\n<li><code>#warning &quot;text&quot;</code>:编译器遇到时会输出warning</li>\n<li><code>##</code>：连接字符串<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> FUNC_GEN_A(tokenA, tokenB) \\</span><br><span class=\"hljs-meta\">void tokenA##tokenB() &#123;&#125;</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> FUNC_GEN_B(tokenA, tokenB) \\</span><br><span class=\"hljs-meta\">void tokenA##_##tokenB() &#123;&#125;</span><br><span class=\"hljs-built_in\">FUNC_GEN_A</span>(my, function)<br><span class=\"hljs-built_in\">FUNC_GEN_B</span>(my, function)<br><span class=\"hljs-built_in\">myfunction</span>(); <span class=\"hljs-comment\">// ok, from FUNC_GEN_A</span><br><span class=\"hljs-built_in\">my_function</span>(); <span class=\"hljs-comment\">// ok, from FUNC_GEN_B</span><br></code></pre></td></tr></table></figure></li>\n<li><code>__VA_ARGS__</code>:多参数宏<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span> </span>&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, a); &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d&quot;</span>, a, b); &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c)</span> </span>&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d %d&quot;</span>, a, b, c); &#125;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> PRINT(...) \\</span><br><span class=\"hljs-meta\">f( VA ARGS );</span><br><span class=\"hljs-built_in\">PRINT</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)<br><span class=\"hljs-built_in\">PRINT</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) <br></code></pre></td></tr></table></figure></li>\n<li><code>#if __has_include(&lt;iostream&gt;)</code>：c++17判断是否存在头文件<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">if</span> __has_include(<span class=\"hljs-string\">&lt;iostream&gt;</span>)</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure></li>\n<li><code>#if __cpp_constexpr</code>:C++20引入，判断编译器是否支持某特性，还有许多其它的宏<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">if</span> __cpp_constexpr</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">square</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> x * x; &#125;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure></li>\n<li><code>#pragma</code>:调用某个指令，依赖于编译器</li>\n</ul>\n<h3 id=\"技巧-1\"><a href=\"#技巧-1\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><p><strong>数字转字符串</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> TO_LITERAL_AUX(x) #x</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> TO_LITERAL(x) TO_LITERAL_AUX(x)</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-type\">int</span> x1 = <span class=\"hljs-number\">3</span> * <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> y1 = __LINE__ + <span class=\"hljs-number\">4</span>;<br><span class=\"hljs-type\">char</span> x2[] = <span class=\"hljs-built_in\">TO_LITERAL</span>(<span class=\"hljs-number\">3</span>);<br><span class=\"hljs-type\">char</span> y2[] = <span class=\"hljs-built_in\">TO_LITERAL</span>(__LINE__);<span class=\"hljs-comment\">//这里你知道为啥包一层了把，有些并不是无意义的包</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Bitfield\"><a href=\"#Bitfield\" class=\"headerlink\" title=\"Bitfield\"></a>Bitfield</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S1</span> &#123;<br><span class=\"hljs-type\">int</span> b1 : <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// range [0, 1023]</span><br><span class=\"hljs-type\">int</span> b2 : <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// range [0, 1023]</span><br><span class=\"hljs-type\">int</span> b3 : <span class=\"hljs-number\">8</span>; <span class=\"hljs-comment\">// range [0, 255]</span><br>&#125;; <span class=\"hljs-comment\">// sizeof(S1): 4 bytes</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S2</span> &#123;<br><span class=\"hljs-type\">int</span> b1 : <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> : <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// reset: force the next field</span><br><span class=\"hljs-type\">int</span> b2 : <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// to start at bit 32</span><br>&#125;; <span class=\"hljs-comment\">// sizeof(S1): 8 bytes</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"type-info\"><a href=\"#type-info\" class=\"headerlink\" title=\"type_info\"></a>type_info</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">B</span> : A &#123;&#125;;<br>A a;<br>B b;<br>A&amp; a1 = b; <span class=\"hljs-comment\">// implicit upcasting</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(a).<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &quot;1A&quot;</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(b).<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &quot;1B&quot;</span><br>cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(a1).<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &quot;1B&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"未定义行为\"><a href=\"#未定义行为\" class=\"headerlink\" title=\"未定义行为\"></a>未定义行为</h2><h3 id=\"Pointer\"><a href=\"#Pointer\" class=\"headerlink\" title=\"Pointer\"></a>Pointer</h3><ul>\n<li>Dereferencing a NULL pointer</li>\n<li>Dereferencing a pointer returned by a “new” allocation of size zero</li>\n<li>Using pointers to objects whose lifetime has ended (for instance, stack allocated objects or deleted objects)</li>\n<li>Dereferencing a pointer that has not yet been definitely initialized</li>\n<li>Performing pointer arithmetic that yields a result outside the boundaries (either above or below) of an array.</li>\n<li>Dereferencing the pointer at a location beyond the end of an array.</li>\n<li>Converting pointers to objects of incompatible types</li>\n<li>Using memcpy to copy overlapping buffers.</li>\n</ul>\n<h3 id=\"buffer-overflows\"><a href=\"#buffer-overflows\" class=\"headerlink\" title=\"buffer overflows\"></a>buffer overflows</h3><ul>\n<li>Reading or writing to an object or array at an offset that is negative, or beyond the size of that object (stack&#x2F;heap overflow)</li>\n</ul>\n<h3 id=\"Integer-Overflows\"><a href=\"#Integer-Overflows\" class=\"headerlink\" title=\"Integer Overflows\"></a>Integer Overflows</h3><ul>\n<li>Signed integer overflow</li>\n<li>Evaluating an expression that is not mathematically defined</li>\n<li>Left-shifting values by a negative amount (right shifts by negative amounts are implementation defined)</li>\n<li>Shifting values by an amount greater than or equal to the number of bits in the number (e.g. int64_t i &#x3D; 1; i &lt;&lt;&#x3D; 72 is undefined)</li>\n</ul>\n<h3 id=\"Types-Cast-and-Const\"><a href=\"#Types-Cast-and-Const\" class=\"headerlink\" title=\"Types, Cast and Const\"></a>Types, Cast and Const</h3><ul>\n<li>Casting a numeric value into a value that can’t be represented by the target type (either directly or via static_cast)</li>\n<li>Using an automatic variable before it has been definitely assigned (e.g., int i; i++; cout &lt;&lt; i;)</li>\n<li>Using the value of any object of type other than volatile or sig_atomic_t at the receipt of a signal</li>\n<li>Attempting to modify a string literal or any other const object during its lifetime</li>\n<li>Concatenating a narrow with a wide string literal during preprocessing</li>\n</ul>\n<h3 id=\"Function-and-Template\"><a href=\"#Function-and-Template\" class=\"headerlink\" title=\"Function and Template\"></a>Function and Template</h3><ul>\n<li>Not returning a value from a value-returning function (directly or by flowing off from a try-block)</li>\n<li>Multiple different definitions for the same entity (class, template, enumeration, inline function, static member function, etc.)</li>\n<li>Infinite recursion in the instantiation of templates</li>\n<li>Calling a function using different parameters or linkage to the parameters and linkage that the function is defined as using.</li>\n</ul>\n<h3 id=\"OOP\"><a href=\"#OOP\" class=\"headerlink\" title=\"OOP\"></a>OOP</h3><ul>\n<li>Cascading destructions of objects with static storage duration</li>\n<li>The result of assigning to partially overlapping objects</li>\n<li>Recursively re-entering a function during the initialization of its static objects</li>\n<li>Making virtual function calls to pure virtual functions of an object from its constructor or destructor</li>\n<li>Referring to nonstatic members of objects that have not been constructed or have already been destructed</li>\n</ul>\n<h3 id=\"Source-file-and-Preprocessing\"><a href=\"#Source-file-and-Preprocessing\" class=\"headerlink\" title=\"Source file and Preprocessing\"></a>Source file and Preprocessing</h3><ul>\n<li>A non-empty source file that doesn’t end with a newline, or ends with a backslash (prior to C++11)</li>\n<li>A backslash followed by a character that is not part of the specified escape codes in a character or string constant (this is implementation-defined in C++11).</li>\n<li>Exceeding implementation limits (number of nested blocks, number of functions in a program, available stack space …)</li>\n<li>Preprocessor numeric values that can’t be represented by a long int</li>\n<li>Preprocessing directive on the left side of a function-like macro definition</li>\n<li>Dynamically generating the defined token in a #if expression</li>\n</ul>\n<h3 id=\"to-be-classified\"><a href=\"#to-be-classified\" class=\"headerlink\" title=\"to be classified\"></a>to be classified</h3><ul>\n<li>Calling exit during the destruction of a program with static storage duration</li>\n</ul>\n<h2 id=\"c-str2num\"><a href=\"#c-str2num\" class=\"headerlink\" title=\"c_str2num\"></a>c_str2num</h2><p>高性能转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">unsigned</span> MUL, <span class=\"hljs-type\">int</span> INDEX = <span class=\"hljs-number\">0</span>&gt;<br><span class=\"hljs-keyword\">struct</span> fastStringToIntStr;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-title\">fastStringToUnsigned</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str, <span class=\"hljs-type\">int</span> length)</span> </span>&#123;<br><span class=\"hljs-keyword\">switch</span>(length) &#123;<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">10</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1000000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">9</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">100000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">8</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">7</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1000000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">6</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">100000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">5</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1000</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">100</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">return</span> fastStringToIntStr&lt; <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br><span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">unsigned</span> MUL, <span class=\"hljs-type\">int</span> INDEX&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">fastStringToIntStr</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-title\">aux</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">unsigned</span>&gt;(str[INDEX] - <span class=\"hljs-string\">&#x27;0&#x27;</span>) * MUL +<br>fastStringToIntStr&lt;N - <span class=\"hljs-number\">1</span>, MUL / <span class=\"hljs-number\">10</span>, INDEX + <span class=\"hljs-number\">1</span>&gt;::<span class=\"hljs-built_in\">aux</span>(str);<br>&#125;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">unsigned</span> MUL, <span class=\"hljs-type\">int</span> INDEX&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">fastStringToIntStr</span>&lt;<span class=\"hljs-number\">1</span>, MUL, INDEX&gt; &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-title\">aux</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">unsigned</span>&gt;(str[INDEX] - <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"删除vector某个元素\"><a href=\"#删除vector某个元素\" class=\"headerlink\" title=\"删除vector某个元素\"></a>删除vector某个元素</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">swap</span>(v[<span class=\"hljs-number\">3</span>], v[v.size()-<span class=\"hljs-number\">1</span>]);<br>v<span class=\"hljs-selector-class\">.pop_back</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"批量删除vector元素\"><a href=\"#批量删除vector元素\" class=\"headerlink\" title=\"批量删除vector元素\"></a>批量删除vector元素</h2><p>以下方法都是类似于把元素移到末尾，然后统一删除</p>\n<ul>\n<li>删除所有值为42的：<code>v.erase(remove(v.begin(), v.end(), 42), v.end());</code></li>\n<li>删除所有值大于0的:<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">vector&lt;<span class=\"hljs-type\">int</span>&gt; v;<br>v.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-built_in\">remove_if</span>(v.<span class=\"hljs-built_in\">begin</span>(), v.<span class=\"hljs-built_in\">end</span>(), [](<span class=\"hljs-type\">int</span> x) &#123;<br>    <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span>;<br>&#125;), v.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></table></figure></li>\n<li>c++20<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">vector&lt;<span class=\"hljs-type\">int</span>&gt; v;<br><span class=\"hljs-built_in\">erase</span>(v, <span class=\"hljs-number\">42</span>);       <span class=\"hljs-comment\">// 删除所有值为 42 的元素</span><br><span class=\"hljs-built_in\">erase_if</span>(v, [](<span class=\"hljs-type\">int</span> x) &#123;<br>    <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span>;   <span class=\"hljs-comment\">// 删除所有值大于 0 的元素</span><br>&#125;);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"维护有序的vector\"><a href=\"#维护有序的vector\" class=\"headerlink\" title=\"维护有序的vector\"></a>维护有序的vector</h2><p><code>s.insert(lower_bound(s.begin(),s.end(),3), 3)</code></p>\n"},{"title":"C++标准库","date":"2019-08-10T13:22:59.000Z","subtitle":null,"index_img":"/images/STL.webp","banner_img":"/images/STL.webp","_content":"# 顺序容器\n|方法|说明|\n|:-:|:-:|\n|c.resize(n)|调整c的大小为n个元素。要么多出的元素被丢弃,要么新添加默认值的元素|\n|c.resize(n,t)|调整c的大小为n个元素。任何新添加的元素初始为t|\n|c.shrink_to_fit()|只适用于vector,string和deque。将capacity()减少与size()相同大小|\n|c.capacity()|只适用于vector和string,返回c可以保存多少元素|\n|c.reserve(n)|只适用于vector和string,分配至少容纳n个元素的内存空间|\n|c.assign(i1)|将c中的元素全部替换为i1元素,i1可以和c类型不同,但元素必须相同,甚至可以是map与set类型|\n|c.assign(n,t)|将c中的元素全部换为n个t|\n\n# 优先队列\n格式:`priority_queue<Type,Container,Functional>`\n例子:`priority_queue<int,vector<int>,myCompare>`,myCompare可以替换为less<int>降序,greater<int>升序\n# 数学相关\n## cmath\n- fabs(x) computes absolute value, |x|, C++11\n- exp(x) returns e raised to the given powerx\n- exp2(x) returns 2 raised to the given power , C++11\n- log(x) computes natural (base e) logarithm, loge (x)\n- log10(x) computes base 10 logarithm, log10(x)\n- log2(x) computes base 2 logarithm, log2 (x), C++11\n- pow(x, y) raises a number to the given power, x y\n- sqrt(x) computes square root\n- cqrt(x) computes cubic root x, C++11\n- sin(x) computes sine, sin(x)\n- cos(x) computes cosine, cos(x)\n- tan(x) computes tangent, tan(x)\n- ceil(x) nearest integer not less than the given value, ⌈x⌉\n- floor(x) nearest integer not greater than the given value, ⌊x⌋\n- atan2(y,x)\n- atan(y)\n- asin()\n- acos()\n- round|lround|llround(x) nearest integer(x+0.5),  (return type: floating point, long, long long respectivel\n## limits\n- `T numeric_limits<T>:: max()`\n- `T numeric_limits<T>:: min()`\n- `T numeric_limits<T>:: lowest()`\n## numeric(c++20)\n- `e` Euler number e\n- `pi` π\n- `phi`黄金分割比率\n- `sqrt2`\n# 随机数\n- 选择随机种子seed(随机引擎的初始值)\n- 定义随机引擎`<type of random engine> generator(seed)`\n- 定义分布`<type of distribution> distribution(range start, range end)`\n- 产生随机数`distribution(generator)`\n## 产生种子\n- 自定义：`unsigned seed = 2`,注意相同种子，产生的随机序列是一样的\n- 使用时间\n```C++\n#include <random>\n#include <chrono>\nunsigned seed = std::chrono::system_clock::now()\n.time_since_epoch().count();\nstd::default_random_engine generator(seed);\n```\n### 使用random_device\n```C++\n#include <random>\nstd::random_device rnd_device;\nstd::default_random_engine generator(rnd_device());\n```\n### 使用seed seq\n```C++\n#include <random>\n#include <chrono>\nunsigned seed1 = std::chrono::system_clock::now()\n.time_since_epoch().count();\nunsigned seed2 = seed1 + 1000;\nstd::seed_seq seq1{ seed1, seed2 };\nstd::default_random_engine generator1(seq);\n```\n## bit\n以下方法支持bitwise，性能更好\nrotate left : std::rotl\nrotate right : std::rotr\ncount leading zero : std::countl zero\ncount leading one : std::countl one\ncount trailing zero : std::countr zero\ncount trailing one : std::countr one\npopulation count : std::popcount\n\n## 随机引擎\n三种随机引擎的对比\n|Generator|Quality|Period|Randomness|C++引擎|\n|:-:|:-:|:-:|:-:|:-:|\n|Linear Congruential|Poor|10^9|Statistical tests|std::minstd_rand,std::minstd_rand0,std::knuth_b|\n|Mersenne Twister 32/64-bit|High|10^6000|Statistical tests|std::mt19937,std::19937_64|\n|Subtract-with-carry 24/48-bit|Highest|10^171|Mathematically proven|std::ranlux24_base,std::ranlux48_base,std::ranlux24,std::ranlux48|\n## 分布\n- `uniform int distribution<T>(range start, range end)` where T is integral type\n- `uniform real distribution<T>(range start, range end)` where T is floating point type\n- `normal distribution<T>(mean, std dev)`where T is floating point type\n- `exponential distribution<T>(lambda)`where T is floating point type\n# 时间\n- `Wall-Clock/Real time` It is the human perception of the passage of time from the start to the completion of a task(整个程序的时间)\n- `User/CPU time` The amount of time spent by the CPU to compute in user code(用户空间的执行时间)\n- `System time` The amount of time spent by the CPU to compute system calls (including I/O calls) executed into kernel code(内核消耗的时间)\n如果程序是但线程并且系统负载不高则有：\nWall-clock time = User time + System time\n## Real Time\n### linux系统调用\n```bash\n# include <time.h> //struct timeval\n# include <sys/time.h> //gettimeofday()\nstruct timeval start, end; // timeval {second, microseconds}\n::gettimeofday(&start, NULL);\n... // code\n::gettimeofday(&end, NULL);\nlong start_time = start.tv_sec * 1000000 + start.tv_usec;\nlong end_time = end.tv_sec * 1000000 + end.tv_usec;\ncout << \"Elapsed: \" << end_time - start_time; // in microsec\n```\n### chrono\n```C++\n# include <chrono>\nauto start_time = std::chrono::system_clock::now();\n... // code\nauto end_time = std::chrono::system_clock::now();\nstd::chrono::duration<double> diff = end_time - start_time;\ncout << \"Elapsed: \" << diff.count(); // in seconds\ncout << std::chrono::duration_cast<milli>(diff).count(); // in ms\n```\n## User Time\n### chrono\n```C++\n# include <chrono>\nclock_t start_time = std::clock();\n... // code\nclock_t end_time = std::clock();\nfloat diff = static_cast<float>(end_time - start_time) / CLOCKS_PER_SEC;\ncout << \"Elapsed: \" << diff; // in seconds\n```\n### 系统调用(包含内核时间的计算方法)\n```C++\n# include <sys/times.h>\nstruct ::tms start_time, end_time;\n::times(&start_time);\n... // code\n::times(&end_time);\nauto user_diff = end_time.tmus_utime - start_time.tms_utime;\nauto sys_diff = end_time.tms_stime - start_time.tms_stime;\nfloat user = static_cast<float>(user_diff) / ::sysconf(_SC_CLK_TCK);\nfloat sys = static_cast<float>(sys_diff) / ::sysconf(_SC_CLK_TCK);\ncout << \"user time: \" << user; // in seconds\ncout << \"system time: \" << sys; // in seconds\n```\n# tuple\n```C++\n# include <tuple>\nstd::tuple<int, float, char> f() { return {7, 0.1f, 'a'}; }\nstd::tuple<int, char, float> tuple1(3, 'c', 2.2f);\nauto tuple2 = std::make_tuple(2, 'd', 1.5f);\ncout << std::get<0>(tuple1); // print 3\ncout << std::get<1>(tuple1); // print 'c'\ncout << std::get<2>(tuple1); // print 2.2f\ncout << (tuple1 > tuple2); // print true\nauto concat = std::tuple_cat(tuple1, tuple2);\ncout << std::tuple_size<decltype(concat)>::value; // print 6\nusing T = std::tuple_element<4, decltype(concat)>::type; // T is int\nint value1; float value2;\nstd::tie(value1, value2, std::ignore) = f();//creates a tuple of references to its arguments\nstd::swap(tuple1,tuple2);\n```\n# variant(c++17)\n代替联合体union，类型安全(切换类型前会自动析构)，见[variant](https://en.cppreference.com/w/cpp/utility/variant)\n- 构造：`std::variant<int, float> tmp`\n- 获取类型个数：`std::variant_size_v<decltype(tmp)> // 2`\n- 获取下标：`tmp = 3.2; tmp.index() // 1`\n- 判断当前值类型：`hold_alternative<float> tmp // true`\n- 获取当前值类型：`static_assert(std::is_same_v<int, variant_alternative_t<0, tmp>>) // int`\n## Example\n```C\nstd::variant<int, float, std::string> tmp;\ntmp = \"hi\";\nstd::get<int>(tmp); // throw exception\nint* s = std::get_if<int>(tmp); // no throw, but return null\nstring g = std::get<std::string>(tmp); //success\n```\n## visitor\nIt is also possible to query the index at run-time depending on the type currently being held by providing a visitor\n```C++\n# include <variant>\nstruct Visitor {\nvoid operator()(int& value) { value *= 2; }\nvoid operator()(float& value) { value += 3.0f; } // <--\nvoid operator()(bool& value) { value = true; }\n};\nstd::variant<int, float, bool> v(3.3f);\nstd::visit(v, Visitor{});\ncout << std::get<float>(v); // 6.3f\n```\n# optional\n```C++\n# include <optional>\nstd::optional<std::string> find(const char* set, char value) {\nfor (int i = 0; i < 10; i++) {\nif (set[i] == value)\nreturn i;\n}\nreturn {}; // std::nullopt;\n}\n=============================\n# include <optional>\nchar set[] = \"sdfslgfsdg\";\nauto x = find(set, 'a'); // 'a' is not present\nif (!x)\ncout << \"not found\";\nif (!x.has_value())\ncout << \"not found\";\nauto y = find(set, 'l');\ncout << *y << \" \" << y.value(); // print '4' '4'\nx.value_or(-1); // returns '-1'\ny.value_or(-1); // returns '4'\n```\n# any\n```C++\n# include <any>\nstd::any var = 1; // int\ncout << var.type().name(); // print 'i'\ncout << std::any_cast<int>(var);\n// cout << std::any_cast<float>(var); // exception!!\nvar = 3.14; // double\ncout << std::any_cast<double>(var);\nvar.reset();\ncout << var.has_value(); // print 'false'\n```\n# stacktrace(c++23)\n```C++\n# include <print>\n# include <stacktrace> // the program must be linked with the library\n// -lstdc++_libbacktrace\n// (-lstdc++exp with gcc-14 trunk)\nvoid g() {\nauto call_stack = std::stacktrace::current();\nfor (const auto& entry : call_stack)\nstd::print(\"{}\\n\", entry);//entry.description()entry.source_file(),entry.source_line()\n}\nvoid f() { g(); }\nint main() { f(); }\n```\n# filesystem(c++17)\n- Follow the Boost filesystem library\n- Based on POSIX\n- Fully-supported from clang 7, gcc 8, etc.\n- Work on Windows, Linux, Android, etc.\n## path\n### member function\n- root_name()\n- relative_path()\n- parent_path()\n- filename()\n- extension()\n### method\n- exists(path)\n- file_size(path)\n- is_directory(path)\n- is_empty(path)\n- is_regular_file(path):return true if path is no dir,hard link,soft link\n- copy(path1, path2)\n- copy_file(src_path, src_path, [fs::copy_options::recursive])\n- create_directory(path)\n- remove(path):remove a file or empty directory\n- remove_all(path)\n- rename(old_path,new_path)\n## iterator\n```C++\nnamespace fs = std::filesystem;\nfor(auto& path : fs::directory_iterator(\"/usr/tmp/\"))\ncout << path << '\\n';\nfor(auto& path : fs::recursive_directory_iterator(\"/usr/tmp/\"))\ncout << path << '\\n';\n```\n## example\n```C++\n# include <filesystem> // required\nnamespace fs = std::filesystem;\nfs::path p1 = \"/usr/tmp/my_file.txt\";\ncout << p1.exists(); // true\ncout << p1.parent_path(); // \"/usr/tmp/\"\ncout << p1.filename(); // \"my_file\"\ncout << p1.extension(); // \"txt\"\ncout << p1.is_directory(); // false\ncout << p1.is_regular_file(); // true\nfs::create_directory(\"/my_dir/\");\nfs::copy(p1.parent_path(), \"/my_dir/\", fs::copy_options::recursive);\nfs::copy_file(p1, \"/my_dir/my_file2.txt\");\nfs::remove(p1);\nfs::remove_all(p1.parent_path());\n```\n# 多线程库\n## thread\n```C++\n# include <iostream>\n# include <thread>\n# include <vector>\nvoid f(int id) {\nstd::cout << \"thread \" << id << std::endl;\n}\nint main() {\nstd::vector<std::thread> thread_vect; // thread vector\nfor (int i = 0; i < 10; i++)\nthread_vect.push_back( std::thread(&f, i) );\nfor (auto& th : thread_vect)\nth.join();\nthread_vect.clear();\nfor (int i = 0; i < 10; i++) { // thread + lambda expression\nthread_vect.push_back(\nstd::thread( [](){ std::cout << \"thread\\n\"; } );\n}\n```\n\n|类别|函数|说明|\n|:-:|:-:|:-:|\n|库函数|`std::this_thread::get_id()`|返回线程id|\n|库函数|`std::this_thread::sleep_for(sleep_duration)`|blocks the thread|\n|库函数|`std::thread::hardware_concurrency()`|returns the number of concurrent threads supported by the implementation|\n|对象方法|`get_id()`|returns the thread id|\n|对象方法|`join()`|waits for a thread to finish its execution|\n|对象方法|`detach()`|permits the thread to execute independently of the thread handle|\n## mutex\n## atomic\n## future\nThe future library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks\n```C++\n# include <future> // numeric, algorithm, vector, iostream\ntemplate <typename RandomIt>\nint parallel_sum(RandomIt beg, RandomIt end) {\nauto len = end - beg;\nif (len < 1000) // base case\nreturn std::accumulate(beg, end, 0);\nRandomIt mid = beg + len / 2;\nauto handle = std::async(std::launch::async, // right side\nparallel_sum<RandomIt>, mid, end);\nint sum = parallel_sum(beg, mid); // left side\nreturn sum + handle.get(); // left + right\n}\nint main() {\nstd::vector<int> v(10000, 1); // init all to 1\nstd::cout << \"The sum is \" << parallel_sum(v.begin(), v.end());\n}\n```\nstd::future methods:\n• T get() returns the result\n• wait() waits for the result to become available\nasync() can be called with two launch policies for a task executed:\n• std::launch::async a new thread is launched to execute the task asynchronously\n• std::launch::deferred the task is executed on the calling thread the first time its result is requested (lazy evaluation)\n","source":"_posts/C-标准库.md","raw":"---\ntitle: C++标准库\ndate: 2019-08-10 21:22:59\nsubtitle:\ncategories: C++\ntags:\nindex_img: /images/STL.webp\nbanner_img: /images/STL.webp\n---\n# 顺序容器\n|方法|说明|\n|:-:|:-:|\n|c.resize(n)|调整c的大小为n个元素。要么多出的元素被丢弃,要么新添加默认值的元素|\n|c.resize(n,t)|调整c的大小为n个元素。任何新添加的元素初始为t|\n|c.shrink_to_fit()|只适用于vector,string和deque。将capacity()减少与size()相同大小|\n|c.capacity()|只适用于vector和string,返回c可以保存多少元素|\n|c.reserve(n)|只适用于vector和string,分配至少容纳n个元素的内存空间|\n|c.assign(i1)|将c中的元素全部替换为i1元素,i1可以和c类型不同,但元素必须相同,甚至可以是map与set类型|\n|c.assign(n,t)|将c中的元素全部换为n个t|\n\n# 优先队列\n格式:`priority_queue<Type,Container,Functional>`\n例子:`priority_queue<int,vector<int>,myCompare>`,myCompare可以替换为less<int>降序,greater<int>升序\n# 数学相关\n## cmath\n- fabs(x) computes absolute value, |x|, C++11\n- exp(x) returns e raised to the given powerx\n- exp2(x) returns 2 raised to the given power , C++11\n- log(x) computes natural (base e) logarithm, loge (x)\n- log10(x) computes base 10 logarithm, log10(x)\n- log2(x) computes base 2 logarithm, log2 (x), C++11\n- pow(x, y) raises a number to the given power, x y\n- sqrt(x) computes square root\n- cqrt(x) computes cubic root x, C++11\n- sin(x) computes sine, sin(x)\n- cos(x) computes cosine, cos(x)\n- tan(x) computes tangent, tan(x)\n- ceil(x) nearest integer not less than the given value, ⌈x⌉\n- floor(x) nearest integer not greater than the given value, ⌊x⌋\n- atan2(y,x)\n- atan(y)\n- asin()\n- acos()\n- round|lround|llround(x) nearest integer(x+0.5),  (return type: floating point, long, long long respectivel\n## limits\n- `T numeric_limits<T>:: max()`\n- `T numeric_limits<T>:: min()`\n- `T numeric_limits<T>:: lowest()`\n## numeric(c++20)\n- `e` Euler number e\n- `pi` π\n- `phi`黄金分割比率\n- `sqrt2`\n# 随机数\n- 选择随机种子seed(随机引擎的初始值)\n- 定义随机引擎`<type of random engine> generator(seed)`\n- 定义分布`<type of distribution> distribution(range start, range end)`\n- 产生随机数`distribution(generator)`\n## 产生种子\n- 自定义：`unsigned seed = 2`,注意相同种子，产生的随机序列是一样的\n- 使用时间\n```C++\n#include <random>\n#include <chrono>\nunsigned seed = std::chrono::system_clock::now()\n.time_since_epoch().count();\nstd::default_random_engine generator(seed);\n```\n### 使用random_device\n```C++\n#include <random>\nstd::random_device rnd_device;\nstd::default_random_engine generator(rnd_device());\n```\n### 使用seed seq\n```C++\n#include <random>\n#include <chrono>\nunsigned seed1 = std::chrono::system_clock::now()\n.time_since_epoch().count();\nunsigned seed2 = seed1 + 1000;\nstd::seed_seq seq1{ seed1, seed2 };\nstd::default_random_engine generator1(seq);\n```\n## bit\n以下方法支持bitwise，性能更好\nrotate left : std::rotl\nrotate right : std::rotr\ncount leading zero : std::countl zero\ncount leading one : std::countl one\ncount trailing zero : std::countr zero\ncount trailing one : std::countr one\npopulation count : std::popcount\n\n## 随机引擎\n三种随机引擎的对比\n|Generator|Quality|Period|Randomness|C++引擎|\n|:-:|:-:|:-:|:-:|:-:|\n|Linear Congruential|Poor|10^9|Statistical tests|std::minstd_rand,std::minstd_rand0,std::knuth_b|\n|Mersenne Twister 32/64-bit|High|10^6000|Statistical tests|std::mt19937,std::19937_64|\n|Subtract-with-carry 24/48-bit|Highest|10^171|Mathematically proven|std::ranlux24_base,std::ranlux48_base,std::ranlux24,std::ranlux48|\n## 分布\n- `uniform int distribution<T>(range start, range end)` where T is integral type\n- `uniform real distribution<T>(range start, range end)` where T is floating point type\n- `normal distribution<T>(mean, std dev)`where T is floating point type\n- `exponential distribution<T>(lambda)`where T is floating point type\n# 时间\n- `Wall-Clock/Real time` It is the human perception of the passage of time from the start to the completion of a task(整个程序的时间)\n- `User/CPU time` The amount of time spent by the CPU to compute in user code(用户空间的执行时间)\n- `System time` The amount of time spent by the CPU to compute system calls (including I/O calls) executed into kernel code(内核消耗的时间)\n如果程序是但线程并且系统负载不高则有：\nWall-clock time = User time + System time\n## Real Time\n### linux系统调用\n```bash\n# include <time.h> //struct timeval\n# include <sys/time.h> //gettimeofday()\nstruct timeval start, end; // timeval {second, microseconds}\n::gettimeofday(&start, NULL);\n... // code\n::gettimeofday(&end, NULL);\nlong start_time = start.tv_sec * 1000000 + start.tv_usec;\nlong end_time = end.tv_sec * 1000000 + end.tv_usec;\ncout << \"Elapsed: \" << end_time - start_time; // in microsec\n```\n### chrono\n```C++\n# include <chrono>\nauto start_time = std::chrono::system_clock::now();\n... // code\nauto end_time = std::chrono::system_clock::now();\nstd::chrono::duration<double> diff = end_time - start_time;\ncout << \"Elapsed: \" << diff.count(); // in seconds\ncout << std::chrono::duration_cast<milli>(diff).count(); // in ms\n```\n## User Time\n### chrono\n```C++\n# include <chrono>\nclock_t start_time = std::clock();\n... // code\nclock_t end_time = std::clock();\nfloat diff = static_cast<float>(end_time - start_time) / CLOCKS_PER_SEC;\ncout << \"Elapsed: \" << diff; // in seconds\n```\n### 系统调用(包含内核时间的计算方法)\n```C++\n# include <sys/times.h>\nstruct ::tms start_time, end_time;\n::times(&start_time);\n... // code\n::times(&end_time);\nauto user_diff = end_time.tmus_utime - start_time.tms_utime;\nauto sys_diff = end_time.tms_stime - start_time.tms_stime;\nfloat user = static_cast<float>(user_diff) / ::sysconf(_SC_CLK_TCK);\nfloat sys = static_cast<float>(sys_diff) / ::sysconf(_SC_CLK_TCK);\ncout << \"user time: \" << user; // in seconds\ncout << \"system time: \" << sys; // in seconds\n```\n# tuple\n```C++\n# include <tuple>\nstd::tuple<int, float, char> f() { return {7, 0.1f, 'a'}; }\nstd::tuple<int, char, float> tuple1(3, 'c', 2.2f);\nauto tuple2 = std::make_tuple(2, 'd', 1.5f);\ncout << std::get<0>(tuple1); // print 3\ncout << std::get<1>(tuple1); // print 'c'\ncout << std::get<2>(tuple1); // print 2.2f\ncout << (tuple1 > tuple2); // print true\nauto concat = std::tuple_cat(tuple1, tuple2);\ncout << std::tuple_size<decltype(concat)>::value; // print 6\nusing T = std::tuple_element<4, decltype(concat)>::type; // T is int\nint value1; float value2;\nstd::tie(value1, value2, std::ignore) = f();//creates a tuple of references to its arguments\nstd::swap(tuple1,tuple2);\n```\n# variant(c++17)\n代替联合体union，类型安全(切换类型前会自动析构)，见[variant](https://en.cppreference.com/w/cpp/utility/variant)\n- 构造：`std::variant<int, float> tmp`\n- 获取类型个数：`std::variant_size_v<decltype(tmp)> // 2`\n- 获取下标：`tmp = 3.2; tmp.index() // 1`\n- 判断当前值类型：`hold_alternative<float> tmp // true`\n- 获取当前值类型：`static_assert(std::is_same_v<int, variant_alternative_t<0, tmp>>) // int`\n## Example\n```C\nstd::variant<int, float, std::string> tmp;\ntmp = \"hi\";\nstd::get<int>(tmp); // throw exception\nint* s = std::get_if<int>(tmp); // no throw, but return null\nstring g = std::get<std::string>(tmp); //success\n```\n## visitor\nIt is also possible to query the index at run-time depending on the type currently being held by providing a visitor\n```C++\n# include <variant>\nstruct Visitor {\nvoid operator()(int& value) { value *= 2; }\nvoid operator()(float& value) { value += 3.0f; } // <--\nvoid operator()(bool& value) { value = true; }\n};\nstd::variant<int, float, bool> v(3.3f);\nstd::visit(v, Visitor{});\ncout << std::get<float>(v); // 6.3f\n```\n# optional\n```C++\n# include <optional>\nstd::optional<std::string> find(const char* set, char value) {\nfor (int i = 0; i < 10; i++) {\nif (set[i] == value)\nreturn i;\n}\nreturn {}; // std::nullopt;\n}\n=============================\n# include <optional>\nchar set[] = \"sdfslgfsdg\";\nauto x = find(set, 'a'); // 'a' is not present\nif (!x)\ncout << \"not found\";\nif (!x.has_value())\ncout << \"not found\";\nauto y = find(set, 'l');\ncout << *y << \" \" << y.value(); // print '4' '4'\nx.value_or(-1); // returns '-1'\ny.value_or(-1); // returns '4'\n```\n# any\n```C++\n# include <any>\nstd::any var = 1; // int\ncout << var.type().name(); // print 'i'\ncout << std::any_cast<int>(var);\n// cout << std::any_cast<float>(var); // exception!!\nvar = 3.14; // double\ncout << std::any_cast<double>(var);\nvar.reset();\ncout << var.has_value(); // print 'false'\n```\n# stacktrace(c++23)\n```C++\n# include <print>\n# include <stacktrace> // the program must be linked with the library\n// -lstdc++_libbacktrace\n// (-lstdc++exp with gcc-14 trunk)\nvoid g() {\nauto call_stack = std::stacktrace::current();\nfor (const auto& entry : call_stack)\nstd::print(\"{}\\n\", entry);//entry.description()entry.source_file(),entry.source_line()\n}\nvoid f() { g(); }\nint main() { f(); }\n```\n# filesystem(c++17)\n- Follow the Boost filesystem library\n- Based on POSIX\n- Fully-supported from clang 7, gcc 8, etc.\n- Work on Windows, Linux, Android, etc.\n## path\n### member function\n- root_name()\n- relative_path()\n- parent_path()\n- filename()\n- extension()\n### method\n- exists(path)\n- file_size(path)\n- is_directory(path)\n- is_empty(path)\n- is_regular_file(path):return true if path is no dir,hard link,soft link\n- copy(path1, path2)\n- copy_file(src_path, src_path, [fs::copy_options::recursive])\n- create_directory(path)\n- remove(path):remove a file or empty directory\n- remove_all(path)\n- rename(old_path,new_path)\n## iterator\n```C++\nnamespace fs = std::filesystem;\nfor(auto& path : fs::directory_iterator(\"/usr/tmp/\"))\ncout << path << '\\n';\nfor(auto& path : fs::recursive_directory_iterator(\"/usr/tmp/\"))\ncout << path << '\\n';\n```\n## example\n```C++\n# include <filesystem> // required\nnamespace fs = std::filesystem;\nfs::path p1 = \"/usr/tmp/my_file.txt\";\ncout << p1.exists(); // true\ncout << p1.parent_path(); // \"/usr/tmp/\"\ncout << p1.filename(); // \"my_file\"\ncout << p1.extension(); // \"txt\"\ncout << p1.is_directory(); // false\ncout << p1.is_regular_file(); // true\nfs::create_directory(\"/my_dir/\");\nfs::copy(p1.parent_path(), \"/my_dir/\", fs::copy_options::recursive);\nfs::copy_file(p1, \"/my_dir/my_file2.txt\");\nfs::remove(p1);\nfs::remove_all(p1.parent_path());\n```\n# 多线程库\n## thread\n```C++\n# include <iostream>\n# include <thread>\n# include <vector>\nvoid f(int id) {\nstd::cout << \"thread \" << id << std::endl;\n}\nint main() {\nstd::vector<std::thread> thread_vect; // thread vector\nfor (int i = 0; i < 10; i++)\nthread_vect.push_back( std::thread(&f, i) );\nfor (auto& th : thread_vect)\nth.join();\nthread_vect.clear();\nfor (int i = 0; i < 10; i++) { // thread + lambda expression\nthread_vect.push_back(\nstd::thread( [](){ std::cout << \"thread\\n\"; } );\n}\n```\n\n|类别|函数|说明|\n|:-:|:-:|:-:|\n|库函数|`std::this_thread::get_id()`|返回线程id|\n|库函数|`std::this_thread::sleep_for(sleep_duration)`|blocks the thread|\n|库函数|`std::thread::hardware_concurrency()`|returns the number of concurrent threads supported by the implementation|\n|对象方法|`get_id()`|returns the thread id|\n|对象方法|`join()`|waits for a thread to finish its execution|\n|对象方法|`detach()`|permits the thread to execute independently of the thread handle|\n## mutex\n## atomic\n## future\nThe future library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks\n```C++\n# include <future> // numeric, algorithm, vector, iostream\ntemplate <typename RandomIt>\nint parallel_sum(RandomIt beg, RandomIt end) {\nauto len = end - beg;\nif (len < 1000) // base case\nreturn std::accumulate(beg, end, 0);\nRandomIt mid = beg + len / 2;\nauto handle = std::async(std::launch::async, // right side\nparallel_sum<RandomIt>, mid, end);\nint sum = parallel_sum(beg, mid); // left side\nreturn sum + handle.get(); // left + right\n}\nint main() {\nstd::vector<int> v(10000, 1); // init all to 1\nstd::cout << \"The sum is \" << parallel_sum(v.begin(), v.end());\n}\n```\nstd::future methods:\n• T get() returns the result\n• wait() waits for the result to become available\nasync() can be called with two launch policies for a task executed:\n• std::launch::async a new thread is launched to execute the task asynchronously\n• std::launch::deferred the task is executed on the calling thread the first time its result is requested (lazy evaluation)\n","slug":"C-标准库","published":1,"updated":"2024-04-17T20:45:56.540Z","_id":"clq1yvi6s0005gwq2hypud0ma","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h1><table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">c.resize(n)</td>\n<td align=\"center\">调整c的大小为n个元素。要么多出的元素被丢弃,要么新添加默认值的元素</td>\n</tr>\n<tr>\n<td align=\"center\">c.resize(n,t)</td>\n<td align=\"center\">调整c的大小为n个元素。任何新添加的元素初始为t</td>\n</tr>\n<tr>\n<td align=\"center\">c.shrink_to_fit()</td>\n<td align=\"center\">只适用于vector,string和deque。将capacity()减少与size()相同大小</td>\n</tr>\n<tr>\n<td align=\"center\">c.capacity()</td>\n<td align=\"center\">只适用于vector和string,返回c可以保存多少元素</td>\n</tr>\n<tr>\n<td align=\"center\">c.reserve(n)</td>\n<td align=\"center\">只适用于vector和string,分配至少容纳n个元素的内存空间</td>\n</tr>\n<tr>\n<td align=\"center\">c.assign(i1)</td>\n<td align=\"center\">将c中的元素全部替换为i1元素,i1可以和c类型不同,但元素必须相同,甚至可以是map与set类型</td>\n</tr>\n<tr>\n<td align=\"center\">c.assign(n,t)</td>\n<td align=\"center\">将c中的元素全部换为n个t</td>\n</tr>\n</tbody></table>\n<h1 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h1><p>格式:<code>priority_queue&lt;Type,Container,Functional&gt;</code><br>例子:<code>priority_queue&lt;int,vector&lt;int&gt;,myCompare&gt;</code>,myCompare可以替换为less<int>降序,greater<int>升序</p>\n<h1 id=\"数学相关\"><a href=\"#数学相关\" class=\"headerlink\" title=\"数学相关\"></a>数学相关</h1><h2 id=\"cmath\"><a href=\"#cmath\" class=\"headerlink\" title=\"cmath\"></a>cmath</h2><ul>\n<li>fabs(x) computes absolute value, |x|, C++11</li>\n<li>exp(x) returns e raised to the given powerx</li>\n<li>exp2(x) returns 2 raised to the given power , C++11</li>\n<li>log(x) computes natural (base e) logarithm, loge (x)</li>\n<li>log10(x) computes base 10 logarithm, log10(x)</li>\n<li>log2(x) computes base 2 logarithm, log2 (x), C++11</li>\n<li>pow(x, y) raises a number to the given power, x y</li>\n<li>sqrt(x) computes square root</li>\n<li>cqrt(x) computes cubic root x, C++11</li>\n<li>sin(x) computes sine, sin(x)</li>\n<li>cos(x) computes cosine, cos(x)</li>\n<li>tan(x) computes tangent, tan(x)</li>\n<li>ceil(x) nearest integer not less than the given value, ⌈x⌉</li>\n<li>floor(x) nearest integer not greater than the given value, ⌊x⌋</li>\n<li>atan2(y,x)</li>\n<li>atan(y)</li>\n<li>asin()</li>\n<li>acos()</li>\n<li>round|lround|llround(x) nearest integer(x+0.5),  (return type: floating point, long, long long respectivel</li>\n</ul>\n<h2 id=\"limits\"><a href=\"#limits\" class=\"headerlink\" title=\"limits\"></a>limits</h2><ul>\n<li><code>T numeric_limits&lt;T&gt;:: max()</code></li>\n<li><code>T numeric_limits&lt;T&gt;:: min()</code></li>\n<li><code>T numeric_limits&lt;T&gt;:: lowest()</code></li>\n</ul>\n<h2 id=\"numeric-c-20\"><a href=\"#numeric-c-20\" class=\"headerlink\" title=\"numeric(c++20)\"></a>numeric(c++20)</h2><ul>\n<li><code>e</code> Euler number e</li>\n<li><code>pi</code> π</li>\n<li><code>phi</code>黄金分割比率</li>\n<li><code>sqrt2</code></li>\n</ul>\n<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><ul>\n<li>选择随机种子seed(随机引擎的初始值)</li>\n<li>定义随机引擎<code>&lt;type of random engine&gt; generator(seed)</code></li>\n<li>定义分布<code>&lt;type of distribution&gt; distribution(range start, range end)</code></li>\n<li>产生随机数<code>distribution(generator)</code></li>\n</ul>\n<h2 id=\"产生种子\"><a href=\"#产生种子\" class=\"headerlink\" title=\"产生种子\"></a>产生种子</h2><ul>\n<li>自定义：<code>unsigned seed = 2</code>,注意相同种子，产生的随机序列是一样的</li>\n<li>使用时间<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-type\">unsigned</span> seed = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>()<br>.<span class=\"hljs-built_in\">time_since_epoch</span>().<span class=\"hljs-built_in\">count</span>();<br><span class=\"hljs-function\">std::default_random_engine <span class=\"hljs-title\">generator</span><span class=\"hljs-params\">(seed)</span></span>;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用random-device\"><a href=\"#使用random-device\" class=\"headerlink\" title=\"使用random_device\"></a>使用random_device</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span></span><br>std::random_device rnd_device;<br><span class=\"hljs-function\">std::default_random_engine <span class=\"hljs-title\">generator</span><span class=\"hljs-params\">(rnd_device())</span></span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用seed-seq\"><a href=\"#使用seed-seq\" class=\"headerlink\" title=\"使用seed seq\"></a>使用seed seq</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-type\">unsigned</span> seed1 = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>()<br>.<span class=\"hljs-built_in\">time_since_epoch</span>().<span class=\"hljs-built_in\">count</span>();<br><span class=\"hljs-type\">unsigned</span> seed2 = seed1 + <span class=\"hljs-number\">1000</span>;<br>std::seed_seq seq1&#123; seed1, seed2 &#125;;<br><span class=\"hljs-function\">std::default_random_engine <span class=\"hljs-title\">generator1</span><span class=\"hljs-params\">(seq)</span></span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"bit\"><a href=\"#bit\" class=\"headerlink\" title=\"bit\"></a>bit</h2><p>以下方法支持bitwise，性能更好<br>rotate left : std::rotl<br>rotate right : std::rotr<br>count leading zero : std::countl zero<br>count leading one : std::countl one<br>count trailing zero : std::countr zero<br>count trailing one : std::countr one<br>population count : std::popcount</p>\n<h2 id=\"随机引擎\"><a href=\"#随机引擎\" class=\"headerlink\" title=\"随机引擎\"></a>随机引擎</h2><p>三种随机引擎的对比</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Generator</th>\n<th align=\"center\">Quality</th>\n<th align=\"center\">Period</th>\n<th align=\"center\">Randomness</th>\n<th align=\"center\">C++引擎</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Linear Congruential</td>\n<td align=\"center\">Poor</td>\n<td align=\"center\">10^9</td>\n<td align=\"center\">Statistical tests</td>\n<td align=\"center\">std::minstd_rand,std::minstd_rand0,std::knuth_b</td>\n</tr>\n<tr>\n<td align=\"center\">Mersenne Twister 32&#x2F;64-bit</td>\n<td align=\"center\">High</td>\n<td align=\"center\">10^6000</td>\n<td align=\"center\">Statistical tests</td>\n<td align=\"center\">std::mt19937,std::19937_64</td>\n</tr>\n<tr>\n<td align=\"center\">Subtract-with-carry 24&#x2F;48-bit</td>\n<td align=\"center\">Highest</td>\n<td align=\"center\">10^171</td>\n<td align=\"center\">Mathematically proven</td>\n<td align=\"center\">std::ranlux24_base,std::ranlux48_base,std::ranlux24,std::ranlux48</td>\n</tr>\n</tbody></table>\n<h2 id=\"分布\"><a href=\"#分布\" class=\"headerlink\" title=\"分布\"></a>分布</h2><ul>\n<li><code>uniform int distribution&lt;T&gt;(range start, range end)</code> where T is integral type</li>\n<li><code>uniform real distribution&lt;T&gt;(range start, range end)</code> where T is floating point type</li>\n<li><code>normal distribution&lt;T&gt;(mean, std dev)</code>where T is floating point type</li>\n<li><code>exponential distribution&lt;T&gt;(lambda)</code>where T is floating point type</li>\n</ul>\n<h1 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h1><ul>\n<li><code>Wall-Clock/Real time</code> It is the human perception of the passage of time from the start to the completion of a task(整个程序的时间)</li>\n<li><code>User/CPU time</code> The amount of time spent by the CPU to compute in user code(用户空间的执行时间)</li>\n<li><code>System time</code> The amount of time spent by the CPU to compute system calls (including I&#x2F;O calls) executed into kernel code(内核消耗的时间)<br>如果程序是但线程并且系统负载不高则有：<br>Wall-clock time &#x3D; User time + System time</li>\n</ul>\n<h2 id=\"Real-Time\"><a href=\"#Real-Time\" class=\"headerlink\" title=\"Real Time\"></a>Real Time</h2><h3 id=\"linux系统调用\"><a href=\"#linux系统调用\" class=\"headerlink\" title=\"linux系统调用\"></a>linux系统调用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># include &lt;time.h&gt; //struct timeval</span><br><span class=\"hljs-comment\"># include &lt;sys/time.h&gt; //gettimeofday()</span><br>struct timeval start, end; // timeval &#123;second, microseconds&#125;<br>::gettimeofday(&amp;start, NULL);<br>... // code<br>::gettimeofday(&amp;end, NULL);<br>long start_time = start.tv_sec * 1000000 + start.tv_usec;<br>long end_time = end.tv_sec * 1000000 + end.tv_usec;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Elapsed: &quot;</span> &lt;&lt; <span class=\"hljs-string\">end_time - start_time; // in microsec</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"chrono\"><a href=\"#chrono\" class=\"headerlink\" title=\"chrono\"></a>chrono</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-keyword\">auto</span> start_time = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>();<br>... <span class=\"hljs-comment\">// code</span><br><span class=\"hljs-keyword\">auto</span> end_time = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>();<br>std::chrono::duration&lt;<span class=\"hljs-type\">double</span>&gt; diff = end_time - start_time;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Elapsed: &quot;</span> &lt;&lt; diff.<span class=\"hljs-built_in\">count</span>(); <span class=\"hljs-comment\">// in seconds</span><br>cout &lt;&lt; std::chrono::<span class=\"hljs-built_in\">duration_cast</span>&lt;milli&gt;(diff).<span class=\"hljs-built_in\">count</span>(); <span class=\"hljs-comment\">// in ms</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"User-Time\"><a href=\"#User-Time\" class=\"headerlink\" title=\"User Time\"></a>User Time</h2><h3 id=\"chrono-1\"><a href=\"#chrono-1\" class=\"headerlink\" title=\"chrono\"></a>chrono</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-type\">clock_t</span> start_time = std::<span class=\"hljs-built_in\">clock</span>();<br>... <span class=\"hljs-comment\">// code</span><br><span class=\"hljs-type\">clock_t</span> end_time = std::<span class=\"hljs-built_in\">clock</span>();<br><span class=\"hljs-type\">float</span> diff = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(end_time - start_time) / CLOCKS_PER_SEC;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Elapsed: &quot;</span> &lt;&lt; diff; <span class=\"hljs-comment\">// in seconds</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"系统调用-包含内核时间的计算方法\"><a href=\"#系统调用-包含内核时间的计算方法\" class=\"headerlink\" title=\"系统调用(包含内核时间的计算方法)\"></a>系统调用(包含内核时间的计算方法)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/times.h&gt;</span></span><br><span class=\"hljs-keyword\">struct</span> ::tms start_time, end_time;<br>::<span class=\"hljs-built_in\">times</span>(&amp;start_time);<br>... <span class=\"hljs-comment\">// code</span><br>::<span class=\"hljs-built_in\">times</span>(&amp;end_time);<br><span class=\"hljs-keyword\">auto</span> user_diff = end_time.tmus_utime - start_time.tms_utime;<br><span class=\"hljs-keyword\">auto</span> sys_diff = end_time.tms_stime - start_time.tms_stime;<br><span class=\"hljs-type\">float</span> user = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(user_diff) / ::<span class=\"hljs-built_in\">sysconf</span>(_SC_CLK_TCK);<br><span class=\"hljs-type\">float</span> sys = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(sys_diff) / ::<span class=\"hljs-built_in\">sysconf</span>(_SC_CLK_TCK);<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;user time: &quot;</span> &lt;&lt; user; <span class=\"hljs-comment\">// in seconds</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;system time: &quot;</span> &lt;&lt; sys; <span class=\"hljs-comment\">// in seconds</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tuple&gt;</span></span><br><span class=\"hljs-function\">std::tuple&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">float</span>, <span class=\"hljs-type\">char</span>&gt; <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>&#125;; &#125;<br><span class=\"hljs-function\">std::tuple&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">tuple1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">2.2f</span>)</span></span>;<br><span class=\"hljs-keyword\">auto</span> tuple2 = std::<span class=\"hljs-built_in\">make_tuple</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">1.5f</span>);<br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(tuple1); <span class=\"hljs-comment\">// print 3</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(tuple1); <span class=\"hljs-comment\">// print &#x27;c&#x27;</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(tuple1); <span class=\"hljs-comment\">// print 2.2f</span><br>cout &lt;&lt; (tuple1 &gt; tuple2); <span class=\"hljs-comment\">// print true</span><br><span class=\"hljs-keyword\">auto</span> concat = std::<span class=\"hljs-built_in\">tuple_cat</span>(tuple1, tuple2);<br>cout &lt;&lt; std::tuple_size&lt;<span class=\"hljs-keyword\">decltype</span>(concat)&gt;::value; <span class=\"hljs-comment\">// print 6</span><br><span class=\"hljs-keyword\">using</span> T = std::tuple_element&lt;<span class=\"hljs-number\">4</span>, <span class=\"hljs-keyword\">decltype</span>(concat)&gt;::type; <span class=\"hljs-comment\">// T is int</span><br><span class=\"hljs-type\">int</span> value1; <span class=\"hljs-type\">float</span> value2;<br>std::<span class=\"hljs-built_in\">tie</span>(value1, value2, std::ignore) = <span class=\"hljs-built_in\">f</span>();<span class=\"hljs-comment\">//creates a tuple of references to its arguments</span><br>std::<span class=\"hljs-built_in\">swap</span>(tuple1,tuple2);<br></code></pre></td></tr></table></figure>\n<h1 id=\"variant-c-17\"><a href=\"#variant-c-17\" class=\"headerlink\" title=\"variant(c++17)\"></a>variant(c++17)</h1><p>代替联合体union，类型安全(切换类型前会自动析构)，见<a href=\"https://en.cppreference.com/w/cpp/utility/variant\">variant</a></p>\n<ul>\n<li>构造：<code>std::variant&lt;int, float&gt; tmp</code></li>\n<li>获取类型个数：<code>std::variant_size_v&lt;decltype(tmp)&gt; // 2</code></li>\n<li>获取下标：<code>tmp = 3.2; tmp.index() // 1</code></li>\n<li>判断当前值类型：<code>hold_alternative&lt;float&gt; tmp // true</code></li>\n<li>获取当前值类型：<code>static_assert(std::is_same_v&lt;int, variant_alternative_t&lt;0, tmp&gt;&gt;) // int</code></li>\n</ul>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-built_in\">std</span>::variant&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">float</span>, <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">string</span>&gt; tmp;<br>tmp = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br><span class=\"hljs-built_in\">std</span>::get&lt;<span class=\"hljs-type\">int</span>&gt;(tmp); <span class=\"hljs-comment\">// throw exception</span><br><span class=\"hljs-type\">int</span>* s = <span class=\"hljs-built_in\">std</span>::get_if&lt;<span class=\"hljs-type\">int</span>&gt;(tmp); <span class=\"hljs-comment\">// no throw, but return null</span><br><span class=\"hljs-built_in\">string</span> g = <span class=\"hljs-built_in\">std</span>::get&lt;<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">string</span>&gt;(tmp); <span class=\"hljs-comment\">//success</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"visitor\"><a href=\"#visitor\" class=\"headerlink\" title=\"visitor\"></a>visitor</h2><p>It is also possible to query the index at run-time depending on the type currently being held by providing a visitor</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;variant&gt;</span></span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Visitor</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; value)</span> </span>&#123; value *= <span class=\"hljs-number\">2</span>; &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span>&amp; value)</span> </span>&#123; value += <span class=\"hljs-number\">3.0f</span>; &#125; <span class=\"hljs-comment\">// &lt;--</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span>&amp; value)</span> </span>&#123; value = <span class=\"hljs-literal\">true</span>; &#125;<br>&#125;;<br><span class=\"hljs-function\">std::variant&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">float</span>, <span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3.3f</span>)</span></span>;<br>std::<span class=\"hljs-built_in\">visit</span>(v, Visitor&#123;&#125;);<br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-type\">float</span>&gt;(v); <span class=\"hljs-comment\">// 6.3f</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"optional\"><a href=\"#optional\" class=\"headerlink\" title=\"optional\"></a>optional</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;optional&gt;</span></span><br><span class=\"hljs-function\">std::optional&lt;std::string&gt; <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* set, <span class=\"hljs-type\">char</span> value)</span> </span>&#123;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br><span class=\"hljs-keyword\">if</span> (set[i] == value)<br><span class=\"hljs-keyword\">return</span> i;<br>&#125;<br><span class=\"hljs-keyword\">return</span> &#123;&#125;; <span class=\"hljs-comment\">// std::nullopt;</span><br>&#125;<br>=============================<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;optional&gt;</span></span><br><span class=\"hljs-type\">char</span> set[] = <span class=\"hljs-string\">&quot;sdfslgfsdg&quot;</span>;<br><span class=\"hljs-keyword\">auto</span> x = <span class=\"hljs-built_in\">find</span>(set, <span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// &#x27;a&#x27; is not present</span><br><span class=\"hljs-keyword\">if</span> (!x)<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;not found&quot;</span>;<br><span class=\"hljs-keyword\">if</span> (!x.<span class=\"hljs-built_in\">has_value</span>())<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;not found&quot;</span>;<br><span class=\"hljs-keyword\">auto</span> y = <span class=\"hljs-built_in\">find</span>(set, <span class=\"hljs-string\">&#x27;l&#x27;</span>);<br>cout &lt;&lt; *y &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; y.<span class=\"hljs-built_in\">value</span>(); <span class=\"hljs-comment\">// print &#x27;4&#x27; &#x27;4&#x27;</span><br>x.<span class=\"hljs-built_in\">value_or</span>(<span class=\"hljs-number\">-1</span>); <span class=\"hljs-comment\">// returns &#x27;-1&#x27;</span><br>y.<span class=\"hljs-built_in\">value_or</span>(<span class=\"hljs-number\">-1</span>); <span class=\"hljs-comment\">// returns &#x27;4&#x27;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;any&gt;</span></span><br>std::any var = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// int</span><br>cout &lt;&lt; var.<span class=\"hljs-built_in\">type</span>().<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &#x27;i&#x27;</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">any_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(var);<br><span class=\"hljs-comment\">// cout &lt;&lt; std::any_cast&lt;float&gt;(var); // exception!!</span><br>var = <span class=\"hljs-number\">3.14</span>; <span class=\"hljs-comment\">// double</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">any_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(var);<br>var.<span class=\"hljs-built_in\">reset</span>();<br>cout &lt;&lt; var.<span class=\"hljs-built_in\">has_value</span>(); <span class=\"hljs-comment\">// print &#x27;false&#x27;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"stacktrace-c-23\"><a href=\"#stacktrace-c-23\" class=\"headerlink\" title=\"stacktrace(c++23)\"></a>stacktrace(c++23)</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;print&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stacktrace&gt;</span> <span class=\"hljs-comment\">// the program must be linked with the library</span></span><br><span class=\"hljs-comment\">// -lstdc++_libbacktrace</span><br><span class=\"hljs-comment\">// (-lstdc++exp with gcc-14 trunk)</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-keyword\">auto</span> call_stack = std::stacktrace::<span class=\"hljs-built_in\">current</span>();<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; entry : call_stack)<br>std::<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;&#123;&#125;\\n&quot;</span>, entry);<span class=\"hljs-comment\">//entry.description()entry.source_file(),entry.source_line()</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-built_in\">g</span>(); &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-built_in\">f</span>(); &#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"filesystem-c-17\"><a href=\"#filesystem-c-17\" class=\"headerlink\" title=\"filesystem(c++17)\"></a>filesystem(c++17)</h1><ul>\n<li>Follow the Boost filesystem library</li>\n<li>Based on POSIX</li>\n<li>Fully-supported from clang 7, gcc 8, etc.</li>\n<li>Work on Windows, Linux, Android, etc.</li>\n</ul>\n<h2 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h2><h3 id=\"member-function\"><a href=\"#member-function\" class=\"headerlink\" title=\"member function\"></a>member function</h3><ul>\n<li>root_name()</li>\n<li>relative_path()</li>\n<li>parent_path()</li>\n<li>filename()</li>\n<li>extension()</li>\n</ul>\n<h3 id=\"method\"><a href=\"#method\" class=\"headerlink\" title=\"method\"></a>method</h3><ul>\n<li>exists(path)</li>\n<li>file_size(path)</li>\n<li>is_directory(path)</li>\n<li>is_empty(path)</li>\n<li>is_regular_file(path):return true if path is no dir,hard link,soft link</li>\n<li>copy(path1, path2)</li>\n<li>copy_file(src_path, src_path, [fs::copy_options::recursive])</li>\n<li>create_directory(path)</li>\n<li>remove(path):remove a file or empty directory</li>\n<li>remove_all(path)</li>\n<li>rename(old_path,new_path)</li>\n</ul>\n<h2 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">namespace</span> fs = std::filesystem;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; path : fs::<span class=\"hljs-built_in\">directory_iterator</span>(<span class=\"hljs-string\">&quot;/usr/tmp/&quot;</span>))<br>cout &lt;&lt; path &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; path : fs::<span class=\"hljs-built_in\">recursive_directory_iterator</span>(<span class=\"hljs-string\">&quot;/usr/tmp/&quot;</span>))<br>cout &lt;&lt; path &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;filesystem&gt;</span> <span class=\"hljs-comment\">// required</span></span><br><span class=\"hljs-keyword\">namespace</span> fs = std::filesystem;<br>fs::path p1 = <span class=\"hljs-string\">&quot;/usr/tmp/my_file.txt&quot;</span>;<br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">exists</span>(); <span class=\"hljs-comment\">// true</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">parent_path</span>(); <span class=\"hljs-comment\">// &quot;/usr/tmp/&quot;</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">filename</span>(); <span class=\"hljs-comment\">// &quot;my_file&quot;</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">extension</span>(); <span class=\"hljs-comment\">// &quot;txt&quot;</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">is_directory</span>(); <span class=\"hljs-comment\">// false</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">is_regular_file</span>(); <span class=\"hljs-comment\">// true</span><br>fs::<span class=\"hljs-built_in\">create_directory</span>(<span class=\"hljs-string\">&quot;/my_dir/&quot;</span>);<br>fs::<span class=\"hljs-built_in\">copy</span>(p1.<span class=\"hljs-built_in\">parent_path</span>(), <span class=\"hljs-string\">&quot;/my_dir/&quot;</span>, fs::copy_options::recursive);<br>fs::<span class=\"hljs-built_in\">copy_file</span>(p1, <span class=\"hljs-string\">&quot;/my_dir/my_file2.txt&quot;</span>);<br>fs::<span class=\"hljs-built_in\">remove</span>(p1);<br>fs::<span class=\"hljs-built_in\">remove_all</span>(p1.<span class=\"hljs-built_in\">parent_path</span>());<br></code></pre></td></tr></table></figure>\n<h1 id=\"多线程库\"><a href=\"#多线程库\" class=\"headerlink\" title=\"多线程库\"></a>多线程库</h1><h2 id=\"thread\"><a href=\"#thread\" class=\"headerlink\" title=\"thread\"></a>thread</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;thread&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> id)</span> </span>&#123;<br>std::cout &lt;&lt; <span class=\"hljs-string\">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>std::vector&lt;std::thread&gt; thread_vect; <span class=\"hljs-comment\">// thread vector</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>thread_vect.<span class=\"hljs-built_in\">push_back</span>( std::<span class=\"hljs-built_in\">thread</span>(&amp;f, i) );<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span>&amp; th : thread_vect)<br>th.<span class=\"hljs-built_in\">join</span>();<br>thread_vect.<span class=\"hljs-built_in\">clear</span>();<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123; <span class=\"hljs-comment\">// thread + lambda expression</span><br>thread_vect.<span class=\"hljs-built_in\">push_back</span>(<br>std::<span class=\"hljs-built_in\">thread</span>( []()&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;thread\\n&quot;</span>; &#125; );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">类别</th>\n<th align=\"center\">函数</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">库函数</td>\n<td align=\"center\"><code>std::this_thread::get_id()</code></td>\n<td align=\"center\">返回线程id</td>\n</tr>\n<tr>\n<td align=\"center\">库函数</td>\n<td align=\"center\"><code>std::this_thread::sleep_for(sleep_duration)</code></td>\n<td align=\"center\">blocks the thread</td>\n</tr>\n<tr>\n<td align=\"center\">库函数</td>\n<td align=\"center\"><code>std::thread::hardware_concurrency()</code></td>\n<td align=\"center\">returns the number of concurrent threads supported by the implementation</td>\n</tr>\n<tr>\n<td align=\"center\">对象方法</td>\n<td align=\"center\"><code>get_id()</code></td>\n<td align=\"center\">returns the thread id</td>\n</tr>\n<tr>\n<td align=\"center\">对象方法</td>\n<td align=\"center\"><code>join()</code></td>\n<td align=\"center\">waits for a thread to finish its execution</td>\n</tr>\n<tr>\n<td align=\"center\">对象方法</td>\n<td align=\"center\"><code>detach()</code></td>\n<td align=\"center\">permits the thread to execute independently of the thread handle</td>\n</tr>\n</tbody></table>\n<h2 id=\"mutex\"><a href=\"#mutex\" class=\"headerlink\" title=\"mutex\"></a>mutex</h2><h2 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h2><h2 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h2><p>The future library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;future&gt;</span> <span class=\"hljs-comment\">// numeric, algorithm, vector, iostream</span></span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> RandomIt&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">parallel_sum</span><span class=\"hljs-params\">(RandomIt beg, RandomIt end)</span> </span>&#123;<br><span class=\"hljs-keyword\">auto</span> len = end - beg;<br><span class=\"hljs-keyword\">if</span> (len &lt; <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// base case</span><br><span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">accumulate</span>(beg, end, <span class=\"hljs-number\">0</span>);<br>RandomIt mid = beg + len / <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">auto</span> handle = std::<span class=\"hljs-built_in\">async</span>(std::launch::async, <span class=\"hljs-comment\">// right side</span><br>parallel_sum&lt;RandomIt&gt;, mid, end);<br><span class=\"hljs-type\">int</span> sum = <span class=\"hljs-built_in\">parallel_sum</span>(beg, mid); <span class=\"hljs-comment\">// left side</span><br><span class=\"hljs-keyword\">return</span> sum + handle.<span class=\"hljs-built_in\">get</span>(); <span class=\"hljs-comment\">// left + right</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10000</span>, <span class=\"hljs-number\">1</span>)</span></span>; <span class=\"hljs-comment\">// init all to 1</span><br>std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The sum is &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">parallel_sum</span>(v.<span class=\"hljs-built_in\">begin</span>(), v.<span class=\"hljs-built_in\">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>std::future methods:<br>• T get() returns the result<br>• wait() waits for the result to become available<br>async() can be called with two launch policies for a task executed:<br>• std::launch::async a new thread is launched to execute the task asynchronously<br>• std::launch::deferred the task is executed on the calling thread the first time its result is requested (lazy evaluation)</p>\n","excerpt":"","more":"<h1 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h1><table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">c.resize(n)</td>\n<td align=\"center\">调整c的大小为n个元素。要么多出的元素被丢弃,要么新添加默认值的元素</td>\n</tr>\n<tr>\n<td align=\"center\">c.resize(n,t)</td>\n<td align=\"center\">调整c的大小为n个元素。任何新添加的元素初始为t</td>\n</tr>\n<tr>\n<td align=\"center\">c.shrink_to_fit()</td>\n<td align=\"center\">只适用于vector,string和deque。将capacity()减少与size()相同大小</td>\n</tr>\n<tr>\n<td align=\"center\">c.capacity()</td>\n<td align=\"center\">只适用于vector和string,返回c可以保存多少元素</td>\n</tr>\n<tr>\n<td align=\"center\">c.reserve(n)</td>\n<td align=\"center\">只适用于vector和string,分配至少容纳n个元素的内存空间</td>\n</tr>\n<tr>\n<td align=\"center\">c.assign(i1)</td>\n<td align=\"center\">将c中的元素全部替换为i1元素,i1可以和c类型不同,但元素必须相同,甚至可以是map与set类型</td>\n</tr>\n<tr>\n<td align=\"center\">c.assign(n,t)</td>\n<td align=\"center\">将c中的元素全部换为n个t</td>\n</tr>\n</tbody></table>\n<h1 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h1><p>格式:<code>priority_queue&lt;Type,Container,Functional&gt;</code><br>例子:<code>priority_queue&lt;int,vector&lt;int&gt;,myCompare&gt;</code>,myCompare可以替换为less<int>降序,greater<int>升序</p>\n<h1 id=\"数学相关\"><a href=\"#数学相关\" class=\"headerlink\" title=\"数学相关\"></a>数学相关</h1><h2 id=\"cmath\"><a href=\"#cmath\" class=\"headerlink\" title=\"cmath\"></a>cmath</h2><ul>\n<li>fabs(x) computes absolute value, |x|, C++11</li>\n<li>exp(x) returns e raised to the given powerx</li>\n<li>exp2(x) returns 2 raised to the given power , C++11</li>\n<li>log(x) computes natural (base e) logarithm, loge (x)</li>\n<li>log10(x) computes base 10 logarithm, log10(x)</li>\n<li>log2(x) computes base 2 logarithm, log2 (x), C++11</li>\n<li>pow(x, y) raises a number to the given power, x y</li>\n<li>sqrt(x) computes square root</li>\n<li>cqrt(x) computes cubic root x, C++11</li>\n<li>sin(x) computes sine, sin(x)</li>\n<li>cos(x) computes cosine, cos(x)</li>\n<li>tan(x) computes tangent, tan(x)</li>\n<li>ceil(x) nearest integer not less than the given value, ⌈x⌉</li>\n<li>floor(x) nearest integer not greater than the given value, ⌊x⌋</li>\n<li>atan2(y,x)</li>\n<li>atan(y)</li>\n<li>asin()</li>\n<li>acos()</li>\n<li>round|lround|llround(x) nearest integer(x+0.5),  (return type: floating point, long, long long respectivel</li>\n</ul>\n<h2 id=\"limits\"><a href=\"#limits\" class=\"headerlink\" title=\"limits\"></a>limits</h2><ul>\n<li><code>T numeric_limits&lt;T&gt;:: max()</code></li>\n<li><code>T numeric_limits&lt;T&gt;:: min()</code></li>\n<li><code>T numeric_limits&lt;T&gt;:: lowest()</code></li>\n</ul>\n<h2 id=\"numeric-c-20\"><a href=\"#numeric-c-20\" class=\"headerlink\" title=\"numeric(c++20)\"></a>numeric(c++20)</h2><ul>\n<li><code>e</code> Euler number e</li>\n<li><code>pi</code> π</li>\n<li><code>phi</code>黄金分割比率</li>\n<li><code>sqrt2</code></li>\n</ul>\n<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><ul>\n<li>选择随机种子seed(随机引擎的初始值)</li>\n<li>定义随机引擎<code>&lt;type of random engine&gt; generator(seed)</code></li>\n<li>定义分布<code>&lt;type of distribution&gt; distribution(range start, range end)</code></li>\n<li>产生随机数<code>distribution(generator)</code></li>\n</ul>\n<h2 id=\"产生种子\"><a href=\"#产生种子\" class=\"headerlink\" title=\"产生种子\"></a>产生种子</h2><ul>\n<li>自定义：<code>unsigned seed = 2</code>,注意相同种子，产生的随机序列是一样的</li>\n<li>使用时间<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-type\">unsigned</span> seed = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>()<br>.<span class=\"hljs-built_in\">time_since_epoch</span>().<span class=\"hljs-built_in\">count</span>();<br><span class=\"hljs-function\">std::default_random_engine <span class=\"hljs-title\">generator</span><span class=\"hljs-params\">(seed)</span></span>;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用random-device\"><a href=\"#使用random-device\" class=\"headerlink\" title=\"使用random_device\"></a>使用random_device</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span></span><br>std::random_device rnd_device;<br><span class=\"hljs-function\">std::default_random_engine <span class=\"hljs-title\">generator</span><span class=\"hljs-params\">(rnd_device())</span></span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用seed-seq\"><a href=\"#使用seed-seq\" class=\"headerlink\" title=\"使用seed seq\"></a>使用seed seq</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-type\">unsigned</span> seed1 = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>()<br>.<span class=\"hljs-built_in\">time_since_epoch</span>().<span class=\"hljs-built_in\">count</span>();<br><span class=\"hljs-type\">unsigned</span> seed2 = seed1 + <span class=\"hljs-number\">1000</span>;<br>std::seed_seq seq1&#123; seed1, seed2 &#125;;<br><span class=\"hljs-function\">std::default_random_engine <span class=\"hljs-title\">generator1</span><span class=\"hljs-params\">(seq)</span></span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"bit\"><a href=\"#bit\" class=\"headerlink\" title=\"bit\"></a>bit</h2><p>以下方法支持bitwise，性能更好<br>rotate left : std::rotl<br>rotate right : std::rotr<br>count leading zero : std::countl zero<br>count leading one : std::countl one<br>count trailing zero : std::countr zero<br>count trailing one : std::countr one<br>population count : std::popcount</p>\n<h2 id=\"随机引擎\"><a href=\"#随机引擎\" class=\"headerlink\" title=\"随机引擎\"></a>随机引擎</h2><p>三种随机引擎的对比</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Generator</th>\n<th align=\"center\">Quality</th>\n<th align=\"center\">Period</th>\n<th align=\"center\">Randomness</th>\n<th align=\"center\">C++引擎</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Linear Congruential</td>\n<td align=\"center\">Poor</td>\n<td align=\"center\">10^9</td>\n<td align=\"center\">Statistical tests</td>\n<td align=\"center\">std::minstd_rand,std::minstd_rand0,std::knuth_b</td>\n</tr>\n<tr>\n<td align=\"center\">Mersenne Twister 32&#x2F;64-bit</td>\n<td align=\"center\">High</td>\n<td align=\"center\">10^6000</td>\n<td align=\"center\">Statistical tests</td>\n<td align=\"center\">std::mt19937,std::19937_64</td>\n</tr>\n<tr>\n<td align=\"center\">Subtract-with-carry 24&#x2F;48-bit</td>\n<td align=\"center\">Highest</td>\n<td align=\"center\">10^171</td>\n<td align=\"center\">Mathematically proven</td>\n<td align=\"center\">std::ranlux24_base,std::ranlux48_base,std::ranlux24,std::ranlux48</td>\n</tr>\n</tbody></table>\n<h2 id=\"分布\"><a href=\"#分布\" class=\"headerlink\" title=\"分布\"></a>分布</h2><ul>\n<li><code>uniform int distribution&lt;T&gt;(range start, range end)</code> where T is integral type</li>\n<li><code>uniform real distribution&lt;T&gt;(range start, range end)</code> where T is floating point type</li>\n<li><code>normal distribution&lt;T&gt;(mean, std dev)</code>where T is floating point type</li>\n<li><code>exponential distribution&lt;T&gt;(lambda)</code>where T is floating point type</li>\n</ul>\n<h1 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h1><ul>\n<li><code>Wall-Clock/Real time</code> It is the human perception of the passage of time from the start to the completion of a task(整个程序的时间)</li>\n<li><code>User/CPU time</code> The amount of time spent by the CPU to compute in user code(用户空间的执行时间)</li>\n<li><code>System time</code> The amount of time spent by the CPU to compute system calls (including I&#x2F;O calls) executed into kernel code(内核消耗的时间)<br>如果程序是但线程并且系统负载不高则有：<br>Wall-clock time &#x3D; User time + System time</li>\n</ul>\n<h2 id=\"Real-Time\"><a href=\"#Real-Time\" class=\"headerlink\" title=\"Real Time\"></a>Real Time</h2><h3 id=\"linux系统调用\"><a href=\"#linux系统调用\" class=\"headerlink\" title=\"linux系统调用\"></a>linux系统调用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># include &lt;time.h&gt; //struct timeval</span><br><span class=\"hljs-comment\"># include &lt;sys/time.h&gt; //gettimeofday()</span><br>struct timeval start, end; // timeval &#123;second, microseconds&#125;<br>::gettimeofday(&amp;start, NULL);<br>... // code<br>::gettimeofday(&amp;end, NULL);<br>long start_time = start.tv_sec * 1000000 + start.tv_usec;<br>long end_time = end.tv_sec * 1000000 + end.tv_usec;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Elapsed: &quot;</span> &lt;&lt; <span class=\"hljs-string\">end_time - start_time; // in microsec</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"chrono\"><a href=\"#chrono\" class=\"headerlink\" title=\"chrono\"></a>chrono</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-keyword\">auto</span> start_time = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>();<br>... <span class=\"hljs-comment\">// code</span><br><span class=\"hljs-keyword\">auto</span> end_time = std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>();<br>std::chrono::duration&lt;<span class=\"hljs-type\">double</span>&gt; diff = end_time - start_time;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Elapsed: &quot;</span> &lt;&lt; diff.<span class=\"hljs-built_in\">count</span>(); <span class=\"hljs-comment\">// in seconds</span><br>cout &lt;&lt; std::chrono::<span class=\"hljs-built_in\">duration_cast</span>&lt;milli&gt;(diff).<span class=\"hljs-built_in\">count</span>(); <span class=\"hljs-comment\">// in ms</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"User-Time\"><a href=\"#User-Time\" class=\"headerlink\" title=\"User Time\"></a>User Time</h2><h3 id=\"chrono-1\"><a href=\"#chrono-1\" class=\"headerlink\" title=\"chrono\"></a>chrono</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span><br><span class=\"hljs-type\">clock_t</span> start_time = std::<span class=\"hljs-built_in\">clock</span>();<br>... <span class=\"hljs-comment\">// code</span><br><span class=\"hljs-type\">clock_t</span> end_time = std::<span class=\"hljs-built_in\">clock</span>();<br><span class=\"hljs-type\">float</span> diff = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(end_time - start_time) / CLOCKS_PER_SEC;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Elapsed: &quot;</span> &lt;&lt; diff; <span class=\"hljs-comment\">// in seconds</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"系统调用-包含内核时间的计算方法\"><a href=\"#系统调用-包含内核时间的计算方法\" class=\"headerlink\" title=\"系统调用(包含内核时间的计算方法)\"></a>系统调用(包含内核时间的计算方法)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/times.h&gt;</span></span><br><span class=\"hljs-keyword\">struct</span> ::tms start_time, end_time;<br>::<span class=\"hljs-built_in\">times</span>(&amp;start_time);<br>... <span class=\"hljs-comment\">// code</span><br>::<span class=\"hljs-built_in\">times</span>(&amp;end_time);<br><span class=\"hljs-keyword\">auto</span> user_diff = end_time.tmus_utime - start_time.tms_utime;<br><span class=\"hljs-keyword\">auto</span> sys_diff = end_time.tms_stime - start_time.tms_stime;<br><span class=\"hljs-type\">float</span> user = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(user_diff) / ::<span class=\"hljs-built_in\">sysconf</span>(_SC_CLK_TCK);<br><span class=\"hljs-type\">float</span> sys = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(sys_diff) / ::<span class=\"hljs-built_in\">sysconf</span>(_SC_CLK_TCK);<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;user time: &quot;</span> &lt;&lt; user; <span class=\"hljs-comment\">// in seconds</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;system time: &quot;</span> &lt;&lt; sys; <span class=\"hljs-comment\">// in seconds</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tuple&gt;</span></span><br><span class=\"hljs-function\">std::tuple&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">float</span>, <span class=\"hljs-type\">char</span>&gt; <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>&#125;; &#125;<br><span class=\"hljs-function\">std::tuple&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">tuple1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">2.2f</span>)</span></span>;<br><span class=\"hljs-keyword\">auto</span> tuple2 = std::<span class=\"hljs-built_in\">make_tuple</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">1.5f</span>);<br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(tuple1); <span class=\"hljs-comment\">// print 3</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(tuple1); <span class=\"hljs-comment\">// print &#x27;c&#x27;</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(tuple1); <span class=\"hljs-comment\">// print 2.2f</span><br>cout &lt;&lt; (tuple1 &gt; tuple2); <span class=\"hljs-comment\">// print true</span><br><span class=\"hljs-keyword\">auto</span> concat = std::<span class=\"hljs-built_in\">tuple_cat</span>(tuple1, tuple2);<br>cout &lt;&lt; std::tuple_size&lt;<span class=\"hljs-keyword\">decltype</span>(concat)&gt;::value; <span class=\"hljs-comment\">// print 6</span><br><span class=\"hljs-keyword\">using</span> T = std::tuple_element&lt;<span class=\"hljs-number\">4</span>, <span class=\"hljs-keyword\">decltype</span>(concat)&gt;::type; <span class=\"hljs-comment\">// T is int</span><br><span class=\"hljs-type\">int</span> value1; <span class=\"hljs-type\">float</span> value2;<br>std::<span class=\"hljs-built_in\">tie</span>(value1, value2, std::ignore) = <span class=\"hljs-built_in\">f</span>();<span class=\"hljs-comment\">//creates a tuple of references to its arguments</span><br>std::<span class=\"hljs-built_in\">swap</span>(tuple1,tuple2);<br></code></pre></td></tr></table></figure>\n<h1 id=\"variant-c-17\"><a href=\"#variant-c-17\" class=\"headerlink\" title=\"variant(c++17)\"></a>variant(c++17)</h1><p>代替联合体union，类型安全(切换类型前会自动析构)，见<a href=\"https://en.cppreference.com/w/cpp/utility/variant\">variant</a></p>\n<ul>\n<li>构造：<code>std::variant&lt;int, float&gt; tmp</code></li>\n<li>获取类型个数：<code>std::variant_size_v&lt;decltype(tmp)&gt; // 2</code></li>\n<li>获取下标：<code>tmp = 3.2; tmp.index() // 1</code></li>\n<li>判断当前值类型：<code>hold_alternative&lt;float&gt; tmp // true</code></li>\n<li>获取当前值类型：<code>static_assert(std::is_same_v&lt;int, variant_alternative_t&lt;0, tmp&gt;&gt;) // int</code></li>\n</ul>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-built_in\">std</span>::variant&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">float</span>, <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">string</span>&gt; tmp;<br>tmp = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br><span class=\"hljs-built_in\">std</span>::get&lt;<span class=\"hljs-type\">int</span>&gt;(tmp); <span class=\"hljs-comment\">// throw exception</span><br><span class=\"hljs-type\">int</span>* s = <span class=\"hljs-built_in\">std</span>::get_if&lt;<span class=\"hljs-type\">int</span>&gt;(tmp); <span class=\"hljs-comment\">// no throw, but return null</span><br><span class=\"hljs-built_in\">string</span> g = <span class=\"hljs-built_in\">std</span>::get&lt;<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">string</span>&gt;(tmp); <span class=\"hljs-comment\">//success</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"visitor\"><a href=\"#visitor\" class=\"headerlink\" title=\"visitor\"></a>visitor</h2><p>It is also possible to query the index at run-time depending on the type currently being held by providing a visitor</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;variant&gt;</span></span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Visitor</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; value)</span> </span>&#123; value *= <span class=\"hljs-number\">2</span>; &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span>&amp; value)</span> </span>&#123; value += <span class=\"hljs-number\">3.0f</span>; &#125; <span class=\"hljs-comment\">// &lt;--</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span>&amp; value)</span> </span>&#123; value = <span class=\"hljs-literal\">true</span>; &#125;<br>&#125;;<br><span class=\"hljs-function\">std::variant&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">float</span>, <span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3.3f</span>)</span></span>;<br>std::<span class=\"hljs-built_in\">visit</span>(v, Visitor&#123;&#125;);<br>cout &lt;&lt; std::<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-type\">float</span>&gt;(v); <span class=\"hljs-comment\">// 6.3f</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"optional\"><a href=\"#optional\" class=\"headerlink\" title=\"optional\"></a>optional</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;optional&gt;</span></span><br><span class=\"hljs-function\">std::optional&lt;std::string&gt; <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* set, <span class=\"hljs-type\">char</span> value)</span> </span>&#123;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br><span class=\"hljs-keyword\">if</span> (set[i] == value)<br><span class=\"hljs-keyword\">return</span> i;<br>&#125;<br><span class=\"hljs-keyword\">return</span> &#123;&#125;; <span class=\"hljs-comment\">// std::nullopt;</span><br>&#125;<br>=============================<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;optional&gt;</span></span><br><span class=\"hljs-type\">char</span> set[] = <span class=\"hljs-string\">&quot;sdfslgfsdg&quot;</span>;<br><span class=\"hljs-keyword\">auto</span> x = <span class=\"hljs-built_in\">find</span>(set, <span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// &#x27;a&#x27; is not present</span><br><span class=\"hljs-keyword\">if</span> (!x)<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;not found&quot;</span>;<br><span class=\"hljs-keyword\">if</span> (!x.<span class=\"hljs-built_in\">has_value</span>())<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;not found&quot;</span>;<br><span class=\"hljs-keyword\">auto</span> y = <span class=\"hljs-built_in\">find</span>(set, <span class=\"hljs-string\">&#x27;l&#x27;</span>);<br>cout &lt;&lt; *y &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; y.<span class=\"hljs-built_in\">value</span>(); <span class=\"hljs-comment\">// print &#x27;4&#x27; &#x27;4&#x27;</span><br>x.<span class=\"hljs-built_in\">value_or</span>(<span class=\"hljs-number\">-1</span>); <span class=\"hljs-comment\">// returns &#x27;-1&#x27;</span><br>y.<span class=\"hljs-built_in\">value_or</span>(<span class=\"hljs-number\">-1</span>); <span class=\"hljs-comment\">// returns &#x27;4&#x27;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;any&gt;</span></span><br>std::any var = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// int</span><br>cout &lt;&lt; var.<span class=\"hljs-built_in\">type</span>().<span class=\"hljs-built_in\">name</span>(); <span class=\"hljs-comment\">// print &#x27;i&#x27;</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">any_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(var);<br><span class=\"hljs-comment\">// cout &lt;&lt; std::any_cast&lt;float&gt;(var); // exception!!</span><br>var = <span class=\"hljs-number\">3.14</span>; <span class=\"hljs-comment\">// double</span><br>cout &lt;&lt; std::<span class=\"hljs-built_in\">any_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(var);<br>var.<span class=\"hljs-built_in\">reset</span>();<br>cout &lt;&lt; var.<span class=\"hljs-built_in\">has_value</span>(); <span class=\"hljs-comment\">// print &#x27;false&#x27;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"stacktrace-c-23\"><a href=\"#stacktrace-c-23\" class=\"headerlink\" title=\"stacktrace(c++23)\"></a>stacktrace(c++23)</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;print&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stacktrace&gt;</span> <span class=\"hljs-comment\">// the program must be linked with the library</span></span><br><span class=\"hljs-comment\">// -lstdc++_libbacktrace</span><br><span class=\"hljs-comment\">// (-lstdc++exp with gcc-14 trunk)</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-keyword\">auto</span> call_stack = std::stacktrace::<span class=\"hljs-built_in\">current</span>();<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; entry : call_stack)<br>std::<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;&#123;&#125;\\n&quot;</span>, entry);<span class=\"hljs-comment\">//entry.description()entry.source_file(),entry.source_line()</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-built_in\">g</span>(); &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-built_in\">f</span>(); &#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"filesystem-c-17\"><a href=\"#filesystem-c-17\" class=\"headerlink\" title=\"filesystem(c++17)\"></a>filesystem(c++17)</h1><ul>\n<li>Follow the Boost filesystem library</li>\n<li>Based on POSIX</li>\n<li>Fully-supported from clang 7, gcc 8, etc.</li>\n<li>Work on Windows, Linux, Android, etc.</li>\n</ul>\n<h2 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h2><h3 id=\"member-function\"><a href=\"#member-function\" class=\"headerlink\" title=\"member function\"></a>member function</h3><ul>\n<li>root_name()</li>\n<li>relative_path()</li>\n<li>parent_path()</li>\n<li>filename()</li>\n<li>extension()</li>\n</ul>\n<h3 id=\"method\"><a href=\"#method\" class=\"headerlink\" title=\"method\"></a>method</h3><ul>\n<li>exists(path)</li>\n<li>file_size(path)</li>\n<li>is_directory(path)</li>\n<li>is_empty(path)</li>\n<li>is_regular_file(path):return true if path is no dir,hard link,soft link</li>\n<li>copy(path1, path2)</li>\n<li>copy_file(src_path, src_path, [fs::copy_options::recursive])</li>\n<li>create_directory(path)</li>\n<li>remove(path):remove a file or empty directory</li>\n<li>remove_all(path)</li>\n<li>rename(old_path,new_path)</li>\n</ul>\n<h2 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">namespace</span> fs = std::filesystem;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; path : fs::<span class=\"hljs-built_in\">directory_iterator</span>(<span class=\"hljs-string\">&quot;/usr/tmp/&quot;</span>))<br>cout &lt;&lt; path &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; path : fs::<span class=\"hljs-built_in\">recursive_directory_iterator</span>(<span class=\"hljs-string\">&quot;/usr/tmp/&quot;</span>))<br>cout &lt;&lt; path &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;filesystem&gt;</span> <span class=\"hljs-comment\">// required</span></span><br><span class=\"hljs-keyword\">namespace</span> fs = std::filesystem;<br>fs::path p1 = <span class=\"hljs-string\">&quot;/usr/tmp/my_file.txt&quot;</span>;<br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">exists</span>(); <span class=\"hljs-comment\">// true</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">parent_path</span>(); <span class=\"hljs-comment\">// &quot;/usr/tmp/&quot;</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">filename</span>(); <span class=\"hljs-comment\">// &quot;my_file&quot;</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">extension</span>(); <span class=\"hljs-comment\">// &quot;txt&quot;</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">is_directory</span>(); <span class=\"hljs-comment\">// false</span><br>cout &lt;&lt; p1.<span class=\"hljs-built_in\">is_regular_file</span>(); <span class=\"hljs-comment\">// true</span><br>fs::<span class=\"hljs-built_in\">create_directory</span>(<span class=\"hljs-string\">&quot;/my_dir/&quot;</span>);<br>fs::<span class=\"hljs-built_in\">copy</span>(p1.<span class=\"hljs-built_in\">parent_path</span>(), <span class=\"hljs-string\">&quot;/my_dir/&quot;</span>, fs::copy_options::recursive);<br>fs::<span class=\"hljs-built_in\">copy_file</span>(p1, <span class=\"hljs-string\">&quot;/my_dir/my_file2.txt&quot;</span>);<br>fs::<span class=\"hljs-built_in\">remove</span>(p1);<br>fs::<span class=\"hljs-built_in\">remove_all</span>(p1.<span class=\"hljs-built_in\">parent_path</span>());<br></code></pre></td></tr></table></figure>\n<h1 id=\"多线程库\"><a href=\"#多线程库\" class=\"headerlink\" title=\"多线程库\"></a>多线程库</h1><h2 id=\"thread\"><a href=\"#thread\" class=\"headerlink\" title=\"thread\"></a>thread</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;thread&gt;</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> id)</span> </span>&#123;<br>std::cout &lt;&lt; <span class=\"hljs-string\">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>std::vector&lt;std::thread&gt; thread_vect; <span class=\"hljs-comment\">// thread vector</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>thread_vect.<span class=\"hljs-built_in\">push_back</span>( std::<span class=\"hljs-built_in\">thread</span>(&amp;f, i) );<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span>&amp; th : thread_vect)<br>th.<span class=\"hljs-built_in\">join</span>();<br>thread_vect.<span class=\"hljs-built_in\">clear</span>();<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123; <span class=\"hljs-comment\">// thread + lambda expression</span><br>thread_vect.<span class=\"hljs-built_in\">push_back</span>(<br>std::<span class=\"hljs-built_in\">thread</span>( []()&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;thread\\n&quot;</span>; &#125; );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">类别</th>\n<th align=\"center\">函数</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">库函数</td>\n<td align=\"center\"><code>std::this_thread::get_id()</code></td>\n<td align=\"center\">返回线程id</td>\n</tr>\n<tr>\n<td align=\"center\">库函数</td>\n<td align=\"center\"><code>std::this_thread::sleep_for(sleep_duration)</code></td>\n<td align=\"center\">blocks the thread</td>\n</tr>\n<tr>\n<td align=\"center\">库函数</td>\n<td align=\"center\"><code>std::thread::hardware_concurrency()</code></td>\n<td align=\"center\">returns the number of concurrent threads supported by the implementation</td>\n</tr>\n<tr>\n<td align=\"center\">对象方法</td>\n<td align=\"center\"><code>get_id()</code></td>\n<td align=\"center\">returns the thread id</td>\n</tr>\n<tr>\n<td align=\"center\">对象方法</td>\n<td align=\"center\"><code>join()</code></td>\n<td align=\"center\">waits for a thread to finish its execution</td>\n</tr>\n<tr>\n<td align=\"center\">对象方法</td>\n<td align=\"center\"><code>detach()</code></td>\n<td align=\"center\">permits the thread to execute independently of the thread handle</td>\n</tr>\n</tbody></table>\n<h2 id=\"mutex\"><a href=\"#mutex\" class=\"headerlink\" title=\"mutex\"></a>mutex</h2><h2 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h2><h2 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h2><p>The future library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;future&gt;</span> <span class=\"hljs-comment\">// numeric, algorithm, vector, iostream</span></span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> RandomIt&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">parallel_sum</span><span class=\"hljs-params\">(RandomIt beg, RandomIt end)</span> </span>&#123;<br><span class=\"hljs-keyword\">auto</span> len = end - beg;<br><span class=\"hljs-keyword\">if</span> (len &lt; <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// base case</span><br><span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">accumulate</span>(beg, end, <span class=\"hljs-number\">0</span>);<br>RandomIt mid = beg + len / <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">auto</span> handle = std::<span class=\"hljs-built_in\">async</span>(std::launch::async, <span class=\"hljs-comment\">// right side</span><br>parallel_sum&lt;RandomIt&gt;, mid, end);<br><span class=\"hljs-type\">int</span> sum = <span class=\"hljs-built_in\">parallel_sum</span>(beg, mid); <span class=\"hljs-comment\">// left side</span><br><span class=\"hljs-keyword\">return</span> sum + handle.<span class=\"hljs-built_in\">get</span>(); <span class=\"hljs-comment\">// left + right</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10000</span>, <span class=\"hljs-number\">1</span>)</span></span>; <span class=\"hljs-comment\">// init all to 1</span><br>std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The sum is &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">parallel_sum</span>(v.<span class=\"hljs-built_in\">begin</span>(), v.<span class=\"hljs-built_in\">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>std::future methods:<br>• T get() returns the result<br>• wait() waits for the result to become available<br>async() can be called with two launch policies for a task executed:<br>• std::launch::async a new thread is launched to execute the task asynchronously<br>• std::launch::deferred the task is executed on the calling thread the first time its result is requested (lazy evaluation)</p>\n"},{"title":"Dockerfile","date":"2022-04-04T02:33:38.000Z","subtitle":null,"banner_img":"/images/dockerfile.jpg","index_img":"/images/dockerfile.jpg","_content":"## 简介\nDockerfile是一个文本文件，其内包含了一条条指令，**每条指令构建一层**\n- `#`进行注释\n- `\\`末尾进行换行，RUN执行多条命令十分有用\n## docker build--构建镜像\n- **格式：**`docker build [选项] [上下文路径/URL/-]`\n\n|选项|含义|\n|:-:|:-:|\n|-t [reposity:tag]|指明镜像名称和tag|\n|-f [dockerfile]|指定dockerfile，非主流，默认文件名为`Dockerfile`，且位于上下文路径中|\n|--target \\<some img\\>|多阶段构建时，指定只构建某个镜像，而不是默认的最后一个|\n\n### 上下文路径\n- docker build命令其实是与服务器（即docker.service）通信，它会将上下文路径下的所有内容上传，而不是在本地进行构建的\n- 支持`.dockerignore`文件，剔除不需要的内容\n### 其他构建法\n- Git repo:`docker build -t hello-world https://github.com/docker-library/hello-world.git`\n- tar包:`docker build http://server/context.tar.gz`\n- 标准输入：`docker build - < Dockerfile`或`cat Dockerfile| docker build -`(直接从标准输入读取，没有上下文，不可用依赖上下文的命令COPY等等)\n- 标准输入+tar包：`docker build - < context.tar.gz`会自动解压，将里面视为上下文\n## docker import-从rootfs压缩包导入(无需Dockerfile)\n- **格式：**`docker import [选项] <文件>|<URL>|- [<仓库名>[:<标签>]]`\n- **例子：**\n```bash\n$ docker import \\\n    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\\n    openvz/ubuntu:16.04\n```\n## docker save和docker load\n是一种古老的保存和加载镜像的方法，已经非主流，实在没网，使用内网私有的Registry\n### docker save\n- 本质上是建立归档文件:`docker save [some image] -o [some file]`\n- 使用压缩：`docker save [some image] | gzip > xx.tar.gz`\n### docker load\n`docker load -i some_file.tar.gz`\n## FROM指定基础镜像\n- **格式：**`FROM [image]`\n- FROM是必备的指令，且必须是第一条\n- 如果你想以空白镜像为基础，你可以这样`FROM scratch`\n- 尽量小尺寸（推荐Alpine）\n## RUN执行命令\n- **格式：**`RUN [command]`\n- 执行多条命令：使用`\\`和`&&`，如下\n  ```bash\n\tRUN apt-get update \\\n\t&& apt-get install vim\n  ```\n- 永远不要`apt upgrade`，而是使用：\n```bash\nRUN apt-get update && apt-get install -y \\\n    aufs-tools \\\n    s3cmd=1.1.* \\\n && rm -rf /var/lib/apt/lists/*\n```\n## COPY复制文件\n- **格式：**`COPY [--chown=<user>:<group>] <源路径>... <目标路径>`\n- **作用：**将从构建上下文目录中的路径复制的新的一层的镜像内的目标路径的位置，支持通配符，如果目录不存在会创建缺失的目录\n- 如果源路径为文件夹，复制的时候不是复制该文件夹，而是将文件夹中的内容复制到目标路径\n- `--from=[some]`:多阶段构建时，指定从某个镜像获取，而不是当前上下文\n- 不要一次copy多个文件，这会使一层的缓存过大\n## ADD更高级的复制文件\n- **说明：**和COPY格式和性质基本一致,但是功能更多(不代表更好，只有自动解压缩时，使用该命令)：\n1) 源路径可以是以个URL,文件权限自动设置为600,更改权限需要再加一层调整,另外如果下载是个压缩包，需要再加一层解压缩\n2) 如果源路径是个tar压缩文件(gzip,bzip2,xz)，会自动解压缩文件\n## CMD容器启动命令\n- **格式1：**`CMD [\"可执行文件\"，\"参数1\"，\"参数2\"...]`(推荐使用这个，也支持bash格式，但会包装一层`sh -c`)\n- **格式2：**`CMD [\"参数1\",\"参数2\"]`,在指定了`ENTRYPOINT`后，可以直接指定参数\n- **作用：**容器就是进程，该命令就是指定容器所运行默认的程序及参数,例如ubuntu的CMD就是`/bin/bash`,当然可以在命令行中用其他命令替换。\n- **注意：**\n1) 启动程序就是容器的应用进程，容器就是为了主进程存在的，主进程退出，容器就会退出，辅助进程不是它所关心的。所以必须是前台进程，例如`CMD service nginx start`被理解为`CMD [\"sh\",\"-c\",\"service nginx start\"]`,因此当sh进程结束，它就会结束。当然即使你用格式1清楚指明service为可执行程序也是不行的，正确做法是指明前台形式运行： `CMD [\"nginx\",\"-g\",\"daemon off;\"]`\n2) 整个Dockerfile应该只出现一次该命令\n## ENTRYPOINT入口点\n**说明：**该命令和CMD一样，都是指定容器启动程序及参数，不过有下面几点需要注意：\n1) 在运行时也可以替代，不过要加个`--entrypoint`指定\n2) 当指定了`ENTRYPOINT`后，CMD的内容将作为参数传给`ENTRYPOINT`\n3) 整个Dockerfile应该只出现一次该命令\n**应用场景：**\n1) 让镜像变成像命令一样使用:\n```bash\nFROM ubuntu:18.04\nRUN apt-get update \\\n    && apt-get install -y curl \\\n    && rm -rf /var/lib/apt/lists/*\nCMD [ \"curl\", \"-s\", \"http://myip.ipip.net\" ]\n```\n如果我们希望显示http头信息，需要加上-i参数,`docker run myip -i`是行不通的，而必须用`$ docker run myip curl -s http://myip.ipip.net -i`，显然很繁琐，如果把上面内容的CMD改成ENTRYPOINT，就可以使用`docker run myip -i`，此时CMD的内容是`-i`\n2) 应用运行前的准备工作。\n## ENV设置环境变量(容器运行时，这些环境变量保持有效)\n- **格式：**`ENV <key> <value>`\n- 如果key或value有空格，用`\"`括起来,可以用`\\`换行\n- 下列指令可以支持环境变量展开：`ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。`\n## ARG构建参数(容器运行时，这些参数无效)\n- **格式：**`ARG <参数名>[=<默认值>]`\n- **说明：**定义参数名称及其默认值，该默认值可以在构建命令中用`--build-arg <参数名>=<值>`来覆盖\n- ARG指令有生效范围，如果在FROM指令之前指定，那么只能用于每个FROM指令中。多阶段中使用这些变量必须在每个阶段分别指定\n## VOLUME定义匿名卷\n- **格式：**`VOLUME [\"<路径1>\",\"<路径2>\"...]`\n- **说明：**路径1等目录会在容器运行时默认自动挂载为匿名卷，任何向指定路径中写入的信息都不会记录进容器存储层。\n- 运行容器时可以覆盖这个挂载配置`$ docker run -d -v mydata:/data xxxx`，这里就用了mydata这个命名卷挂载到了/data这个位置，替代了Dockerfile中定义的匿名卷挂载配置\n## EXPOSE声明端口\n- **格式：**`EXPOSE <端口1> <端口2> ...`\n- **作用：**这只是个声明，并不会开启这个端口的服务，主要帮助镜像使用者理解这个镜像服务的守护端口，方便映射，另外-P选项，会自动随机映射EXPOSE的端口，要想映射端口请使用-p选项\n## WORKDIR指定工作目录\n- **格式：**`WORKDIR <工作目录路径>`\n- **作用：**指定当前目录，以后各层的当前目录就改为指定目录，如果目录不存在，会自动建立，若指定相对路径，则是在之前工作目录的基础上的。\n- **注意：**单独一层cd不会影响之后的一层，因为一层一层是独立的，应该用WORKDIR\n## USER指定当前用户\n- **格式：**`USER <用户名>[:<用户组>]`\n- **作用：**改变之后层的命令执行的身份，这个用户身份必须存在\n## HEALTHCHECK健康检查\n- **格式1：**`HEALTHCHECK [选项] CMD <命令>`设置检查容器健康状况的命令\n- **格式2：**`HEALTHCHECK NONE`如果基础镜像有健康检查指令，使用这个可以屏蔽其健康检查指令\n- **历史原因：**在没有该命令之前，docker通过主进程是否退出来判断是否异常，这忽略了一种情形，如果程序进入死锁或死循环，就不会检查出错误\n- **功能作用：**当一个镜像指定了HEALTHCHECK指令后，启动容器的初始状态会是starting,在HEALTHCHECK指令检查成功后变为healthy,如果连续一定次数失败，则为unhealthy,**整个Dockerfile应该只出现一次该命令**\n- **选项：**\n\n|选项|含义|\n|:-:|:-:|\n|--interval=<间隔>|两次健康检查的间隔，默认为30秒|\n|--timeout=<时长>|健康检查命令运行超时时间，默认为30秒|\n|--retries=<次数>|当连续失败指定次数后，则将认定为unhealthy，默认为3次|\n\n## LABEL指令\n- **格式：**`LABEL <key>=<value> <key>=<value> <key>=<value> ...`\n- **作用：**给镜像以键值对的形式添加些元数据，如镜像的作者、文档地址等\n```bash\nLABEL org.opencontainers.image.authors=\"yeasy\"\nLABEL org.opencontainers.image.documentation=\"https://yeasy.gitbooks.io\"\n```\n## SHELL指令\n- **格式：**`SHELL [\"executable\", \"parameters\"]`\n- **作用：**指定RUN、ENTRYPOINT、CMD指令的shell,默认为`[\"/bin/sh\",\"-c\"]`,其中ENTRYPOINT,CMD只有以shell格式指定时，才起作用\n## ONBUILD为他人做嫁衣\n- **格式：**`ONBUILD <其他指令>`\n- **作用：**它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。\n- 这常常应用于基础镜像，例如npm包管理\n## 多阶段构建\n1) 之前多阶段构建一种方式把所有东西放在一个Dockerfile中，但这会造成层次太多，镜像体积过大，部署时间变长，源代码存在泄露问题，如下：\n```bash\nFROM golang:alpine\n\nRUN apk --no-cache add git ca-certificates\n\nWORKDIR /go/src/github.com/go/helloworld/\n\nCOPY app.go .\n\nRUN go get -d -v github.com/go-sql-driver/mysql \\\n  && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \\\n  && cp /go/src/github.com/go/helloworld/app /root\n\nWORKDIR /root/\n\nCMD [\"./app\"]\n```\n2) 第二种方式分散多个Dockerfile，然后再写脚本整合，虽然镜像体积较小，但过程较复杂：\n```bash\n# 构建dockerfile-->Dockerfile.build\nFROM golang:alpine\n\nRUN apk --no-cache add git\n\nWORKDIR /go/src/github.com/go/helloworld\n\nCOPY app.go .\n\nRUN go get -d -v github.com/go-sql-driver/mysql \\\n  && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\n# 部署dockerfile-->Dockerfile.copy\nFROM alpine:latest\n\nRUN apk --no-cache add ca-certificates\n\nWORKDIR /root/\n\nCOPY app .\n\nCMD [\"./app\"]\n# 整合脚本--> build.sh\n#!/bin/sh\necho Building go/helloworld:build\n\ndocker build -t go/helloworld:build . -f Dockerfile.build\n\ndocker create --name extract go/helloworld:build\ndocker cp extract:/go/src/github.com/go/helloworld/app ./app\ndocker rm -f extract\n\necho Building go/helloworld:2\n\ndocker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy\nrm ./app\n```\n3) 更加高效的方式\n```bash\nFROM golang:alpine as builder\n\nRUN apk --no-cache add git\n\nWORKDIR /go/src/github.com/go/helloworld/\n\nRUN go get -d -v github.com/go-sql-driver/mysql\n\nCOPY app.go .\n\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\n\nFROM alpine:latest as prod\n\nRUN apk --no-cache add ca-certificates\n\nWORKDIR /root/\n\n# 这里的0代表上个阶段的镜像,当然可以指定其他镜像如`--from=nginx:latest`\nCOPY --from=0 /go/src/github.com/go/helloworld/app .\n\nCMD [\"./app\"]\n```\n可以只构建某个阶段的镜像`$ docker build --target builder -t username/imagename:tag .`\n## docker manifest--多系统架构支持\n- **背景：**使用镜像创建一个容器，该镜像必须与Docker宿主机架构一致（Windows、macOS除外，在x86_64系统上，这两个系统可以运行arm等其他架构），为了支持多个架构，必须提供两个架构版本的镜像，manifest命令就是支持自动识别宿主机架构，然后拉取合适的镜像。\n### 构建镜像\n在两个架构上构建两个镜像\n### 创建manifest列表\n```bash\n# $ docker manifest create MANIFEST_LIST MANIFEST [MANIFEST...]\n$ docker manifest create username/test \\\n      username/x8664-test \\\n      username/arm64v8-test\n```\n当需要修改时加个-a或--amend参数\n### 设置manifest列表\n```bash\n# $ docker manifest annotate [OPTIONS] MANIFEST_LIST MANIFEST\n$ docker manifest annotate username/test \\\n      username/x8664-test \\\n      --os linux --arch x86_64\n\n$ docker manifest annotate username/test \\\n      username/arm64v8-test \\\n      --os linux --arch arm64 --variant v8\n```\n### 查看manifest支持列表\n`docker manifest inspect username/test`\n### 推送manifest列表\n`docker manifest push username/test`\n## tips\n- 如果想以root临时执行一个命令，不要使用su、sudo,而是使用gosu,见如下例子：\n```bash\n# 建立 redis 用户，并使用 gosu 换另一个用户执行命令\nRUN groupadd -r redis && useradd -r -g redis redis\n# 下载 gosu\nRUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64\" \\\n    && chmod +x /usr/local/bin/gosu \\\n    && gosu nobody true\n# 设置 CMD，并以另外的用户执行\nCMD [ \"exec\", \"gosu\", \"redis\", \"redis-server\" ]\n```\n","source":"_posts/Dockerfile.md","raw":"---\ntitle: Dockerfile\ndate: 2022-04-04 10:33:38\nsubtitle:\ncategories:\ntags:\nbanner_img: /images/dockerfile.jpg\nindex_img: /images/dockerfile.jpg\n---\n## 简介\nDockerfile是一个文本文件，其内包含了一条条指令，**每条指令构建一层**\n- `#`进行注释\n- `\\`末尾进行换行，RUN执行多条命令十分有用\n## docker build--构建镜像\n- **格式：**`docker build [选项] [上下文路径/URL/-]`\n\n|选项|含义|\n|:-:|:-:|\n|-t [reposity:tag]|指明镜像名称和tag|\n|-f [dockerfile]|指定dockerfile，非主流，默认文件名为`Dockerfile`，且位于上下文路径中|\n|--target \\<some img\\>|多阶段构建时，指定只构建某个镜像，而不是默认的最后一个|\n\n### 上下文路径\n- docker build命令其实是与服务器（即docker.service）通信，它会将上下文路径下的所有内容上传，而不是在本地进行构建的\n- 支持`.dockerignore`文件，剔除不需要的内容\n### 其他构建法\n- Git repo:`docker build -t hello-world https://github.com/docker-library/hello-world.git`\n- tar包:`docker build http://server/context.tar.gz`\n- 标准输入：`docker build - < Dockerfile`或`cat Dockerfile| docker build -`(直接从标准输入读取，没有上下文，不可用依赖上下文的命令COPY等等)\n- 标准输入+tar包：`docker build - < context.tar.gz`会自动解压，将里面视为上下文\n## docker import-从rootfs压缩包导入(无需Dockerfile)\n- **格式：**`docker import [选项] <文件>|<URL>|- [<仓库名>[:<标签>]]`\n- **例子：**\n```bash\n$ docker import \\\n    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\\n    openvz/ubuntu:16.04\n```\n## docker save和docker load\n是一种古老的保存和加载镜像的方法，已经非主流，实在没网，使用内网私有的Registry\n### docker save\n- 本质上是建立归档文件:`docker save [some image] -o [some file]`\n- 使用压缩：`docker save [some image] | gzip > xx.tar.gz`\n### docker load\n`docker load -i some_file.tar.gz`\n## FROM指定基础镜像\n- **格式：**`FROM [image]`\n- FROM是必备的指令，且必须是第一条\n- 如果你想以空白镜像为基础，你可以这样`FROM scratch`\n- 尽量小尺寸（推荐Alpine）\n## RUN执行命令\n- **格式：**`RUN [command]`\n- 执行多条命令：使用`\\`和`&&`，如下\n  ```bash\n\tRUN apt-get update \\\n\t&& apt-get install vim\n  ```\n- 永远不要`apt upgrade`，而是使用：\n```bash\nRUN apt-get update && apt-get install -y \\\n    aufs-tools \\\n    s3cmd=1.1.* \\\n && rm -rf /var/lib/apt/lists/*\n```\n## COPY复制文件\n- **格式：**`COPY [--chown=<user>:<group>] <源路径>... <目标路径>`\n- **作用：**将从构建上下文目录中的路径复制的新的一层的镜像内的目标路径的位置，支持通配符，如果目录不存在会创建缺失的目录\n- 如果源路径为文件夹，复制的时候不是复制该文件夹，而是将文件夹中的内容复制到目标路径\n- `--from=[some]`:多阶段构建时，指定从某个镜像获取，而不是当前上下文\n- 不要一次copy多个文件，这会使一层的缓存过大\n## ADD更高级的复制文件\n- **说明：**和COPY格式和性质基本一致,但是功能更多(不代表更好，只有自动解压缩时，使用该命令)：\n1) 源路径可以是以个URL,文件权限自动设置为600,更改权限需要再加一层调整,另外如果下载是个压缩包，需要再加一层解压缩\n2) 如果源路径是个tar压缩文件(gzip,bzip2,xz)，会自动解压缩文件\n## CMD容器启动命令\n- **格式1：**`CMD [\"可执行文件\"，\"参数1\"，\"参数2\"...]`(推荐使用这个，也支持bash格式，但会包装一层`sh -c`)\n- **格式2：**`CMD [\"参数1\",\"参数2\"]`,在指定了`ENTRYPOINT`后，可以直接指定参数\n- **作用：**容器就是进程，该命令就是指定容器所运行默认的程序及参数,例如ubuntu的CMD就是`/bin/bash`,当然可以在命令行中用其他命令替换。\n- **注意：**\n1) 启动程序就是容器的应用进程，容器就是为了主进程存在的，主进程退出，容器就会退出，辅助进程不是它所关心的。所以必须是前台进程，例如`CMD service nginx start`被理解为`CMD [\"sh\",\"-c\",\"service nginx start\"]`,因此当sh进程结束，它就会结束。当然即使你用格式1清楚指明service为可执行程序也是不行的，正确做法是指明前台形式运行： `CMD [\"nginx\",\"-g\",\"daemon off;\"]`\n2) 整个Dockerfile应该只出现一次该命令\n## ENTRYPOINT入口点\n**说明：**该命令和CMD一样，都是指定容器启动程序及参数，不过有下面几点需要注意：\n1) 在运行时也可以替代，不过要加个`--entrypoint`指定\n2) 当指定了`ENTRYPOINT`后，CMD的内容将作为参数传给`ENTRYPOINT`\n3) 整个Dockerfile应该只出现一次该命令\n**应用场景：**\n1) 让镜像变成像命令一样使用:\n```bash\nFROM ubuntu:18.04\nRUN apt-get update \\\n    && apt-get install -y curl \\\n    && rm -rf /var/lib/apt/lists/*\nCMD [ \"curl\", \"-s\", \"http://myip.ipip.net\" ]\n```\n如果我们希望显示http头信息，需要加上-i参数,`docker run myip -i`是行不通的，而必须用`$ docker run myip curl -s http://myip.ipip.net -i`，显然很繁琐，如果把上面内容的CMD改成ENTRYPOINT，就可以使用`docker run myip -i`，此时CMD的内容是`-i`\n2) 应用运行前的准备工作。\n## ENV设置环境变量(容器运行时，这些环境变量保持有效)\n- **格式：**`ENV <key> <value>`\n- 如果key或value有空格，用`\"`括起来,可以用`\\`换行\n- 下列指令可以支持环境变量展开：`ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。`\n## ARG构建参数(容器运行时，这些参数无效)\n- **格式：**`ARG <参数名>[=<默认值>]`\n- **说明：**定义参数名称及其默认值，该默认值可以在构建命令中用`--build-arg <参数名>=<值>`来覆盖\n- ARG指令有生效范围，如果在FROM指令之前指定，那么只能用于每个FROM指令中。多阶段中使用这些变量必须在每个阶段分别指定\n## VOLUME定义匿名卷\n- **格式：**`VOLUME [\"<路径1>\",\"<路径2>\"...]`\n- **说明：**路径1等目录会在容器运行时默认自动挂载为匿名卷，任何向指定路径中写入的信息都不会记录进容器存储层。\n- 运行容器时可以覆盖这个挂载配置`$ docker run -d -v mydata:/data xxxx`，这里就用了mydata这个命名卷挂载到了/data这个位置，替代了Dockerfile中定义的匿名卷挂载配置\n## EXPOSE声明端口\n- **格式：**`EXPOSE <端口1> <端口2> ...`\n- **作用：**这只是个声明，并不会开启这个端口的服务，主要帮助镜像使用者理解这个镜像服务的守护端口，方便映射，另外-P选项，会自动随机映射EXPOSE的端口，要想映射端口请使用-p选项\n## WORKDIR指定工作目录\n- **格式：**`WORKDIR <工作目录路径>`\n- **作用：**指定当前目录，以后各层的当前目录就改为指定目录，如果目录不存在，会自动建立，若指定相对路径，则是在之前工作目录的基础上的。\n- **注意：**单独一层cd不会影响之后的一层，因为一层一层是独立的，应该用WORKDIR\n## USER指定当前用户\n- **格式：**`USER <用户名>[:<用户组>]`\n- **作用：**改变之后层的命令执行的身份，这个用户身份必须存在\n## HEALTHCHECK健康检查\n- **格式1：**`HEALTHCHECK [选项] CMD <命令>`设置检查容器健康状况的命令\n- **格式2：**`HEALTHCHECK NONE`如果基础镜像有健康检查指令，使用这个可以屏蔽其健康检查指令\n- **历史原因：**在没有该命令之前，docker通过主进程是否退出来判断是否异常，这忽略了一种情形，如果程序进入死锁或死循环，就不会检查出错误\n- **功能作用：**当一个镜像指定了HEALTHCHECK指令后，启动容器的初始状态会是starting,在HEALTHCHECK指令检查成功后变为healthy,如果连续一定次数失败，则为unhealthy,**整个Dockerfile应该只出现一次该命令**\n- **选项：**\n\n|选项|含义|\n|:-:|:-:|\n|--interval=<间隔>|两次健康检查的间隔，默认为30秒|\n|--timeout=<时长>|健康检查命令运行超时时间，默认为30秒|\n|--retries=<次数>|当连续失败指定次数后，则将认定为unhealthy，默认为3次|\n\n## LABEL指令\n- **格式：**`LABEL <key>=<value> <key>=<value> <key>=<value> ...`\n- **作用：**给镜像以键值对的形式添加些元数据，如镜像的作者、文档地址等\n```bash\nLABEL org.opencontainers.image.authors=\"yeasy\"\nLABEL org.opencontainers.image.documentation=\"https://yeasy.gitbooks.io\"\n```\n## SHELL指令\n- **格式：**`SHELL [\"executable\", \"parameters\"]`\n- **作用：**指定RUN、ENTRYPOINT、CMD指令的shell,默认为`[\"/bin/sh\",\"-c\"]`,其中ENTRYPOINT,CMD只有以shell格式指定时，才起作用\n## ONBUILD为他人做嫁衣\n- **格式：**`ONBUILD <其他指令>`\n- **作用：**它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。\n- 这常常应用于基础镜像，例如npm包管理\n## 多阶段构建\n1) 之前多阶段构建一种方式把所有东西放在一个Dockerfile中，但这会造成层次太多，镜像体积过大，部署时间变长，源代码存在泄露问题，如下：\n```bash\nFROM golang:alpine\n\nRUN apk --no-cache add git ca-certificates\n\nWORKDIR /go/src/github.com/go/helloworld/\n\nCOPY app.go .\n\nRUN go get -d -v github.com/go-sql-driver/mysql \\\n  && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \\\n  && cp /go/src/github.com/go/helloworld/app /root\n\nWORKDIR /root/\n\nCMD [\"./app\"]\n```\n2) 第二种方式分散多个Dockerfile，然后再写脚本整合，虽然镜像体积较小，但过程较复杂：\n```bash\n# 构建dockerfile-->Dockerfile.build\nFROM golang:alpine\n\nRUN apk --no-cache add git\n\nWORKDIR /go/src/github.com/go/helloworld\n\nCOPY app.go .\n\nRUN go get -d -v github.com/go-sql-driver/mysql \\\n  && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\n# 部署dockerfile-->Dockerfile.copy\nFROM alpine:latest\n\nRUN apk --no-cache add ca-certificates\n\nWORKDIR /root/\n\nCOPY app .\n\nCMD [\"./app\"]\n# 整合脚本--> build.sh\n#!/bin/sh\necho Building go/helloworld:build\n\ndocker build -t go/helloworld:build . -f Dockerfile.build\n\ndocker create --name extract go/helloworld:build\ndocker cp extract:/go/src/github.com/go/helloworld/app ./app\ndocker rm -f extract\n\necho Building go/helloworld:2\n\ndocker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy\nrm ./app\n```\n3) 更加高效的方式\n```bash\nFROM golang:alpine as builder\n\nRUN apk --no-cache add git\n\nWORKDIR /go/src/github.com/go/helloworld/\n\nRUN go get -d -v github.com/go-sql-driver/mysql\n\nCOPY app.go .\n\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\n\nFROM alpine:latest as prod\n\nRUN apk --no-cache add ca-certificates\n\nWORKDIR /root/\n\n# 这里的0代表上个阶段的镜像,当然可以指定其他镜像如`--from=nginx:latest`\nCOPY --from=0 /go/src/github.com/go/helloworld/app .\n\nCMD [\"./app\"]\n```\n可以只构建某个阶段的镜像`$ docker build --target builder -t username/imagename:tag .`\n## docker manifest--多系统架构支持\n- **背景：**使用镜像创建一个容器，该镜像必须与Docker宿主机架构一致（Windows、macOS除外，在x86_64系统上，这两个系统可以运行arm等其他架构），为了支持多个架构，必须提供两个架构版本的镜像，manifest命令就是支持自动识别宿主机架构，然后拉取合适的镜像。\n### 构建镜像\n在两个架构上构建两个镜像\n### 创建manifest列表\n```bash\n# $ docker manifest create MANIFEST_LIST MANIFEST [MANIFEST...]\n$ docker manifest create username/test \\\n      username/x8664-test \\\n      username/arm64v8-test\n```\n当需要修改时加个-a或--amend参数\n### 设置manifest列表\n```bash\n# $ docker manifest annotate [OPTIONS] MANIFEST_LIST MANIFEST\n$ docker manifest annotate username/test \\\n      username/x8664-test \\\n      --os linux --arch x86_64\n\n$ docker manifest annotate username/test \\\n      username/arm64v8-test \\\n      --os linux --arch arm64 --variant v8\n```\n### 查看manifest支持列表\n`docker manifest inspect username/test`\n### 推送manifest列表\n`docker manifest push username/test`\n## tips\n- 如果想以root临时执行一个命令，不要使用su、sudo,而是使用gosu,见如下例子：\n```bash\n# 建立 redis 用户，并使用 gosu 换另一个用户执行命令\nRUN groupadd -r redis && useradd -r -g redis redis\n# 下载 gosu\nRUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64\" \\\n    && chmod +x /usr/local/bin/gosu \\\n    && gosu nobody true\n# 设置 CMD，并以另外的用户执行\nCMD [ \"exec\", \"gosu\", \"redis\", \"redis-server\" ]\n```\n","slug":"Dockerfile","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi6t0007gwq22xo27h1a","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dockerfile是一个文本文件，其内包含了一条条指令，<strong>每条指令构建一层</strong></p>\n<ul>\n<li><code>#</code>进行注释</li>\n<li><code>\\</code>末尾进行换行，RUN执行多条命令十分有用</li>\n</ul>\n<h2 id=\"docker-build–构建镜像\"><a href=\"#docker-build–构建镜像\" class=\"headerlink\" title=\"docker build–构建镜像\"></a>docker build–构建镜像</h2><ul>\n<li><strong>格式：</strong><code>docker build [选项] [上下文路径/URL/-]</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-t [reposity:tag]</td>\n<td align=\"center\">指明镜像名称和tag</td>\n</tr>\n<tr>\n<td align=\"center\">-f [dockerfile]</td>\n<td align=\"center\">指定dockerfile，非主流，默认文件名为<code>Dockerfile</code>，且位于上下文路径中</td>\n</tr>\n<tr>\n<td align=\"center\">–target &lt;some img&gt;</td>\n<td align=\"center\">多阶段构建时，指定只构建某个镜像，而不是默认的最后一个</td>\n</tr>\n</tbody></table>\n<h3 id=\"上下文路径\"><a href=\"#上下文路径\" class=\"headerlink\" title=\"上下文路径\"></a>上下文路径</h3><ul>\n<li>docker build命令其实是与服务器（即docker.service）通信，它会将上下文路径下的所有内容上传，而不是在本地进行构建的</li>\n<li>支持<code>.dockerignore</code>文件，剔除不需要的内容</li>\n</ul>\n<h3 id=\"其他构建法\"><a href=\"#其他构建法\" class=\"headerlink\" title=\"其他构建法\"></a>其他构建法</h3><ul>\n<li>Git repo:<code>docker build -t hello-world https://github.com/docker-library/hello-world.git</code></li>\n<li>tar包:<code>docker build http://server/context.tar.gz</code></li>\n<li>标准输入：<code>docker build - &lt; Dockerfile</code>或<code>cat Dockerfile| docker build -</code>(直接从标准输入读取，没有上下文，不可用依赖上下文的命令COPY等等)</li>\n<li>标准输入+tar包：<code>docker build - &lt; context.tar.gz</code>会自动解压，将里面视为上下文</li>\n</ul>\n<h2 id=\"docker-import-从rootfs压缩包导入-无需Dockerfile\"><a href=\"#docker-import-从rootfs压缩包导入-无需Dockerfile\" class=\"headerlink\" title=\"docker import-从rootfs压缩包导入(无需Dockerfile)\"></a>docker import-从rootfs压缩包导入(无需Dockerfile)</h2><ul>\n<li><strong>格式：</strong><code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></li>\n<li><strong>例子：</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ docker import \\<br>    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\<br>    openvz/ubuntu:16.04<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"docker-save和docker-load\"><a href=\"#docker-save和docker-load\" class=\"headerlink\" title=\"docker save和docker load\"></a>docker save和docker load</h2><p>是一种古老的保存和加载镜像的方法，已经非主流，实在没网，使用内网私有的Registry</p>\n<h3 id=\"docker-save\"><a href=\"#docker-save\" class=\"headerlink\" title=\"docker save\"></a>docker save</h3><ul>\n<li>本质上是建立归档文件:<code>docker save [some image] -o [some file]</code></li>\n<li>使用压缩：<code>docker save [some image] | gzip &gt; xx.tar.gz</code></li>\n</ul>\n<h3 id=\"docker-load\"><a href=\"#docker-load\" class=\"headerlink\" title=\"docker load\"></a>docker load</h3><p><code>docker load -i some_file.tar.gz</code></p>\n<h2 id=\"FROM指定基础镜像\"><a href=\"#FROM指定基础镜像\" class=\"headerlink\" title=\"FROM指定基础镜像\"></a>FROM指定基础镜像</h2><ul>\n<li><strong>格式：</strong><code>FROM [image]</code></li>\n<li>FROM是必备的指令，且必须是第一条</li>\n<li>如果你想以空白镜像为基础，你可以这样<code>FROM scratch</code></li>\n<li>尽量小尺寸（推荐Alpine）</li>\n</ul>\n<h2 id=\"RUN执行命令\"><a href=\"#RUN执行命令\" class=\"headerlink\" title=\"RUN执行命令\"></a>RUN执行命令</h2><ul>\n<li><strong>格式：</strong><code>RUN [command]</code></li>\n<li>执行多条命令：使用<code>\\</code>和<code>&amp;&amp;</code>，如下<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">RUN apt-get update \\<br>&amp;&amp; apt-get install vim<br></code></pre></td></tr></table></figure></li>\n<li>永远不要<code>apt upgrade</code>，而是使用：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">RUN apt-get update &amp;&amp; apt-get install -y \\<br>    aufs-tools \\<br>    s3cmd=1.1.* \\<br> &amp;&amp; <span class=\"hljs-built_in\">rm</span> -rf /var/lib/apt/lists/*<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"COPY复制文件\"><a href=\"#COPY复制文件\" class=\"headerlink\" title=\"COPY复制文件\"></a>COPY复制文件</h2><ul>\n<li><strong>格式：</strong><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>\n<li><strong>作用：</strong>将从构建上下文目录中的路径复制的新的一层的镜像内的目标路径的位置，支持通配符，如果目录不存在会创建缺失的目录</li>\n<li>如果源路径为文件夹，复制的时候不是复制该文件夹，而是将文件夹中的内容复制到目标路径</li>\n<li><code>--from=[some]</code>:多阶段构建时，指定从某个镜像获取，而不是当前上下文</li>\n<li>不要一次copy多个文件，这会使一层的缓存过大</li>\n</ul>\n<h2 id=\"ADD更高级的复制文件\"><a href=\"#ADD更高级的复制文件\" class=\"headerlink\" title=\"ADD更高级的复制文件\"></a>ADD更高级的复制文件</h2><ul>\n<li><strong>说明：</strong>和COPY格式和性质基本一致,但是功能更多(不代表更好，只有自动解压缩时，使用该命令)：</li>\n</ul>\n<ol>\n<li>源路径可以是以个URL,文件权限自动设置为600,更改权限需要再加一层调整,另外如果下载是个压缩包，需要再加一层解压缩</li>\n<li>如果源路径是个tar压缩文件(gzip,bzip2,xz)，会自动解压缩文件</li>\n</ol>\n<h2 id=\"CMD容器启动命令\"><a href=\"#CMD容器启动命令\" class=\"headerlink\" title=\"CMD容器启动命令\"></a>CMD容器启动命令</h2><ul>\n<li><strong>格式1：</strong><code>CMD [&quot;可执行文件&quot;，&quot;参数1&quot;，&quot;参数2&quot;...]</code>(推荐使用这个，也支持bash格式，但会包装一层<code>sh -c</code>)</li>\n<li><strong>格式2：</strong><code>CMD [&quot;参数1&quot;,&quot;参数2&quot;]</code>,在指定了<code>ENTRYPOINT</code>后，可以直接指定参数</li>\n<li><strong>作用：</strong>容器就是进程，该命令就是指定容器所运行默认的程序及参数,例如ubuntu的CMD就是<code>/bin/bash</code>,当然可以在命令行中用其他命令替换。</li>\n<li><strong>注意：</strong></li>\n</ul>\n<ol>\n<li>启动程序就是容器的应用进程，容器就是为了主进程存在的，主进程退出，容器就会退出，辅助进程不是它所关心的。所以必须是前台进程，例如<code>CMD service nginx start</code>被理解为<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;service nginx start&quot;]</code>,因此当sh进程结束，它就会结束。当然即使你用格式1清楚指明service为可执行程序也是不行的，正确做法是指明前台形式运行： <code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></li>\n<li>整个Dockerfile应该只出现一次该命令</li>\n</ol>\n<h2 id=\"ENTRYPOINT入口点\"><a href=\"#ENTRYPOINT入口点\" class=\"headerlink\" title=\"ENTRYPOINT入口点\"></a>ENTRYPOINT入口点</h2><p><strong>说明：</strong>该命令和CMD一样，都是指定容器启动程序及参数，不过有下面几点需要注意：</p>\n<ol>\n<li>在运行时也可以替代，不过要加个<code>--entrypoint</code>指定</li>\n<li>当指定了<code>ENTRYPOINT</code>后，CMD的内容将作为参数传给<code>ENTRYPOINT</code></li>\n<li>整个Dockerfile应该只出现一次该命令<br><strong>应用场景：</strong></li>\n<li>让镜像变成像命令一样使用:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FROM ubuntu:18.04<br>RUN apt-get update \\<br>    &amp;&amp; apt-get install -y curl \\<br>    &amp;&amp; <span class=\"hljs-built_in\">rm</span> -rf /var/lib/apt/lists/*<br>CMD [ <span class=\"hljs-string\">&quot;curl&quot;</span>, <span class=\"hljs-string\">&quot;-s&quot;</span>, <span class=\"hljs-string\">&quot;http://myip.ipip.net&quot;</span> ]<br></code></pre></td></tr></table></figure>\n如果我们希望显示http头信息，需要加上-i参数,<code>docker run myip -i</code>是行不通的，而必须用<code>$ docker run myip curl -s http://myip.ipip.net -i</code>，显然很繁琐，如果把上面内容的CMD改成ENTRYPOINT，就可以使用<code>docker run myip -i</code>，此时CMD的内容是<code>-i</code></li>\n<li>应用运行前的准备工作。</li>\n</ol>\n<h2 id=\"ENV设置环境变量-容器运行时，这些环境变量保持有效\"><a href=\"#ENV设置环境变量-容器运行时，这些环境变量保持有效\" class=\"headerlink\" title=\"ENV设置环境变量(容器运行时，这些环境变量保持有效)\"></a>ENV设置环境变量(容器运行时，这些环境变量保持有效)</h2><ul>\n<li><strong>格式：</strong><code>ENV &lt;key&gt; &lt;value&gt;</code></li>\n<li>如果key或value有空格，用<code>&quot;</code>括起来,可以用<code>\\</code>换行</li>\n<li>下列指令可以支持环境变量展开：<code>ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。</code></li>\n</ul>\n<h2 id=\"ARG构建参数-容器运行时，这些参数无效\"><a href=\"#ARG构建参数-容器运行时，这些参数无效\" class=\"headerlink\" title=\"ARG构建参数(容器运行时，这些参数无效)\"></a>ARG构建参数(容器运行时，这些参数无效)</h2><ul>\n<li><strong>格式：</strong><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li>\n<li><strong>说明：</strong>定义参数名称及其默认值，该默认值可以在构建命令中用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖</li>\n<li>ARG指令有生效范围，如果在FROM指令之前指定，那么只能用于每个FROM指令中。多阶段中使用这些变量必须在每个阶段分别指定</li>\n</ul>\n<h2 id=\"VOLUME定义匿名卷\"><a href=\"#VOLUME定义匿名卷\" class=\"headerlink\" title=\"VOLUME定义匿名卷\"></a>VOLUME定义匿名卷</h2><ul>\n<li><strong>格式：</strong><code>VOLUME [&quot;&lt;路径1&gt;&quot;,&quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><strong>说明：</strong>路径1等目录会在容器运行时默认自动挂载为匿名卷，任何向指定路径中写入的信息都不会记录进容器存储层。</li>\n<li>运行容器时可以覆盖这个挂载配置<code>$ docker run -d -v mydata:/data xxxx</code>，这里就用了mydata这个命名卷挂载到了&#x2F;data这个位置，替代了Dockerfile中定义的匿名卷挂载配置</li>\n</ul>\n<h2 id=\"EXPOSE声明端口\"><a href=\"#EXPOSE声明端口\" class=\"headerlink\" title=\"EXPOSE声明端口\"></a>EXPOSE声明端口</h2><ul>\n<li><strong>格式：</strong><code>EXPOSE &lt;端口1&gt; &lt;端口2&gt; ...</code></li>\n<li><strong>作用：</strong>这只是个声明，并不会开启这个端口的服务，主要帮助镜像使用者理解这个镜像服务的守护端口，方便映射，另外-P选项，会自动随机映射EXPOSE的端口，要想映射端口请使用-p选项</li>\n</ul>\n<h2 id=\"WORKDIR指定工作目录\"><a href=\"#WORKDIR指定工作目录\" class=\"headerlink\" title=\"WORKDIR指定工作目录\"></a>WORKDIR指定工作目录</h2><ul>\n<li><strong>格式：</strong><code>WORKDIR &lt;工作目录路径&gt;</code></li>\n<li><strong>作用：</strong>指定当前目录，以后各层的当前目录就改为指定目录，如果目录不存在，会自动建立，若指定相对路径，则是在之前工作目录的基础上的。</li>\n<li><strong>注意：</strong>单独一层cd不会影响之后的一层，因为一层一层是独立的，应该用WORKDIR</li>\n</ul>\n<h2 id=\"USER指定当前用户\"><a href=\"#USER指定当前用户\" class=\"headerlink\" title=\"USER指定当前用户\"></a>USER指定当前用户</h2><ul>\n<li><strong>格式：</strong><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></li>\n<li><strong>作用：</strong>改变之后层的命令执行的身份，这个用户身份必须存在</li>\n</ul>\n<h2 id=\"HEALTHCHECK健康检查\"><a href=\"#HEALTHCHECK健康检查\" class=\"headerlink\" title=\"HEALTHCHECK健康检查\"></a>HEALTHCHECK健康检查</h2><ul>\n<li><strong>格式1：</strong><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>设置检查容器健康状况的命令</li>\n<li><strong>格式2：</strong><code>HEALTHCHECK NONE</code>如果基础镜像有健康检查指令，使用这个可以屏蔽其健康检查指令</li>\n<li><strong>历史原因：</strong>在没有该命令之前，docker通过主进程是否退出来判断是否异常，这忽略了一种情形，如果程序进入死锁或死循环，就不会检查出错误</li>\n<li><strong>功能作用：</strong>当一个镜像指定了HEALTHCHECK指令后，启动容器的初始状态会是starting,在HEALTHCHECK指令检查成功后变为healthy,如果连续一定次数失败，则为unhealthy,<strong>整个Dockerfile应该只出现一次该命令</strong></li>\n<li><strong>选项：</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–interval&#x3D;&lt;间隔&gt;</td>\n<td align=\"center\">两次健康检查的间隔，默认为30秒</td>\n</tr>\n<tr>\n<td align=\"center\">–timeout&#x3D;&lt;时长&gt;</td>\n<td align=\"center\">健康检查命令运行超时时间，默认为30秒</td>\n</tr>\n<tr>\n<td align=\"center\">–retries&#x3D;&lt;次数&gt;</td>\n<td align=\"center\">当连续失败指定次数后，则将认定为unhealthy，默认为3次</td>\n</tr>\n</tbody></table>\n<h2 id=\"LABEL指令\"><a href=\"#LABEL指令\" class=\"headerlink\" title=\"LABEL指令\"></a>LABEL指令</h2><ul>\n<li><strong>格式：</strong><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li>\n<li><strong>作用：</strong>给镜像以键值对的形式添加些元数据，如镜像的作者、文档地址等<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">LABEL org.opencontainers.image.authors=<span class=\"hljs-string\">&quot;yeasy&quot;</span><br>LABEL org.opencontainers.image.documentation=<span class=\"hljs-string\">&quot;https://yeasy.gitbooks.io&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"SHELL指令\"><a href=\"#SHELL指令\" class=\"headerlink\" title=\"SHELL指令\"></a>SHELL指令</h2><ul>\n<li><strong>格式：</strong><code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></li>\n<li><strong>作用：</strong>指定RUN、ENTRYPOINT、CMD指令的shell,默认为<code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code>,其中ENTRYPOINT,CMD只有以shell格式指定时，才起作用</li>\n</ul>\n<h2 id=\"ONBUILD为他人做嫁衣\"><a href=\"#ONBUILD为他人做嫁衣\" class=\"headerlink\" title=\"ONBUILD为他人做嫁衣\"></a>ONBUILD为他人做嫁衣</h2><ul>\n<li><strong>格式：</strong><code>ONBUILD &lt;其他指令&gt;</code></li>\n<li><strong>作用：</strong>它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</li>\n<li>这常常应用于基础镜像，例如npm包管理</li>\n</ul>\n<h2 id=\"多阶段构建\"><a href=\"#多阶段构建\" class=\"headerlink\" title=\"多阶段构建\"></a>多阶段构建</h2><ol>\n<li>之前多阶段构建一种方式把所有东西放在一个Dockerfile中，但这会造成层次太多，镜像体积过大，部署时间变长，源代码存在泄露问题，如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FROM golang:alpine<br><br>RUN apk --no-cache add git ca-certificates<br><br>WORKDIR /go/src/github.com/go/helloworld/<br><br>COPY app.go .<br><br>RUN go get -d -v github.com/go-sql-driver/mysql \\<br>  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \\<br>  &amp;&amp; <span class=\"hljs-built_in\">cp</span> /go/src/github.com/go/helloworld/app /root<br><br>WORKDIR /root/<br><br>CMD [<span class=\"hljs-string\">&quot;./app&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n<li>第二种方式分散多个Dockerfile，然后再写脚本整合，虽然镜像体积较小，但过程较复杂：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 构建dockerfile--&gt;Dockerfile.build</span><br>FROM golang:alpine<br><br>RUN apk --no-cache add git<br><br>WORKDIR /go/src/github.com/go/helloworld<br><br>COPY app.go .<br><br>RUN go get -d -v github.com/go-sql-driver/mysql \\<br>  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .<br><span class=\"hljs-comment\"># 部署dockerfile--&gt;Dockerfile.copy</span><br>FROM alpine:latest<br><br>RUN apk --no-cache add ca-certificates<br><br>WORKDIR /root/<br><br>COPY app .<br><br>CMD [<span class=\"hljs-string\">&quot;./app&quot;</span>]<br><span class=\"hljs-comment\"># 整合脚本--&gt; build.sh</span><br><span class=\"hljs-comment\">#!/bin/sh</span><br><span class=\"hljs-built_in\">echo</span> Building go/helloworld:build<br><br>docker build -t go/helloworld:build . -f Dockerfile.build<br><br>docker create --name extract go/helloworld:build<br>docker <span class=\"hljs-built_in\">cp</span> extract:/go/src/github.com/go/helloworld/app ./app<br>docker <span class=\"hljs-built_in\">rm</span> -f extract<br><br><span class=\"hljs-built_in\">echo</span> Building go/helloworld:2<br><br>docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy<br><span class=\"hljs-built_in\">rm</span> ./app<br></code></pre></td></tr></table></figure></li>\n<li>更加高效的方式<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FROM golang:alpine as builder<br><br>RUN apk --no-cache add git<br><br>WORKDIR /go/src/github.com/go/helloworld/<br><br>RUN go get -d -v github.com/go-sql-driver/mysql<br><br>COPY app.go .<br><br>RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .<br><br>FROM alpine:latest as prod<br><br>RUN apk --no-cache add ca-certificates<br><br>WORKDIR /root/<br><br><span class=\"hljs-comment\"># 这里的0代表上个阶段的镜像,当然可以指定其他镜像如`--from=nginx:latest`</span><br>COPY --from=0 /go/src/github.com/go/helloworld/app .<br><br>CMD [<span class=\"hljs-string\">&quot;./app&quot;</span>]<br></code></pre></td></tr></table></figure>\n可以只构建某个阶段的镜像<code>$ docker build --target builder -t username/imagename:tag .</code></li>\n</ol>\n<h2 id=\"docker-manifest–多系统架构支持\"><a href=\"#docker-manifest–多系统架构支持\" class=\"headerlink\" title=\"docker manifest–多系统架构支持\"></a>docker manifest–多系统架构支持</h2><ul>\n<li><strong>背景：</strong>使用镜像创建一个容器，该镜像必须与Docker宿主机架构一致（Windows、macOS除外，在x86_64系统上，这两个系统可以运行arm等其他架构），为了支持多个架构，必须提供两个架构版本的镜像，manifest命令就是支持自动识别宿主机架构，然后拉取合适的镜像。</li>\n</ul>\n<h3 id=\"构建镜像\"><a href=\"#构建镜像\" class=\"headerlink\" title=\"构建镜像\"></a>构建镜像</h3><p>在两个架构上构建两个镜像</p>\n<h3 id=\"创建manifest列表\"><a href=\"#创建manifest列表\" class=\"headerlink\" title=\"创建manifest列表\"></a>创建manifest列表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># $ docker manifest create MANIFEST_LIST MANIFEST [MANIFEST...]</span><br>$ docker manifest create username/test \\<br>      username/x8664-<span class=\"hljs-built_in\">test</span> \\<br>      username/arm64v8-<span class=\"hljs-built_in\">test</span><br></code></pre></td></tr></table></figure>\n<p>当需要修改时加个-a或–amend参数</p>\n<h3 id=\"设置manifest列表\"><a href=\"#设置manifest列表\" class=\"headerlink\" title=\"设置manifest列表\"></a>设置manifest列表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># $ docker manifest annotate [OPTIONS] MANIFEST_LIST MANIFEST</span><br>$ docker manifest annotate username/test \\<br>      username/x8664-<span class=\"hljs-built_in\">test</span> \\<br>      --os linux --<span class=\"hljs-built_in\">arch</span> x86_64<br><br>$ docker manifest annotate username/test \\<br>      username/arm64v8-<span class=\"hljs-built_in\">test</span> \\<br>      --os linux --<span class=\"hljs-built_in\">arch</span> arm64 --variant v8<br></code></pre></td></tr></table></figure>\n<h3 id=\"查看manifest支持列表\"><a href=\"#查看manifest支持列表\" class=\"headerlink\" title=\"查看manifest支持列表\"></a>查看manifest支持列表</h3><p><code>docker manifest inspect username/test</code></p>\n<h3 id=\"推送manifest列表\"><a href=\"#推送manifest列表\" class=\"headerlink\" title=\"推送manifest列表\"></a>推送manifest列表</h3><p><code>docker manifest push username/test</code></p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ul>\n<li>如果想以root临时执行一个命令，不要使用su、sudo,而是使用gosu,见如下例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis<br><span class=\"hljs-comment\"># 下载 gosu</span><br>RUN wget -O /usr/local/bin/gosu <span class=\"hljs-string\">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \\<br>    &amp;&amp; <span class=\"hljs-built_in\">chmod</span> +x /usr/local/bin/gosu \\<br>    &amp;&amp; gosu nobody <span class=\"hljs-literal\">true</span><br><span class=\"hljs-comment\"># 设置 CMD，并以另外的用户执行</span><br>CMD [ <span class=\"hljs-string\">&quot;exec&quot;</span>, <span class=\"hljs-string\">&quot;gosu&quot;</span>, <span class=\"hljs-string\">&quot;redis&quot;</span>, <span class=\"hljs-string\">&quot;redis-server&quot;</span> ]<br></code></pre></td></tr></table></figure></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dockerfile是一个文本文件，其内包含了一条条指令，<strong>每条指令构建一层</strong></p>\n<ul>\n<li><code>#</code>进行注释</li>\n<li><code>\\</code>末尾进行换行，RUN执行多条命令十分有用</li>\n</ul>\n<h2 id=\"docker-build–构建镜像\"><a href=\"#docker-build–构建镜像\" class=\"headerlink\" title=\"docker build–构建镜像\"></a>docker build–构建镜像</h2><ul>\n<li><strong>格式：</strong><code>docker build [选项] [上下文路径/URL/-]</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-t [reposity:tag]</td>\n<td align=\"center\">指明镜像名称和tag</td>\n</tr>\n<tr>\n<td align=\"center\">-f [dockerfile]</td>\n<td align=\"center\">指定dockerfile，非主流，默认文件名为<code>Dockerfile</code>，且位于上下文路径中</td>\n</tr>\n<tr>\n<td align=\"center\">–target &lt;some img&gt;</td>\n<td align=\"center\">多阶段构建时，指定只构建某个镜像，而不是默认的最后一个</td>\n</tr>\n</tbody></table>\n<h3 id=\"上下文路径\"><a href=\"#上下文路径\" class=\"headerlink\" title=\"上下文路径\"></a>上下文路径</h3><ul>\n<li>docker build命令其实是与服务器（即docker.service）通信，它会将上下文路径下的所有内容上传，而不是在本地进行构建的</li>\n<li>支持<code>.dockerignore</code>文件，剔除不需要的内容</li>\n</ul>\n<h3 id=\"其他构建法\"><a href=\"#其他构建法\" class=\"headerlink\" title=\"其他构建法\"></a>其他构建法</h3><ul>\n<li>Git repo:<code>docker build -t hello-world https://github.com/docker-library/hello-world.git</code></li>\n<li>tar包:<code>docker build http://server/context.tar.gz</code></li>\n<li>标准输入：<code>docker build - &lt; Dockerfile</code>或<code>cat Dockerfile| docker build -</code>(直接从标准输入读取，没有上下文，不可用依赖上下文的命令COPY等等)</li>\n<li>标准输入+tar包：<code>docker build - &lt; context.tar.gz</code>会自动解压，将里面视为上下文</li>\n</ul>\n<h2 id=\"docker-import-从rootfs压缩包导入-无需Dockerfile\"><a href=\"#docker-import-从rootfs压缩包导入-无需Dockerfile\" class=\"headerlink\" title=\"docker import-从rootfs压缩包导入(无需Dockerfile)\"></a>docker import-从rootfs压缩包导入(无需Dockerfile)</h2><ul>\n<li><strong>格式：</strong><code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></li>\n<li><strong>例子：</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ docker import \\<br>    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\<br>    openvz/ubuntu:16.04<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"docker-save和docker-load\"><a href=\"#docker-save和docker-load\" class=\"headerlink\" title=\"docker save和docker load\"></a>docker save和docker load</h2><p>是一种古老的保存和加载镜像的方法，已经非主流，实在没网，使用内网私有的Registry</p>\n<h3 id=\"docker-save\"><a href=\"#docker-save\" class=\"headerlink\" title=\"docker save\"></a>docker save</h3><ul>\n<li>本质上是建立归档文件:<code>docker save [some image] -o [some file]</code></li>\n<li>使用压缩：<code>docker save [some image] | gzip &gt; xx.tar.gz</code></li>\n</ul>\n<h3 id=\"docker-load\"><a href=\"#docker-load\" class=\"headerlink\" title=\"docker load\"></a>docker load</h3><p><code>docker load -i some_file.tar.gz</code></p>\n<h2 id=\"FROM指定基础镜像\"><a href=\"#FROM指定基础镜像\" class=\"headerlink\" title=\"FROM指定基础镜像\"></a>FROM指定基础镜像</h2><ul>\n<li><strong>格式：</strong><code>FROM [image]</code></li>\n<li>FROM是必备的指令，且必须是第一条</li>\n<li>如果你想以空白镜像为基础，你可以这样<code>FROM scratch</code></li>\n<li>尽量小尺寸（推荐Alpine）</li>\n</ul>\n<h2 id=\"RUN执行命令\"><a href=\"#RUN执行命令\" class=\"headerlink\" title=\"RUN执行命令\"></a>RUN执行命令</h2><ul>\n<li><strong>格式：</strong><code>RUN [command]</code></li>\n<li>执行多条命令：使用<code>\\</code>和<code>&amp;&amp;</code>，如下<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">RUN apt-get update \\<br>&amp;&amp; apt-get install vim<br></code></pre></td></tr></table></figure></li>\n<li>永远不要<code>apt upgrade</code>，而是使用：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">RUN apt-get update &amp;&amp; apt-get install -y \\<br>    aufs-tools \\<br>    s3cmd=1.1.* \\<br> &amp;&amp; <span class=\"hljs-built_in\">rm</span> -rf /var/lib/apt/lists/*<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"COPY复制文件\"><a href=\"#COPY复制文件\" class=\"headerlink\" title=\"COPY复制文件\"></a>COPY复制文件</h2><ul>\n<li><strong>格式：</strong><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>\n<li><strong>作用：</strong>将从构建上下文目录中的路径复制的新的一层的镜像内的目标路径的位置，支持通配符，如果目录不存在会创建缺失的目录</li>\n<li>如果源路径为文件夹，复制的时候不是复制该文件夹，而是将文件夹中的内容复制到目标路径</li>\n<li><code>--from=[some]</code>:多阶段构建时，指定从某个镜像获取，而不是当前上下文</li>\n<li>不要一次copy多个文件，这会使一层的缓存过大</li>\n</ul>\n<h2 id=\"ADD更高级的复制文件\"><a href=\"#ADD更高级的复制文件\" class=\"headerlink\" title=\"ADD更高级的复制文件\"></a>ADD更高级的复制文件</h2><ul>\n<li><strong>说明：</strong>和COPY格式和性质基本一致,但是功能更多(不代表更好，只有自动解压缩时，使用该命令)：</li>\n</ul>\n<ol>\n<li>源路径可以是以个URL,文件权限自动设置为600,更改权限需要再加一层调整,另外如果下载是个压缩包，需要再加一层解压缩</li>\n<li>如果源路径是个tar压缩文件(gzip,bzip2,xz)，会自动解压缩文件</li>\n</ol>\n<h2 id=\"CMD容器启动命令\"><a href=\"#CMD容器启动命令\" class=\"headerlink\" title=\"CMD容器启动命令\"></a>CMD容器启动命令</h2><ul>\n<li><strong>格式1：</strong><code>CMD [&quot;可执行文件&quot;，&quot;参数1&quot;，&quot;参数2&quot;...]</code>(推荐使用这个，也支持bash格式，但会包装一层<code>sh -c</code>)</li>\n<li><strong>格式2：</strong><code>CMD [&quot;参数1&quot;,&quot;参数2&quot;]</code>,在指定了<code>ENTRYPOINT</code>后，可以直接指定参数</li>\n<li><strong>作用：</strong>容器就是进程，该命令就是指定容器所运行默认的程序及参数,例如ubuntu的CMD就是<code>/bin/bash</code>,当然可以在命令行中用其他命令替换。</li>\n<li><strong>注意：</strong></li>\n</ul>\n<ol>\n<li>启动程序就是容器的应用进程，容器就是为了主进程存在的，主进程退出，容器就会退出，辅助进程不是它所关心的。所以必须是前台进程，例如<code>CMD service nginx start</code>被理解为<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;service nginx start&quot;]</code>,因此当sh进程结束，它就会结束。当然即使你用格式1清楚指明service为可执行程序也是不行的，正确做法是指明前台形式运行： <code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></li>\n<li>整个Dockerfile应该只出现一次该命令</li>\n</ol>\n<h2 id=\"ENTRYPOINT入口点\"><a href=\"#ENTRYPOINT入口点\" class=\"headerlink\" title=\"ENTRYPOINT入口点\"></a>ENTRYPOINT入口点</h2><p><strong>说明：</strong>该命令和CMD一样，都是指定容器启动程序及参数，不过有下面几点需要注意：</p>\n<ol>\n<li>在运行时也可以替代，不过要加个<code>--entrypoint</code>指定</li>\n<li>当指定了<code>ENTRYPOINT</code>后，CMD的内容将作为参数传给<code>ENTRYPOINT</code></li>\n<li>整个Dockerfile应该只出现一次该命令<br><strong>应用场景：</strong></li>\n<li>让镜像变成像命令一样使用:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FROM ubuntu:18.04<br>RUN apt-get update \\<br>    &amp;&amp; apt-get install -y curl \\<br>    &amp;&amp; <span class=\"hljs-built_in\">rm</span> -rf /var/lib/apt/lists/*<br>CMD [ <span class=\"hljs-string\">&quot;curl&quot;</span>, <span class=\"hljs-string\">&quot;-s&quot;</span>, <span class=\"hljs-string\">&quot;http://myip.ipip.net&quot;</span> ]<br></code></pre></td></tr></table></figure>\n如果我们希望显示http头信息，需要加上-i参数,<code>docker run myip -i</code>是行不通的，而必须用<code>$ docker run myip curl -s http://myip.ipip.net -i</code>，显然很繁琐，如果把上面内容的CMD改成ENTRYPOINT，就可以使用<code>docker run myip -i</code>，此时CMD的内容是<code>-i</code></li>\n<li>应用运行前的准备工作。</li>\n</ol>\n<h2 id=\"ENV设置环境变量-容器运行时，这些环境变量保持有效\"><a href=\"#ENV设置环境变量-容器运行时，这些环境变量保持有效\" class=\"headerlink\" title=\"ENV设置环境变量(容器运行时，这些环境变量保持有效)\"></a>ENV设置环境变量(容器运行时，这些环境变量保持有效)</h2><ul>\n<li><strong>格式：</strong><code>ENV &lt;key&gt; &lt;value&gt;</code></li>\n<li>如果key或value有空格，用<code>&quot;</code>括起来,可以用<code>\\</code>换行</li>\n<li>下列指令可以支持环境变量展开：<code>ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。</code></li>\n</ul>\n<h2 id=\"ARG构建参数-容器运行时，这些参数无效\"><a href=\"#ARG构建参数-容器运行时，这些参数无效\" class=\"headerlink\" title=\"ARG构建参数(容器运行时，这些参数无效)\"></a>ARG构建参数(容器运行时，这些参数无效)</h2><ul>\n<li><strong>格式：</strong><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li>\n<li><strong>说明：</strong>定义参数名称及其默认值，该默认值可以在构建命令中用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖</li>\n<li>ARG指令有生效范围，如果在FROM指令之前指定，那么只能用于每个FROM指令中。多阶段中使用这些变量必须在每个阶段分别指定</li>\n</ul>\n<h2 id=\"VOLUME定义匿名卷\"><a href=\"#VOLUME定义匿名卷\" class=\"headerlink\" title=\"VOLUME定义匿名卷\"></a>VOLUME定义匿名卷</h2><ul>\n<li><strong>格式：</strong><code>VOLUME [&quot;&lt;路径1&gt;&quot;,&quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><strong>说明：</strong>路径1等目录会在容器运行时默认自动挂载为匿名卷，任何向指定路径中写入的信息都不会记录进容器存储层。</li>\n<li>运行容器时可以覆盖这个挂载配置<code>$ docker run -d -v mydata:/data xxxx</code>，这里就用了mydata这个命名卷挂载到了&#x2F;data这个位置，替代了Dockerfile中定义的匿名卷挂载配置</li>\n</ul>\n<h2 id=\"EXPOSE声明端口\"><a href=\"#EXPOSE声明端口\" class=\"headerlink\" title=\"EXPOSE声明端口\"></a>EXPOSE声明端口</h2><ul>\n<li><strong>格式：</strong><code>EXPOSE &lt;端口1&gt; &lt;端口2&gt; ...</code></li>\n<li><strong>作用：</strong>这只是个声明，并不会开启这个端口的服务，主要帮助镜像使用者理解这个镜像服务的守护端口，方便映射，另外-P选项，会自动随机映射EXPOSE的端口，要想映射端口请使用-p选项</li>\n</ul>\n<h2 id=\"WORKDIR指定工作目录\"><a href=\"#WORKDIR指定工作目录\" class=\"headerlink\" title=\"WORKDIR指定工作目录\"></a>WORKDIR指定工作目录</h2><ul>\n<li><strong>格式：</strong><code>WORKDIR &lt;工作目录路径&gt;</code></li>\n<li><strong>作用：</strong>指定当前目录，以后各层的当前目录就改为指定目录，如果目录不存在，会自动建立，若指定相对路径，则是在之前工作目录的基础上的。</li>\n<li><strong>注意：</strong>单独一层cd不会影响之后的一层，因为一层一层是独立的，应该用WORKDIR</li>\n</ul>\n<h2 id=\"USER指定当前用户\"><a href=\"#USER指定当前用户\" class=\"headerlink\" title=\"USER指定当前用户\"></a>USER指定当前用户</h2><ul>\n<li><strong>格式：</strong><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></li>\n<li><strong>作用：</strong>改变之后层的命令执行的身份，这个用户身份必须存在</li>\n</ul>\n<h2 id=\"HEALTHCHECK健康检查\"><a href=\"#HEALTHCHECK健康检查\" class=\"headerlink\" title=\"HEALTHCHECK健康检查\"></a>HEALTHCHECK健康检查</h2><ul>\n<li><strong>格式1：</strong><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>设置检查容器健康状况的命令</li>\n<li><strong>格式2：</strong><code>HEALTHCHECK NONE</code>如果基础镜像有健康检查指令，使用这个可以屏蔽其健康检查指令</li>\n<li><strong>历史原因：</strong>在没有该命令之前，docker通过主进程是否退出来判断是否异常，这忽略了一种情形，如果程序进入死锁或死循环，就不会检查出错误</li>\n<li><strong>功能作用：</strong>当一个镜像指定了HEALTHCHECK指令后，启动容器的初始状态会是starting,在HEALTHCHECK指令检查成功后变为healthy,如果连续一定次数失败，则为unhealthy,<strong>整个Dockerfile应该只出现一次该命令</strong></li>\n<li><strong>选项：</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–interval&#x3D;&lt;间隔&gt;</td>\n<td align=\"center\">两次健康检查的间隔，默认为30秒</td>\n</tr>\n<tr>\n<td align=\"center\">–timeout&#x3D;&lt;时长&gt;</td>\n<td align=\"center\">健康检查命令运行超时时间，默认为30秒</td>\n</tr>\n<tr>\n<td align=\"center\">–retries&#x3D;&lt;次数&gt;</td>\n<td align=\"center\">当连续失败指定次数后，则将认定为unhealthy，默认为3次</td>\n</tr>\n</tbody></table>\n<h2 id=\"LABEL指令\"><a href=\"#LABEL指令\" class=\"headerlink\" title=\"LABEL指令\"></a>LABEL指令</h2><ul>\n<li><strong>格式：</strong><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li>\n<li><strong>作用：</strong>给镜像以键值对的形式添加些元数据，如镜像的作者、文档地址等<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">LABEL org.opencontainers.image.authors=<span class=\"hljs-string\">&quot;yeasy&quot;</span><br>LABEL org.opencontainers.image.documentation=<span class=\"hljs-string\">&quot;https://yeasy.gitbooks.io&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"SHELL指令\"><a href=\"#SHELL指令\" class=\"headerlink\" title=\"SHELL指令\"></a>SHELL指令</h2><ul>\n<li><strong>格式：</strong><code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></li>\n<li><strong>作用：</strong>指定RUN、ENTRYPOINT、CMD指令的shell,默认为<code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code>,其中ENTRYPOINT,CMD只有以shell格式指定时，才起作用</li>\n</ul>\n<h2 id=\"ONBUILD为他人做嫁衣\"><a href=\"#ONBUILD为他人做嫁衣\" class=\"headerlink\" title=\"ONBUILD为他人做嫁衣\"></a>ONBUILD为他人做嫁衣</h2><ul>\n<li><strong>格式：</strong><code>ONBUILD &lt;其他指令&gt;</code></li>\n<li><strong>作用：</strong>它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</li>\n<li>这常常应用于基础镜像，例如npm包管理</li>\n</ul>\n<h2 id=\"多阶段构建\"><a href=\"#多阶段构建\" class=\"headerlink\" title=\"多阶段构建\"></a>多阶段构建</h2><ol>\n<li>之前多阶段构建一种方式把所有东西放在一个Dockerfile中，但这会造成层次太多，镜像体积过大，部署时间变长，源代码存在泄露问题，如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FROM golang:alpine<br><br>RUN apk --no-cache add git ca-certificates<br><br>WORKDIR /go/src/github.com/go/helloworld/<br><br>COPY app.go .<br><br>RUN go get -d -v github.com/go-sql-driver/mysql \\<br>  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \\<br>  &amp;&amp; <span class=\"hljs-built_in\">cp</span> /go/src/github.com/go/helloworld/app /root<br><br>WORKDIR /root/<br><br>CMD [<span class=\"hljs-string\">&quot;./app&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n<li>第二种方式分散多个Dockerfile，然后再写脚本整合，虽然镜像体积较小，但过程较复杂：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 构建dockerfile--&gt;Dockerfile.build</span><br>FROM golang:alpine<br><br>RUN apk --no-cache add git<br><br>WORKDIR /go/src/github.com/go/helloworld<br><br>COPY app.go .<br><br>RUN go get -d -v github.com/go-sql-driver/mysql \\<br>  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .<br><span class=\"hljs-comment\"># 部署dockerfile--&gt;Dockerfile.copy</span><br>FROM alpine:latest<br><br>RUN apk --no-cache add ca-certificates<br><br>WORKDIR /root/<br><br>COPY app .<br><br>CMD [<span class=\"hljs-string\">&quot;./app&quot;</span>]<br><span class=\"hljs-comment\"># 整合脚本--&gt; build.sh</span><br><span class=\"hljs-comment\">#!/bin/sh</span><br><span class=\"hljs-built_in\">echo</span> Building go/helloworld:build<br><br>docker build -t go/helloworld:build . -f Dockerfile.build<br><br>docker create --name extract go/helloworld:build<br>docker <span class=\"hljs-built_in\">cp</span> extract:/go/src/github.com/go/helloworld/app ./app<br>docker <span class=\"hljs-built_in\">rm</span> -f extract<br><br><span class=\"hljs-built_in\">echo</span> Building go/helloworld:2<br><br>docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy<br><span class=\"hljs-built_in\">rm</span> ./app<br></code></pre></td></tr></table></figure></li>\n<li>更加高效的方式<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">FROM golang:alpine as builder<br><br>RUN apk --no-cache add git<br><br>WORKDIR /go/src/github.com/go/helloworld/<br><br>RUN go get -d -v github.com/go-sql-driver/mysql<br><br>COPY app.go .<br><br>RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .<br><br>FROM alpine:latest as prod<br><br>RUN apk --no-cache add ca-certificates<br><br>WORKDIR /root/<br><br><span class=\"hljs-comment\"># 这里的0代表上个阶段的镜像,当然可以指定其他镜像如`--from=nginx:latest`</span><br>COPY --from=0 /go/src/github.com/go/helloworld/app .<br><br>CMD [<span class=\"hljs-string\">&quot;./app&quot;</span>]<br></code></pre></td></tr></table></figure>\n可以只构建某个阶段的镜像<code>$ docker build --target builder -t username/imagename:tag .</code></li>\n</ol>\n<h2 id=\"docker-manifest–多系统架构支持\"><a href=\"#docker-manifest–多系统架构支持\" class=\"headerlink\" title=\"docker manifest–多系统架构支持\"></a>docker manifest–多系统架构支持</h2><ul>\n<li><strong>背景：</strong>使用镜像创建一个容器，该镜像必须与Docker宿主机架构一致（Windows、macOS除外，在x86_64系统上，这两个系统可以运行arm等其他架构），为了支持多个架构，必须提供两个架构版本的镜像，manifest命令就是支持自动识别宿主机架构，然后拉取合适的镜像。</li>\n</ul>\n<h3 id=\"构建镜像\"><a href=\"#构建镜像\" class=\"headerlink\" title=\"构建镜像\"></a>构建镜像</h3><p>在两个架构上构建两个镜像</p>\n<h3 id=\"创建manifest列表\"><a href=\"#创建manifest列表\" class=\"headerlink\" title=\"创建manifest列表\"></a>创建manifest列表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># $ docker manifest create MANIFEST_LIST MANIFEST [MANIFEST...]</span><br>$ docker manifest create username/test \\<br>      username/x8664-<span class=\"hljs-built_in\">test</span> \\<br>      username/arm64v8-<span class=\"hljs-built_in\">test</span><br></code></pre></td></tr></table></figure>\n<p>当需要修改时加个-a或–amend参数</p>\n<h3 id=\"设置manifest列表\"><a href=\"#设置manifest列表\" class=\"headerlink\" title=\"设置manifest列表\"></a>设置manifest列表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># $ docker manifest annotate [OPTIONS] MANIFEST_LIST MANIFEST</span><br>$ docker manifest annotate username/test \\<br>      username/x8664-<span class=\"hljs-built_in\">test</span> \\<br>      --os linux --<span class=\"hljs-built_in\">arch</span> x86_64<br><br>$ docker manifest annotate username/test \\<br>      username/arm64v8-<span class=\"hljs-built_in\">test</span> \\<br>      --os linux --<span class=\"hljs-built_in\">arch</span> arm64 --variant v8<br></code></pre></td></tr></table></figure>\n<h3 id=\"查看manifest支持列表\"><a href=\"#查看manifest支持列表\" class=\"headerlink\" title=\"查看manifest支持列表\"></a>查看manifest支持列表</h3><p><code>docker manifest inspect username/test</code></p>\n<h3 id=\"推送manifest列表\"><a href=\"#推送manifest列表\" class=\"headerlink\" title=\"推送manifest列表\"></a>推送manifest列表</h3><p><code>docker manifest push username/test</code></p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ul>\n<li>如果想以root临时执行一个命令，不要使用su、sudo,而是使用gosu,见如下例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis<br><span class=\"hljs-comment\"># 下载 gosu</span><br>RUN wget -O /usr/local/bin/gosu <span class=\"hljs-string\">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \\<br>    &amp;&amp; <span class=\"hljs-built_in\">chmod</span> +x /usr/local/bin/gosu \\<br>    &amp;&amp; gosu nobody <span class=\"hljs-literal\">true</span><br><span class=\"hljs-comment\"># 设置 CMD，并以另外的用户执行</span><br>CMD [ <span class=\"hljs-string\">&quot;exec&quot;</span>, <span class=\"hljs-string\">&quot;gosu&quot;</span>, <span class=\"hljs-string\">&quot;redis&quot;</span>, <span class=\"hljs-string\">&quot;redis-server&quot;</span> ]<br></code></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Find命令","date":"2020-11-18T10:40:05.000Z","subtitle":null,"index_img":"/images/find.jpg","banner_img":"/images/find.jpg","_content":"1.**格式** \nfind <范围> <条件> <动作>\n2.**查询表**\n\n|测试条件|描述|\n|:-:|:-:|\n|-cmin [num]|匹配文件的最后修改时间正好在[num]分钟之前|\n|-cnewer [fileName]|匹配文件的最后修改时间晚于file的文件或目录|\n|-ctime [num]|匹配文件的最后修改时间在num\\*24小时之前|\n|-empty|匹配空文件和目录|\n|-group [groupName]|匹配属于一个组的文件|\n|-iname [pattern]|与-name一样，但是不区分大小写|\n|-inum [nodeId]|匹配inode号是[nodeId]的文件,可用来查找硬链接|\n|-mmin [num]|匹配内容修改于[num]分钟之前|\n|-mtime [num]|匹配内容修改于[num\\*24]小时之前|\n|-name [pattern]|用指定的通配符模式匹配文件名|\n|-newer [file]|匹配晚于[file]的文件|\n|-newerct [yyyy-mm-dd HH:mm:ss]|创建晚于某个时间,详见man|\n|-nouser|匹配不属于一个有效用户的文件|\n|-nogroup|匹配不属于一个有效组的文件|\n|-perm [mode]|匹配权限设置为[mode]的文件,mode可用八进制或符号|\n|-samefile [filename]|类似于-inum测试条件,匹配和文件[fileName]享有同样inode号的文件|\n|-size [num]|匹配大小为[num]的文件,数字后加单位,详情见其他表|\n|-type [fileType]|匹配文件类型是[fileType]的文件|\n|-user name|匹配属于某个用户文件|\n\n\n(注:一般[num]都可以在前面加±号,表示大于或少于,如+5M表示(5M,+∞),-5M表示(0,4M],5M则表示(4M,5M]))\n\n\n|字符|单位|\n|:-:|:-:|\n|b|512个字节快,为默认值|\n|c|字节|\n|w|两个字节的字|\n|k|千字节(1024个字节单位)|\n|M|兆字节(1048576个字节单位)|\n|G|千兆字节(1073741824个字节单位)|\n\n\n|操作符|描述|\n|:-:|:-:|\n|-and(-a)|如果操作符两边的测试条件都是真,则匹配,默认使用|\n|-or(-o)|如果操作符两边的测试条件,任一是真,则匹配|\n|-not(!)|如果操作符后面的条件为假,则匹配|\n|()|用来改变优先级,注意一般shell对其有特殊解释,所以用引号或反斜杠加来转义|\n\n\n|操作|描述|\n|:-:|:-:|\n|-delete|删除当前匹配的文件|\n|-print|默认操作，打印|\n|-ls|对匹配文件执行等同ls -dils命令|\n|-quit|匹配到第一个即立刻退出|\n|`-exec [command] '{}' ';'`|\"{}\"代表匹配到的文件(为决定路径),因为是shell特殊符号所以要用单引号,结尾必须用\";\",同样是特殊符号,要用单引号|\n|`-ok [command] '{}' ';'`|与-exec相似，只不过执行前会进行确认|\n|-regex|文件路径的正则匹配|\n\n\n|文件类型|描述|\n|:-:|:-:|\n|b|块特殊设备文件|\n|c|字符特殊设备文件|\n|d|目录|\n|f|普通文件|\n|l|符号链接|\n\n\n控制find命令的搜索范围\n\n\n|选项|描述|\n|:-:|:-:|\n|-depth|指定find程序先处理目录中的文件,再处理目录自身(深度优先搜索?)。当指定-delete行为时,会自动用这个选项|\n|-maxdepth [num]|设置陷入目录树的最大级别数|\n|-mindepth [num]|设置陷入目录树的最小级别数|\n|-mount|不搜索挂载到其他系统下的目录|\n|-noleaf|在搜索DOS/Win文件系统或CD/ROMS时的时候优化选项|\n\n\n3.**-exec与\"+\"**\n`find -type f -name 'foo*' -exec ls -l '{}' ';'`\n`find -type f -name 'foo*' -exec ls -l '{}' +`\n上述两个命令的区别在于,假设匹配到fooA与fooB两个文件,第一个相当于执行两次ls命令,相当于`ls -l fooA`和`ls -l fooB`而第二个只执行一次`ls -l fooA fooB`\n\n4.**xargs**\n`find ~ -type f -name 'foo*' -print | xargs ls -l`与上述带有\"+\"的-exec选项效果一样,注意xargs有最大参数个数限制,可以通过`xargs -show-limits`来查看最大值\n5.**文件名存在空格的问题**\n类 Unix 的系统允许在文件名中嵌入空格(甚至换行符)。这就给一些程序,如\n为其它程序构建参数列表的 xargs 程序,造成了问题。一个嵌入的空格会被看作是\n一个分隔符,生成的命令会把每个空格分离的单词解释为单独的参数。为了解决这\n个问题,find 命令和 xarg 程序允许使用一个可选的 null 字符作为参数分隔符。一\n个 null 字符被定义在 ASCII 码中,由数字零来表示(相反的,例如,空格字符在\nASCII 码中由数字 32 表示)。find 命令提供的 -print0 行为,则会产生由 null 字符\n分离的输出,并且 xargs 命令有一个 –null 选项,这个选项会接受由 null 字符分离\n的输入。这里有一个例子\n`find ~ -iname '*.jpg' -print0 | xargs -null ls -l`\n6.**例子**\n`sudo find /tmp -type d -empty`\n`find ~ -perm /a=x`查找所有可执行文件\n`find . -regex '.*[^-\\_./0-9a-zA-Z].*'`查找不符合规范字符的路径名(中文咋办?)\n","source":"_posts/Find命令.md","raw":"---\ntitle: Find命令\ndate: 2020-11-18 18:40:05\nsubtitle:\ncategories:\ntags:\nindex_img: /images/find.jpg\nbanner_img: /images/find.jpg\n---\n1.**格式** \nfind <范围> <条件> <动作>\n2.**查询表**\n\n|测试条件|描述|\n|:-:|:-:|\n|-cmin [num]|匹配文件的最后修改时间正好在[num]分钟之前|\n|-cnewer [fileName]|匹配文件的最后修改时间晚于file的文件或目录|\n|-ctime [num]|匹配文件的最后修改时间在num\\*24小时之前|\n|-empty|匹配空文件和目录|\n|-group [groupName]|匹配属于一个组的文件|\n|-iname [pattern]|与-name一样，但是不区分大小写|\n|-inum [nodeId]|匹配inode号是[nodeId]的文件,可用来查找硬链接|\n|-mmin [num]|匹配内容修改于[num]分钟之前|\n|-mtime [num]|匹配内容修改于[num\\*24]小时之前|\n|-name [pattern]|用指定的通配符模式匹配文件名|\n|-newer [file]|匹配晚于[file]的文件|\n|-newerct [yyyy-mm-dd HH:mm:ss]|创建晚于某个时间,详见man|\n|-nouser|匹配不属于一个有效用户的文件|\n|-nogroup|匹配不属于一个有效组的文件|\n|-perm [mode]|匹配权限设置为[mode]的文件,mode可用八进制或符号|\n|-samefile [filename]|类似于-inum测试条件,匹配和文件[fileName]享有同样inode号的文件|\n|-size [num]|匹配大小为[num]的文件,数字后加单位,详情见其他表|\n|-type [fileType]|匹配文件类型是[fileType]的文件|\n|-user name|匹配属于某个用户文件|\n\n\n(注:一般[num]都可以在前面加±号,表示大于或少于,如+5M表示(5M,+∞),-5M表示(0,4M],5M则表示(4M,5M]))\n\n\n|字符|单位|\n|:-:|:-:|\n|b|512个字节快,为默认值|\n|c|字节|\n|w|两个字节的字|\n|k|千字节(1024个字节单位)|\n|M|兆字节(1048576个字节单位)|\n|G|千兆字节(1073741824个字节单位)|\n\n\n|操作符|描述|\n|:-:|:-:|\n|-and(-a)|如果操作符两边的测试条件都是真,则匹配,默认使用|\n|-or(-o)|如果操作符两边的测试条件,任一是真,则匹配|\n|-not(!)|如果操作符后面的条件为假,则匹配|\n|()|用来改变优先级,注意一般shell对其有特殊解释,所以用引号或反斜杠加来转义|\n\n\n|操作|描述|\n|:-:|:-:|\n|-delete|删除当前匹配的文件|\n|-print|默认操作，打印|\n|-ls|对匹配文件执行等同ls -dils命令|\n|-quit|匹配到第一个即立刻退出|\n|`-exec [command] '{}' ';'`|\"{}\"代表匹配到的文件(为决定路径),因为是shell特殊符号所以要用单引号,结尾必须用\";\",同样是特殊符号,要用单引号|\n|`-ok [command] '{}' ';'`|与-exec相似，只不过执行前会进行确认|\n|-regex|文件路径的正则匹配|\n\n\n|文件类型|描述|\n|:-:|:-:|\n|b|块特殊设备文件|\n|c|字符特殊设备文件|\n|d|目录|\n|f|普通文件|\n|l|符号链接|\n\n\n控制find命令的搜索范围\n\n\n|选项|描述|\n|:-:|:-:|\n|-depth|指定find程序先处理目录中的文件,再处理目录自身(深度优先搜索?)。当指定-delete行为时,会自动用这个选项|\n|-maxdepth [num]|设置陷入目录树的最大级别数|\n|-mindepth [num]|设置陷入目录树的最小级别数|\n|-mount|不搜索挂载到其他系统下的目录|\n|-noleaf|在搜索DOS/Win文件系统或CD/ROMS时的时候优化选项|\n\n\n3.**-exec与\"+\"**\n`find -type f -name 'foo*' -exec ls -l '{}' ';'`\n`find -type f -name 'foo*' -exec ls -l '{}' +`\n上述两个命令的区别在于,假设匹配到fooA与fooB两个文件,第一个相当于执行两次ls命令,相当于`ls -l fooA`和`ls -l fooB`而第二个只执行一次`ls -l fooA fooB`\n\n4.**xargs**\n`find ~ -type f -name 'foo*' -print | xargs ls -l`与上述带有\"+\"的-exec选项效果一样,注意xargs有最大参数个数限制,可以通过`xargs -show-limits`来查看最大值\n5.**文件名存在空格的问题**\n类 Unix 的系统允许在文件名中嵌入空格(甚至换行符)。这就给一些程序,如\n为其它程序构建参数列表的 xargs 程序,造成了问题。一个嵌入的空格会被看作是\n一个分隔符,生成的命令会把每个空格分离的单词解释为单独的参数。为了解决这\n个问题,find 命令和 xarg 程序允许使用一个可选的 null 字符作为参数分隔符。一\n个 null 字符被定义在 ASCII 码中,由数字零来表示(相反的,例如,空格字符在\nASCII 码中由数字 32 表示)。find 命令提供的 -print0 行为,则会产生由 null 字符\n分离的输出,并且 xargs 命令有一个 –null 选项,这个选项会接受由 null 字符分离\n的输入。这里有一个例子\n`find ~ -iname '*.jpg' -print0 | xargs -null ls -l`\n6.**例子**\n`sudo find /tmp -type d -empty`\n`find ~ -perm /a=x`查找所有可执行文件\n`find . -regex '.*[^-\\_./0-9a-zA-Z].*'`查找不符合规范字符的路径名(中文咋办?)\n","slug":"Find命令","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi6u0008gwq20gttdhk0","content":"<p>1.<strong>格式</strong><br>find &lt;范围&gt; &lt;条件&gt; &lt;动作&gt;<br>2.<strong>查询表</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">测试条件</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-cmin [num]</td>\n<td align=\"center\">匹配文件的最后修改时间正好在[num]分钟之前</td>\n</tr>\n<tr>\n<td align=\"center\">-cnewer [fileName]</td>\n<td align=\"center\">匹配文件的最后修改时间晚于file的文件或目录</td>\n</tr>\n<tr>\n<td align=\"center\">-ctime [num]</td>\n<td align=\"center\">匹配文件的最后修改时间在num*24小时之前</td>\n</tr>\n<tr>\n<td align=\"center\">-empty</td>\n<td align=\"center\">匹配空文件和目录</td>\n</tr>\n<tr>\n<td align=\"center\">-group [groupName]</td>\n<td align=\"center\">匹配属于一个组的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-iname [pattern]</td>\n<td align=\"center\">与-name一样，但是不区分大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-inum [nodeId]</td>\n<td align=\"center\">匹配inode号是[nodeId]的文件,可用来查找硬链接</td>\n</tr>\n<tr>\n<td align=\"center\">-mmin [num]</td>\n<td align=\"center\">匹配内容修改于[num]分钟之前</td>\n</tr>\n<tr>\n<td align=\"center\">-mtime [num]</td>\n<td align=\"center\">匹配内容修改于[num*24]小时之前</td>\n</tr>\n<tr>\n<td align=\"center\">-name [pattern]</td>\n<td align=\"center\">用指定的通配符模式匹配文件名</td>\n</tr>\n<tr>\n<td align=\"center\">-newer [file]</td>\n<td align=\"center\">匹配晚于[file]的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-newerct [yyyy-mm-dd HH:mm:ss]</td>\n<td align=\"center\">创建晚于某个时间,详见man</td>\n</tr>\n<tr>\n<td align=\"center\">-nouser</td>\n<td align=\"center\">匹配不属于一个有效用户的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-nogroup</td>\n<td align=\"center\">匹配不属于一个有效组的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-perm [mode]</td>\n<td align=\"center\">匹配权限设置为[mode]的文件,mode可用八进制或符号</td>\n</tr>\n<tr>\n<td align=\"center\">-samefile [filename]</td>\n<td align=\"center\">类似于-inum测试条件,匹配和文件[fileName]享有同样inode号的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-size [num]</td>\n<td align=\"center\">匹配大小为[num]的文件,数字后加单位,详情见其他表</td>\n</tr>\n<tr>\n<td align=\"center\">-type [fileType]</td>\n<td align=\"center\">匹配文件类型是[fileType]的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-user name</td>\n<td align=\"center\">匹配属于某个用户文件</td>\n</tr>\n</tbody></table>\n<p>(注:一般[num]都可以在前面加±号,表示大于或少于,如+5M表示(5M,+∞),-5M表示(0,4M],5M则表示(4M,5M]))</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符</th>\n<th align=\"center\">单位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">b</td>\n<td align=\"center\">512个字节快,为默认值</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">字节</td>\n</tr>\n<tr>\n<td align=\"center\">w</td>\n<td align=\"center\">两个字节的字</td>\n</tr>\n<tr>\n<td align=\"center\">k</td>\n<td align=\"center\">千字节(1024个字节单位)</td>\n</tr>\n<tr>\n<td align=\"center\">M</td>\n<td align=\"center\">兆字节(1048576个字节单位)</td>\n</tr>\n<tr>\n<td align=\"center\">G</td>\n<td align=\"center\">千兆字节(1073741824个字节单位)</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-and(-a)</td>\n<td align=\"center\">如果操作符两边的测试条件都是真,则匹配,默认使用</td>\n</tr>\n<tr>\n<td align=\"center\">-or(-o)</td>\n<td align=\"center\">如果操作符两边的测试条件,任一是真,则匹配</td>\n</tr>\n<tr>\n<td align=\"center\">-not(!)</td>\n<td align=\"center\">如果操作符后面的条件为假,则匹配</td>\n</tr>\n<tr>\n<td align=\"center\">()</td>\n<td align=\"center\">用来改变优先级,注意一般shell对其有特殊解释,所以用引号或反斜杠加来转义</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-delete</td>\n<td align=\"center\">删除当前匹配的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-print</td>\n<td align=\"center\">默认操作，打印</td>\n</tr>\n<tr>\n<td align=\"center\">-ls</td>\n<td align=\"center\">对匹配文件执行等同ls -dils命令</td>\n</tr>\n<tr>\n<td align=\"center\">-quit</td>\n<td align=\"center\">匹配到第一个即立刻退出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-exec [command] &#39;&#123;&#125;&#39; &#39;;&#39;</code></td>\n<td align=\"center\">“{}”代表匹配到的文件(为决定路径),因为是shell特殊符号所以要用单引号,结尾必须用”;”,同样是特殊符号,要用单引号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-ok [command] &#39;&#123;&#125;&#39; &#39;;&#39;</code></td>\n<td align=\"center\">与-exec相似，只不过执行前会进行确认</td>\n</tr>\n<tr>\n<td align=\"center\">-regex</td>\n<td align=\"center\">文件路径的正则匹配</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文件类型</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">b</td>\n<td align=\"center\">块特殊设备文件</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">字符特殊设备文件</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">目录</td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">普通文件</td>\n</tr>\n<tr>\n<td align=\"center\">l</td>\n<td align=\"center\">符号链接</td>\n</tr>\n</tbody></table>\n<p>控制find命令的搜索范围</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-depth</td>\n<td align=\"center\">指定find程序先处理目录中的文件,再处理目录自身(深度优先搜索?)。当指定-delete行为时,会自动用这个选项</td>\n</tr>\n<tr>\n<td align=\"center\">-maxdepth [num]</td>\n<td align=\"center\">设置陷入目录树的最大级别数</td>\n</tr>\n<tr>\n<td align=\"center\">-mindepth [num]</td>\n<td align=\"center\">设置陷入目录树的最小级别数</td>\n</tr>\n<tr>\n<td align=\"center\">-mount</td>\n<td align=\"center\">不搜索挂载到其他系统下的目录</td>\n</tr>\n<tr>\n<td align=\"center\">-noleaf</td>\n<td align=\"center\">在搜索DOS&#x2F;Win文件系统或CD&#x2F;ROMS时的时候优化选项</td>\n</tr>\n</tbody></table>\n<p>3.<strong>-exec与”+”</strong><br><code>find -type f -name &#39;foo*&#39; -exec ls -l &#39;&#123;&#125;&#39; &#39;;&#39;</code><br><code>find -type f -name &#39;foo*&#39; -exec ls -l &#39;&#123;&#125;&#39; +</code><br>上述两个命令的区别在于,假设匹配到fooA与fooB两个文件,第一个相当于执行两次ls命令,相当于<code>ls -l fooA</code>和<code>ls -l fooB</code>而第二个只执行一次<code>ls -l fooA fooB</code></p>\n<p>4.<strong>xargs</strong><br><code>find ~ -type f -name &#39;foo*&#39; -print | xargs ls -l</code>与上述带有”+”的-exec选项效果一样,注意xargs有最大参数个数限制,可以通过<code>xargs -show-limits</code>来查看最大值<br>5.<strong>文件名存在空格的问题</strong><br>类 Unix 的系统允许在文件名中嵌入空格(甚至换行符)。这就给一些程序,如<br>为其它程序构建参数列表的 xargs 程序,造成了问题。一个嵌入的空格会被看作是<br>一个分隔符,生成的命令会把每个空格分离的单词解释为单独的参数。为了解决这<br>个问题,find 命令和 xarg 程序允许使用一个可选的 null 字符作为参数分隔符。一<br>个 null 字符被定义在 ASCII 码中,由数字零来表示(相反的,例如,空格字符在<br>ASCII 码中由数字 32 表示)。find 命令提供的 -print0 行为,则会产生由 null 字符<br>分离的输出,并且 xargs 命令有一个 –null 选项,这个选项会接受由 null 字符分离<br>的输入。这里有一个例子<br><code>find ~ -iname &#39;*.jpg&#39; -print0 | xargs -null ls -l</code><br>6.<strong>例子</strong><br><code>sudo find /tmp -type d -empty</code><br><code>find ~ -perm /a=x</code>查找所有可执行文件<br><code>find . -regex &#39;.*[^-\\_./0-9a-zA-Z].*&#39;</code>查找不符合规范字符的路径名(中文咋办?)</p>\n","excerpt":"","more":"<p>1.<strong>格式</strong><br>find &lt;范围&gt; &lt;条件&gt; &lt;动作&gt;<br>2.<strong>查询表</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">测试条件</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-cmin [num]</td>\n<td align=\"center\">匹配文件的最后修改时间正好在[num]分钟之前</td>\n</tr>\n<tr>\n<td align=\"center\">-cnewer [fileName]</td>\n<td align=\"center\">匹配文件的最后修改时间晚于file的文件或目录</td>\n</tr>\n<tr>\n<td align=\"center\">-ctime [num]</td>\n<td align=\"center\">匹配文件的最后修改时间在num*24小时之前</td>\n</tr>\n<tr>\n<td align=\"center\">-empty</td>\n<td align=\"center\">匹配空文件和目录</td>\n</tr>\n<tr>\n<td align=\"center\">-group [groupName]</td>\n<td align=\"center\">匹配属于一个组的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-iname [pattern]</td>\n<td align=\"center\">与-name一样，但是不区分大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-inum [nodeId]</td>\n<td align=\"center\">匹配inode号是[nodeId]的文件,可用来查找硬链接</td>\n</tr>\n<tr>\n<td align=\"center\">-mmin [num]</td>\n<td align=\"center\">匹配内容修改于[num]分钟之前</td>\n</tr>\n<tr>\n<td align=\"center\">-mtime [num]</td>\n<td align=\"center\">匹配内容修改于[num*24]小时之前</td>\n</tr>\n<tr>\n<td align=\"center\">-name [pattern]</td>\n<td align=\"center\">用指定的通配符模式匹配文件名</td>\n</tr>\n<tr>\n<td align=\"center\">-newer [file]</td>\n<td align=\"center\">匹配晚于[file]的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-newerct [yyyy-mm-dd HH:mm:ss]</td>\n<td align=\"center\">创建晚于某个时间,详见man</td>\n</tr>\n<tr>\n<td align=\"center\">-nouser</td>\n<td align=\"center\">匹配不属于一个有效用户的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-nogroup</td>\n<td align=\"center\">匹配不属于一个有效组的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-perm [mode]</td>\n<td align=\"center\">匹配权限设置为[mode]的文件,mode可用八进制或符号</td>\n</tr>\n<tr>\n<td align=\"center\">-samefile [filename]</td>\n<td align=\"center\">类似于-inum测试条件,匹配和文件[fileName]享有同样inode号的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-size [num]</td>\n<td align=\"center\">匹配大小为[num]的文件,数字后加单位,详情见其他表</td>\n</tr>\n<tr>\n<td align=\"center\">-type [fileType]</td>\n<td align=\"center\">匹配文件类型是[fileType]的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-user name</td>\n<td align=\"center\">匹配属于某个用户文件</td>\n</tr>\n</tbody></table>\n<p>(注:一般[num]都可以在前面加±号,表示大于或少于,如+5M表示(5M,+∞),-5M表示(0,4M],5M则表示(4M,5M]))</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符</th>\n<th align=\"center\">单位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">b</td>\n<td align=\"center\">512个字节快,为默认值</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">字节</td>\n</tr>\n<tr>\n<td align=\"center\">w</td>\n<td align=\"center\">两个字节的字</td>\n</tr>\n<tr>\n<td align=\"center\">k</td>\n<td align=\"center\">千字节(1024个字节单位)</td>\n</tr>\n<tr>\n<td align=\"center\">M</td>\n<td align=\"center\">兆字节(1048576个字节单位)</td>\n</tr>\n<tr>\n<td align=\"center\">G</td>\n<td align=\"center\">千兆字节(1073741824个字节单位)</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-and(-a)</td>\n<td align=\"center\">如果操作符两边的测试条件都是真,则匹配,默认使用</td>\n</tr>\n<tr>\n<td align=\"center\">-or(-o)</td>\n<td align=\"center\">如果操作符两边的测试条件,任一是真,则匹配</td>\n</tr>\n<tr>\n<td align=\"center\">-not(!)</td>\n<td align=\"center\">如果操作符后面的条件为假,则匹配</td>\n</tr>\n<tr>\n<td align=\"center\">()</td>\n<td align=\"center\">用来改变优先级,注意一般shell对其有特殊解释,所以用引号或反斜杠加来转义</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-delete</td>\n<td align=\"center\">删除当前匹配的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-print</td>\n<td align=\"center\">默认操作，打印</td>\n</tr>\n<tr>\n<td align=\"center\">-ls</td>\n<td align=\"center\">对匹配文件执行等同ls -dils命令</td>\n</tr>\n<tr>\n<td align=\"center\">-quit</td>\n<td align=\"center\">匹配到第一个即立刻退出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-exec [command] &#39;&#123;&#125;&#39; &#39;;&#39;</code></td>\n<td align=\"center\">“{}”代表匹配到的文件(为决定路径),因为是shell特殊符号所以要用单引号,结尾必须用”;”,同样是特殊符号,要用单引号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-ok [command] &#39;&#123;&#125;&#39; &#39;;&#39;</code></td>\n<td align=\"center\">与-exec相似，只不过执行前会进行确认</td>\n</tr>\n<tr>\n<td align=\"center\">-regex</td>\n<td align=\"center\">文件路径的正则匹配</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文件类型</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">b</td>\n<td align=\"center\">块特殊设备文件</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">字符特殊设备文件</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">目录</td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">普通文件</td>\n</tr>\n<tr>\n<td align=\"center\">l</td>\n<td align=\"center\">符号链接</td>\n</tr>\n</tbody></table>\n<p>控制find命令的搜索范围</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-depth</td>\n<td align=\"center\">指定find程序先处理目录中的文件,再处理目录自身(深度优先搜索?)。当指定-delete行为时,会自动用这个选项</td>\n</tr>\n<tr>\n<td align=\"center\">-maxdepth [num]</td>\n<td align=\"center\">设置陷入目录树的最大级别数</td>\n</tr>\n<tr>\n<td align=\"center\">-mindepth [num]</td>\n<td align=\"center\">设置陷入目录树的最小级别数</td>\n</tr>\n<tr>\n<td align=\"center\">-mount</td>\n<td align=\"center\">不搜索挂载到其他系统下的目录</td>\n</tr>\n<tr>\n<td align=\"center\">-noleaf</td>\n<td align=\"center\">在搜索DOS&#x2F;Win文件系统或CD&#x2F;ROMS时的时候优化选项</td>\n</tr>\n</tbody></table>\n<p>3.<strong>-exec与”+”</strong><br><code>find -type f -name &#39;foo*&#39; -exec ls -l &#39;&#123;&#125;&#39; &#39;;&#39;</code><br><code>find -type f -name &#39;foo*&#39; -exec ls -l &#39;&#123;&#125;&#39; +</code><br>上述两个命令的区别在于,假设匹配到fooA与fooB两个文件,第一个相当于执行两次ls命令,相当于<code>ls -l fooA</code>和<code>ls -l fooB</code>而第二个只执行一次<code>ls -l fooA fooB</code></p>\n<p>4.<strong>xargs</strong><br><code>find ~ -type f -name &#39;foo*&#39; -print | xargs ls -l</code>与上述带有”+”的-exec选项效果一样,注意xargs有最大参数个数限制,可以通过<code>xargs -show-limits</code>来查看最大值<br>5.<strong>文件名存在空格的问题</strong><br>类 Unix 的系统允许在文件名中嵌入空格(甚至换行符)。这就给一些程序,如<br>为其它程序构建参数列表的 xargs 程序,造成了问题。一个嵌入的空格会被看作是<br>一个分隔符,生成的命令会把每个空格分离的单词解释为单独的参数。为了解决这<br>个问题,find 命令和 xarg 程序允许使用一个可选的 null 字符作为参数分隔符。一<br>个 null 字符被定义在 ASCII 码中,由数字零来表示(相反的,例如,空格字符在<br>ASCII 码中由数字 32 表示)。find 命令提供的 -print0 行为,则会产生由 null 字符<br>分离的输出,并且 xargs 命令有一个 –null 选项,这个选项会接受由 null 字符分离<br>的输入。这里有一个例子<br><code>find ~ -iname &#39;*.jpg&#39; -print0 | xargs -null ls -l</code><br>6.<strong>例子</strong><br><code>sudo find /tmp -type d -empty</code><br><code>find ~ -perm /a=x</code>查找所有可执行文件<br><code>find . -regex &#39;.*[^-\\_./0-9a-zA-Z].*&#39;</code>查找不符合规范字符的路径名(中文咋办?)</p>\n"},{"title":"GDB","date":"2020-01-16T03:47:33.000Z","subtitle":null,"index_img":"/images/gdb.png","banner_img":"/images/gdb.png","_content":"\n- 编译文件时要加上-g选项\n　几种启动gdb方式:\n　`gdb <program>`,`gdb <program> core`(core是程序非法执行后core dump后产生的文件),`gdb <program> <PID>`(可以指定这个服务程序运行时的进程ID)\n- `break`  \n　a.加函数名,则会在函数内第一个非简单赋值语句处\n　b.加行号,则会在该行号处停止\n- `step(s)`:进入函数\n- `next`:不进入函数\n- `print /<f> <expr>`:<f>为格式\n　a.加表达式:其中$1、$2、....表示第几个print的表达式的值,$$n则表示倒数n+1的命令\n　b.变量=表达式:赋值\n　c.静态数组直接加数组名,动态数组格式为`*array@len`,@左边是array数组的首地址,右边则是数组的长度\n　d.格式表\n\n|符号|意义|\n|:-:|:-:|\n|x(a)|十六进制格式|\n|d|十进制格式|\n|u|十进制无符号整型|\n|o|八进制格式|\n|t|二进制格式|\n|c|字符格式|\n|f|浮点数格式|\n|s|字符串格式|\n|i|指令格式|\n\n- `display /<fmt> <expr>`:在使用display命令时,每次中断,挂起都会显示表达式的值,<fmt>指定格式可选有s和i\n  a.`info display`:查看display设置的自动显示信息\n  b.`enable/disable display <dnums>`:失效或恢复某个自动显示\n  c.`undisplay <dnums> or delete display <dnums>`:删除某个自动显示,支持1-5这样的范围表示或者以空格分割不同号码\n- `run`\n- `finish`:结束执行当前函数,显示其返回值\n- `set`:设置变量新值\n- `continue(cont)`:后面可以加数字,表示忽略几个断点\n- `condition <断点号>　<条件表达式>`:条件为真时,执行断点\n- `tbreak`:临时断点等价于`break xx;enable delete <断点号>`\n- `enable <断点编号>`:恢复暂时失效的断点\n- `disable <断点编号>`:使断点失效\n- `delete <断点的编号或表达式>`:清除断点或者表达式\n- `clear <要清除的断点所在的行号>`:与delete不同的是给出行号,并且gdb会给出提示,delete则不会\n- `watch <条件表达式>`:在表达式为真时中断程序的运行\n- `info line <行号>or<函数名>or<文件名:行号>or<文件名:函数名>`:显示所指定源代码运行时的内存地址\n- `disassemble <函数名>`:该函数的机器指令(汇编码)\n- 查看栈信息 \n　a.`bt <n>或<-n>`:打印栈顶n层或栈底n层信息,不加n则表示打印当前所有函数栈的信息\n　b.`frame(f) <n>`:frame 0表示栈顶,依次类推,不加n则表示输出当前层\n　c.`up <n>或down <n>`:向栈底移动n层或向栈顶移动一层,栈底处于高地址区域,栈顶处于低地址区域\n　d.`info frame(f)`:显示当前层更为详细的信息\n　e.`info args`:显示当前函数的参数名及值\n　f.`info locals`:显示当前函数所有局部变量及值\n　g.`info catch`:显示当前函数中的异常处理信息\n- 显示源代码--list\n　a.`list <linenum>`:显示第linenum行的周围的源程序\n　b.`list <function>`:显示function函数的源程序\n　c.`list`:显示当前行后面的源程序\n　d.`list -`:显示当前行前面的源程序\n　e.`list <first>,<last>`:first行到last行之间的源程序\n　f.`list ,<last>`:当前行到last行之间的源程序\n- 搜索源代码\n　a.`search <regexp>`:正向搜索\n　b.`reverse-search <regexp>`:反向搜索\n- 指定源文件路径--directory\n　a.`directory(dir) <dirname1:dirname2>`:添加路径到当前路径下\n　b.`direcory`:清除所有自定义源文件搜索路径\n　c.`show directories`:显示已定义的搜索路径\n- `examine(x)/<n/f/u> <addr>`　\n　n、f、u是可选参数\n　n:是一个正整数,表示一个显示内存的长度,也就是说从当前地址向后显示几个地址的内容\n　f:表示显示的格式\n　u:表示往后请求的字节数,默认是4bytes,b表示单字节,h表示双字节,w表示4字节,g表示8字节\n　`x/3uh 0x54320`表示从内存地址0x54320读取内容,h表示以双字节为一个单位,3表示3个单位,u表示以十进制无符号整型显示\n- 设置显示选项:`show\\set <某个选项> (状态)`\n　a.`set print address <on/off>`:系统默认打开,显示函数参数地址\n　b.`set print array <on/off>`:系统默认关闭,显示数组元素是否占一行\n　c.`set print elements <number of elements>`:显示数组最大显示长度,默认为0表示不做限制\n　d.`set print null-stop <on/off>`:默认为off,表示字符串时，遇到结束符是否停止显示\n　e.`set print pretty <on/off>`:为on时,结构体每个元素占一行\n　f.`set print sevenbit-strings <on/off>`:为on时,字符显示ascll码\n　g.`set print union <on/off>`:为on时,显示结构体中联合体数据\n　h.`set print statci-members <on/off>`:是否显示c++对象中静态数据成员\n　i.`set print object <on/off>`:是否按虚方法显示c++中的对象\n　j.`set print vtbl <on/off>`:按规整的格式显示虚函数表\n　k.`info frame`:查看当前函数语言\n　l.`info source`:查看当前文件语言\n　m.`show language`:查看当前语言环境\n　n.`set language <language>`:设置语言环境\n- `set`:可以用set设置gdb的环境变量,如:`set $i = 0`,为了不与环境变量冲突,设置程序中的值时最好用`set var xx=xx`\n- 寄存器情况\n　a.`info registers`:查看除浮点寄存器外的所有寄存器\n　b.`info all-registers`:查看所有寄存器\n　c.`info registers <regname>`:查看指定寄存器\n- 跳转\n　a.`jump <linespec or address>`:可以是文件的行号、也可以是file:line、也可以是＋num偏移量、也可以是内存地址\n- 产生信号量\n　`signal <1-15>`:在断点处设置1-15的任意信号\n- 强制函数返回\n　`return (<expression>)`:忽略当前函数未执行语句,直接返回表达式的值\n- 强制调用函数\n　`cal <expr>`:调用某函数\n- `ptype`:显示某个量的类型\n- `until`:执行某个循环体直到结束\n# 分割窗口\n- `layout`：用于分割窗口，可以一边查看代码，一边测试：\n- `layout src`：显示源代码窗口\n- `layout asm`：显示反汇编窗口\n- `layout regs`：显示源代码/反汇编和CPU寄存器窗口\n- `layout split`：显示源代码和反汇编窗口\n- Ctrl+L:刷新窗口\n","source":"_posts/GDB.md","raw":"---\ntitle: GDB\ndate: 2020-01-16 11:47:33\nsubtitle:\ncategories:\ntags:\nindex_img: /images/gdb.png\nbanner_img: /images/gdb.png\n---\n\n- 编译文件时要加上-g选项\n　几种启动gdb方式:\n　`gdb <program>`,`gdb <program> core`(core是程序非法执行后core dump后产生的文件),`gdb <program> <PID>`(可以指定这个服务程序运行时的进程ID)\n- `break`  \n　a.加函数名,则会在函数内第一个非简单赋值语句处\n　b.加行号,则会在该行号处停止\n- `step(s)`:进入函数\n- `next`:不进入函数\n- `print /<f> <expr>`:<f>为格式\n　a.加表达式:其中$1、$2、....表示第几个print的表达式的值,$$n则表示倒数n+1的命令\n　b.变量=表达式:赋值\n　c.静态数组直接加数组名,动态数组格式为`*array@len`,@左边是array数组的首地址,右边则是数组的长度\n　d.格式表\n\n|符号|意义|\n|:-:|:-:|\n|x(a)|十六进制格式|\n|d|十进制格式|\n|u|十进制无符号整型|\n|o|八进制格式|\n|t|二进制格式|\n|c|字符格式|\n|f|浮点数格式|\n|s|字符串格式|\n|i|指令格式|\n\n- `display /<fmt> <expr>`:在使用display命令时,每次中断,挂起都会显示表达式的值,<fmt>指定格式可选有s和i\n  a.`info display`:查看display设置的自动显示信息\n  b.`enable/disable display <dnums>`:失效或恢复某个自动显示\n  c.`undisplay <dnums> or delete display <dnums>`:删除某个自动显示,支持1-5这样的范围表示或者以空格分割不同号码\n- `run`\n- `finish`:结束执行当前函数,显示其返回值\n- `set`:设置变量新值\n- `continue(cont)`:后面可以加数字,表示忽略几个断点\n- `condition <断点号>　<条件表达式>`:条件为真时,执行断点\n- `tbreak`:临时断点等价于`break xx;enable delete <断点号>`\n- `enable <断点编号>`:恢复暂时失效的断点\n- `disable <断点编号>`:使断点失效\n- `delete <断点的编号或表达式>`:清除断点或者表达式\n- `clear <要清除的断点所在的行号>`:与delete不同的是给出行号,并且gdb会给出提示,delete则不会\n- `watch <条件表达式>`:在表达式为真时中断程序的运行\n- `info line <行号>or<函数名>or<文件名:行号>or<文件名:函数名>`:显示所指定源代码运行时的内存地址\n- `disassemble <函数名>`:该函数的机器指令(汇编码)\n- 查看栈信息 \n　a.`bt <n>或<-n>`:打印栈顶n层或栈底n层信息,不加n则表示打印当前所有函数栈的信息\n　b.`frame(f) <n>`:frame 0表示栈顶,依次类推,不加n则表示输出当前层\n　c.`up <n>或down <n>`:向栈底移动n层或向栈顶移动一层,栈底处于高地址区域,栈顶处于低地址区域\n　d.`info frame(f)`:显示当前层更为详细的信息\n　e.`info args`:显示当前函数的参数名及值\n　f.`info locals`:显示当前函数所有局部变量及值\n　g.`info catch`:显示当前函数中的异常处理信息\n- 显示源代码--list\n　a.`list <linenum>`:显示第linenum行的周围的源程序\n　b.`list <function>`:显示function函数的源程序\n　c.`list`:显示当前行后面的源程序\n　d.`list -`:显示当前行前面的源程序\n　e.`list <first>,<last>`:first行到last行之间的源程序\n　f.`list ,<last>`:当前行到last行之间的源程序\n- 搜索源代码\n　a.`search <regexp>`:正向搜索\n　b.`reverse-search <regexp>`:反向搜索\n- 指定源文件路径--directory\n　a.`directory(dir) <dirname1:dirname2>`:添加路径到当前路径下\n　b.`direcory`:清除所有自定义源文件搜索路径\n　c.`show directories`:显示已定义的搜索路径\n- `examine(x)/<n/f/u> <addr>`　\n　n、f、u是可选参数\n　n:是一个正整数,表示一个显示内存的长度,也就是说从当前地址向后显示几个地址的内容\n　f:表示显示的格式\n　u:表示往后请求的字节数,默认是4bytes,b表示单字节,h表示双字节,w表示4字节,g表示8字节\n　`x/3uh 0x54320`表示从内存地址0x54320读取内容,h表示以双字节为一个单位,3表示3个单位,u表示以十进制无符号整型显示\n- 设置显示选项:`show\\set <某个选项> (状态)`\n　a.`set print address <on/off>`:系统默认打开,显示函数参数地址\n　b.`set print array <on/off>`:系统默认关闭,显示数组元素是否占一行\n　c.`set print elements <number of elements>`:显示数组最大显示长度,默认为0表示不做限制\n　d.`set print null-stop <on/off>`:默认为off,表示字符串时，遇到结束符是否停止显示\n　e.`set print pretty <on/off>`:为on时,结构体每个元素占一行\n　f.`set print sevenbit-strings <on/off>`:为on时,字符显示ascll码\n　g.`set print union <on/off>`:为on时,显示结构体中联合体数据\n　h.`set print statci-members <on/off>`:是否显示c++对象中静态数据成员\n　i.`set print object <on/off>`:是否按虚方法显示c++中的对象\n　j.`set print vtbl <on/off>`:按规整的格式显示虚函数表\n　k.`info frame`:查看当前函数语言\n　l.`info source`:查看当前文件语言\n　m.`show language`:查看当前语言环境\n　n.`set language <language>`:设置语言环境\n- `set`:可以用set设置gdb的环境变量,如:`set $i = 0`,为了不与环境变量冲突,设置程序中的值时最好用`set var xx=xx`\n- 寄存器情况\n　a.`info registers`:查看除浮点寄存器外的所有寄存器\n　b.`info all-registers`:查看所有寄存器\n　c.`info registers <regname>`:查看指定寄存器\n- 跳转\n　a.`jump <linespec or address>`:可以是文件的行号、也可以是file:line、也可以是＋num偏移量、也可以是内存地址\n- 产生信号量\n　`signal <1-15>`:在断点处设置1-15的任意信号\n- 强制函数返回\n　`return (<expression>)`:忽略当前函数未执行语句,直接返回表达式的值\n- 强制调用函数\n　`cal <expr>`:调用某函数\n- `ptype`:显示某个量的类型\n- `until`:执行某个循环体直到结束\n# 分割窗口\n- `layout`：用于分割窗口，可以一边查看代码，一边测试：\n- `layout src`：显示源代码窗口\n- `layout asm`：显示反汇编窗口\n- `layout regs`：显示源代码/反汇编和CPU寄存器窗口\n- `layout split`：显示源代码和反汇编窗口\n- Ctrl+L:刷新窗口\n","slug":"GDB","published":1,"updated":"2024-04-29T19:39:56.669Z","_id":"clq1yvi6u0009gwq2gedfaf02","comments":1,"layout":"post","photos":[],"content":"<ul>\n<li>编译文件时要加上-g选项<br>　几种启动gdb方式:<br>　<code>gdb &lt;program&gt;</code>,<code>gdb &lt;program&gt; core</code>(core是程序非法执行后core dump后产生的文件),<code>gdb &lt;program&gt; &lt;PID&gt;</code>(可以指定这个服务程序运行时的进程ID)</li>\n<li><code>break</code><br>　a.加函数名,则会在函数内第一个非简单赋值语句处<br>　b.加行号,则会在该行号处停止</li>\n<li><code>step(s)</code>:进入函数</li>\n<li><code>next</code>:不进入函数</li>\n<li><code>print /&lt;f&gt; &lt;expr&gt;</code>:<f>为格式<br>　a.加表达式:其中$1、$2、….表示第几个print的表达式的值,$$n则表示倒数n+1的命令<br>　b.变量&#x3D;表达式:赋值<br>　c.静态数组直接加数组名,动态数组格式为<code>*array@len</code>,@左边是array数组的首地址,右边则是数组的长度<br>　d.格式表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">x(a)</td>\n<td align=\"center\">十六进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">十进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">u</td>\n<td align=\"center\">十进制无符号整型</td>\n</tr>\n<tr>\n<td align=\"center\">o</td>\n<td align=\"center\">八进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">二进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">字符格式</td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">浮点数格式</td>\n</tr>\n<tr>\n<td align=\"center\">s</td>\n<td align=\"center\">字符串格式</td>\n</tr>\n<tr>\n<td align=\"center\">i</td>\n<td align=\"center\">指令格式</td>\n</tr>\n</tbody></table>\n<ul>\n<li><code>display /&lt;fmt&gt; &lt;expr&gt;</code>:在使用display命令时,每次中断,挂起都会显示表达式的值,<fmt>指定格式可选有s和i<br>a.<code>info display</code>:查看display设置的自动显示信息<br>b.<code>enable/disable display &lt;dnums&gt;</code>:失效或恢复某个自动显示<br>c.<code>undisplay &lt;dnums&gt; or delete display &lt;dnums&gt;</code>:删除某个自动显示,支持1-5这样的范围表示或者以空格分割不同号码</li>\n<li><code>run</code></li>\n<li><code>finish</code>:结束执行当前函数,显示其返回值</li>\n<li><code>set</code>:设置变量新值</li>\n<li><code>continue(cont)</code>:后面可以加数字,表示忽略几个断点</li>\n<li><code>condition &lt;断点号&gt;　&lt;条件表达式&gt;</code>:条件为真时,执行断点</li>\n<li><code>tbreak</code>:临时断点等价于<code>break xx;enable delete &lt;断点号&gt;</code></li>\n<li><code>enable &lt;断点编号&gt;</code>:恢复暂时失效的断点</li>\n<li><code>disable &lt;断点编号&gt;</code>:使断点失效</li>\n<li><code>delete &lt;断点的编号或表达式&gt;</code>:清除断点或者表达式</li>\n<li><code>clear &lt;要清除的断点所在的行号&gt;</code>:与delete不同的是给出行号,并且gdb会给出提示,delete则不会</li>\n<li><code>watch &lt;条件表达式&gt;</code>:在表达式为真时中断程序的运行</li>\n<li><code>info line &lt;行号&gt;or&lt;函数名&gt;or&lt;文件名:行号&gt;or&lt;文件名:函数名&gt;</code>:显示所指定源代码运行时的内存地址</li>\n<li><code>disassemble &lt;函数名&gt;</code>:该函数的机器指令(汇编码)</li>\n<li>查看栈信息<br>　a.<code>bt &lt;n&gt;或&lt;-n&gt;</code>:打印栈顶n层或栈底n层信息,不加n则表示打印当前所有函数栈的信息<br>　b.<code>frame(f) &lt;n&gt;</code>:frame 0表示栈顶,依次类推,不加n则表示输出当前层<br>　c.<code>up &lt;n&gt;或down &lt;n&gt;</code>:向栈底移动n层或向栈顶移动一层,栈底处于高地址区域,栈顶处于低地址区域<br>　d.<code>info frame(f)</code>:显示当前层更为详细的信息<br>　e.<code>info args</code>:显示当前函数的参数名及值<br>　f.<code>info locals</code>:显示当前函数所有局部变量及值<br>　g.<code>info catch</code>:显示当前函数中的异常处理信息</li>\n<li>显示源代码–list<br>　a.<code>list &lt;linenum&gt;</code>:显示第linenum行的周围的源程序<br>　b.<code>list &lt;function&gt;</code>:显示function函数的源程序<br>　c.<code>list</code>:显示当前行后面的源程序<br>　d.<code>list -</code>:显示当前行前面的源程序<br>　e.<code>list &lt;first&gt;,&lt;last&gt;</code>:first行到last行之间的源程序<br>　f.<code>list ,&lt;last&gt;</code>:当前行到last行之间的源程序</li>\n<li>搜索源代码<br>　a.<code>search &lt;regexp&gt;</code>:正向搜索<br>　b.<code>reverse-search &lt;regexp&gt;</code>:反向搜索</li>\n<li>指定源文件路径–directory<br>　a.<code>directory(dir) &lt;dirname1:dirname2&gt;</code>:添加路径到当前路径下<br>　b.<code>direcory</code>:清除所有自定义源文件搜索路径<br>　c.<code>show directories</code>:显示已定义的搜索路径</li>\n<li><code>examine(x)/&lt;n/f/u&gt; &lt;addr&gt;</code>　<br>　n、f、u是可选参数<br>　n:是一个正整数,表示一个显示内存的长度,也就是说从当前地址向后显示几个地址的内容<br>　f:表示显示的格式<br>　u:表示往后请求的字节数,默认是4bytes,b表示单字节,h表示双字节,w表示4字节,g表示8字节<br>　<code>x/3uh 0x54320</code>表示从内存地址0x54320读取内容,h表示以双字节为一个单位,3表示3个单位,u表示以十进制无符号整型显示</li>\n<li>设置显示选项:<code>show\\set &lt;某个选项&gt; (状态)</code><br>　a.<code>set print address &lt;on/off&gt;</code>:系统默认打开,显示函数参数地址<br>　b.<code>set print array &lt;on/off&gt;</code>:系统默认关闭,显示数组元素是否占一行<br>　c.<code>set print elements &lt;number of elements&gt;</code>:显示数组最大显示长度,默认为0表示不做限制<br>　d.<code>set print null-stop &lt;on/off&gt;</code>:默认为off,表示字符串时，遇到结束符是否停止显示<br>　e.<code>set print pretty &lt;on/off&gt;</code>:为on时,结构体每个元素占一行<br>　f.<code>set print sevenbit-strings &lt;on/off&gt;</code>:为on时,字符显示ascll码<br>　g.<code>set print union &lt;on/off&gt;</code>:为on时,显示结构体中联合体数据<br>　h.<code>set print statci-members &lt;on/off&gt;</code>:是否显示c++对象中静态数据成员<br>　i.<code>set print object &lt;on/off&gt;</code>:是否按虚方法显示c++中的对象<br>　j.<code>set print vtbl &lt;on/off&gt;</code>:按规整的格式显示虚函数表<br>　k.<code>info frame</code>:查看当前函数语言<br>　l.<code>info source</code>:查看当前文件语言<br>　m.<code>show language</code>:查看当前语言环境<br>　n.<code>set language &lt;language&gt;</code>:设置语言环境</li>\n<li><code>set</code>:可以用set设置gdb的环境变量,如:<code>set $i = 0</code>,为了不与环境变量冲突,设置程序中的值时最好用<code>set var xx=xx</code></li>\n<li>寄存器情况<br>　a.<code>info registers</code>:查看除浮点寄存器外的所有寄存器<br>　b.<code>info all-registers</code>:查看所有寄存器<br>　c.<code>info registers &lt;regname&gt;</code>:查看指定寄存器</li>\n<li>跳转<br>　a.<code>jump &lt;linespec or address&gt;</code>:可以是文件的行号、也可以是file:line、也可以是＋num偏移量、也可以是内存地址</li>\n<li>产生信号量<br>　<code>signal &lt;1-15&gt;</code>:在断点处设置1-15的任意信号</li>\n<li>强制函数返回<br>　<code>return (&lt;expression&gt;)</code>:忽略当前函数未执行语句,直接返回表达式的值</li>\n<li>强制调用函数<br>　<code>cal &lt;expr&gt;</code>:调用某函数</li>\n<li><code>ptype</code>:显示某个量的类型</li>\n<li><code>until</code>:执行某个循环体直到结束</li>\n</ul>\n<h1 id=\"分割窗口\"><a href=\"#分割窗口\" class=\"headerlink\" title=\"分割窗口\"></a>分割窗口</h1><ul>\n<li><code>layout</code>：用于分割窗口，可以一边查看代码，一边测试：</li>\n<li><code>layout src</code>：显示源代码窗口</li>\n<li><code>layout asm</code>：显示反汇编窗口</li>\n<li><code>layout regs</code>：显示源代码&#x2F;反汇编和CPU寄存器窗口</li>\n<li><code>layout split</code>：显示源代码和反汇编窗口</li>\n<li>Ctrl+L:刷新窗口</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>编译文件时要加上-g选项<br>　几种启动gdb方式:<br>　<code>gdb &lt;program&gt;</code>,<code>gdb &lt;program&gt; core</code>(core是程序非法执行后core dump后产生的文件),<code>gdb &lt;program&gt; &lt;PID&gt;</code>(可以指定这个服务程序运行时的进程ID)</li>\n<li><code>break</code><br>　a.加函数名,则会在函数内第一个非简单赋值语句处<br>　b.加行号,则会在该行号处停止</li>\n<li><code>step(s)</code>:进入函数</li>\n<li><code>next</code>:不进入函数</li>\n<li><code>print /&lt;f&gt; &lt;expr&gt;</code>:<f>为格式<br>　a.加表达式:其中$1、$2、….表示第几个print的表达式的值,$$n则表示倒数n+1的命令<br>　b.变量&#x3D;表达式:赋值<br>　c.静态数组直接加数组名,动态数组格式为<code>*array@len</code>,@左边是array数组的首地址,右边则是数组的长度<br>　d.格式表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">x(a)</td>\n<td align=\"center\">十六进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">十进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">u</td>\n<td align=\"center\">十进制无符号整型</td>\n</tr>\n<tr>\n<td align=\"center\">o</td>\n<td align=\"center\">八进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">二进制格式</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">字符格式</td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">浮点数格式</td>\n</tr>\n<tr>\n<td align=\"center\">s</td>\n<td align=\"center\">字符串格式</td>\n</tr>\n<tr>\n<td align=\"center\">i</td>\n<td align=\"center\">指令格式</td>\n</tr>\n</tbody></table>\n<ul>\n<li><code>display /&lt;fmt&gt; &lt;expr&gt;</code>:在使用display命令时,每次中断,挂起都会显示表达式的值,<fmt>指定格式可选有s和i<br>a.<code>info display</code>:查看display设置的自动显示信息<br>b.<code>enable/disable display &lt;dnums&gt;</code>:失效或恢复某个自动显示<br>c.<code>undisplay &lt;dnums&gt; or delete display &lt;dnums&gt;</code>:删除某个自动显示,支持1-5这样的范围表示或者以空格分割不同号码</li>\n<li><code>run</code></li>\n<li><code>finish</code>:结束执行当前函数,显示其返回值</li>\n<li><code>set</code>:设置变量新值</li>\n<li><code>continue(cont)</code>:后面可以加数字,表示忽略几个断点</li>\n<li><code>condition &lt;断点号&gt;　&lt;条件表达式&gt;</code>:条件为真时,执行断点</li>\n<li><code>tbreak</code>:临时断点等价于<code>break xx;enable delete &lt;断点号&gt;</code></li>\n<li><code>enable &lt;断点编号&gt;</code>:恢复暂时失效的断点</li>\n<li><code>disable &lt;断点编号&gt;</code>:使断点失效</li>\n<li><code>delete &lt;断点的编号或表达式&gt;</code>:清除断点或者表达式</li>\n<li><code>clear &lt;要清除的断点所在的行号&gt;</code>:与delete不同的是给出行号,并且gdb会给出提示,delete则不会</li>\n<li><code>watch &lt;条件表达式&gt;</code>:在表达式为真时中断程序的运行</li>\n<li><code>info line &lt;行号&gt;or&lt;函数名&gt;or&lt;文件名:行号&gt;or&lt;文件名:函数名&gt;</code>:显示所指定源代码运行时的内存地址</li>\n<li><code>disassemble &lt;函数名&gt;</code>:该函数的机器指令(汇编码)</li>\n<li>查看栈信息<br>　a.<code>bt &lt;n&gt;或&lt;-n&gt;</code>:打印栈顶n层或栈底n层信息,不加n则表示打印当前所有函数栈的信息<br>　b.<code>frame(f) &lt;n&gt;</code>:frame 0表示栈顶,依次类推,不加n则表示输出当前层<br>　c.<code>up &lt;n&gt;或down &lt;n&gt;</code>:向栈底移动n层或向栈顶移动一层,栈底处于高地址区域,栈顶处于低地址区域<br>　d.<code>info frame(f)</code>:显示当前层更为详细的信息<br>　e.<code>info args</code>:显示当前函数的参数名及值<br>　f.<code>info locals</code>:显示当前函数所有局部变量及值<br>　g.<code>info catch</code>:显示当前函数中的异常处理信息</li>\n<li>显示源代码–list<br>　a.<code>list &lt;linenum&gt;</code>:显示第linenum行的周围的源程序<br>　b.<code>list &lt;function&gt;</code>:显示function函数的源程序<br>　c.<code>list</code>:显示当前行后面的源程序<br>　d.<code>list -</code>:显示当前行前面的源程序<br>　e.<code>list &lt;first&gt;,&lt;last&gt;</code>:first行到last行之间的源程序<br>　f.<code>list ,&lt;last&gt;</code>:当前行到last行之间的源程序</li>\n<li>搜索源代码<br>　a.<code>search &lt;regexp&gt;</code>:正向搜索<br>　b.<code>reverse-search &lt;regexp&gt;</code>:反向搜索</li>\n<li>指定源文件路径–directory<br>　a.<code>directory(dir) &lt;dirname1:dirname2&gt;</code>:添加路径到当前路径下<br>　b.<code>direcory</code>:清除所有自定义源文件搜索路径<br>　c.<code>show directories</code>:显示已定义的搜索路径</li>\n<li><code>examine(x)/&lt;n/f/u&gt; &lt;addr&gt;</code>　<br>　n、f、u是可选参数<br>　n:是一个正整数,表示一个显示内存的长度,也就是说从当前地址向后显示几个地址的内容<br>　f:表示显示的格式<br>　u:表示往后请求的字节数,默认是4bytes,b表示单字节,h表示双字节,w表示4字节,g表示8字节<br>　<code>x/3uh 0x54320</code>表示从内存地址0x54320读取内容,h表示以双字节为一个单位,3表示3个单位,u表示以十进制无符号整型显示</li>\n<li>设置显示选项:<code>show\\set &lt;某个选项&gt; (状态)</code><br>　a.<code>set print address &lt;on/off&gt;</code>:系统默认打开,显示函数参数地址<br>　b.<code>set print array &lt;on/off&gt;</code>:系统默认关闭,显示数组元素是否占一行<br>　c.<code>set print elements &lt;number of elements&gt;</code>:显示数组最大显示长度,默认为0表示不做限制<br>　d.<code>set print null-stop &lt;on/off&gt;</code>:默认为off,表示字符串时，遇到结束符是否停止显示<br>　e.<code>set print pretty &lt;on/off&gt;</code>:为on时,结构体每个元素占一行<br>　f.<code>set print sevenbit-strings &lt;on/off&gt;</code>:为on时,字符显示ascll码<br>　g.<code>set print union &lt;on/off&gt;</code>:为on时,显示结构体中联合体数据<br>　h.<code>set print statci-members &lt;on/off&gt;</code>:是否显示c++对象中静态数据成员<br>　i.<code>set print object &lt;on/off&gt;</code>:是否按虚方法显示c++中的对象<br>　j.<code>set print vtbl &lt;on/off&gt;</code>:按规整的格式显示虚函数表<br>　k.<code>info frame</code>:查看当前函数语言<br>　l.<code>info source</code>:查看当前文件语言<br>　m.<code>show language</code>:查看当前语言环境<br>　n.<code>set language &lt;language&gt;</code>:设置语言环境</li>\n<li><code>set</code>:可以用set设置gdb的环境变量,如:<code>set $i = 0</code>,为了不与环境变量冲突,设置程序中的值时最好用<code>set var xx=xx</code></li>\n<li>寄存器情况<br>　a.<code>info registers</code>:查看除浮点寄存器外的所有寄存器<br>　b.<code>info all-registers</code>:查看所有寄存器<br>　c.<code>info registers &lt;regname&gt;</code>:查看指定寄存器</li>\n<li>跳转<br>　a.<code>jump &lt;linespec or address&gt;</code>:可以是文件的行号、也可以是file:line、也可以是＋num偏移量、也可以是内存地址</li>\n<li>产生信号量<br>　<code>signal &lt;1-15&gt;</code>:在断点处设置1-15的任意信号</li>\n<li>强制函数返回<br>　<code>return (&lt;expression&gt;)</code>:忽略当前函数未执行语句,直接返回表达式的值</li>\n<li>强制调用函数<br>　<code>cal &lt;expr&gt;</code>:调用某函数</li>\n<li><code>ptype</code>:显示某个量的类型</li>\n<li><code>until</code>:执行某个循环体直到结束</li>\n</ul>\n<h1 id=\"分割窗口\"><a href=\"#分割窗口\" class=\"headerlink\" title=\"分割窗口\"></a>分割窗口</h1><ul>\n<li><code>layout</code>：用于分割窗口，可以一边查看代码，一边测试：</li>\n<li><code>layout src</code>：显示源代码窗口</li>\n<li><code>layout asm</code>：显示反汇编窗口</li>\n<li><code>layout regs</code>：显示源代码&#x2F;反汇编和CPU寄存器窗口</li>\n<li><code>layout split</code>：显示源代码和反汇编窗口</li>\n<li>Ctrl+L:刷新窗口</li>\n</ul>\n"},{"title":"Linux命令","date":"2019-07-18T08:15:42.000Z","subtitle":null,"index_img":"/images/linuxCmd.jpeg","banner_img":"/images/linuxCmd.jpeg","_content":"- 同时对某个目录下多个文件操作用`{a,b}`\n- 搜索某个软件包 `sudo apt-cache search <关键字>`\n- 终端快捷键:\n\n  |按键|功能|\n  |:-:|:-:|\n  |ctrl+a|命令行首部|\n  |ctrl+e|命令行尾部|\n  |ctrl+f|前移一个字符|\n  |ctrl+b|后移一个字符|\n  |ctrl+l|等价于clear|\n  |ctrl+n|向下翻页|\n  |ctrl+p|向上翻页|\n  |alt+f|前移一个字|\n  |alt+b|后移一个字|\n  |alt+c|单词首字符大写|\n  |alt+t|光标位置的字和其前面的字互换|\n  |alt+l|从光标到字尾转换成小写字母|\n  |alt+u|从光标到字尾转换成大写字母|\n  |alt+d|剪切从光标到字尾的文本|\n  |alt+#|注释当前的命令|\n  |alt+.|插入上一个命令的最后一个参数|\n  |alt+Backspace|剪切从光标到字首的文本|\n  |ctrl+k|删除光标后的字符|\n  |ctrl+d|删除光标上的字符|\n  |ctrl+t|交换光标处和它的前面字符|\n  |ctrl+s|锁定屏幕|\n  |ctrl+q|解锁|\n  |ctrl+h|删除左侧字符|\n  |ctrl+w|删除上一个单词|\n  |ctrl+y|粘贴剪切的文本|\n  |ctrl+k|剪切从光标到行尾的文本|\n  |ctrl+u|剪切从光标到行首的文本|\n  |ctrl+v|输入特殊字符|\n  |ctrl+r|搜索词,再次按该组合键可以循环搜索,回车选中,ctrl+G不做任何操作返回终端|\n  |ctrl+x+ctrl+e|在文本编辑器中快速打开当前命令,退出编辑器后，自动执行|\n  |set -o vi |设置vi风格|\n  |!$|重新使用上一个命令中的最后一项(最好用`alt+.`可以跳转上几次)|\n  |!number|重复历史表中第number行命令|\n  |!!|执行上一个命令(常用于忘加sudo`sudo !!`)|\n- 命令间连接\n  - \";\":一直执行无论成功与否\n  - \"&&\":前面的命令执行成功才能执行后面\n  - \"||\":前面的命令执行失败才能执行后面\n- `kill %2` 2代表jobs命令显示下的任务号码,%区别于进程ID\n- man\n\n  `man <num> <cmd>`\n\n  |章节|内容|\n  |:-:|:-:|\n  |1|用户命令|\n  |2|程序接口内核系统调用|\n  |3|c库函数程序接口|\n  |4|特殊文件,比如说设备节点和驱动程序|\n  |5|文件格式|\n  |6|游戏娱乐,如屏幕保护程序|\n  |7|其他方面|\n  |8|系统管理员命令|\n  |9|内核例程|\n  `-k <pattern>`在文档中搜索某个关键字,\n- 后台运行\n\n  `nohup [命令参数] &`\n- ln命令：\n  - `ln source target` 硬链接\n  - `ln -s source target`软连接。\n  \n  两者的区别:\n  - 软连接不增加文件的链接数，而硬链接则增加\n  - 不能跨文件系统创建硬链接，硬链接不能连接目录\n  - 硬链接的inode号完全相同，指向同一文件，软连接则有不同的inode号，并且新文件类型为专有软链接类型，其指向的文件内容存储着实际文件的路径\n  - 硬链接指向的文件当链接数减为0时，才真正删除，软链接若实际文件删除，则软链接失效。\n`readlink -f filename`可以显示链接的原始指向位置\n- nslookup\n\n  `nslookup github.global.ssl.fastly.Net`\n  `nslookup github.com`\n  查到的域名加到/etc/hosts里可以加快访问速度 \n`sudo /etc/init.d/networking restart`刷新缓存\n- systemctl\n\n  - systemctl查看/etc/init.d中哪些服务进程会在引导时启动  \n  `systemctl list-unit-files --type=service | grep enabled`  \n  - 查找废弃服务\n  `systemctl --all | grep not-found`\n  - 停止某个服务进程、开机禁止启动以及某个进程的状态  \n  `sudo systemctl stop xxx.service`  \n  `sudo systemctl disable xxx.service`  \n  `sudo systemctl status xxx.service`  \n**注**:不能启用或禁用静态服务，这些服务为其他进程所依赖。\n  - 查看前一次启动的开机日志`journalctl -b -1`  \n  - 查看启动服务消耗时间`systemd-analyze blame`\n  - mask禁用某种服务 `systemctl mask xx.service`\n- 命令行复制到剪贴板\n  `cat filename | xsel -b`\n- plymouth\n  - 主题文件夹：/usr/share/plymouth/themes/\n  - 设置文件夹:/etc/plymouth/plymouthd.conf\n  - 列出主题列表`plymouth-set-default-theme -l`\n  - 更改Theme=的内容`sudo vi /etc/plymouth/plymouthd.conf`\n  `sudo mkinitcpio -p linux`生成新的镜像,重启生效\n  需要'quite splash'静默启动参数,在grub里设置\n- `grub-mkconfig` 刷新grub的配置\n- 同个命令对应不同软件版本配置\n\n  `update-alternatives --install <link> <name> <path> <priority>`\n\n  `update-alternatives --install /usr/bin/arm-linux-gnueabi-gcc arm-linux-gnueabi-gcc /usr/bin/arm-linux-gnueabi-gcc-5 5`\n\n  `update-alternatives --config arm-linux-gnueabi-gcc`\n- 内核模块相关\n  - `modinfo *.ko`查看某个编译好的模块\n  - `sudo insmod *.ko`装入模块\n  - `dmesg` 查看内核打印信息\n  - `lsmod` 显示已加载的模块\n  - 已加载的模块会在/sys/module/下建立对应文件夹\n  - `sudo rmmod x.ko`卸载模块\n- 手机USB线wifi共享：\n  - `ip addr show`查看USB网络借口\n  - `dhclient enpxxx`给借口设置ip地址，手机热点要开\n- od命令\n  - `od -t x1 x.dat`以十六进制打印文件x.dat各字节\n  - `od -c /bin/bash`逐字符方式打印文件,遇到不可打印字符打印编码\n  - `echo \\' | od -t o1`查看单引号的八进制\n- md5sum命令\n  - `md5sum file1 file2`计算两个文件的md5值,相同文件md5值相同\n- 行律问题\n  - `ctty -a`查看行律配置\n  - `ctty erase ^H`设置退格键\n- windows文件不兼容\n  - `unix2dos filename`转换成windows类型的文件,也有dos2unix命令\n- gbk中文字符转换为utf\n  - `iconv -f utf-8 -t gbk`\n  - `echo \"汉字\" | iconv -f utf-8 -t gbk | od -t x1`\n- `--`显示终止选项命令\n  `rm -- -i`表示删除名为'-i'的文件\n- 在任何命令前加`time`,可以计时运行时间\n# xargs命令\n将标准输入构造为命令的命令行参数,如果命令行参数过多,会启动多个进程,与单一普通管道相比就是批处理\n## 举例\n- 打印c语言文件含有--hlep的行：`find src -name \\*.c -print | xargs grep -n -- --help`\n- 只打印不执行命令，用于确认：`ls|xargs -L1 -p head`\n- 移动文件到文件夹:`find . -name \"*.bak\" -print 0|xargs -0 -I file mv file ~/old`\n\n# 输入重定向\n- `cat < filename`打印名为filename的文件内容\n- `cat << END`接下来直到END之间的内容\n- `cat <<< filename`打印filename这个单词\n- `> 文件名`清空文件\n# tee\n  从Stdin读取数据，并同时输出到Stdout和文件 `ls /usr/bin | tee ls.txt |grep zip`\n# du命令  \n- `du -sh * | sort -rh`查看当前目录下所有文件大小并排序\n- `du -sh`统计当前目录大小\n- `du -h --max-depth=1 | sort`查看当前所有一级子目录大小并排序\n\n# at\n  - `systemctl start atd.service`启动服务\n  - `at <时间点>`时间点格式举例:19:33、3pm+7 days、20:00 tomorrow 之后进入交互界面,输入命令,ctrl+D退出\n  - `at -l 或者 atq`查看列表\n  - `at -c 任务号`查看任务内容\n  - `at -r 任务号 或者 atrm 任务号`取消任务\n  - `at -f 脚本文件`不进入交互,直接运行某个脚本\n  - `-M`忽略产生的任何输出\n  - /etc/at.deny,文件中的用户不能执行at(系统默认存在)\n  - /etc/at.allow,默认不存在,只要存在的用户才能执行\n# crontab服务定时任务计划\n- `sudo systemctl start cronie.service`启动服务\n- `crontab -e`新增任务或编辑任务\n- `crontab -l`显示crontab文件\n- `crontab -r`删除crontab文件\n- `crontab -ir`删除crontab文件前提醒用户\n## 内容格式\n格式如下: `<minute> <hour> <day> <month> <week> <command>`\n\n|条目|取值|\n|:-:|:-:|\n|minute|0到59之间任何整数|\n|hour|0到23之间任何整数|\n|day|1到31之间的任何整数|\n|month|1到12之间任何整数|\n|week|1到7之间任何整数,|\n|command|执行的命令|\n\n- `*`代表所有可能值\n- `,`一个列表范围\n- `-`表示一个整数范围\n- `/`指定时间间隔的频率,比如\"0-23/2\"表示每两小时执行\n## example\n如果对时间精读要求不高,可以把脚本复制到/etc/cron.daily等目录下\n- `* * * * * myCommand`:每分钟执行一次\n- `3,15 * * * * myCommand`:每小时的第3和第15分钟执行\n- `3,15 8-11 * * * myCommand`:在上午8点到11点的第3和第15分钟执行\n- `3,15 8-11 */2  *  * myCommand`:每隔两天的上午8点到11点的第3和第15分钟执行\n- `3,15 8-11 * * 1 myCommand`:每周一上午8点到11点的第3和第15分钟执行\n- `30 21 * * * /etc/init.d/smb restart`:每晚的21:30重启smb\n- `45 4 1,10,22 * * /etc/init.d/smb restart`:每月1、10、22日的4 : 45重启smb\n- `10 1 * * 6,0 /etc/init.d/smb restart`:每周六、周日的1 : 10重启smb\n- `0,30 18-23 * * * /etc/init.d/smb restart`:每天18 : 00至23 : 00之间每隔30分钟重启smb\n- `0 23 * * 6 /etc/init.d/smb restart`:每星期六的晚上11 : 00 pm重启smb\n- `* */1 * * * /etc/init.d/smb restart`:每一小时重启smb\n- `0 23-7 * * * /etc/init.d/smb restart`晚上11点到早上7点之间，每隔一小时重启smb\n## anacron\nanacron是对该程序的一个补充,它会自动运行crontab原本应该运行但由于关机等原因造成的程序,但它只会处理位于/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly下的脚本文件,它的配置文件位于/etc/anacrontab\nanacron是自动运行的?(有待研究)\n- run-parts一个接一个运行同一目录下的脚本\n  -  `run-parts<directory-path>`\n  -  `run-parts --list --regex  '^s.\\*sh$' <directory> `\n- `type <command>`识别命令,有以下几种\n  - 可执行命令，给出路径\n  - shell自身的命令(builtins),内建命令不会产生子进程,代价更小\n  - 一个shell函数\n  - 别名命令\n- `whatis <command>`会给出命令简短的说明\n- `rm !(*.csv)`删除除了csv结尾的所有文件(貌似只有bash支持，zsh不支持)\n- `mkdir {2007..2009}\\_0{1..9}{A,B}`创建一系列文件夹,这其实是花括号展开\n- `apropos <some word>`在man手册里搜索关键字\n- `info <command>`man手册的另一种排版，有点鸡肋\n- 标准错误的重定向\n\n  标准错误和标准输出重定向同一个文件\n  `ls -l xx >info.txt 2>&1`等价于`ls -l xx &> info.txt`\n- env 或 printenv打印当前环境变量(全局变量)\n- set打印当前环境变量并按字母排列(包括局部变量、全局变量、用户定义变量)\n- alias查看别名,上面的不可以查看\n- `ps -f --forest` 可以显示当前shell的进程关系\n- coproc(这就是协程?)\n  `coproc [job_name(可选)] [command]`等价于`( command )&`\n  即生成后台子shell，并在子shell中执行命令。command本身可以是小括号命令集(嵌套子shell)或大括号命令集\n- mktemp\n\n  mktemp可以用来创建临时文件,成功会输出文件路径\n  \n  `mktemp [module]`不指定[module]会在/tmp中创建唯一临时文件,有用户有读写权限(不使用umask值),若指定[module],则会在当前文件夹下产生模板临时文件(会用任意字符替换模板值中的X),如`mktemp test.XXX`可能会在当前文件夹下产生文件test.UGH\n\n  -t:强制在/tmp下创建临时文件\n\n  -d:创建临时目录\n- nice以某个优先级来运行某个程序\n  `nice -[num] [command]`,num值越大,优先级越低,可以通过\"ps -o ni\"查看优先级,只能降低,不能提高优先级,\n- renice调整某个程序优先级\n  `renice -[num] -p [process id]`普通用户只能降低优先级,root可以任意调整\n- ntpd\n  `sudo ntpd -qg`可以校准时间\n- readlink输出文件的绝对路径\n `readlink -f [fileName]`\n- truncate\n`truncate -s 5 test.txt`截断test.txt，只保留5个字符\n- nm\nnm作用于目标文件，统计标识符有大用\n- parallel\nparallel用法复杂，建议读man\n**用法:**\n  - cmd | parallel [options] 'somecmd',parallel会默认把每行的内容,插到命令末尾\n  - parallel [options] 'cmd' ::: [parameter1 list] ::: [parameter2 list]...\n强大的xargs的升级版（这只是个人感觉啊）\n\n|选项|含义|\n|:-:|:-:|\n|-j/--jobs [num]|同时运行num个任务|\n|--C/--colsep [regep]|参数分隔符号|\n|--header|忽略第一行|\n|--results [file]|保存输出内容到某文件，还会输出到标准输出|\n|--keep-order|并行有时会不按输出行的顺序，这个保持顺序|\n|--tag|在每个结果开头，输出参数内容|\n|--slf/--sshloginfile [hostnames]|使用远程机当算力|\n|--sshlogin|登录远程机|\n|--nonall|不传递参数，只传递命令给远程机|\n|-N[num]|分配给远程多少个参数|\n\n|特殊变量名|含义|\n|:-:|:-:|\n|`{}`|一行的内容|\n|`{/}`|相当于对当前行运行basename|\n|`{井}`|任务号，从1开始编号|\n\n**例子：**\n- `seq 0 2 100 | parallel \"echo {}^2 | bc\"`\n- `seq 1000 | parallel -N100 --pipe --slf hostnames \"paste -sd+ | bc\" | paste -sd+|bc`并行算1-1000的和，一个核算一百个参数\n- history\n任何匹配HISTIGNORE环境变量的命令不会被记录,以`:`分割多个模式\n1) `unset HISTFILE`当前会话下不记录命令行历史\n2) 设置HISTIGNORE为`HISTIGNORE=\"[&:\\t]\"`在命令前加空格会使当前命令不被记录到历史,并且`&`表示上一次执行的命令，就是重复命令只记录一次\n3) `HISTFILE=~/docs/shell_history.txt`更改历史记录文件\n4) `HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S\"`在每条记录前加时间戳\n5) 显示执行最多的10个命令\n```bash\n history |\n    sed 's/^ \\+//;s/  / /' |\n    cut -d' ' -f2- |\n    awk '{ count[$0]++ } END { for (i in count) print count[i], i }' |\n    sort -rn |\n    head -10\n```\n- 使用python快速搭建web服务器`python3 -m http.server 8080`\n- Linux性能分析火焰图\n![](/images/flameLinux1.jpg)\n![](/images/flameLinux2.jpg)\n![](/images/flameLinux3.jpg)\n![](/images/flameLinux4.jpg)\n- factor\n分解一个数字的因子\n","source":"_posts/Linux命令.md","raw":"---\ntitle: Linux命令\ndate: 2019-07-18 16:15:42\nsubtitle:\ncategories: Linux\ntags: 命令\nindex_img: /images/linuxCmd.jpeg\nbanner_img: /images/linuxCmd.jpeg\n---\n- 同时对某个目录下多个文件操作用`{a,b}`\n- 搜索某个软件包 `sudo apt-cache search <关键字>`\n- 终端快捷键:\n\n  |按键|功能|\n  |:-:|:-:|\n  |ctrl+a|命令行首部|\n  |ctrl+e|命令行尾部|\n  |ctrl+f|前移一个字符|\n  |ctrl+b|后移一个字符|\n  |ctrl+l|等价于clear|\n  |ctrl+n|向下翻页|\n  |ctrl+p|向上翻页|\n  |alt+f|前移一个字|\n  |alt+b|后移一个字|\n  |alt+c|单词首字符大写|\n  |alt+t|光标位置的字和其前面的字互换|\n  |alt+l|从光标到字尾转换成小写字母|\n  |alt+u|从光标到字尾转换成大写字母|\n  |alt+d|剪切从光标到字尾的文本|\n  |alt+#|注释当前的命令|\n  |alt+.|插入上一个命令的最后一个参数|\n  |alt+Backspace|剪切从光标到字首的文本|\n  |ctrl+k|删除光标后的字符|\n  |ctrl+d|删除光标上的字符|\n  |ctrl+t|交换光标处和它的前面字符|\n  |ctrl+s|锁定屏幕|\n  |ctrl+q|解锁|\n  |ctrl+h|删除左侧字符|\n  |ctrl+w|删除上一个单词|\n  |ctrl+y|粘贴剪切的文本|\n  |ctrl+k|剪切从光标到行尾的文本|\n  |ctrl+u|剪切从光标到行首的文本|\n  |ctrl+v|输入特殊字符|\n  |ctrl+r|搜索词,再次按该组合键可以循环搜索,回车选中,ctrl+G不做任何操作返回终端|\n  |ctrl+x+ctrl+e|在文本编辑器中快速打开当前命令,退出编辑器后，自动执行|\n  |set -o vi |设置vi风格|\n  |!$|重新使用上一个命令中的最后一项(最好用`alt+.`可以跳转上几次)|\n  |!number|重复历史表中第number行命令|\n  |!!|执行上一个命令(常用于忘加sudo`sudo !!`)|\n- 命令间连接\n  - \";\":一直执行无论成功与否\n  - \"&&\":前面的命令执行成功才能执行后面\n  - \"||\":前面的命令执行失败才能执行后面\n- `kill %2` 2代表jobs命令显示下的任务号码,%区别于进程ID\n- man\n\n  `man <num> <cmd>`\n\n  |章节|内容|\n  |:-:|:-:|\n  |1|用户命令|\n  |2|程序接口内核系统调用|\n  |3|c库函数程序接口|\n  |4|特殊文件,比如说设备节点和驱动程序|\n  |5|文件格式|\n  |6|游戏娱乐,如屏幕保护程序|\n  |7|其他方面|\n  |8|系统管理员命令|\n  |9|内核例程|\n  `-k <pattern>`在文档中搜索某个关键字,\n- 后台运行\n\n  `nohup [命令参数] &`\n- ln命令：\n  - `ln source target` 硬链接\n  - `ln -s source target`软连接。\n  \n  两者的区别:\n  - 软连接不增加文件的链接数，而硬链接则增加\n  - 不能跨文件系统创建硬链接，硬链接不能连接目录\n  - 硬链接的inode号完全相同，指向同一文件，软连接则有不同的inode号，并且新文件类型为专有软链接类型，其指向的文件内容存储着实际文件的路径\n  - 硬链接指向的文件当链接数减为0时，才真正删除，软链接若实际文件删除，则软链接失效。\n`readlink -f filename`可以显示链接的原始指向位置\n- nslookup\n\n  `nslookup github.global.ssl.fastly.Net`\n  `nslookup github.com`\n  查到的域名加到/etc/hosts里可以加快访问速度 \n`sudo /etc/init.d/networking restart`刷新缓存\n- systemctl\n\n  - systemctl查看/etc/init.d中哪些服务进程会在引导时启动  \n  `systemctl list-unit-files --type=service | grep enabled`  \n  - 查找废弃服务\n  `systemctl --all | grep not-found`\n  - 停止某个服务进程、开机禁止启动以及某个进程的状态  \n  `sudo systemctl stop xxx.service`  \n  `sudo systemctl disable xxx.service`  \n  `sudo systemctl status xxx.service`  \n**注**:不能启用或禁用静态服务，这些服务为其他进程所依赖。\n  - 查看前一次启动的开机日志`journalctl -b -1`  \n  - 查看启动服务消耗时间`systemd-analyze blame`\n  - mask禁用某种服务 `systemctl mask xx.service`\n- 命令行复制到剪贴板\n  `cat filename | xsel -b`\n- plymouth\n  - 主题文件夹：/usr/share/plymouth/themes/\n  - 设置文件夹:/etc/plymouth/plymouthd.conf\n  - 列出主题列表`plymouth-set-default-theme -l`\n  - 更改Theme=的内容`sudo vi /etc/plymouth/plymouthd.conf`\n  `sudo mkinitcpio -p linux`生成新的镜像,重启生效\n  需要'quite splash'静默启动参数,在grub里设置\n- `grub-mkconfig` 刷新grub的配置\n- 同个命令对应不同软件版本配置\n\n  `update-alternatives --install <link> <name> <path> <priority>`\n\n  `update-alternatives --install /usr/bin/arm-linux-gnueabi-gcc arm-linux-gnueabi-gcc /usr/bin/arm-linux-gnueabi-gcc-5 5`\n\n  `update-alternatives --config arm-linux-gnueabi-gcc`\n- 内核模块相关\n  - `modinfo *.ko`查看某个编译好的模块\n  - `sudo insmod *.ko`装入模块\n  - `dmesg` 查看内核打印信息\n  - `lsmod` 显示已加载的模块\n  - 已加载的模块会在/sys/module/下建立对应文件夹\n  - `sudo rmmod x.ko`卸载模块\n- 手机USB线wifi共享：\n  - `ip addr show`查看USB网络借口\n  - `dhclient enpxxx`给借口设置ip地址，手机热点要开\n- od命令\n  - `od -t x1 x.dat`以十六进制打印文件x.dat各字节\n  - `od -c /bin/bash`逐字符方式打印文件,遇到不可打印字符打印编码\n  - `echo \\' | od -t o1`查看单引号的八进制\n- md5sum命令\n  - `md5sum file1 file2`计算两个文件的md5值,相同文件md5值相同\n- 行律问题\n  - `ctty -a`查看行律配置\n  - `ctty erase ^H`设置退格键\n- windows文件不兼容\n  - `unix2dos filename`转换成windows类型的文件,也有dos2unix命令\n- gbk中文字符转换为utf\n  - `iconv -f utf-8 -t gbk`\n  - `echo \"汉字\" | iconv -f utf-8 -t gbk | od -t x1`\n- `--`显示终止选项命令\n  `rm -- -i`表示删除名为'-i'的文件\n- 在任何命令前加`time`,可以计时运行时间\n# xargs命令\n将标准输入构造为命令的命令行参数,如果命令行参数过多,会启动多个进程,与单一普通管道相比就是批处理\n## 举例\n- 打印c语言文件含有--hlep的行：`find src -name \\*.c -print | xargs grep -n -- --help`\n- 只打印不执行命令，用于确认：`ls|xargs -L1 -p head`\n- 移动文件到文件夹:`find . -name \"*.bak\" -print 0|xargs -0 -I file mv file ~/old`\n\n# 输入重定向\n- `cat < filename`打印名为filename的文件内容\n- `cat << END`接下来直到END之间的内容\n- `cat <<< filename`打印filename这个单词\n- `> 文件名`清空文件\n# tee\n  从Stdin读取数据，并同时输出到Stdout和文件 `ls /usr/bin | tee ls.txt |grep zip`\n# du命令  \n- `du -sh * | sort -rh`查看当前目录下所有文件大小并排序\n- `du -sh`统计当前目录大小\n- `du -h --max-depth=1 | sort`查看当前所有一级子目录大小并排序\n\n# at\n  - `systemctl start atd.service`启动服务\n  - `at <时间点>`时间点格式举例:19:33、3pm+7 days、20:00 tomorrow 之后进入交互界面,输入命令,ctrl+D退出\n  - `at -l 或者 atq`查看列表\n  - `at -c 任务号`查看任务内容\n  - `at -r 任务号 或者 atrm 任务号`取消任务\n  - `at -f 脚本文件`不进入交互,直接运行某个脚本\n  - `-M`忽略产生的任何输出\n  - /etc/at.deny,文件中的用户不能执行at(系统默认存在)\n  - /etc/at.allow,默认不存在,只要存在的用户才能执行\n# crontab服务定时任务计划\n- `sudo systemctl start cronie.service`启动服务\n- `crontab -e`新增任务或编辑任务\n- `crontab -l`显示crontab文件\n- `crontab -r`删除crontab文件\n- `crontab -ir`删除crontab文件前提醒用户\n## 内容格式\n格式如下: `<minute> <hour> <day> <month> <week> <command>`\n\n|条目|取值|\n|:-:|:-:|\n|minute|0到59之间任何整数|\n|hour|0到23之间任何整数|\n|day|1到31之间的任何整数|\n|month|1到12之间任何整数|\n|week|1到7之间任何整数,|\n|command|执行的命令|\n\n- `*`代表所有可能值\n- `,`一个列表范围\n- `-`表示一个整数范围\n- `/`指定时间间隔的频率,比如\"0-23/2\"表示每两小时执行\n## example\n如果对时间精读要求不高,可以把脚本复制到/etc/cron.daily等目录下\n- `* * * * * myCommand`:每分钟执行一次\n- `3,15 * * * * myCommand`:每小时的第3和第15分钟执行\n- `3,15 8-11 * * * myCommand`:在上午8点到11点的第3和第15分钟执行\n- `3,15 8-11 */2  *  * myCommand`:每隔两天的上午8点到11点的第3和第15分钟执行\n- `3,15 8-11 * * 1 myCommand`:每周一上午8点到11点的第3和第15分钟执行\n- `30 21 * * * /etc/init.d/smb restart`:每晚的21:30重启smb\n- `45 4 1,10,22 * * /etc/init.d/smb restart`:每月1、10、22日的4 : 45重启smb\n- `10 1 * * 6,0 /etc/init.d/smb restart`:每周六、周日的1 : 10重启smb\n- `0,30 18-23 * * * /etc/init.d/smb restart`:每天18 : 00至23 : 00之间每隔30分钟重启smb\n- `0 23 * * 6 /etc/init.d/smb restart`:每星期六的晚上11 : 00 pm重启smb\n- `* */1 * * * /etc/init.d/smb restart`:每一小时重启smb\n- `0 23-7 * * * /etc/init.d/smb restart`晚上11点到早上7点之间，每隔一小时重启smb\n## anacron\nanacron是对该程序的一个补充,它会自动运行crontab原本应该运行但由于关机等原因造成的程序,但它只会处理位于/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly下的脚本文件,它的配置文件位于/etc/anacrontab\nanacron是自动运行的?(有待研究)\n- run-parts一个接一个运行同一目录下的脚本\n  -  `run-parts<directory-path>`\n  -  `run-parts --list --regex  '^s.\\*sh$' <directory> `\n- `type <command>`识别命令,有以下几种\n  - 可执行命令，给出路径\n  - shell自身的命令(builtins),内建命令不会产生子进程,代价更小\n  - 一个shell函数\n  - 别名命令\n- `whatis <command>`会给出命令简短的说明\n- `rm !(*.csv)`删除除了csv结尾的所有文件(貌似只有bash支持，zsh不支持)\n- `mkdir {2007..2009}\\_0{1..9}{A,B}`创建一系列文件夹,这其实是花括号展开\n- `apropos <some word>`在man手册里搜索关键字\n- `info <command>`man手册的另一种排版，有点鸡肋\n- 标准错误的重定向\n\n  标准错误和标准输出重定向同一个文件\n  `ls -l xx >info.txt 2>&1`等价于`ls -l xx &> info.txt`\n- env 或 printenv打印当前环境变量(全局变量)\n- set打印当前环境变量并按字母排列(包括局部变量、全局变量、用户定义变量)\n- alias查看别名,上面的不可以查看\n- `ps -f --forest` 可以显示当前shell的进程关系\n- coproc(这就是协程?)\n  `coproc [job_name(可选)] [command]`等价于`( command )&`\n  即生成后台子shell，并在子shell中执行命令。command本身可以是小括号命令集(嵌套子shell)或大括号命令集\n- mktemp\n\n  mktemp可以用来创建临时文件,成功会输出文件路径\n  \n  `mktemp [module]`不指定[module]会在/tmp中创建唯一临时文件,有用户有读写权限(不使用umask值),若指定[module],则会在当前文件夹下产生模板临时文件(会用任意字符替换模板值中的X),如`mktemp test.XXX`可能会在当前文件夹下产生文件test.UGH\n\n  -t:强制在/tmp下创建临时文件\n\n  -d:创建临时目录\n- nice以某个优先级来运行某个程序\n  `nice -[num] [command]`,num值越大,优先级越低,可以通过\"ps -o ni\"查看优先级,只能降低,不能提高优先级,\n- renice调整某个程序优先级\n  `renice -[num] -p [process id]`普通用户只能降低优先级,root可以任意调整\n- ntpd\n  `sudo ntpd -qg`可以校准时间\n- readlink输出文件的绝对路径\n `readlink -f [fileName]`\n- truncate\n`truncate -s 5 test.txt`截断test.txt，只保留5个字符\n- nm\nnm作用于目标文件，统计标识符有大用\n- parallel\nparallel用法复杂，建议读man\n**用法:**\n  - cmd | parallel [options] 'somecmd',parallel会默认把每行的内容,插到命令末尾\n  - parallel [options] 'cmd' ::: [parameter1 list] ::: [parameter2 list]...\n强大的xargs的升级版（这只是个人感觉啊）\n\n|选项|含义|\n|:-:|:-:|\n|-j/--jobs [num]|同时运行num个任务|\n|--C/--colsep [regep]|参数分隔符号|\n|--header|忽略第一行|\n|--results [file]|保存输出内容到某文件，还会输出到标准输出|\n|--keep-order|并行有时会不按输出行的顺序，这个保持顺序|\n|--tag|在每个结果开头，输出参数内容|\n|--slf/--sshloginfile [hostnames]|使用远程机当算力|\n|--sshlogin|登录远程机|\n|--nonall|不传递参数，只传递命令给远程机|\n|-N[num]|分配给远程多少个参数|\n\n|特殊变量名|含义|\n|:-:|:-:|\n|`{}`|一行的内容|\n|`{/}`|相当于对当前行运行basename|\n|`{井}`|任务号，从1开始编号|\n\n**例子：**\n- `seq 0 2 100 | parallel \"echo {}^2 | bc\"`\n- `seq 1000 | parallel -N100 --pipe --slf hostnames \"paste -sd+ | bc\" | paste -sd+|bc`并行算1-1000的和，一个核算一百个参数\n- history\n任何匹配HISTIGNORE环境变量的命令不会被记录,以`:`分割多个模式\n1) `unset HISTFILE`当前会话下不记录命令行历史\n2) 设置HISTIGNORE为`HISTIGNORE=\"[&:\\t]\"`在命令前加空格会使当前命令不被记录到历史,并且`&`表示上一次执行的命令，就是重复命令只记录一次\n3) `HISTFILE=~/docs/shell_history.txt`更改历史记录文件\n4) `HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S\"`在每条记录前加时间戳\n5) 显示执行最多的10个命令\n```bash\n history |\n    sed 's/^ \\+//;s/  / /' |\n    cut -d' ' -f2- |\n    awk '{ count[$0]++ } END { for (i in count) print count[i], i }' |\n    sort -rn |\n    head -10\n```\n- 使用python快速搭建web服务器`python3 -m http.server 8080`\n- Linux性能分析火焰图\n![](/images/flameLinux1.jpg)\n![](/images/flameLinux2.jpg)\n![](/images/flameLinux3.jpg)\n![](/images/flameLinux4.jpg)\n- factor\n分解一个数字的因子\n","slug":"Linux命令","published":1,"updated":"2024-10-07T01:18:45.225Z","_id":"clq1yvi6v000bgwq23mfgg2zk","comments":1,"layout":"post","photos":[],"content":"<ul>\n<li><p>同时对某个目录下多个文件操作用<code>&#123;a,b&#125;</code></p>\n</li>\n<li><p>搜索某个软件包 <code>sudo apt-cache search &lt;关键字&gt;</code></p>\n</li>\n<li><p>终端快捷键:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">按键</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ctrl+a</td>\n<td align=\"center\">命令行首部</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+e</td>\n<td align=\"center\">命令行尾部</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+f</td>\n<td align=\"center\">前移一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+b</td>\n<td align=\"center\">后移一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+l</td>\n<td align=\"center\">等价于clear</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+n</td>\n<td align=\"center\">向下翻页</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+p</td>\n<td align=\"center\">向上翻页</td>\n</tr>\n<tr>\n<td align=\"center\">alt+f</td>\n<td align=\"center\">前移一个字</td>\n</tr>\n<tr>\n<td align=\"center\">alt+b</td>\n<td align=\"center\">后移一个字</td>\n</tr>\n<tr>\n<td align=\"center\">alt+c</td>\n<td align=\"center\">单词首字符大写</td>\n</tr>\n<tr>\n<td align=\"center\">alt+t</td>\n<td align=\"center\">光标位置的字和其前面的字互换</td>\n</tr>\n<tr>\n<td align=\"center\">alt+l</td>\n<td align=\"center\">从光标到字尾转换成小写字母</td>\n</tr>\n<tr>\n<td align=\"center\">alt+u</td>\n<td align=\"center\">从光标到字尾转换成大写字母</td>\n</tr>\n<tr>\n<td align=\"center\">alt+d</td>\n<td align=\"center\">剪切从光标到字尾的文本</td>\n</tr>\n<tr>\n<td align=\"center\">alt+#</td>\n<td align=\"center\">注释当前的命令</td>\n</tr>\n<tr>\n<td align=\"center\">alt+.</td>\n<td align=\"center\">插入上一个命令的最后一个参数</td>\n</tr>\n<tr>\n<td align=\"center\">alt+Backspace</td>\n<td align=\"center\">剪切从光标到字首的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+k</td>\n<td align=\"center\">删除光标后的字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+d</td>\n<td align=\"center\">删除光标上的字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+t</td>\n<td align=\"center\">交换光标处和它的前面字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+s</td>\n<td align=\"center\">锁定屏幕</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+q</td>\n<td align=\"center\">解锁</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+h</td>\n<td align=\"center\">删除左侧字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+w</td>\n<td align=\"center\">删除上一个单词</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+y</td>\n<td align=\"center\">粘贴剪切的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+k</td>\n<td align=\"center\">剪切从光标到行尾的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+u</td>\n<td align=\"center\">剪切从光标到行首的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+v</td>\n<td align=\"center\">输入特殊字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+r</td>\n<td align=\"center\">搜索词,再次按该组合键可以循环搜索,回车选中,ctrl+G不做任何操作返回终端</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+x+ctrl+e</td>\n<td align=\"center\">在文本编辑器中快速打开当前命令,退出编辑器后，自动执行</td>\n</tr>\n<tr>\n<td align=\"center\">set -o vi</td>\n<td align=\"center\">设置vi风格</td>\n</tr>\n<tr>\n<td align=\"center\">!$</td>\n<td align=\"center\">重新使用上一个命令中的最后一项(最好用<code>alt+.</code>可以跳转上几次)</td>\n</tr>\n<tr>\n<td align=\"center\">!number</td>\n<td align=\"center\">重复历史表中第number行命令</td>\n</tr>\n<tr>\n<td align=\"center\">!!</td>\n<td align=\"center\">执行上一个命令(常用于忘加sudo<code>sudo !!</code>)</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>命令间连接</p>\n<ul>\n<li>“;”:一直执行无论成功与否</li>\n<li>“&amp;&amp;”:前面的命令执行成功才能执行后面</li>\n<li>“||”:前面的命令执行失败才能执行后面</li>\n</ul>\n</li>\n<li><p><code>kill %2</code> 2代表jobs命令显示下的任务号码,%区别于进程ID</p>\n</li>\n<li><p>man</p>\n<p><code>man &lt;num&gt; &lt;cmd&gt;</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">章节</th>\n<th align=\"center\">内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">用户命令</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">程序接口内核系统调用</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">c库函数程序接口</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">特殊文件,比如说设备节点和驱动程序</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">文件格式</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">游戏娱乐,如屏幕保护程序</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">其他方面</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\">系统管理员命令</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">内核例程</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-k &lt;pattern&gt;</code>在文档中搜索某个关键字,</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>后台运行</p>\n<p><code>nohup [命令参数] &amp;</code></p>\n</li>\n<li><p>ln命令：</p>\n<ul>\n<li><code>ln source target</code> 硬链接</li>\n<li><code>ln -s source target</code>软连接。</li>\n</ul>\n<p>两者的区别:</p>\n<ul>\n<li>软连接不增加文件的链接数，而硬链接则增加</li>\n<li>不能跨文件系统创建硬链接，硬链接不能连接目录</li>\n<li>硬链接的inode号完全相同，指向同一文件，软连接则有不同的inode号，并且新文件类型为专有软链接类型，其指向的文件内容存储着实际文件的路径</li>\n<li>硬链接指向的文件当链接数减为0时，才真正删除，软链接若实际文件删除，则软链接失效。</li>\n</ul>\n</li>\n</ul>\n<p><code>readlink -f filename</code>可以显示链接的原始指向位置</p>\n<ul>\n<li><p>nslookup</p>\n<p><code>nslookup github.global.ssl.fastly.Net</code><br><code>nslookup github.com</code><br>查到的域名加到&#x2F;etc&#x2F;hosts里可以加快访问速度</p>\n</li>\n</ul>\n<p><code>sudo /etc/init.d/networking restart</code>刷新缓存</p>\n<ul>\n<li><p>systemctl</p>\n<ul>\n<li>systemctl查看&#x2F;etc&#x2F;init.d中哪些服务进程会在引导时启动<br><code>systemctl list-unit-files --type=service | grep enabled</code>  </li>\n<li>查找废弃服务<br><code>systemctl --all | grep not-found</code></li>\n<li>停止某个服务进程、开机禁止启动以及某个进程的状态<br><code>sudo systemctl stop xxx.service</code><br><code>sudo systemctl disable xxx.service</code><br><code>sudo systemctl status xxx.service</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>注</strong>:不能启用或禁用静态服务，这些服务为其他进程所依赖。</p>\n<ul>\n<li><p>查看前一次启动的开机日志<code>journalctl -b -1</code>  </p>\n</li>\n<li><p>查看启动服务消耗时间<code>systemd-analyze blame</code></p>\n</li>\n<li><p>mask禁用某种服务 <code>systemctl mask xx.service</code></p>\n</li>\n<li><p>命令行复制到剪贴板<br><code>cat filename | xsel -b</code></p>\n</li>\n<li><p>plymouth</p>\n<ul>\n<li>主题文件夹：&#x2F;usr&#x2F;share&#x2F;plymouth&#x2F;themes&#x2F;</li>\n<li>设置文件夹:&#x2F;etc&#x2F;plymouth&#x2F;plymouthd.conf</li>\n<li>列出主题列表<code>plymouth-set-default-theme -l</code></li>\n<li>更改Theme&#x3D;的内容<code>sudo vi /etc/plymouth/plymouthd.conf</code><br><code>sudo mkinitcpio -p linux</code>生成新的镜像,重启生效<br>需要’quite splash’静默启动参数,在grub里设置</li>\n</ul>\n</li>\n<li><p><code>grub-mkconfig</code> 刷新grub的配置</p>\n</li>\n<li><p>同个命令对应不同软件版本配置</p>\n<p><code>update-alternatives --install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</code></p>\n<p><code>update-alternatives --install /usr/bin/arm-linux-gnueabi-gcc arm-linux-gnueabi-gcc /usr/bin/arm-linux-gnueabi-gcc-5 5</code></p>\n<p><code>update-alternatives --config arm-linux-gnueabi-gcc</code></p>\n</li>\n<li><p>内核模块相关</p>\n<ul>\n<li><code>modinfo *.ko</code>查看某个编译好的模块</li>\n<li><code>sudo insmod *.ko</code>装入模块</li>\n<li><code>dmesg</code> 查看内核打印信息</li>\n<li><code>lsmod</code> 显示已加载的模块</li>\n<li>已加载的模块会在&#x2F;sys&#x2F;module&#x2F;下建立对应文件夹</li>\n<li><code>sudo rmmod x.ko</code>卸载模块</li>\n</ul>\n</li>\n<li><p>手机USB线wifi共享：</p>\n<ul>\n<li><code>ip addr show</code>查看USB网络借口</li>\n<li><code>dhclient enpxxx</code>给借口设置ip地址，手机热点要开</li>\n</ul>\n</li>\n<li><p>od命令</p>\n<ul>\n<li><code>od -t x1 x.dat</code>以十六进制打印文件x.dat各字节</li>\n<li><code>od -c /bin/bash</code>逐字符方式打印文件,遇到不可打印字符打印编码</li>\n<li><code>echo \\&#39; | od -t o1</code>查看单引号的八进制</li>\n</ul>\n</li>\n<li><p>md5sum命令</p>\n<ul>\n<li><code>md5sum file1 file2</code>计算两个文件的md5值,相同文件md5值相同</li>\n</ul>\n</li>\n<li><p>行律问题</p>\n<ul>\n<li><code>ctty -a</code>查看行律配置</li>\n<li><code>ctty erase ^H</code>设置退格键</li>\n</ul>\n</li>\n<li><p>windows文件不兼容</p>\n<ul>\n<li><code>unix2dos filename</code>转换成windows类型的文件,也有dos2unix命令</li>\n</ul>\n</li>\n<li><p>gbk中文字符转换为utf</p>\n<ul>\n<li><code>iconv -f utf-8 -t gbk</code></li>\n<li><code>echo &quot;汉字&quot; | iconv -f utf-8 -t gbk | od -t x1</code></li>\n</ul>\n</li>\n<li><p><code>--</code>显示终止选项命令<br><code>rm -- -i</code>表示删除名为’-i’的文件</p>\n</li>\n<li><p>在任何命令前加<code>time</code>,可以计时运行时间</p>\n</li>\n</ul>\n<h1 id=\"xargs命令\"><a href=\"#xargs命令\" class=\"headerlink\" title=\"xargs命令\"></a>xargs命令</h1><p>将标准输入构造为命令的命令行参数,如果命令行参数过多,会启动多个进程,与单一普通管道相比就是批处理</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><ul>\n<li>打印c语言文件含有–hlep的行：<code>find src -name \\*.c -print | xargs grep -n -- --help</code></li>\n<li>只打印不执行命令，用于确认：<code>ls|xargs -L1 -p head</code></li>\n<li>移动文件到文件夹:<code>find . -name &quot;*.bak&quot; -print 0|xargs -0 -I file mv file ~/old</code></li>\n</ul>\n<h1 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h1><ul>\n<li><code>cat &lt; filename</code>打印名为filename的文件内容</li>\n<li><code>cat &lt;&lt; END</code>接下来直到END之间的内容</li>\n<li><code>cat &lt;&lt;&lt; filename</code>打印filename这个单词</li>\n<li><code>&gt; 文件名</code>清空文件</li>\n</ul>\n<h1 id=\"tee\"><a href=\"#tee\" class=\"headerlink\" title=\"tee\"></a>tee</h1><p>  从Stdin读取数据，并同时输出到Stdout和文件 <code>ls /usr/bin | tee ls.txt |grep zip</code></p>\n<h1 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a>du命令</h1><ul>\n<li><code>du -sh * | sort -rh</code>查看当前目录下所有文件大小并排序</li>\n<li><code>du -sh</code>统计当前目录大小</li>\n<li><code>du -h --max-depth=1 | sort</code>查看当前所有一级子目录大小并排序</li>\n</ul>\n<h1 id=\"at\"><a href=\"#at\" class=\"headerlink\" title=\"at\"></a>at</h1><ul>\n<li><code>systemctl start atd.service</code>启动服务</li>\n<li><code>at &lt;时间点&gt;</code>时间点格式举例:19:33、3pm+7 days、20:00 tomorrow 之后进入交互界面,输入命令,ctrl+D退出</li>\n<li><code>at -l 或者 atq</code>查看列表</li>\n<li><code>at -c 任务号</code>查看任务内容</li>\n<li><code>at -r 任务号 或者 atrm 任务号</code>取消任务</li>\n<li><code>at -f 脚本文件</code>不进入交互,直接运行某个脚本</li>\n<li><code>-M</code>忽略产生的任何输出</li>\n<li>&#x2F;etc&#x2F;at.deny,文件中的用户不能执行at(系统默认存在)</li>\n<li>&#x2F;etc&#x2F;at.allow,默认不存在,只要存在的用户才能执行</li>\n</ul>\n<h1 id=\"crontab服务定时任务计划\"><a href=\"#crontab服务定时任务计划\" class=\"headerlink\" title=\"crontab服务定时任务计划\"></a>crontab服务定时任务计划</h1><ul>\n<li><code>sudo systemctl start cronie.service</code>启动服务</li>\n<li><code>crontab -e</code>新增任务或编辑任务</li>\n<li><code>crontab -l</code>显示crontab文件</li>\n<li><code>crontab -r</code>删除crontab文件</li>\n<li><code>crontab -ir</code>删除crontab文件前提醒用户</li>\n</ul>\n<h2 id=\"内容格式\"><a href=\"#内容格式\" class=\"headerlink\" title=\"内容格式\"></a>内容格式</h2><p>格式如下: <code>&lt;minute&gt; &lt;hour&gt; &lt;day&gt; &lt;month&gt; &lt;week&gt; &lt;command&gt;</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">条目</th>\n<th align=\"center\">取值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">minute</td>\n<td align=\"center\">0到59之间任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">hour</td>\n<td align=\"center\">0到23之间任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">day</td>\n<td align=\"center\">1到31之间的任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">month</td>\n<td align=\"center\">1到12之间任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">week</td>\n<td align=\"center\">1到7之间任何整数,</td>\n</tr>\n<tr>\n<td align=\"center\">command</td>\n<td align=\"center\">执行的命令</td>\n</tr>\n</tbody></table>\n<ul>\n<li><code>*</code>代表所有可能值</li>\n<li><code>,</code>一个列表范围</li>\n<li><code>-</code>表示一个整数范围</li>\n<li><code>/</code>指定时间间隔的频率,比如”0-23&#x2F;2”表示每两小时执行</li>\n</ul>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><p>如果对时间精读要求不高,可以把脚本复制到&#x2F;etc&#x2F;cron.daily等目录下</p>\n<ul>\n<li><code>* * * * * myCommand</code>:每分钟执行一次</li>\n<li><code>3,15 * * * * myCommand</code>:每小时的第3和第15分钟执行</li>\n<li><code>3,15 8-11 * * * myCommand</code>:在上午8点到11点的第3和第15分钟执行</li>\n<li><code>3,15 8-11 */2  *  * myCommand</code>:每隔两天的上午8点到11点的第3和第15分钟执行</li>\n<li><code>3,15 8-11 * * 1 myCommand</code>:每周一上午8点到11点的第3和第15分钟执行</li>\n<li><code>30 21 * * * /etc/init.d/smb restart</code>:每晚的21:30重启smb</li>\n<li><code>45 4 1,10,22 * * /etc/init.d/smb restart</code>:每月1、10、22日的4 : 45重启smb</li>\n<li><code>10 1 * * 6,0 /etc/init.d/smb restart</code>:每周六、周日的1 : 10重启smb</li>\n<li><code>0,30 18-23 * * * /etc/init.d/smb restart</code>:每天18 : 00至23 : 00之间每隔30分钟重启smb</li>\n<li><code>0 23 * * 6 /etc/init.d/smb restart</code>:每星期六的晚上11 : 00 pm重启smb</li>\n<li><code>* */1 * * * /etc/init.d/smb restart</code>:每一小时重启smb</li>\n<li><code>0 23-7 * * * /etc/init.d/smb restart</code>晚上11点到早上7点之间，每隔一小时重启smb</li>\n</ul>\n<h2 id=\"anacron\"><a href=\"#anacron\" class=\"headerlink\" title=\"anacron\"></a>anacron</h2><p>anacron是对该程序的一个补充,它会自动运行crontab原本应该运行但由于关机等原因造成的程序,但它只会处理位于&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly下的脚本文件,它的配置文件位于&#x2F;etc&#x2F;anacrontab<br>anacron是自动运行的?(有待研究)</p>\n<ul>\n<li><p>run-parts一个接一个运行同一目录下的脚本</p>\n<ul>\n<li><code>run-parts&lt;directory-path&gt;</code></li>\n<li><code>run-parts --list --regex  &#39;^s.\\*sh$&#39; &lt;directory&gt; </code></li>\n</ul>\n</li>\n<li><p><code>type &lt;command&gt;</code>识别命令,有以下几种</p>\n<ul>\n<li>可执行命令，给出路径</li>\n<li>shell自身的命令(builtins),内建命令不会产生子进程,代价更小</li>\n<li>一个shell函数</li>\n<li>别名命令</li>\n</ul>\n</li>\n<li><p><code>whatis &lt;command&gt;</code>会给出命令简短的说明</p>\n</li>\n<li><p><code>rm !(*.csv)</code>删除除了csv结尾的所有文件(貌似只有bash支持，zsh不支持)</p>\n</li>\n<li><p><code>mkdir &#123;2007..2009&#125;\\_0&#123;1..9&#125;&#123;A,B&#125;</code>创建一系列文件夹,这其实是花括号展开</p>\n</li>\n<li><p><code>apropos &lt;some word&gt;</code>在man手册里搜索关键字</p>\n</li>\n<li><p><code>info &lt;command&gt;</code>man手册的另一种排版，有点鸡肋</p>\n</li>\n<li><p>标准错误的重定向</p>\n<p>标准错误和标准输出重定向同一个文件<br><code>ls -l xx &gt;info.txt 2&gt;&amp;1</code>等价于<code>ls -l xx &amp;&gt; info.txt</code></p>\n</li>\n<li><p>env 或 printenv打印当前环境变量(全局变量)</p>\n</li>\n<li><p>set打印当前环境变量并按字母排列(包括局部变量、全局变量、用户定义变量)</p>\n</li>\n<li><p>alias查看别名,上面的不可以查看</p>\n</li>\n<li><p><code>ps -f --forest</code> 可以显示当前shell的进程关系</p>\n</li>\n<li><p>coproc(这就是协程?)<br><code>coproc [job_name(可选)] [command]</code>等价于<code>( command )&amp;</code><br>即生成后台子shell，并在子shell中执行命令。command本身可以是小括号命令集(嵌套子shell)或大括号命令集</p>\n</li>\n<li><p>mktemp</p>\n<p>mktemp可以用来创建临时文件,成功会输出文件路径</p>\n<p><code>mktemp [module]</code>不指定[module]会在&#x2F;tmp中创建唯一临时文件,有用户有读写权限(不使用umask值),若指定[module],则会在当前文件夹下产生模板临时文件(会用任意字符替换模板值中的X),如<code>mktemp test.XXX</code>可能会在当前文件夹下产生文件test.UGH</p>\n<p>-t:强制在&#x2F;tmp下创建临时文件</p>\n<p>-d:创建临时目录</p>\n</li>\n<li><p>nice以某个优先级来运行某个程序<br><code>nice -[num] [command]</code>,num值越大,优先级越低,可以通过”ps -o ni”查看优先级,只能降低,不能提高优先级,</p>\n</li>\n<li><p>renice调整某个程序优先级<br><code>renice -[num] -p [process id]</code>普通用户只能降低优先级,root可以任意调整</p>\n</li>\n<li><p>ntpd<br><code>sudo ntpd -qg</code>可以校准时间</p>\n</li>\n<li><p>readlink输出文件的绝对路径<br> <code>readlink -f [fileName]</code></p>\n</li>\n<li><p>truncate<br><code>truncate -s 5 test.txt</code>截断test.txt，只保留5个字符</p>\n</li>\n<li><p>nm<br>nm作用于目标文件，统计标识符有大用</p>\n</li>\n<li><p>parallel<br>parallel用法复杂，建议读man<br><strong>用法:</strong></p>\n<ul>\n<li>cmd | parallel [options] ‘somecmd’,parallel会默认把每行的内容,插到命令末尾</li>\n<li>parallel [options] ‘cmd’ ::: [parameter1 list] ::: [parameter2 list]…<br>强大的xargs的升级版（这只是个人感觉啊）</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-j&#x2F;–jobs [num]</td>\n<td align=\"center\">同时运行num个任务</td>\n</tr>\n<tr>\n<td align=\"center\">–C&#x2F;–colsep [regep]</td>\n<td align=\"center\">参数分隔符号</td>\n</tr>\n<tr>\n<td align=\"center\">–header</td>\n<td align=\"center\">忽略第一行</td>\n</tr>\n<tr>\n<td align=\"center\">–results [file]</td>\n<td align=\"center\">保存输出内容到某文件，还会输出到标准输出</td>\n</tr>\n<tr>\n<td align=\"center\">–keep-order</td>\n<td align=\"center\">并行有时会不按输出行的顺序，这个保持顺序</td>\n</tr>\n<tr>\n<td align=\"center\">–tag</td>\n<td align=\"center\">在每个结果开头，输出参数内容</td>\n</tr>\n<tr>\n<td align=\"center\">–slf&#x2F;–sshloginfile [hostnames]</td>\n<td align=\"center\">使用远程机当算力</td>\n</tr>\n<tr>\n<td align=\"center\">–sshlogin</td>\n<td align=\"center\">登录远程机</td>\n</tr>\n<tr>\n<td align=\"center\">–nonall</td>\n<td align=\"center\">不传递参数，只传递命令给远程机</td>\n</tr>\n<tr>\n<td align=\"center\">-N[num]</td>\n<td align=\"center\">分配给远程多少个参数</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特殊变量名</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&#123;&#125;</code></td>\n<td align=\"center\">一行的内容</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&#123;/&#125;</code></td>\n<td align=\"center\">相当于对当前行运行basename</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&#123;井&#125;</code></td>\n<td align=\"center\">任务号，从1开始编号</td>\n</tr>\n</tbody></table>\n<p><strong>例子：</strong></p>\n<ul>\n<li><code>seq 0 2 100 | parallel &quot;echo &#123;&#125;^2 | bc&quot;</code></li>\n<li><code>seq 1000 | parallel -N100 --pipe --slf hostnames &quot;paste -sd+ | bc&quot; | paste -sd+|bc</code>并行算1-1000的和，一个核算一百个参数</li>\n<li>history<br>任何匹配HISTIGNORE环境变量的命令不会被记录,以<code>:</code>分割多个模式</li>\n</ul>\n<ol>\n<li><code>unset HISTFILE</code>当前会话下不记录命令行历史</li>\n<li>设置HISTIGNORE为<code>HISTIGNORE=&quot;[&amp;:\\t]&quot;</code>在命令前加空格会使当前命令不被记录到历史,并且<code>&amp;</code>表示上一次执行的命令，就是重复命令只记录一次</li>\n<li><code>HISTFILE=~/docs/shell_history.txt</code>更改历史记录文件</li>\n<li><code>HISTTIMEFORMAT=&quot;%Y-%m-%d %H:%M:%S&quot;</code>在每条记录前加时间戳</li>\n<li>显示执行最多的10个命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">history</span> |<br>   sed <span class=\"hljs-string\">&#x27;s/^ \\+//;s/  / /&#x27;</span> |<br>   <span class=\"hljs-built_in\">cut</span> -d<span class=\"hljs-string\">&#x27; &#x27;</span> -f2- |<br>   awk <span class=\"hljs-string\">&#x27;&#123; count[$0]++ &#125; END &#123; for (i in count) print count[i], i &#125;&#x27;</span> |<br>   <span class=\"hljs-built_in\">sort</span> -rn |<br>   <span class=\"hljs-built_in\">head</span> -10<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>使用python快速搭建web服务器<code>python3 -m http.server 8080</code></li>\n<li>Linux性能分析火焰图<br><img src=\"/images/flameLinux1.jpg\"><br><img src=\"/images/flameLinux2.jpg\"><br><img src=\"/images/flameLinux3.jpg\"><br><img src=\"/images/flameLinux4.jpg\"></li>\n<li>factor<br>分解一个数字的因子</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><p>同时对某个目录下多个文件操作用<code>&#123;a,b&#125;</code></p>\n</li>\n<li><p>搜索某个软件包 <code>sudo apt-cache search &lt;关键字&gt;</code></p>\n</li>\n<li><p>终端快捷键:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">按键</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ctrl+a</td>\n<td align=\"center\">命令行首部</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+e</td>\n<td align=\"center\">命令行尾部</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+f</td>\n<td align=\"center\">前移一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+b</td>\n<td align=\"center\">后移一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+l</td>\n<td align=\"center\">等价于clear</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+n</td>\n<td align=\"center\">向下翻页</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+p</td>\n<td align=\"center\">向上翻页</td>\n</tr>\n<tr>\n<td align=\"center\">alt+f</td>\n<td align=\"center\">前移一个字</td>\n</tr>\n<tr>\n<td align=\"center\">alt+b</td>\n<td align=\"center\">后移一个字</td>\n</tr>\n<tr>\n<td align=\"center\">alt+c</td>\n<td align=\"center\">单词首字符大写</td>\n</tr>\n<tr>\n<td align=\"center\">alt+t</td>\n<td align=\"center\">光标位置的字和其前面的字互换</td>\n</tr>\n<tr>\n<td align=\"center\">alt+l</td>\n<td align=\"center\">从光标到字尾转换成小写字母</td>\n</tr>\n<tr>\n<td align=\"center\">alt+u</td>\n<td align=\"center\">从光标到字尾转换成大写字母</td>\n</tr>\n<tr>\n<td align=\"center\">alt+d</td>\n<td align=\"center\">剪切从光标到字尾的文本</td>\n</tr>\n<tr>\n<td align=\"center\">alt+#</td>\n<td align=\"center\">注释当前的命令</td>\n</tr>\n<tr>\n<td align=\"center\">alt+.</td>\n<td align=\"center\">插入上一个命令的最后一个参数</td>\n</tr>\n<tr>\n<td align=\"center\">alt+Backspace</td>\n<td align=\"center\">剪切从光标到字首的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+k</td>\n<td align=\"center\">删除光标后的字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+d</td>\n<td align=\"center\">删除光标上的字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+t</td>\n<td align=\"center\">交换光标处和它的前面字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+s</td>\n<td align=\"center\">锁定屏幕</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+q</td>\n<td align=\"center\">解锁</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+h</td>\n<td align=\"center\">删除左侧字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+w</td>\n<td align=\"center\">删除上一个单词</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+y</td>\n<td align=\"center\">粘贴剪切的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+k</td>\n<td align=\"center\">剪切从光标到行尾的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+u</td>\n<td align=\"center\">剪切从光标到行首的文本</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+v</td>\n<td align=\"center\">输入特殊字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+r</td>\n<td align=\"center\">搜索词,再次按该组合键可以循环搜索,回车选中,ctrl+G不做任何操作返回终端</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+x+ctrl+e</td>\n<td align=\"center\">在文本编辑器中快速打开当前命令,退出编辑器后，自动执行</td>\n</tr>\n<tr>\n<td align=\"center\">set -o vi</td>\n<td align=\"center\">设置vi风格</td>\n</tr>\n<tr>\n<td align=\"center\">!$</td>\n<td align=\"center\">重新使用上一个命令中的最后一项(最好用<code>alt+.</code>可以跳转上几次)</td>\n</tr>\n<tr>\n<td align=\"center\">!number</td>\n<td align=\"center\">重复历史表中第number行命令</td>\n</tr>\n<tr>\n<td align=\"center\">!!</td>\n<td align=\"center\">执行上一个命令(常用于忘加sudo<code>sudo !!</code>)</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>命令间连接</p>\n<ul>\n<li>“;”:一直执行无论成功与否</li>\n<li>“&amp;&amp;”:前面的命令执行成功才能执行后面</li>\n<li>“||”:前面的命令执行失败才能执行后面</li>\n</ul>\n</li>\n<li><p><code>kill %2</code> 2代表jobs命令显示下的任务号码,%区别于进程ID</p>\n</li>\n<li><p>man</p>\n<p><code>man &lt;num&gt; &lt;cmd&gt;</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">章节</th>\n<th align=\"center\">内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">用户命令</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">程序接口内核系统调用</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">c库函数程序接口</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">特殊文件,比如说设备节点和驱动程序</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">文件格式</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">游戏娱乐,如屏幕保护程序</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">其他方面</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\">系统管理员命令</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">内核例程</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-k &lt;pattern&gt;</code>在文档中搜索某个关键字,</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>后台运行</p>\n<p><code>nohup [命令参数] &amp;</code></p>\n</li>\n<li><p>ln命令：</p>\n<ul>\n<li><code>ln source target</code> 硬链接</li>\n<li><code>ln -s source target</code>软连接。</li>\n</ul>\n<p>两者的区别:</p>\n<ul>\n<li>软连接不增加文件的链接数，而硬链接则增加</li>\n<li>不能跨文件系统创建硬链接，硬链接不能连接目录</li>\n<li>硬链接的inode号完全相同，指向同一文件，软连接则有不同的inode号，并且新文件类型为专有软链接类型，其指向的文件内容存储着实际文件的路径</li>\n<li>硬链接指向的文件当链接数减为0时，才真正删除，软链接若实际文件删除，则软链接失效。</li>\n</ul>\n</li>\n</ul>\n<p><code>readlink -f filename</code>可以显示链接的原始指向位置</p>\n<ul>\n<li><p>nslookup</p>\n<p><code>nslookup github.global.ssl.fastly.Net</code><br><code>nslookup github.com</code><br>查到的域名加到&#x2F;etc&#x2F;hosts里可以加快访问速度</p>\n</li>\n</ul>\n<p><code>sudo /etc/init.d/networking restart</code>刷新缓存</p>\n<ul>\n<li><p>systemctl</p>\n<ul>\n<li>systemctl查看&#x2F;etc&#x2F;init.d中哪些服务进程会在引导时启动<br><code>systemctl list-unit-files --type=service | grep enabled</code>  </li>\n<li>查找废弃服务<br><code>systemctl --all | grep not-found</code></li>\n<li>停止某个服务进程、开机禁止启动以及某个进程的状态<br><code>sudo systemctl stop xxx.service</code><br><code>sudo systemctl disable xxx.service</code><br><code>sudo systemctl status xxx.service</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>注</strong>:不能启用或禁用静态服务，这些服务为其他进程所依赖。</p>\n<ul>\n<li><p>查看前一次启动的开机日志<code>journalctl -b -1</code>  </p>\n</li>\n<li><p>查看启动服务消耗时间<code>systemd-analyze blame</code></p>\n</li>\n<li><p>mask禁用某种服务 <code>systemctl mask xx.service</code></p>\n</li>\n<li><p>命令行复制到剪贴板<br><code>cat filename | xsel -b</code></p>\n</li>\n<li><p>plymouth</p>\n<ul>\n<li>主题文件夹：&#x2F;usr&#x2F;share&#x2F;plymouth&#x2F;themes&#x2F;</li>\n<li>设置文件夹:&#x2F;etc&#x2F;plymouth&#x2F;plymouthd.conf</li>\n<li>列出主题列表<code>plymouth-set-default-theme -l</code></li>\n<li>更改Theme&#x3D;的内容<code>sudo vi /etc/plymouth/plymouthd.conf</code><br><code>sudo mkinitcpio -p linux</code>生成新的镜像,重启生效<br>需要’quite splash’静默启动参数,在grub里设置</li>\n</ul>\n</li>\n<li><p><code>grub-mkconfig</code> 刷新grub的配置</p>\n</li>\n<li><p>同个命令对应不同软件版本配置</p>\n<p><code>update-alternatives --install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</code></p>\n<p><code>update-alternatives --install /usr/bin/arm-linux-gnueabi-gcc arm-linux-gnueabi-gcc /usr/bin/arm-linux-gnueabi-gcc-5 5</code></p>\n<p><code>update-alternatives --config arm-linux-gnueabi-gcc</code></p>\n</li>\n<li><p>内核模块相关</p>\n<ul>\n<li><code>modinfo *.ko</code>查看某个编译好的模块</li>\n<li><code>sudo insmod *.ko</code>装入模块</li>\n<li><code>dmesg</code> 查看内核打印信息</li>\n<li><code>lsmod</code> 显示已加载的模块</li>\n<li>已加载的模块会在&#x2F;sys&#x2F;module&#x2F;下建立对应文件夹</li>\n<li><code>sudo rmmod x.ko</code>卸载模块</li>\n</ul>\n</li>\n<li><p>手机USB线wifi共享：</p>\n<ul>\n<li><code>ip addr show</code>查看USB网络借口</li>\n<li><code>dhclient enpxxx</code>给借口设置ip地址，手机热点要开</li>\n</ul>\n</li>\n<li><p>od命令</p>\n<ul>\n<li><code>od -t x1 x.dat</code>以十六进制打印文件x.dat各字节</li>\n<li><code>od -c /bin/bash</code>逐字符方式打印文件,遇到不可打印字符打印编码</li>\n<li><code>echo \\&#39; | od -t o1</code>查看单引号的八进制</li>\n</ul>\n</li>\n<li><p>md5sum命令</p>\n<ul>\n<li><code>md5sum file1 file2</code>计算两个文件的md5值,相同文件md5值相同</li>\n</ul>\n</li>\n<li><p>行律问题</p>\n<ul>\n<li><code>ctty -a</code>查看行律配置</li>\n<li><code>ctty erase ^H</code>设置退格键</li>\n</ul>\n</li>\n<li><p>windows文件不兼容</p>\n<ul>\n<li><code>unix2dos filename</code>转换成windows类型的文件,也有dos2unix命令</li>\n</ul>\n</li>\n<li><p>gbk中文字符转换为utf</p>\n<ul>\n<li><code>iconv -f utf-8 -t gbk</code></li>\n<li><code>echo &quot;汉字&quot; | iconv -f utf-8 -t gbk | od -t x1</code></li>\n</ul>\n</li>\n<li><p><code>--</code>显示终止选项命令<br><code>rm -- -i</code>表示删除名为’-i’的文件</p>\n</li>\n<li><p>在任何命令前加<code>time</code>,可以计时运行时间</p>\n</li>\n</ul>\n<h1 id=\"xargs命令\"><a href=\"#xargs命令\" class=\"headerlink\" title=\"xargs命令\"></a>xargs命令</h1><p>将标准输入构造为命令的命令行参数,如果命令行参数过多,会启动多个进程,与单一普通管道相比就是批处理</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><ul>\n<li>打印c语言文件含有–hlep的行：<code>find src -name \\*.c -print | xargs grep -n -- --help</code></li>\n<li>只打印不执行命令，用于确认：<code>ls|xargs -L1 -p head</code></li>\n<li>移动文件到文件夹:<code>find . -name &quot;*.bak&quot; -print 0|xargs -0 -I file mv file ~/old</code></li>\n</ul>\n<h1 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h1><ul>\n<li><code>cat &lt; filename</code>打印名为filename的文件内容</li>\n<li><code>cat &lt;&lt; END</code>接下来直到END之间的内容</li>\n<li><code>cat &lt;&lt;&lt; filename</code>打印filename这个单词</li>\n<li><code>&gt; 文件名</code>清空文件</li>\n</ul>\n<h1 id=\"tee\"><a href=\"#tee\" class=\"headerlink\" title=\"tee\"></a>tee</h1><p>  从Stdin读取数据，并同时输出到Stdout和文件 <code>ls /usr/bin | tee ls.txt |grep zip</code></p>\n<h1 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a>du命令</h1><ul>\n<li><code>du -sh * | sort -rh</code>查看当前目录下所有文件大小并排序</li>\n<li><code>du -sh</code>统计当前目录大小</li>\n<li><code>du -h --max-depth=1 | sort</code>查看当前所有一级子目录大小并排序</li>\n</ul>\n<h1 id=\"at\"><a href=\"#at\" class=\"headerlink\" title=\"at\"></a>at</h1><ul>\n<li><code>systemctl start atd.service</code>启动服务</li>\n<li><code>at &lt;时间点&gt;</code>时间点格式举例:19:33、3pm+7 days、20:00 tomorrow 之后进入交互界面,输入命令,ctrl+D退出</li>\n<li><code>at -l 或者 atq</code>查看列表</li>\n<li><code>at -c 任务号</code>查看任务内容</li>\n<li><code>at -r 任务号 或者 atrm 任务号</code>取消任务</li>\n<li><code>at -f 脚本文件</code>不进入交互,直接运行某个脚本</li>\n<li><code>-M</code>忽略产生的任何输出</li>\n<li>&#x2F;etc&#x2F;at.deny,文件中的用户不能执行at(系统默认存在)</li>\n<li>&#x2F;etc&#x2F;at.allow,默认不存在,只要存在的用户才能执行</li>\n</ul>\n<h1 id=\"crontab服务定时任务计划\"><a href=\"#crontab服务定时任务计划\" class=\"headerlink\" title=\"crontab服务定时任务计划\"></a>crontab服务定时任务计划</h1><ul>\n<li><code>sudo systemctl start cronie.service</code>启动服务</li>\n<li><code>crontab -e</code>新增任务或编辑任务</li>\n<li><code>crontab -l</code>显示crontab文件</li>\n<li><code>crontab -r</code>删除crontab文件</li>\n<li><code>crontab -ir</code>删除crontab文件前提醒用户</li>\n</ul>\n<h2 id=\"内容格式\"><a href=\"#内容格式\" class=\"headerlink\" title=\"内容格式\"></a>内容格式</h2><p>格式如下: <code>&lt;minute&gt; &lt;hour&gt; &lt;day&gt; &lt;month&gt; &lt;week&gt; &lt;command&gt;</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">条目</th>\n<th align=\"center\">取值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">minute</td>\n<td align=\"center\">0到59之间任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">hour</td>\n<td align=\"center\">0到23之间任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">day</td>\n<td align=\"center\">1到31之间的任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">month</td>\n<td align=\"center\">1到12之间任何整数</td>\n</tr>\n<tr>\n<td align=\"center\">week</td>\n<td align=\"center\">1到7之间任何整数,</td>\n</tr>\n<tr>\n<td align=\"center\">command</td>\n<td align=\"center\">执行的命令</td>\n</tr>\n</tbody></table>\n<ul>\n<li><code>*</code>代表所有可能值</li>\n<li><code>,</code>一个列表范围</li>\n<li><code>-</code>表示一个整数范围</li>\n<li><code>/</code>指定时间间隔的频率,比如”0-23&#x2F;2”表示每两小时执行</li>\n</ul>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><p>如果对时间精读要求不高,可以把脚本复制到&#x2F;etc&#x2F;cron.daily等目录下</p>\n<ul>\n<li><code>* * * * * myCommand</code>:每分钟执行一次</li>\n<li><code>3,15 * * * * myCommand</code>:每小时的第3和第15分钟执行</li>\n<li><code>3,15 8-11 * * * myCommand</code>:在上午8点到11点的第3和第15分钟执行</li>\n<li><code>3,15 8-11 */2  *  * myCommand</code>:每隔两天的上午8点到11点的第3和第15分钟执行</li>\n<li><code>3,15 8-11 * * 1 myCommand</code>:每周一上午8点到11点的第3和第15分钟执行</li>\n<li><code>30 21 * * * /etc/init.d/smb restart</code>:每晚的21:30重启smb</li>\n<li><code>45 4 1,10,22 * * /etc/init.d/smb restart</code>:每月1、10、22日的4 : 45重启smb</li>\n<li><code>10 1 * * 6,0 /etc/init.d/smb restart</code>:每周六、周日的1 : 10重启smb</li>\n<li><code>0,30 18-23 * * * /etc/init.d/smb restart</code>:每天18 : 00至23 : 00之间每隔30分钟重启smb</li>\n<li><code>0 23 * * 6 /etc/init.d/smb restart</code>:每星期六的晚上11 : 00 pm重启smb</li>\n<li><code>* */1 * * * /etc/init.d/smb restart</code>:每一小时重启smb</li>\n<li><code>0 23-7 * * * /etc/init.d/smb restart</code>晚上11点到早上7点之间，每隔一小时重启smb</li>\n</ul>\n<h2 id=\"anacron\"><a href=\"#anacron\" class=\"headerlink\" title=\"anacron\"></a>anacron</h2><p>anacron是对该程序的一个补充,它会自动运行crontab原本应该运行但由于关机等原因造成的程序,但它只会处理位于&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly下的脚本文件,它的配置文件位于&#x2F;etc&#x2F;anacrontab<br>anacron是自动运行的?(有待研究)</p>\n<ul>\n<li><p>run-parts一个接一个运行同一目录下的脚本</p>\n<ul>\n<li><code>run-parts&lt;directory-path&gt;</code></li>\n<li><code>run-parts --list --regex  &#39;^s.\\*sh$&#39; &lt;directory&gt; </code></li>\n</ul>\n</li>\n<li><p><code>type &lt;command&gt;</code>识别命令,有以下几种</p>\n<ul>\n<li>可执行命令，给出路径</li>\n<li>shell自身的命令(builtins),内建命令不会产生子进程,代价更小</li>\n<li>一个shell函数</li>\n<li>别名命令</li>\n</ul>\n</li>\n<li><p><code>whatis &lt;command&gt;</code>会给出命令简短的说明</p>\n</li>\n<li><p><code>rm !(*.csv)</code>删除除了csv结尾的所有文件(貌似只有bash支持，zsh不支持)</p>\n</li>\n<li><p><code>mkdir &#123;2007..2009&#125;\\_0&#123;1..9&#125;&#123;A,B&#125;</code>创建一系列文件夹,这其实是花括号展开</p>\n</li>\n<li><p><code>apropos &lt;some word&gt;</code>在man手册里搜索关键字</p>\n</li>\n<li><p><code>info &lt;command&gt;</code>man手册的另一种排版，有点鸡肋</p>\n</li>\n<li><p>标准错误的重定向</p>\n<p>标准错误和标准输出重定向同一个文件<br><code>ls -l xx &gt;info.txt 2&gt;&amp;1</code>等价于<code>ls -l xx &amp;&gt; info.txt</code></p>\n</li>\n<li><p>env 或 printenv打印当前环境变量(全局变量)</p>\n</li>\n<li><p>set打印当前环境变量并按字母排列(包括局部变量、全局变量、用户定义变量)</p>\n</li>\n<li><p>alias查看别名,上面的不可以查看</p>\n</li>\n<li><p><code>ps -f --forest</code> 可以显示当前shell的进程关系</p>\n</li>\n<li><p>coproc(这就是协程?)<br><code>coproc [job_name(可选)] [command]</code>等价于<code>( command )&amp;</code><br>即生成后台子shell，并在子shell中执行命令。command本身可以是小括号命令集(嵌套子shell)或大括号命令集</p>\n</li>\n<li><p>mktemp</p>\n<p>mktemp可以用来创建临时文件,成功会输出文件路径</p>\n<p><code>mktemp [module]</code>不指定[module]会在&#x2F;tmp中创建唯一临时文件,有用户有读写权限(不使用umask值),若指定[module],则会在当前文件夹下产生模板临时文件(会用任意字符替换模板值中的X),如<code>mktemp test.XXX</code>可能会在当前文件夹下产生文件test.UGH</p>\n<p>-t:强制在&#x2F;tmp下创建临时文件</p>\n<p>-d:创建临时目录</p>\n</li>\n<li><p>nice以某个优先级来运行某个程序<br><code>nice -[num] [command]</code>,num值越大,优先级越低,可以通过”ps -o ni”查看优先级,只能降低,不能提高优先级,</p>\n</li>\n<li><p>renice调整某个程序优先级<br><code>renice -[num] -p [process id]</code>普通用户只能降低优先级,root可以任意调整</p>\n</li>\n<li><p>ntpd<br><code>sudo ntpd -qg</code>可以校准时间</p>\n</li>\n<li><p>readlink输出文件的绝对路径<br> <code>readlink -f [fileName]</code></p>\n</li>\n<li><p>truncate<br><code>truncate -s 5 test.txt</code>截断test.txt，只保留5个字符</p>\n</li>\n<li><p>nm<br>nm作用于目标文件，统计标识符有大用</p>\n</li>\n<li><p>parallel<br>parallel用法复杂，建议读man<br><strong>用法:</strong></p>\n<ul>\n<li>cmd | parallel [options] ‘somecmd’,parallel会默认把每行的内容,插到命令末尾</li>\n<li>parallel [options] ‘cmd’ ::: [parameter1 list] ::: [parameter2 list]…<br>强大的xargs的升级版（这只是个人感觉啊）</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-j&#x2F;–jobs [num]</td>\n<td align=\"center\">同时运行num个任务</td>\n</tr>\n<tr>\n<td align=\"center\">–C&#x2F;–colsep [regep]</td>\n<td align=\"center\">参数分隔符号</td>\n</tr>\n<tr>\n<td align=\"center\">–header</td>\n<td align=\"center\">忽略第一行</td>\n</tr>\n<tr>\n<td align=\"center\">–results [file]</td>\n<td align=\"center\">保存输出内容到某文件，还会输出到标准输出</td>\n</tr>\n<tr>\n<td align=\"center\">–keep-order</td>\n<td align=\"center\">并行有时会不按输出行的顺序，这个保持顺序</td>\n</tr>\n<tr>\n<td align=\"center\">–tag</td>\n<td align=\"center\">在每个结果开头，输出参数内容</td>\n</tr>\n<tr>\n<td align=\"center\">–slf&#x2F;–sshloginfile [hostnames]</td>\n<td align=\"center\">使用远程机当算力</td>\n</tr>\n<tr>\n<td align=\"center\">–sshlogin</td>\n<td align=\"center\">登录远程机</td>\n</tr>\n<tr>\n<td align=\"center\">–nonall</td>\n<td align=\"center\">不传递参数，只传递命令给远程机</td>\n</tr>\n<tr>\n<td align=\"center\">-N[num]</td>\n<td align=\"center\">分配给远程多少个参数</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特殊变量名</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&#123;&#125;</code></td>\n<td align=\"center\">一行的内容</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&#123;/&#125;</code></td>\n<td align=\"center\">相当于对当前行运行basename</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&#123;井&#125;</code></td>\n<td align=\"center\">任务号，从1开始编号</td>\n</tr>\n</tbody></table>\n<p><strong>例子：</strong></p>\n<ul>\n<li><code>seq 0 2 100 | parallel &quot;echo &#123;&#125;^2 | bc&quot;</code></li>\n<li><code>seq 1000 | parallel -N100 --pipe --slf hostnames &quot;paste -sd+ | bc&quot; | paste -sd+|bc</code>并行算1-1000的和，一个核算一百个参数</li>\n<li>history<br>任何匹配HISTIGNORE环境变量的命令不会被记录,以<code>:</code>分割多个模式</li>\n</ul>\n<ol>\n<li><code>unset HISTFILE</code>当前会话下不记录命令行历史</li>\n<li>设置HISTIGNORE为<code>HISTIGNORE=&quot;[&amp;:\\t]&quot;</code>在命令前加空格会使当前命令不被记录到历史,并且<code>&amp;</code>表示上一次执行的命令，就是重复命令只记录一次</li>\n<li><code>HISTFILE=~/docs/shell_history.txt</code>更改历史记录文件</li>\n<li><code>HISTTIMEFORMAT=&quot;%Y-%m-%d %H:%M:%S&quot;</code>在每条记录前加时间戳</li>\n<li>显示执行最多的10个命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">history</span> |<br>   sed <span class=\"hljs-string\">&#x27;s/^ \\+//;s/  / /&#x27;</span> |<br>   <span class=\"hljs-built_in\">cut</span> -d<span class=\"hljs-string\">&#x27; &#x27;</span> -f2- |<br>   awk <span class=\"hljs-string\">&#x27;&#123; count[$0]++ &#125; END &#123; for (i in count) print count[i], i &#125;&#x27;</span> |<br>   <span class=\"hljs-built_in\">sort</span> -rn |<br>   <span class=\"hljs-built_in\">head</span> -10<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>使用python快速搭建web服务器<code>python3 -m http.server 8080</code></li>\n<li>Linux性能分析火焰图<br><img src=\"/images/flameLinux1.jpg\"><br><img src=\"/images/flameLinux2.jpg\"><br><img src=\"/images/flameLinux3.jpg\"><br><img src=\"/images/flameLinux4.jpg\"></li>\n<li>factor<br>分解一个数字的因子</li>\n</ul>\n"},{"title":"Linux文件","date":"2019-07-18T08:28:04.000Z","subtitle":null,"index_img":"/images/linuxFile.webp","banner_img":"/images/linuxFile.webp","_content":"1.  \n/etc/resolv.conf:加快网速的\n\n2.  \n/etc/apt/sources.list:源列表\n5.  \n/etc/sudoers:sudo权限设置\n6.  \n/etc/xinetd.d/:守护进程文件夹\n7.  \n/etc/inputrc:登录式bash的热键设置\n8.  \n登录式bash加载设置文件顺序:/etc/profile -> \\~/.bash_profile(\\~/.bash_login、\\~/.profile) -> \\~/.bashrc\n9.  \n非登录式bash加载设置文件顺序:\\~/.bashrc -> /etc/bashrc -> /etc/profile.d/\\*.sh  \n这其中的/etc/profile.d/\\*.sh里为bash操作界面、语系等\n10.  \n/dev/pts:伪终端设备的目录\n/dev/:字符设备对应的节点\n11.  \n/proc/net/dev:网络终端接口\n12.\n/etc/mkinitcpio.conf:钩子的配置文件\n13.\n/etc/default/grub:设置当前系统的启动参数(仅deepin有)\n/boot/grub/grub.cfg:设置所有系统的启动参数(arch的也可以设置,存在于deepin目录)\n14.  \n/proc/kallsyms:内核导出的符号表，第一列表示内核地址空间地址，第二列表示符号属性，第三段表示符号的字符串，也就是EXPORT_SYMBOL()导出的符号，第四列表示那些模块在使用这些符号\n15.  \n/proc/devices:字符设备,第一列数字代表主设备号,第二列则是设备内核模块名\n/proc/(number):进程号的相关动态信息\n16.  \n超级块是对一个文件系统的描述\n索引节点是对一个文件物理属性的描述\n目录项是对一个文件逻辑属性的描述\n一个进程所处的位置是由fs_struct来描述的,而一个进程(或用户)打开的文件是由files_struct来描述的,而整个系统所打开的文件是由file结构来描述的\n17./etc/ld.so.conf.d/*.conf\n里面是库文件所在目录，配置完用`ldconfig`更新一下\n18./usr/share/doc目录下为各个安装软件的文档\n19./usr/share/dict下竟然存了个英文字典\n20.修改用户头像\n/var/lib/AccountsService/users/[userName]\n默认icons文件位置在/usr/share/pixmaps/faces/\n头像尺寸方形才不缺失\n","source":"_posts/Linux文件.md","raw":"---\ntitle: Linux文件\ndate: 2019-07-18 16:28:04\nsubtitle:\ncategories: Linux\ntags: 文件\nindex_img: /images/linuxFile.webp\nbanner_img: /images/linuxFile.webp\n---\n1.  \n/etc/resolv.conf:加快网速的\n\n2.  \n/etc/apt/sources.list:源列表\n5.  \n/etc/sudoers:sudo权限设置\n6.  \n/etc/xinetd.d/:守护进程文件夹\n7.  \n/etc/inputrc:登录式bash的热键设置\n8.  \n登录式bash加载设置文件顺序:/etc/profile -> \\~/.bash_profile(\\~/.bash_login、\\~/.profile) -> \\~/.bashrc\n9.  \n非登录式bash加载设置文件顺序:\\~/.bashrc -> /etc/bashrc -> /etc/profile.d/\\*.sh  \n这其中的/etc/profile.d/\\*.sh里为bash操作界面、语系等\n10.  \n/dev/pts:伪终端设备的目录\n/dev/:字符设备对应的节点\n11.  \n/proc/net/dev:网络终端接口\n12.\n/etc/mkinitcpio.conf:钩子的配置文件\n13.\n/etc/default/grub:设置当前系统的启动参数(仅deepin有)\n/boot/grub/grub.cfg:设置所有系统的启动参数(arch的也可以设置,存在于deepin目录)\n14.  \n/proc/kallsyms:内核导出的符号表，第一列表示内核地址空间地址，第二列表示符号属性，第三段表示符号的字符串，也就是EXPORT_SYMBOL()导出的符号，第四列表示那些模块在使用这些符号\n15.  \n/proc/devices:字符设备,第一列数字代表主设备号,第二列则是设备内核模块名\n/proc/(number):进程号的相关动态信息\n16.  \n超级块是对一个文件系统的描述\n索引节点是对一个文件物理属性的描述\n目录项是对一个文件逻辑属性的描述\n一个进程所处的位置是由fs_struct来描述的,而一个进程(或用户)打开的文件是由files_struct来描述的,而整个系统所打开的文件是由file结构来描述的\n17./etc/ld.so.conf.d/*.conf\n里面是库文件所在目录，配置完用`ldconfig`更新一下\n18./usr/share/doc目录下为各个安装软件的文档\n19./usr/share/dict下竟然存了个英文字典\n20.修改用户头像\n/var/lib/AccountsService/users/[userName]\n默认icons文件位置在/usr/share/pixmaps/faces/\n头像尺寸方形才不缺失\n","slug":"Linux文件","published":1,"updated":"2023-12-20T12:39:06.923Z","_id":"clq1yvi6v000cgwq243c82psb","comments":1,"layout":"post","photos":[],"content":"<ol>\n<li><p>&#x2F;etc&#x2F;resolv.conf:加快网速的</p>\n</li>\n<li><p>&#x2F;etc&#x2F;apt&#x2F;sources.list:源列表</p>\n</li>\n<li><p>&#x2F;etc&#x2F;sudoers:sudo权限设置</p>\n</li>\n<li><p>&#x2F;etc&#x2F;xinetd.d&#x2F;:守护进程文件夹</p>\n</li>\n<li><p>&#x2F;etc&#x2F;inputrc:登录式bash的热键设置</p>\n</li>\n<li><p>登录式bash加载设置文件顺序:&#x2F;etc&#x2F;profile -&gt; ~&#x2F;.bash_profile(~&#x2F;.bash_login、~&#x2F;.profile) -&gt; ~&#x2F;.bashrc</p>\n</li>\n<li><p>非登录式bash加载设置文件顺序:~&#x2F;.bashrc -&gt; &#x2F;etc&#x2F;bashrc -&gt; &#x2F;etc&#x2F;profile.d&#x2F;*.sh<br>这其中的&#x2F;etc&#x2F;profile.d&#x2F;*.sh里为bash操作界面、语系等</p>\n</li>\n<li><p>&#x2F;dev&#x2F;pts:伪终端设备的目录<br>&#x2F;dev&#x2F;:字符设备对应的节点</p>\n</li>\n<li><p>&#x2F;proc&#x2F;net&#x2F;dev:网络终端接口</p>\n</li>\n<li><p>&#x2F;etc&#x2F;mkinitcpio.conf:钩子的配置文件</p>\n</li>\n<li><p>&#x2F;etc&#x2F;default&#x2F;grub:设置当前系统的启动参数(仅deepin有)<br>&#x2F;boot&#x2F;grub&#x2F;grub.cfg:设置所有系统的启动参数(arch的也可以设置,存在于deepin目录)</p>\n</li>\n<li><p>&#x2F;proc&#x2F;kallsyms:内核导出的符号表，第一列表示内核地址空间地址，第二列表示符号属性，第三段表示符号的字符串，也就是EXPORT_SYMBOL()导出的符号，第四列表示那些模块在使用这些符号</p>\n</li>\n<li><p>&#x2F;proc&#x2F;devices:字符设备,第一列数字代表主设备号,第二列则是设备内核模块名<br>&#x2F;proc&#x2F;(number):进程号的相关动态信息</p>\n</li>\n<li><p>超级块是对一个文件系统的描述<br>索引节点是对一个文件物理属性的描述<br>目录项是对一个文件逻辑属性的描述<br>一个进程所处的位置是由fs_struct来描述的,而一个进程(或用户)打开的文件是由files_struct来描述的,而整个系统所打开的文件是由file结构来描述的<br>17.&#x2F;etc&#x2F;ld.so.conf.d&#x2F;*.conf<br>里面是库文件所在目录，配置完用<code>ldconfig</code>更新一下<br>18.&#x2F;usr&#x2F;share&#x2F;doc目录下为各个安装软件的文档<br>19.&#x2F;usr&#x2F;share&#x2F;dict下竟然存了个英文字典<br>20.修改用户头像<br>&#x2F;var&#x2F;lib&#x2F;AccountsService&#x2F;users&#x2F;[userName]<br>默认icons文件位置在&#x2F;usr&#x2F;share&#x2F;pixmaps&#x2F;faces&#x2F;<br>头像尺寸方形才不缺失</p>\n</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li><p>&#x2F;etc&#x2F;resolv.conf:加快网速的</p>\n</li>\n<li><p>&#x2F;etc&#x2F;apt&#x2F;sources.list:源列表</p>\n</li>\n<li><p>&#x2F;etc&#x2F;sudoers:sudo权限设置</p>\n</li>\n<li><p>&#x2F;etc&#x2F;xinetd.d&#x2F;:守护进程文件夹</p>\n</li>\n<li><p>&#x2F;etc&#x2F;inputrc:登录式bash的热键设置</p>\n</li>\n<li><p>登录式bash加载设置文件顺序:&#x2F;etc&#x2F;profile -&gt; ~&#x2F;.bash_profile(~&#x2F;.bash_login、~&#x2F;.profile) -&gt; ~&#x2F;.bashrc</p>\n</li>\n<li><p>非登录式bash加载设置文件顺序:~&#x2F;.bashrc -&gt; &#x2F;etc&#x2F;bashrc -&gt; &#x2F;etc&#x2F;profile.d&#x2F;*.sh<br>这其中的&#x2F;etc&#x2F;profile.d&#x2F;*.sh里为bash操作界面、语系等</p>\n</li>\n<li><p>&#x2F;dev&#x2F;pts:伪终端设备的目录<br>&#x2F;dev&#x2F;:字符设备对应的节点</p>\n</li>\n<li><p>&#x2F;proc&#x2F;net&#x2F;dev:网络终端接口</p>\n</li>\n<li><p>&#x2F;etc&#x2F;mkinitcpio.conf:钩子的配置文件</p>\n</li>\n<li><p>&#x2F;etc&#x2F;default&#x2F;grub:设置当前系统的启动参数(仅deepin有)<br>&#x2F;boot&#x2F;grub&#x2F;grub.cfg:设置所有系统的启动参数(arch的也可以设置,存在于deepin目录)</p>\n</li>\n<li><p>&#x2F;proc&#x2F;kallsyms:内核导出的符号表，第一列表示内核地址空间地址，第二列表示符号属性，第三段表示符号的字符串，也就是EXPORT_SYMBOL()导出的符号，第四列表示那些模块在使用这些符号</p>\n</li>\n<li><p>&#x2F;proc&#x2F;devices:字符设备,第一列数字代表主设备号,第二列则是设备内核模块名<br>&#x2F;proc&#x2F;(number):进程号的相关动态信息</p>\n</li>\n<li><p>超级块是对一个文件系统的描述<br>索引节点是对一个文件物理属性的描述<br>目录项是对一个文件逻辑属性的描述<br>一个进程所处的位置是由fs_struct来描述的,而一个进程(或用户)打开的文件是由files_struct来描述的,而整个系统所打开的文件是由file结构来描述的<br>17.&#x2F;etc&#x2F;ld.so.conf.d&#x2F;*.conf<br>里面是库文件所在目录，配置完用<code>ldconfig</code>更新一下<br>18.&#x2F;usr&#x2F;share&#x2F;doc目录下为各个安装软件的文档<br>19.&#x2F;usr&#x2F;share&#x2F;dict下竟然存了个英文字典<br>20.修改用户头像<br>&#x2F;var&#x2F;lib&#x2F;AccountsService&#x2F;users&#x2F;[userName]<br>默认icons文件位置在&#x2F;usr&#x2F;share&#x2F;pixmaps&#x2F;faces&#x2F;<br>头像尺寸方形才不缺失</p>\n</li>\n</ol>\n"},{"title":"Linux文件权限","date":"2021-10-20T12:41:40.000Z","subtitle":null,"index_img":"/images/file_permission.jpg","banner_img":"/images/file_permission.jpg","_content":"## 用户\n### /etc/passwd文件\n/etc/passwd包含了一些与用户有关的信息 以':'分割符依次为以下内容\n* 登陆用户名\n* 用户账户的UID(数字形式)\n* 用户账户的组ID(GID)(数字形式)\n* 用户账户的文本描述(备注字段)\n* 用户HOME目录位置\n* 用户默认shell\nroot的UID为0,1000以下的UID为系统服务账户预留,普通用户为1000以后\n\n### /etc/shadow文件\n/etc/shadow文件管理着各个用户的密码,** 最好不要擅自修改,可能会造成系统崩溃**,以冒号分隔符,有以下字段\n* 与/etc/passwd 文件中的登录名字段对应的登录名\n* 加密后的密码\n* 自上次修改密码后过去的天数（自 1970 年 1 月 1 日开始计算）\n* 多少天后才能更改密码\n* 多少天后必须更改密码\n* 密码过期前提前多少天提醒用户更改密码\n* 密码过期后多少天禁用用户账户\n* 用户账户被禁用的日期（用自 1970 年 1 月 1 日到当天的天数表示）\n* 预留字段给将来使用\n\n### useradd命令与useradd文件\n`useradd`命令使用系统的默认配置存在/etc/default/useradd文件中,arch linux默认配置如下:\n\n```bash\n# useradd defaults file for ArchLinux\n# original changes by TomK\nGROUP=users\nHOME=/home\nINACTIVE=-1\nEXPIRE=\nSHELL=/bin/bash\nSKEL=/etc/skel\nCREATE_MAIL_SPOOL=no\n```\n\n含义如下:\n* 新用户会被添加到 users 的公共组；\n* 新用户的 HOME 目录将会位于/home/loginname；\n* 新用户账户密码在过期后不会被禁用；\n* 新用户账户未被设置过期日期；\n* 新用户账户将 bash shell 作为默认 shell；\n* 系统会将/etc/skel 目录下的内容复制到用户的 HOME 目录下；(一般用于一些bash或vim配置文件等)\n* 系统不会为该用户账户在 mail 目录下创建一个用于接收邮件的文件。\n最常用命令\n`sudo useradd -m test`创建新HOME目录名为test。\n\n### userdel\n`sudo userdel -r test`删除用户test，-r选项表明删除test用户的HOME目录及邮件目录\n\n### usermod\nusermod命令很强大(基本可以替代接下来的修改命令)可以用来修改/etc/passwd中的大部分字段,常用选项如下:\n* -c修改备注字段\n* -e修改过期日期\n* -g修改默认的登录组\n* -l修改用户账户的登录名\n* -L锁定账户,使用户无法登录\n* -p修改账户的密码\n* -U解除锁定,使用户能够登录\n* `sudo usermod -G shared test`把test用户添加到组shared <span id = \"usermod\"></span>\n\n### passwd和chpasswd\n* `sudo passwd test`修改test用户的密码,如果只用passwd只会改变当前用户的密码,-e选项能强制用户下次登录时修改密码。\n* chpasswd可以大量修改密码`sudo chpasswd < users.txt`能从users.txt中自动读取登录名和密码对(由冒号分割)列表\n\n### chsh、chfn和chage\n* `sudo chsh -s /bin/zsh test`快速修改默认的用户登录shell。必须全路径\n* `sudo chfn test`为用户test添加备注字段,默认会用finger命令的输出作为备注字段,如果没装finger，会询问你。\n* chage命令用来帮助管理用户的有效期\n    * -d:设置上次修改密码到现在的天数\n\t* -E:设置密码过期的日期\n\t* -l:设置密码过期到锁定账户的天数\n\t* -m:设置修改密码之间最少要多少天\n\t* -W:设置密码过期前多久开始出现提醒信息\nchange命令的日期值可以用下面两种方式\n\t* YYYY-MM-DD\n\t* 代表从1970年1月1日起到该日期的天数\n\n## 组\n### /etc/group文件\n与/etc/passwd文件类似,以冒号分割符有以下四个字段:\n* 组名\n* 组密码(用的不多,允许非成员通过它成为该组的成员)\n* GID\n* 属于该组的用户列表(**注意:文件中不一定列全了,一定要结合/etc/passwd来查看**)\n\n### groupadd命令\n`sudo groupad shared`创建新组,默认没有用户\n见[usermod](#usermod)那节,为组添加用户\n\n### groupmod\n* -g:修改已有组GID`groupmod -g newGid groupName`\n* -n:修改组名`groupmod -n newname oldname`\n\n## umask\n`umask`命令会输出4位数的掩码值,以**0022**为例(第一个0仅代表8进制的意思):\n* 二进制: 000 010 010\n* 取消新文件和新目录的组w权限和其他用户w权限\n对照表\n\n|Oct|Bin|File Mode|\n|:-:|:-:|:-:|\n|0|000|---|\n|1|001|--x|\n|2|010|-w-|\n|3|011|-wx|\n|4|100|r--|\n|5|101|r-x|\n|6|110|rw-|\n|7|111|rwx|\n\n问题是touch默认的权限是644(即rw-r--r--),怎么来的呢？首先文件有个全权限为666,目录的全权限为777,666把umask值的1位减去即是644\n\n## 文件的属性\n文件除了权限外,还有属性设置,也很有用\n* chattr:为文件添加或删除属性`sudo chattr +i testfile`,`sudo chattr -i testfile`\n* lsattr:查看文件的属性`sudo lsattr testfile`\n\n可通过`man chattr`来查看可以设置哪些属性,下表列出常用属性\n\n|字母|含义|\n|:-:|:-:|\n|i|文件不能被删除、改名、设置链接、也无法写入或新增数据|\n|a|只能增加数据,而不能删除也不能修改数据|\n\n## chmod\nchmod [ugoa][+=-][rwxst] 文件名表\n也可以用八进制数字设置:`chmod xxx file`,对应关系见上表\n\n### 三个特殊权限:\n* setuid(SUID)--仅作用于可执行文件,`chmod u+s program` 当应用到一个可执行文件(s标志会出现在拥有者的x权限上)，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。\nb.setgid(SGID)--作用于可执行文件和目录(s标志会出现在组的x权限上) ,`chmod g+s dir` 把有效用户组 ID 从真正的用户组ID更改为文件所有者的组ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。\nc.sticky位(SBIT)--仅作用于目录(t标志会出现在其他的x权限上)`chmod o+t dir`,如果一个目录设置了sticky位，那么它能阻止用户删除或重命名文件,除非用户是这个目录的所有者,或者是文件所有者,或是超级用户。这个经常用来控制访问共享目录,比方说/tmp。\n这3种权限也可以用另一套八进制来表示`chmod xxxx file`第一个数字是设置特殊权限的,这与umask的第一位**含义不同**\n\n|Oct|Bin|File Mode|\n|:-:|:-:|:-:|\n|0|000|所有特殊位为0|\n|1|001|sticky置位|\n|2|010|SGID置位|\n|3|011|SGID和sticky置位|\n|4|100|SUID置位|\n|5|101|SUID和sticky置位|\n|6|110|SUID和SGID置位|\n|7|111|所有位都置位|\n\n### 可执行权限上的'S/T'(还有X有待研究)\n没有执行权限的 UID/GID 和黏置位。小写的 s 与 t 都是取代 x 这个权限的，但是当下达 7666 权限时，也就是说,user,group 以及 others 都没有 x 这个可执行的标志时(因为是 666)，特殊权限位也不可能有权限执行，7666 的结果为-rwSrwSrwT。所以，这个 S, T 代表的就是“空的”执行权限，不具有执行权限。换个说法， SUID +s 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件拥有者都无法执行时，也就不存在权限给其他人使用了。\n\n## chown和chgrp\n这两个命令除了root外,只有修改用户处于原用户组和新用户组才能修改\n* `chown username.groupname filename`改变文件的用户和用户组,用户组名可选,当省略username,并在groupname前面加个`.`,则只改变用户组名,当省略groupname,在username后面加个`.`,则改变用户并把用户组改成与用户名同名的用户组\n    * -R:递归目录\n\t* -h:该文件的所有链接文件也被改变所属关系\n* `chgrp groupname filename`更改用户组\n","source":"_posts/Linux文件权限.md","raw":"---\ntitle: Linux文件权限\ndate: 2021-10-20 20:41:40\nsubtitle:\ncategories:\ntags:\nindex_img: /images/file_permission.jpg\nbanner_img: /images/file_permission.jpg\n---\n## 用户\n### /etc/passwd文件\n/etc/passwd包含了一些与用户有关的信息 以':'分割符依次为以下内容\n* 登陆用户名\n* 用户账户的UID(数字形式)\n* 用户账户的组ID(GID)(数字形式)\n* 用户账户的文本描述(备注字段)\n* 用户HOME目录位置\n* 用户默认shell\nroot的UID为0,1000以下的UID为系统服务账户预留,普通用户为1000以后\n\n### /etc/shadow文件\n/etc/shadow文件管理着各个用户的密码,** 最好不要擅自修改,可能会造成系统崩溃**,以冒号分隔符,有以下字段\n* 与/etc/passwd 文件中的登录名字段对应的登录名\n* 加密后的密码\n* 自上次修改密码后过去的天数（自 1970 年 1 月 1 日开始计算）\n* 多少天后才能更改密码\n* 多少天后必须更改密码\n* 密码过期前提前多少天提醒用户更改密码\n* 密码过期后多少天禁用用户账户\n* 用户账户被禁用的日期（用自 1970 年 1 月 1 日到当天的天数表示）\n* 预留字段给将来使用\n\n### useradd命令与useradd文件\n`useradd`命令使用系统的默认配置存在/etc/default/useradd文件中,arch linux默认配置如下:\n\n```bash\n# useradd defaults file for ArchLinux\n# original changes by TomK\nGROUP=users\nHOME=/home\nINACTIVE=-1\nEXPIRE=\nSHELL=/bin/bash\nSKEL=/etc/skel\nCREATE_MAIL_SPOOL=no\n```\n\n含义如下:\n* 新用户会被添加到 users 的公共组；\n* 新用户的 HOME 目录将会位于/home/loginname；\n* 新用户账户密码在过期后不会被禁用；\n* 新用户账户未被设置过期日期；\n* 新用户账户将 bash shell 作为默认 shell；\n* 系统会将/etc/skel 目录下的内容复制到用户的 HOME 目录下；(一般用于一些bash或vim配置文件等)\n* 系统不会为该用户账户在 mail 目录下创建一个用于接收邮件的文件。\n最常用命令\n`sudo useradd -m test`创建新HOME目录名为test。\n\n### userdel\n`sudo userdel -r test`删除用户test，-r选项表明删除test用户的HOME目录及邮件目录\n\n### usermod\nusermod命令很强大(基本可以替代接下来的修改命令)可以用来修改/etc/passwd中的大部分字段,常用选项如下:\n* -c修改备注字段\n* -e修改过期日期\n* -g修改默认的登录组\n* -l修改用户账户的登录名\n* -L锁定账户,使用户无法登录\n* -p修改账户的密码\n* -U解除锁定,使用户能够登录\n* `sudo usermod -G shared test`把test用户添加到组shared <span id = \"usermod\"></span>\n\n### passwd和chpasswd\n* `sudo passwd test`修改test用户的密码,如果只用passwd只会改变当前用户的密码,-e选项能强制用户下次登录时修改密码。\n* chpasswd可以大量修改密码`sudo chpasswd < users.txt`能从users.txt中自动读取登录名和密码对(由冒号分割)列表\n\n### chsh、chfn和chage\n* `sudo chsh -s /bin/zsh test`快速修改默认的用户登录shell。必须全路径\n* `sudo chfn test`为用户test添加备注字段,默认会用finger命令的输出作为备注字段,如果没装finger，会询问你。\n* chage命令用来帮助管理用户的有效期\n    * -d:设置上次修改密码到现在的天数\n\t* -E:设置密码过期的日期\n\t* -l:设置密码过期到锁定账户的天数\n\t* -m:设置修改密码之间最少要多少天\n\t* -W:设置密码过期前多久开始出现提醒信息\nchange命令的日期值可以用下面两种方式\n\t* YYYY-MM-DD\n\t* 代表从1970年1月1日起到该日期的天数\n\n## 组\n### /etc/group文件\n与/etc/passwd文件类似,以冒号分割符有以下四个字段:\n* 组名\n* 组密码(用的不多,允许非成员通过它成为该组的成员)\n* GID\n* 属于该组的用户列表(**注意:文件中不一定列全了,一定要结合/etc/passwd来查看**)\n\n### groupadd命令\n`sudo groupad shared`创建新组,默认没有用户\n见[usermod](#usermod)那节,为组添加用户\n\n### groupmod\n* -g:修改已有组GID`groupmod -g newGid groupName`\n* -n:修改组名`groupmod -n newname oldname`\n\n## umask\n`umask`命令会输出4位数的掩码值,以**0022**为例(第一个0仅代表8进制的意思):\n* 二进制: 000 010 010\n* 取消新文件和新目录的组w权限和其他用户w权限\n对照表\n\n|Oct|Bin|File Mode|\n|:-:|:-:|:-:|\n|0|000|---|\n|1|001|--x|\n|2|010|-w-|\n|3|011|-wx|\n|4|100|r--|\n|5|101|r-x|\n|6|110|rw-|\n|7|111|rwx|\n\n问题是touch默认的权限是644(即rw-r--r--),怎么来的呢？首先文件有个全权限为666,目录的全权限为777,666把umask值的1位减去即是644\n\n## 文件的属性\n文件除了权限外,还有属性设置,也很有用\n* chattr:为文件添加或删除属性`sudo chattr +i testfile`,`sudo chattr -i testfile`\n* lsattr:查看文件的属性`sudo lsattr testfile`\n\n可通过`man chattr`来查看可以设置哪些属性,下表列出常用属性\n\n|字母|含义|\n|:-:|:-:|\n|i|文件不能被删除、改名、设置链接、也无法写入或新增数据|\n|a|只能增加数据,而不能删除也不能修改数据|\n\n## chmod\nchmod [ugoa][+=-][rwxst] 文件名表\n也可以用八进制数字设置:`chmod xxx file`,对应关系见上表\n\n### 三个特殊权限:\n* setuid(SUID)--仅作用于可执行文件,`chmod u+s program` 当应用到一个可执行文件(s标志会出现在拥有者的x权限上)，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。\nb.setgid(SGID)--作用于可执行文件和目录(s标志会出现在组的x权限上) ,`chmod g+s dir` 把有效用户组 ID 从真正的用户组ID更改为文件所有者的组ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。\nc.sticky位(SBIT)--仅作用于目录(t标志会出现在其他的x权限上)`chmod o+t dir`,如果一个目录设置了sticky位，那么它能阻止用户删除或重命名文件,除非用户是这个目录的所有者,或者是文件所有者,或是超级用户。这个经常用来控制访问共享目录,比方说/tmp。\n这3种权限也可以用另一套八进制来表示`chmod xxxx file`第一个数字是设置特殊权限的,这与umask的第一位**含义不同**\n\n|Oct|Bin|File Mode|\n|:-:|:-:|:-:|\n|0|000|所有特殊位为0|\n|1|001|sticky置位|\n|2|010|SGID置位|\n|3|011|SGID和sticky置位|\n|4|100|SUID置位|\n|5|101|SUID和sticky置位|\n|6|110|SUID和SGID置位|\n|7|111|所有位都置位|\n\n### 可执行权限上的'S/T'(还有X有待研究)\n没有执行权限的 UID/GID 和黏置位。小写的 s 与 t 都是取代 x 这个权限的，但是当下达 7666 权限时，也就是说,user,group 以及 others 都没有 x 这个可执行的标志时(因为是 666)，特殊权限位也不可能有权限执行，7666 的结果为-rwSrwSrwT。所以，这个 S, T 代表的就是“空的”执行权限，不具有执行权限。换个说法， SUID +s 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件拥有者都无法执行时，也就不存在权限给其他人使用了。\n\n## chown和chgrp\n这两个命令除了root外,只有修改用户处于原用户组和新用户组才能修改\n* `chown username.groupname filename`改变文件的用户和用户组,用户组名可选,当省略username,并在groupname前面加个`.`,则只改变用户组名,当省略groupname,在username后面加个`.`,则改变用户并把用户组改成与用户名同名的用户组\n    * -R:递归目录\n\t* -h:该文件的所有链接文件也被改变所属关系\n* `chgrp groupname filename`更改用户组\n","slug":"Linux文件权限","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi6w000ggwq253otht9m","content":"<h2 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h2><h3 id=\"etc-passwd文件\"><a href=\"#etc-passwd文件\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;passwd文件\"></a>&#x2F;etc&#x2F;passwd文件</h3><p>&#x2F;etc&#x2F;passwd包含了一些与用户有关的信息 以’:’分割符依次为以下内容</p>\n<ul>\n<li>登陆用户名</li>\n<li>用户账户的UID(数字形式)</li>\n<li>用户账户的组ID(GID)(数字形式)</li>\n<li>用户账户的文本描述(备注字段)</li>\n<li>用户HOME目录位置</li>\n<li>用户默认shell<br>root的UID为0,1000以下的UID为系统服务账户预留,普通用户为1000以后</li>\n</ul>\n<h3 id=\"etc-shadow文件\"><a href=\"#etc-shadow文件\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;shadow文件\"></a>&#x2F;etc&#x2F;shadow文件</h3><p>&#x2F;etc&#x2F;shadow文件管理着各个用户的密码,** 最好不要擅自修改,可能会造成系统崩溃**,以冒号分隔符,有以下字段</p>\n<ul>\n<li>与&#x2F;etc&#x2F;passwd 文件中的登录名字段对应的登录名</li>\n<li>加密后的密码</li>\n<li>自上次修改密码后过去的天数（自 1970 年 1 月 1 日开始计算）</li>\n<li>多少天后才能更改密码</li>\n<li>多少天后必须更改密码</li>\n<li>密码过期前提前多少天提醒用户更改密码</li>\n<li>密码过期后多少天禁用用户账户</li>\n<li>用户账户被禁用的日期（用自 1970 年 1 月 1 日到当天的天数表示）</li>\n<li>预留字段给将来使用</li>\n</ul>\n<h3 id=\"useradd命令与useradd文件\"><a href=\"#useradd命令与useradd文件\" class=\"headerlink\" title=\"useradd命令与useradd文件\"></a>useradd命令与useradd文件</h3><p><code>useradd</code>命令使用系统的默认配置存在&#x2F;etc&#x2F;default&#x2F;useradd文件中,arch linux默认配置如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># useradd defaults file for ArchLinux</span><br><span class=\"hljs-comment\"># original changes by TomK</span><br>GROUP=<span class=\"hljs-built_in\">users</span><br>HOME=/home<br>INACTIVE=-1<br>EXPIRE=<br>SHELL=/bin/bash<br>SKEL=/etc/skel<br>CREATE_MAIL_SPOOL=no<br></code></pre></td></tr></table></figure>\n\n<p>含义如下:</p>\n<ul>\n<li>新用户会被添加到 users 的公共组；</li>\n<li>新用户的 HOME 目录将会位于&#x2F;home&#x2F;loginname；</li>\n<li>新用户账户密码在过期后不会被禁用；</li>\n<li>新用户账户未被设置过期日期；</li>\n<li>新用户账户将 bash shell 作为默认 shell；</li>\n<li>系统会将&#x2F;etc&#x2F;skel 目录下的内容复制到用户的 HOME 目录下；(一般用于一些bash或vim配置文件等)</li>\n<li>系统不会为该用户账户在 mail 目录下创建一个用于接收邮件的文件。<br>最常用命令<br><code>sudo useradd -m test</code>创建新HOME目录名为test。</li>\n</ul>\n<h3 id=\"userdel\"><a href=\"#userdel\" class=\"headerlink\" title=\"userdel\"></a>userdel</h3><p><code>sudo userdel -r test</code>删除用户test，-r选项表明删除test用户的HOME目录及邮件目录</p>\n<h3 id=\"usermod\"><a href=\"#usermod\" class=\"headerlink\" title=\"usermod\"></a>usermod</h3><p>usermod命令很强大(基本可以替代接下来的修改命令)可以用来修改&#x2F;etc&#x2F;passwd中的大部分字段,常用选项如下:</p>\n<ul>\n<li>-c修改备注字段</li>\n<li>-e修改过期日期</li>\n<li>-g修改默认的登录组</li>\n<li>-l修改用户账户的登录名</li>\n<li>-L锁定账户,使用户无法登录</li>\n<li>-p修改账户的密码</li>\n<li>-U解除锁定,使用户能够登录</li>\n<li><code>sudo usermod -G shared test</code>把test用户添加到组shared <span id = \"usermod\"></span></li>\n</ul>\n<h3 id=\"passwd和chpasswd\"><a href=\"#passwd和chpasswd\" class=\"headerlink\" title=\"passwd和chpasswd\"></a>passwd和chpasswd</h3><ul>\n<li><code>sudo passwd test</code>修改test用户的密码,如果只用passwd只会改变当前用户的密码,-e选项能强制用户下次登录时修改密码。</li>\n<li>chpasswd可以大量修改密码<code>sudo chpasswd &lt; users.txt</code>能从users.txt中自动读取登录名和密码对(由冒号分割)列表</li>\n</ul>\n<h3 id=\"chsh、chfn和chage\"><a href=\"#chsh、chfn和chage\" class=\"headerlink\" title=\"chsh、chfn和chage\"></a>chsh、chfn和chage</h3><ul>\n<li><code>sudo chsh -s /bin/zsh test</code>快速修改默认的用户登录shell。必须全路径</li>\n<li><code>sudo chfn test</code>为用户test添加备注字段,默认会用finger命令的输出作为备注字段,如果没装finger，会询问你。</li>\n<li>chage命令用来帮助管理用户的有效期<ul>\n<li>-d:设置上次修改密码到现在的天数</li>\n<li>-E:设置密码过期的日期</li>\n<li>-l:设置密码过期到锁定账户的天数</li>\n<li>-m:设置修改密码之间最少要多少天</li>\n<li>-W:设置密码过期前多久开始出现提醒信息<br>change命令的日期值可以用下面两种方式</li>\n<li>YYYY-MM-DD</li>\n<li>代表从1970年1月1日起到该日期的天数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"组\"><a href=\"#组\" class=\"headerlink\" title=\"组\"></a>组</h2><h3 id=\"etc-group文件\"><a href=\"#etc-group文件\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;group文件\"></a>&#x2F;etc&#x2F;group文件</h3><p>与&#x2F;etc&#x2F;passwd文件类似,以冒号分割符有以下四个字段:</p>\n<ul>\n<li>组名</li>\n<li>组密码(用的不多,允许非成员通过它成为该组的成员)</li>\n<li>GID</li>\n<li>属于该组的用户列表(<strong>注意:文件中不一定列全了,一定要结合&#x2F;etc&#x2F;passwd来查看</strong>)</li>\n</ul>\n<h3 id=\"groupadd命令\"><a href=\"#groupadd命令\" class=\"headerlink\" title=\"groupadd命令\"></a>groupadd命令</h3><p><code>sudo groupad shared</code>创建新组,默认没有用户<br>见<a href=\"#usermod\">usermod</a>那节,为组添加用户</p>\n<h3 id=\"groupmod\"><a href=\"#groupmod\" class=\"headerlink\" title=\"groupmod\"></a>groupmod</h3><ul>\n<li>-g:修改已有组GID<code>groupmod -g newGid groupName</code></li>\n<li>-n:修改组名<code>groupmod -n newname oldname</code></li>\n</ul>\n<h2 id=\"umask\"><a href=\"#umask\" class=\"headerlink\" title=\"umask\"></a>umask</h2><p><code>umask</code>命令会输出4位数的掩码值,以<strong>0022</strong>为例(第一个0仅代表8进制的意思):</p>\n<ul>\n<li>二进制: 000 010 010</li>\n<li>取消新文件和新目录的组w权限和其他用户w权限<br>对照表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Oct</th>\n<th align=\"center\">Bin</th>\n<th align=\"center\">File Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">000</td>\n<td align=\"center\">—</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">001</td>\n<td align=\"center\">–x</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">010</td>\n<td align=\"center\">-w-</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">011</td>\n<td align=\"center\">-wx</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">100</td>\n<td align=\"center\">r–</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">101</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">110</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">111</td>\n<td align=\"center\">rwx</td>\n</tr>\n</tbody></table>\n<p>问题是touch默认的权限是644(即rw-r–r–),怎么来的呢？首先文件有个全权限为666,目录的全权限为777,666把umask值的1位减去即是644</p>\n<h2 id=\"文件的属性\"><a href=\"#文件的属性\" class=\"headerlink\" title=\"文件的属性\"></a>文件的属性</h2><p>文件除了权限外,还有属性设置,也很有用</p>\n<ul>\n<li>chattr:为文件添加或删除属性<code>sudo chattr +i testfile</code>,<code>sudo chattr -i testfile</code></li>\n<li>lsattr:查看文件的属性<code>sudo lsattr testfile</code></li>\n</ul>\n<p>可通过<code>man chattr</code>来查看可以设置哪些属性,下表列出常用属性</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字母</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">i</td>\n<td align=\"center\">文件不能被删除、改名、设置链接、也无法写入或新增数据</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"center\">只能增加数据,而不能删除也不能修改数据</td>\n</tr>\n</tbody></table>\n<h2 id=\"chmod\"><a href=\"#chmod\" class=\"headerlink\" title=\"chmod\"></a>chmod</h2><p>chmod [ugoa][+&#x3D;-][rwxst] 文件名表<br>也可以用八进制数字设置:<code>chmod xxx file</code>,对应关系见上表</p>\n<h3 id=\"三个特殊权限\"><a href=\"#三个特殊权限\" class=\"headerlink\" title=\"三个特殊权限:\"></a>三个特殊权限:</h3><ul>\n<li>setuid(SUID)–仅作用于可执行文件,<code>chmod u+s program</code> 当应用到一个可执行文件(s标志会出现在拥有者的x权限上)，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。<br>b.setgid(SGID)–作用于可执行文件和目录(s标志会出现在组的x权限上) ,<code>chmod g+s dir</code> 把有效用户组 ID 从真正的用户组ID更改为文件所有者的组ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。<br>c.sticky位(SBIT)–仅作用于目录(t标志会出现在其他的x权限上)<code>chmod o+t dir</code>,如果一个目录设置了sticky位，那么它能阻止用户删除或重命名文件,除非用户是这个目录的所有者,或者是文件所有者,或是超级用户。这个经常用来控制访问共享目录,比方说&#x2F;tmp。<br>这3种权限也可以用另一套八进制来表示<code>chmod xxxx file</code>第一个数字是设置特殊权限的,这与umask的第一位<strong>含义不同</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Oct</th>\n<th align=\"center\">Bin</th>\n<th align=\"center\">File Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">000</td>\n<td align=\"center\">所有特殊位为0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">001</td>\n<td align=\"center\">sticky置位</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">010</td>\n<td align=\"center\">SGID置位</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">011</td>\n<td align=\"center\">SGID和sticky置位</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">100</td>\n<td align=\"center\">SUID置位</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">101</td>\n<td align=\"center\">SUID和sticky置位</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">110</td>\n<td align=\"center\">SUID和SGID置位</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">111</td>\n<td align=\"center\">所有位都置位</td>\n</tr>\n</tbody></table>\n<h3 id=\"可执行权限上的’S-T’-还有X有待研究\"><a href=\"#可执行权限上的’S-T’-还有X有待研究\" class=\"headerlink\" title=\"可执行权限上的’S&#x2F;T’(还有X有待研究)\"></a>可执行权限上的’S&#x2F;T’(还有X有待研究)</h3><p>没有执行权限的 UID&#x2F;GID 和黏置位。小写的 s 与 t 都是取代 x 这个权限的，但是当下达 7666 权限时，也就是说,user,group 以及 others 都没有 x 这个可执行的标志时(因为是 666)，特殊权限位也不可能有权限执行，7666 的结果为-rwSrwSrwT。所以，这个 S, T 代表的就是“空的”执行权限，不具有执行权限。换个说法， SUID +s 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件拥有者都无法执行时，也就不存在权限给其他人使用了。</p>\n<h2 id=\"chown和chgrp\"><a href=\"#chown和chgrp\" class=\"headerlink\" title=\"chown和chgrp\"></a>chown和chgrp</h2><p>这两个命令除了root外,只有修改用户处于原用户组和新用户组才能修改</p>\n<ul>\n<li><code>chown username.groupname filename</code>改变文件的用户和用户组,用户组名可选,当省略username,并在groupname前面加个<code>.</code>,则只改变用户组名,当省略groupname,在username后面加个<code>.</code>,则改变用户并把用户组改成与用户名同名的用户组<ul>\n<li>-R:递归目录</li>\n<li>-h:该文件的所有链接文件也被改变所属关系</li>\n</ul>\n</li>\n<li><code>chgrp groupname filename</code>更改用户组</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h2><h3 id=\"etc-passwd文件\"><a href=\"#etc-passwd文件\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;passwd文件\"></a>&#x2F;etc&#x2F;passwd文件</h3><p>&#x2F;etc&#x2F;passwd包含了一些与用户有关的信息 以’:’分割符依次为以下内容</p>\n<ul>\n<li>登陆用户名</li>\n<li>用户账户的UID(数字形式)</li>\n<li>用户账户的组ID(GID)(数字形式)</li>\n<li>用户账户的文本描述(备注字段)</li>\n<li>用户HOME目录位置</li>\n<li>用户默认shell<br>root的UID为0,1000以下的UID为系统服务账户预留,普通用户为1000以后</li>\n</ul>\n<h3 id=\"etc-shadow文件\"><a href=\"#etc-shadow文件\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;shadow文件\"></a>&#x2F;etc&#x2F;shadow文件</h3><p>&#x2F;etc&#x2F;shadow文件管理着各个用户的密码,** 最好不要擅自修改,可能会造成系统崩溃**,以冒号分隔符,有以下字段</p>\n<ul>\n<li>与&#x2F;etc&#x2F;passwd 文件中的登录名字段对应的登录名</li>\n<li>加密后的密码</li>\n<li>自上次修改密码后过去的天数（自 1970 年 1 月 1 日开始计算）</li>\n<li>多少天后才能更改密码</li>\n<li>多少天后必须更改密码</li>\n<li>密码过期前提前多少天提醒用户更改密码</li>\n<li>密码过期后多少天禁用用户账户</li>\n<li>用户账户被禁用的日期（用自 1970 年 1 月 1 日到当天的天数表示）</li>\n<li>预留字段给将来使用</li>\n</ul>\n<h3 id=\"useradd命令与useradd文件\"><a href=\"#useradd命令与useradd文件\" class=\"headerlink\" title=\"useradd命令与useradd文件\"></a>useradd命令与useradd文件</h3><p><code>useradd</code>命令使用系统的默认配置存在&#x2F;etc&#x2F;default&#x2F;useradd文件中,arch linux默认配置如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># useradd defaults file for ArchLinux</span><br><span class=\"hljs-comment\"># original changes by TomK</span><br>GROUP=<span class=\"hljs-built_in\">users</span><br>HOME=/home<br>INACTIVE=-1<br>EXPIRE=<br>SHELL=/bin/bash<br>SKEL=/etc/skel<br>CREATE_MAIL_SPOOL=no<br></code></pre></td></tr></table></figure>\n\n<p>含义如下:</p>\n<ul>\n<li>新用户会被添加到 users 的公共组；</li>\n<li>新用户的 HOME 目录将会位于&#x2F;home&#x2F;loginname；</li>\n<li>新用户账户密码在过期后不会被禁用；</li>\n<li>新用户账户未被设置过期日期；</li>\n<li>新用户账户将 bash shell 作为默认 shell；</li>\n<li>系统会将&#x2F;etc&#x2F;skel 目录下的内容复制到用户的 HOME 目录下；(一般用于一些bash或vim配置文件等)</li>\n<li>系统不会为该用户账户在 mail 目录下创建一个用于接收邮件的文件。<br>最常用命令<br><code>sudo useradd -m test</code>创建新HOME目录名为test。</li>\n</ul>\n<h3 id=\"userdel\"><a href=\"#userdel\" class=\"headerlink\" title=\"userdel\"></a>userdel</h3><p><code>sudo userdel -r test</code>删除用户test，-r选项表明删除test用户的HOME目录及邮件目录</p>\n<h3 id=\"usermod\"><a href=\"#usermod\" class=\"headerlink\" title=\"usermod\"></a>usermod</h3><p>usermod命令很强大(基本可以替代接下来的修改命令)可以用来修改&#x2F;etc&#x2F;passwd中的大部分字段,常用选项如下:</p>\n<ul>\n<li>-c修改备注字段</li>\n<li>-e修改过期日期</li>\n<li>-g修改默认的登录组</li>\n<li>-l修改用户账户的登录名</li>\n<li>-L锁定账户,使用户无法登录</li>\n<li>-p修改账户的密码</li>\n<li>-U解除锁定,使用户能够登录</li>\n<li><code>sudo usermod -G shared test</code>把test用户添加到组shared <span id = \"usermod\"></span></li>\n</ul>\n<h3 id=\"passwd和chpasswd\"><a href=\"#passwd和chpasswd\" class=\"headerlink\" title=\"passwd和chpasswd\"></a>passwd和chpasswd</h3><ul>\n<li><code>sudo passwd test</code>修改test用户的密码,如果只用passwd只会改变当前用户的密码,-e选项能强制用户下次登录时修改密码。</li>\n<li>chpasswd可以大量修改密码<code>sudo chpasswd &lt; users.txt</code>能从users.txt中自动读取登录名和密码对(由冒号分割)列表</li>\n</ul>\n<h3 id=\"chsh、chfn和chage\"><a href=\"#chsh、chfn和chage\" class=\"headerlink\" title=\"chsh、chfn和chage\"></a>chsh、chfn和chage</h3><ul>\n<li><code>sudo chsh -s /bin/zsh test</code>快速修改默认的用户登录shell。必须全路径</li>\n<li><code>sudo chfn test</code>为用户test添加备注字段,默认会用finger命令的输出作为备注字段,如果没装finger，会询问你。</li>\n<li>chage命令用来帮助管理用户的有效期<ul>\n<li>-d:设置上次修改密码到现在的天数</li>\n<li>-E:设置密码过期的日期</li>\n<li>-l:设置密码过期到锁定账户的天数</li>\n<li>-m:设置修改密码之间最少要多少天</li>\n<li>-W:设置密码过期前多久开始出现提醒信息<br>change命令的日期值可以用下面两种方式</li>\n<li>YYYY-MM-DD</li>\n<li>代表从1970年1月1日起到该日期的天数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"组\"><a href=\"#组\" class=\"headerlink\" title=\"组\"></a>组</h2><h3 id=\"etc-group文件\"><a href=\"#etc-group文件\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;group文件\"></a>&#x2F;etc&#x2F;group文件</h3><p>与&#x2F;etc&#x2F;passwd文件类似,以冒号分割符有以下四个字段:</p>\n<ul>\n<li>组名</li>\n<li>组密码(用的不多,允许非成员通过它成为该组的成员)</li>\n<li>GID</li>\n<li>属于该组的用户列表(<strong>注意:文件中不一定列全了,一定要结合&#x2F;etc&#x2F;passwd来查看</strong>)</li>\n</ul>\n<h3 id=\"groupadd命令\"><a href=\"#groupadd命令\" class=\"headerlink\" title=\"groupadd命令\"></a>groupadd命令</h3><p><code>sudo groupad shared</code>创建新组,默认没有用户<br>见<a href=\"#usermod\">usermod</a>那节,为组添加用户</p>\n<h3 id=\"groupmod\"><a href=\"#groupmod\" class=\"headerlink\" title=\"groupmod\"></a>groupmod</h3><ul>\n<li>-g:修改已有组GID<code>groupmod -g newGid groupName</code></li>\n<li>-n:修改组名<code>groupmod -n newname oldname</code></li>\n</ul>\n<h2 id=\"umask\"><a href=\"#umask\" class=\"headerlink\" title=\"umask\"></a>umask</h2><p><code>umask</code>命令会输出4位数的掩码值,以<strong>0022</strong>为例(第一个0仅代表8进制的意思):</p>\n<ul>\n<li>二进制: 000 010 010</li>\n<li>取消新文件和新目录的组w权限和其他用户w权限<br>对照表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Oct</th>\n<th align=\"center\">Bin</th>\n<th align=\"center\">File Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">000</td>\n<td align=\"center\">—</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">001</td>\n<td align=\"center\">–x</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">010</td>\n<td align=\"center\">-w-</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">011</td>\n<td align=\"center\">-wx</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">100</td>\n<td align=\"center\">r–</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">101</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">110</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">111</td>\n<td align=\"center\">rwx</td>\n</tr>\n</tbody></table>\n<p>问题是touch默认的权限是644(即rw-r–r–),怎么来的呢？首先文件有个全权限为666,目录的全权限为777,666把umask值的1位减去即是644</p>\n<h2 id=\"文件的属性\"><a href=\"#文件的属性\" class=\"headerlink\" title=\"文件的属性\"></a>文件的属性</h2><p>文件除了权限外,还有属性设置,也很有用</p>\n<ul>\n<li>chattr:为文件添加或删除属性<code>sudo chattr +i testfile</code>,<code>sudo chattr -i testfile</code></li>\n<li>lsattr:查看文件的属性<code>sudo lsattr testfile</code></li>\n</ul>\n<p>可通过<code>man chattr</code>来查看可以设置哪些属性,下表列出常用属性</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字母</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">i</td>\n<td align=\"center\">文件不能被删除、改名、设置链接、也无法写入或新增数据</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"center\">只能增加数据,而不能删除也不能修改数据</td>\n</tr>\n</tbody></table>\n<h2 id=\"chmod\"><a href=\"#chmod\" class=\"headerlink\" title=\"chmod\"></a>chmod</h2><p>chmod [ugoa][+&#x3D;-][rwxst] 文件名表<br>也可以用八进制数字设置:<code>chmod xxx file</code>,对应关系见上表</p>\n<h3 id=\"三个特殊权限\"><a href=\"#三个特殊权限\" class=\"headerlink\" title=\"三个特殊权限:\"></a>三个特殊权限:</h3><ul>\n<li>setuid(SUID)–仅作用于可执行文件,<code>chmod u+s program</code> 当应用到一个可执行文件(s标志会出现在拥有者的x权限上)，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。<br>b.setgid(SGID)–作用于可执行文件和目录(s标志会出现在组的x权限上) ,<code>chmod g+s dir</code> 把有效用户组 ID 从真正的用户组ID更改为文件所有者的组ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。<br>c.sticky位(SBIT)–仅作用于目录(t标志会出现在其他的x权限上)<code>chmod o+t dir</code>,如果一个目录设置了sticky位，那么它能阻止用户删除或重命名文件,除非用户是这个目录的所有者,或者是文件所有者,或是超级用户。这个经常用来控制访问共享目录,比方说&#x2F;tmp。<br>这3种权限也可以用另一套八进制来表示<code>chmod xxxx file</code>第一个数字是设置特殊权限的,这与umask的第一位<strong>含义不同</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Oct</th>\n<th align=\"center\">Bin</th>\n<th align=\"center\">File Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">000</td>\n<td align=\"center\">所有特殊位为0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">001</td>\n<td align=\"center\">sticky置位</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">010</td>\n<td align=\"center\">SGID置位</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">011</td>\n<td align=\"center\">SGID和sticky置位</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">100</td>\n<td align=\"center\">SUID置位</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">101</td>\n<td align=\"center\">SUID和sticky置位</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">110</td>\n<td align=\"center\">SUID和SGID置位</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">111</td>\n<td align=\"center\">所有位都置位</td>\n</tr>\n</tbody></table>\n<h3 id=\"可执行权限上的’S-T’-还有X有待研究\"><a href=\"#可执行权限上的’S-T’-还有X有待研究\" class=\"headerlink\" title=\"可执行权限上的’S&#x2F;T’(还有X有待研究)\"></a>可执行权限上的’S&#x2F;T’(还有X有待研究)</h3><p>没有执行权限的 UID&#x2F;GID 和黏置位。小写的 s 与 t 都是取代 x 这个权限的，但是当下达 7666 权限时，也就是说,user,group 以及 others 都没有 x 这个可执行的标志时(因为是 666)，特殊权限位也不可能有权限执行，7666 的结果为-rwSrwSrwT。所以，这个 S, T 代表的就是“空的”执行权限，不具有执行权限。换个说法， SUID +s 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件拥有者都无法执行时，也就不存在权限给其他人使用了。</p>\n<h2 id=\"chown和chgrp\"><a href=\"#chown和chgrp\" class=\"headerlink\" title=\"chown和chgrp\"></a>chown和chgrp</h2><p>这两个命令除了root外,只有修改用户处于原用户组和新用户组才能修改</p>\n<ul>\n<li><code>chown username.groupname filename</code>改变文件的用户和用户组,用户组名可选,当省略username,并在groupname前面加个<code>.</code>,则只改变用户组名,当省略groupname,在username后面加个<code>.</code>,则改变用户并把用户组改成与用户名同名的用户组<ul>\n<li>-R:递归目录</li>\n<li>-h:该文件的所有链接文件也被改变所属关系</li>\n</ul>\n</li>\n<li><code>chgrp groupname filename</code>更改用户组</li>\n</ul>\n"},{"title":"Make","date":"2020-01-17T04:45:15.000Z","subtitle":null,"index_img":"/images/makeFile.png","banner_img":"/images/makeFile.png","_content":"\n### 引用其它的Makefile\n`include <filename>`\nmake会在当前目录寻找,接着在以下目录下找:\n* 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。\n* 如果目录 <prefix>/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。\n### 变量相关  \n变量在声明时需要给予初值，而在使用时，需要给在变量名前加上`$`符号，但最好用小括号`()`或是大括号`{}`把变量给包括起来。如果你要使用真实的`$`字符，那么你需要用`$$`来表示\n\n#### 赋值操作\n* `:=`操作符,操作符右边只能出现已定义的变量,如果是未定义的变量,则会自动忽略,用来避免递归展开 \n* `=`操作符右边可以出现未定义的变量\n*  `?=`如果变量没有定义过,则使用后面的值\n* `+=`追加变量值\n\n#### 内置变量\n\n|变量类型|特殊变量|含义|用例或说明|\n|:-:|:-:|:-:|:-:|\n|特殊变量|`VPATH`|寻找依赖或目标的路径,以冒号为分隔符,当前目录永远最优先|`VPATH = src:../headers`|\n|特殊变量|`SUFFIXE`|定义默认的后缀列表,最好不要直接改变，通过`.SUFFIXE`|| |特殊变量|.DIRSEPSTR|路径分隔符一般是斜杠||\n|特殊变量|.MAKEDIR|调用make的绝对路径名||\n|特殊变量|.NULL|空字符串||\n|特殊变量|.OS|正在运行的操作系统名称||\n|特殊变量|.PWD|运行时活动工作目录的绝对路径名||\n|特殊变量|.SHELL|启动的shell类型||\n|命令变量|`AR`|函数库打包程序,默认命令是ar||\n|命令变量|`AS`|汇编语言编译程序,默认命令是as||\n|命令变量|`CC`|C语言编译程序,默认命令是cc||\n|命令变量|`CXX`|C++语言编译程序,默认命令是g++||\n|命令变量|`CPP`|C程序的预处理器,默认命令是$(CC) -E||\n|命令变量|`RM`|删除文件命令,默认命令是rm -f||\n|参数变量|`ARFLAGS`|函数库打包程序AR命令参数,默认值是rv||\n|参数变量|`ASFLAGS`|汇编语言编译器参数,默认值是空||\n|参数变量|`CFLAGS`|C语言编译器参数,默认为空||\n|参数变量|`CPPFLAGS`|C预处理器参数,默认为空||\n|参数变量|`CXXFLAGS`|C++语言编译器参数,默认为空||\n|参数变量|`LDFLAGS`|ld链接器参数,默认为空||\n|系统变量|`MAKELEVEL`|当前Makefile的调用层数,从0开始||\n|系统变量|`MAKECMDGOALS`|存放那个你命令行中所指定的终极目标的列表,没有指定则为空||\n|自动变量|`$@`|目标集|它代表一个量,遍历目标集,一般与依赖集相匹配|\n|自动变量|`$%`|目标集|仅当目标是函数库文件时,表示规则中的目标成员名,foo.a(bar.o),$%就是bar.o,$@就是foo.a|\n|自动变量|`$<`|依赖集|它代表一个量,遍历目标集,一般用于目标集相匹配|\n|自动变量|`$?`|依赖集|所有比目标新的依赖目标的集合,以空格分隔|\n|自动变量|`$^`|依赖集|所有依赖目标的集合,去掉重复以空格分隔|\n|自动变量|`$+`|依赖集|所有依赖目标的集合,不去掉重复以空格分隔|\n|自动变量|`$*`||对应模式的'%'及之前的部分,包括路径|\n\n**所有自动变量都可以与`D`,`F`搭配使用,表示匹配的目录部分和文件部分,如`$(@D)`**\n#### 高级用法\n* 替换`.o`到`.c`\n**方法一:**\n```bash\nfoo:=a.o b.o c.o\nbar:=$(foo:.o=.c)\n```\n**方法二:**\n```bash\n#静态模式\nfoo:=a.o b.o c.o\nbar:=$(foo:%.o=%.c)\n```\n* 强制覆盖 \n\n`override <variable>=<value>`make命令行参数可以用这个强制覆盖,否则覆盖不了\n* 替换变量中字符串\n`变量名: s/原字符串/新字符串`\n* 加前后缀\n`变量:^ \"前缀\"`\n`变量:+ \"后缀\"`\n* 取部分\n`$(VARIABLE:<option>)`,option有3个选项d(仅取路径)、b(文件名,不包括扩展)、f(文件名,包括扩展)\n### 关键字vpath\n* 用法一:`vpath <pattern> <directories>`符合模式的在指定文件夹搜索\n* 用法二:`vpath <pattern>`清除对应模式搜索目录\n* 用法三:`vpath`清除所有搜索目录\n***注意:<pattern>都必须包含%,意思是包含一个以上的匹配字符***\n### 局部作用的变量\n```bash\nprog: CFLAGS = -g\n\tprog: prog.o foo.o bar.o\n\t\t$(gcc) $(CFLAGS) prog.o foo.o bar.o\n\tprog.o: prog.c\n\t\t$(gcc) $(CFLAGS) prog.c\n\tfoo.o: foo.c\n\t\t$(gcc) $(CFLAGS) bar.c\n```\n不管全局的`$(CFLAGS)`的值是什么,prog目标及其所引发的所有规则中(prog.o foo.o bar.o),$(CFLAGS)的值都是-gl\n### 伪目标\n用`.PHONY`指明伪目标\n- 伪目标并不是文件，只是个标签,最终不产生文件\n- 只有显式地指名才能使其生效\n- 最终目标可以是伪目标,一个用法如下,使一个make文件生成多个目标:\n```bash\nall: prog1 prog2 prog3\n.PHONY: all\nprog1: prog1.o utils.o\n\tgcc -o prog1 prog1.o utils.o\nprog2: prog2.o\n\tgcc -o prog2 prog2.o\nprog3: prog3.o sort.o utils.o\n\tgcc -o prog3 prog3.o sort.o utils.o\n```\n### 静态模式:更方便定义多目标\n`<targets>: <target-pattern>: <prereq-patterns>`\n例子:\n```bash\nobjects = foo.o bar.o\nall: $(objects)\n$(objects): %.o: %.c\n\t$(gcc) -c $(CFLAGS) $< -o $@\n```\n等价于\n```bash\nfoo.o: foo.c\n\t$(gcc) -c $(CFLAGS) foo.c -o foo.o\nbar.o: bar.c\n\t$(gcc) -c $(CFLAGS) bar.c -o bar.o\n```\n### gcc -MM选项\n该选项可以为.c源文件自动生成依赖的非标准库的头文件,按习惯称为.d文件\n可以用以下模式规则来产生.d文件\n```bash\n%.d: %.c\n    @set -e; rm -f $@; \\\n    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \\\n    sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' < $@.$$$$ > $@; \\\n    rm -f $@.$$$$\n```\n然后用include\n```bash\nsources = foo.c bar.c\ninclude $(sources:.c=.d)\n```\n### `@`关键字\nmake默认会显示命令,在命令前加@可以阻止输出,例如\n`@echo 正在编译XXX模块`\n### `-`关键字\n在命令前加`-`会忽略该命令产生的错误\n### 嵌套make  \n```bash\nsubsystem:\n\tcd subdir && $(MAKE) #也可以这么写$(MAKE) -C subdir\n```\n　要想传递变量给嵌套的make,使用export,不想传递使用unexport\n　其中`SHELL`和`MAKEFLAGS`总会影响下层make,但-C、-f、-h、-o、-W几个参数并不往下传递\n### 定义命令包(即命令集)\n其实这是多行变量\n例子:\n```bash\ndefine run-yacc\nmkdir dir\nmv dir newdir\nendef\ncrap: \n\t$(run-yacc)\n```\n### 条件判断\nmake是在读取Makefile时就计算条件表达式的值,而不是运行,所以不要用自动变量\n```bash\nxx: xc\n<conditional-directive> #可以是ifeq(arg1,arg2)、ifneq、ifdef <variable-name>(不加美元符号)、ifndef\n\t<text-if-true>\nelse\n\t<text-if-false>\nendif\n```\n### 函数\n#### 调用语法\n`$(<function> <arguments>)`,参数间用','分隔\n#### 字符串函数\n\n|函数|功能|返回|\n|:-:|:-:|:-:|\n|`$(subst <from>,<to>,<text>)`|把字符串<text>中的<from>换成<to>|`被替换过的字符串`|\n|`$(patsubst <pattern>,<replacement>,<text>)`|查找<text>中的单词(以空格、Tab、回车、换行)符合<pattern>,替换<replacement>|被替换后的字符串|\n|`$(strip <string>)`|去掉<string>中开头和结尾的空字符|去掉空字符的字符串|\n|`$(findstring <find>,<in>)`|在字符串<in>中查找<find>|如果找到,返回<find>,否则返回空字符串|\n|`$(filter <pattern...>,<text>)`|以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割|返回符合<pattern>的字符串|\n|`$(filter-out <pattern...>,<text>)`|以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割|返回不符合<pattern>的字符串|\n|`$(sort <list>)`|给字符串<list>中的单词升序|返回排序后的字符串(会去掉相同的单词)|\n|`$(word <n>,<text>)`|取字符串<text>中的第<n>个单词|返回该单词,如果n过大,则返回空字符串|\n|`$(wordlist <n>,<m>,<text>)`|取第<n>-第<m>个单词|返回那些单词|\n|`$(words <text>)`|统计<text>中的单词数|返回个数|\n|`$(firstword <text>)`|返回字符串<text>中第一个单词|返回第一个单词|\n\n#### 文件名函数\n\n|格式|例子|返回值|\n|:-:|:-:|:-:|\n|`$(dir <names...>)`|`$(dir src/foo.c hacks)`|`src/ ./`|\n|`$(notdir <names...>)`|`$(notdir src/foo.c hacks)`|`foo.c hacks`|\n|`$(suffix <names...>)`|`$(suffix src/foo.c src-1.0/bar.c hacks)`|`.c .c`|\n|`$(basename <names...>)`|`$(basename src/foo.c src-1.0/bar.c hacks)`|`src/foo src-1.0/bar hacks`|\n|`$(addsuffix <suffix>,<names...>)`|`$(addsuffix .c,foo bar)`|`foo.c bar.c`|\n|`$(addprefix <prefix>,<names...>)`|`$(addprefix src/,foo bar)`|`src/foo src/bar`|\n|`$(join <list1>,<list2>)`|`$(join aaa bbb,111 222 333)`|`aaa111 bbb222`|\n\n#### foreach函数\n格式:`$(foreach <var>,<list>,<text>)`\n```bash\nnames:= a b c d\nfiles:= $(foreach n,$(names),$(n).o)\n#$(files)的值是‘a.o b.o c.o d.o’\n```\n#### if函数\n`$(if <condition>,<then-part>,<else-part>)`,<condition>若返回为非空,则执行<then-part>,其是整个函数的返回值\n#### call函数\n`$(call <expression>,<parm1>,<parm2>,<parm3>...)`;<expression>中`$(1)`,`$(2)`等,会被参数`<parm1>`、`<parm2>`等代替\n```bash\nreverse=$(2) $(1)\nfoo=$(call reverse,a,b)\n```\n此时foo的值就是'b a'\n#### shell函数\n`files:=$(shell echo *.c)`\n#### origin函数\n`$(origin <variable>)`:告知变量来源情况\n\n|返回值|含义|\n|:-:|:-:|\n|undefined|未定义|\n|default|默认定义|\n|environment|环境变量|\n|file|定义在make文件中|\n|override|被override重新定义|\n|automatic|命令运行中的自动化变量|\n|command line|命令行定义|\n\n#### error函数和warning函数\n`$(error <text ...>)`\n`$(warning <text ...>)`\nerror函数产生一个致命的错误,<text ...>是错误信息\nwarning函数只是输出警告信息,make会继续执行\n\n例1：\n```bash\nifdef ERROR_001\n\t#运行到下面的会出错跳出脚本\n    $(error error is $(ERROR_001))\nendif\n```\n例2：\n```bash\n#这里并不会出错跳出脚本\nERR = $(error found an error!)\n\n.PHONY: err\n#这里才会跳出\nerr: $(ERR)\n```\n\n### make的退出码\n* 0:表示成功执行\n* 1:表示出错\n* 2:如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。\n\n### 一些常用伪目标命名\n\n|名称|含义|\n|:-:|:-:|\n|all|这个伪目标一般是所有目标的目标,一般为编译所有的目标|\n|clean|这个伪目标的功能一般是删除所有make创建的文件|\n|install|安装已编译好的程序,其实是把目标执行文件复制到指定文件夹|\n|print|这个伪目标的功能是列出改变过的源文件|\n|tar|这个伪目标的功能是打包备份源程序|\n|dist|一般是把打包文件进行压缩|\n|tags|这个伪目标的功能用于更新所有的目标,以备完整地重新编译|\n|check、test|一般用来测试makefile文件流程|\n\n### make选项参数\n\n|短选项|长选项|含义|\n|:-:|:-:|:-:|\n|-b,-m||忽略其他版本make兼容性|\n|-B|--always-make|认为所有目标都更新(重编译)|\n|-C <dir>|--directory=<dir>|指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog”|\n|-d||相当于`-debug=a`|\n|-e|--environment-overrides|指定环境变量值,覆盖makefile文件中定义的变量值|\n|-f|--file、--makefile|指定某个makefile文件|\n|-i|--ignore-errors|在执行时忽略所有的错误|\n|-I <dir>|--include-dir=<dir>|指定一个包含makefile文件的搜索目标|\n|-j <jobsnum>|--jobs=<jobsnum>|指同时运行的命令数,如果没有这个参数,能运行多少就多少,只有最后一个-j选项有效|\n|-k|--keep-going|出错也不停止,执行其它目标,失败的目标,依赖于其上的就不会执行|\n|-l <load>|--load-average [=<load>];--max-load[=<load>]|指定make运行命令的负载|\n|-n|--just-print、--dry-run、--recon|不管目标更不更新,只打印命令,不执行|\n|-o <file>|--old-file=<file>;--assume-old=<file>|不生成指定的<file>,即使这个目标的依赖文件比他新|\n|-p|--print-database|输出makefile文件中所有数据,包括所有的规则和变量|\n|-q|--question|寻找目标,如果目标存在,什么也不输出,也不执行编译,返回0.如果目标不存在,打印一条出错信息,返回2|\n|-r|--no-builtin-rules|禁止使用任何隐式规则，会使得SUFFIXE变量为空|\n|-R|--no-builtin-variables|禁止使用任作用于变量上的何隐式规则|\n|-s|--silent;--quiet|命令运行时不显示命令的输出|\n|-S|--no-keep-going;--stop|取消-k选项的作用|\n|-t|--touch|把目标文件时间更新,但不更改目标文件,假装编译文件|\n|-w|--print-directory|输出运行makefile文件之前之后的信息,跟踪嵌套make时很有用|\n|-W <file>|--what-if=<file>;--assume-new=<file>;--new-file=<file>|假定目标<file>;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>;的修改时间为当前时间。|\n||--no-print-directory|禁止-w选项|\n||--warn-undefined-variables|警告未定义的变量|\n\n#### --debug \\<options\\>\noptions可以是以下:\n* 也就是all,输出所有的调试信息\n* 也就是basic,只输出简单的调试信息,即输出不需要重新编译的目标\n* 也就是verbose,输出的信息包括哪一个makefile文件被解析,不需要重新编译的依赖文件(或是依赖目标)\n* 也就是implicit,输出所有的隐含规则\n* 也就是jobs,输出执行规则中命令的详细信息,如PID、返回码等\n* 也就是makefile文件,输出make,读取makefile,更新makefile文件,并执行makefile文件的信息\n#### 常用组合\n- `make -qp`只输出信息而不执行\n- `make -p -f /dev/null`查看makefile前的预设变量和规则\n### 模式的匹配\n一般来说，一个目标的模式有一个有前缀或是后缀的%，或是没有前后缀，直接就是一个%。因为%代表一个或多个字符，所以在定义好了的模式中，我们把%所匹配的内容叫做“茎”，例如%.c所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有%时，依赖目标的“茎”会传给目标，当做目标中的“茎”。\n\n当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式e%t，文件src/eat匹配于该模式，于是src/a就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式c%r，那么，目标就是src/car。（“茎”被传递）\n### 一些\"老东西\"--后缀规则\n- `.c.o:`等价于`%.o : %.c`\n- `.c:`等价于`% : %.c`\n以上称为后缀规则，要想这么用，必须为默认后缀，你可以用以下来添加默认后缀\n```bash\n.SUFFIXES:              # 删除默认的后缀\n.SUFFIXES: .a .b .c c # 定义自己的后缀\n```\n### 隐含规则  \n#### 各个规则\n- C程序隐含规则:<n>.o的目标的依赖目标会是:<n>.c,命令是`$(CC) -c $(CPPFLAGS)$(CFLAGS)`\n- C++程序隐含规则:<n>.o的目标的依赖目标是:<n>.cc或<n>.C,命令是`$(CXX) -c  $(CPPFLAGS)$(CXXFLAGS)`\n- 汇编和预处理隐含规则:<n>.o的目标的依赖目标会自动推导为<n>.s，默认使用编译器as，并且其生成命令是：`$ (AS) $(ASFLAGS)`。<n>.s的目标的依赖目标会自动推导为<n>.S，默认使用C预编译器cpp，并且其生成命令是：`$(AS) $(ASFLAGS)`。\n- 链接Object文件的隐含规则:<n>目标依赖于<n>.o，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是：`$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)`。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:\n```bash\nx : y.o z.o\n```\n隐含规则执行如下(x.c、y.c、z.c都存在):\n```bash\ncc -c x.c -o x.o\ncc -c y.c -o y.o\ncc -c z.c -o z.o\ncc x.o y.o z.o -o x\nrm -f x.o\nrm -f y.o\nrm -f z.o\n```\n#### 一些tip\n- 隐式规则产生的中间目标，最终会被自动删除，被makefile指定成的目标或依赖目标不能被当作中介，但是可以通过`.INTERMEDIATE`来强制声明为中间目标。如`.intermediate: mid`\n- 也可以阻止自动删除中间目标，通过`.SECONDARY`来强制声明。如`.SECONDARY`。或以模式的方式指定(如：%.o)成为伪目标`.PRECIOUS`的依赖目标。\n- Make会优化一些特殊的隐含规则，而不生成中间文件。从文件.c直接生成执行文件，不产生目标文件\n#### 模式规则来定义一个隐含规则\n模式规则，目标的定义需要有`%`字符。依赖目标随便，与变量不同的是，模式规则的展开发生在运行期间。\n示例：\n```bash\n%.o: %.c\n $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@\n```\n#### 隐含规则搜索算法\n比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是archive(member)的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把member当作T来搜索。\n\n1) 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是src/foo.o，那么，D就是src/，N就是foo.o）\n2) 创建所有匹配于T或是N的模式规则列表。\n3) 如果在模式规则列表中有匹配所有文件的模式，如%，那么从列表中移除其它的模式。\n4) 移除列表中没有命令的规则。\n5) 对于第一个在列表中的模式规则：\n  *  推导其“茎”S，S应该是T或是N匹配于模式中%非空的部分。\n  *  计算依赖文件。把依赖文件中的%都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。\n  * 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）\n  * 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。\n6) 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：\n  * 如果规则是终止规则，那就忽略它，继续下一条模式规则。\n  * 计算依赖文件。（同第5步）\n  * 测试所有的依赖文件是否存在或是理当存在。\n  * 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。\n  * 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。\n  * 如果没有隐含规则可以使用，查看.DEFAULT规则，如果有，采用，把.DEFAULT的命令给T使用。\n### 函数库打包\n函数库文件也就是对.o文件的打包文件\n示例:\n```bash\nfoolib(hack.o xx.o): hack.o xx.o\n\tar cr foolib hack.o xx.o #foolib是库名,hack.o是包含文件\n```\n\n### Tips\n* make中遇到的第一条规则是最终目标  \n* 和bash一样用空格和\"\\\"进行换行\n* 命令总是以tab键开头,其余不是命令\n* `MAKEFILES`最好不用该环境变量,该变量类似于include动作,但其中文件中的目标不会起作用,最好置为空,以免引入未考虑到的东西,莫名奇妙出现问题时,可以查看该变量\n* 要想前面命令作用于后面命令,需要写在同一行上,用分号分隔,如下:\n```bash\nexec:\n\tcd /home/nanbert;pwd\n```\n* 可以在命令前加`-`,来忽略该命令可能执行失败,这也可用于include\n","source":"_posts/Make.md","raw":"---\ntitle: Make\ndate: 2020-01-17 12:45:15\nsubtitle:\ncategories:\ntags:\nindex_img: /images/makeFile.png\nbanner_img: /images/makeFile.png\n---\n\n### 引用其它的Makefile\n`include <filename>`\nmake会在当前目录寻找,接着在以下目录下找:\n* 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。\n* 如果目录 <prefix>/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。\n### 变量相关  \n变量在声明时需要给予初值，而在使用时，需要给在变量名前加上`$`符号，但最好用小括号`()`或是大括号`{}`把变量给包括起来。如果你要使用真实的`$`字符，那么你需要用`$$`来表示\n\n#### 赋值操作\n* `:=`操作符,操作符右边只能出现已定义的变量,如果是未定义的变量,则会自动忽略,用来避免递归展开 \n* `=`操作符右边可以出现未定义的变量\n*  `?=`如果变量没有定义过,则使用后面的值\n* `+=`追加变量值\n\n#### 内置变量\n\n|变量类型|特殊变量|含义|用例或说明|\n|:-:|:-:|:-:|:-:|\n|特殊变量|`VPATH`|寻找依赖或目标的路径,以冒号为分隔符,当前目录永远最优先|`VPATH = src:../headers`|\n|特殊变量|`SUFFIXE`|定义默认的后缀列表,最好不要直接改变，通过`.SUFFIXE`|| |特殊变量|.DIRSEPSTR|路径分隔符一般是斜杠||\n|特殊变量|.MAKEDIR|调用make的绝对路径名||\n|特殊变量|.NULL|空字符串||\n|特殊变量|.OS|正在运行的操作系统名称||\n|特殊变量|.PWD|运行时活动工作目录的绝对路径名||\n|特殊变量|.SHELL|启动的shell类型||\n|命令变量|`AR`|函数库打包程序,默认命令是ar||\n|命令变量|`AS`|汇编语言编译程序,默认命令是as||\n|命令变量|`CC`|C语言编译程序,默认命令是cc||\n|命令变量|`CXX`|C++语言编译程序,默认命令是g++||\n|命令变量|`CPP`|C程序的预处理器,默认命令是$(CC) -E||\n|命令变量|`RM`|删除文件命令,默认命令是rm -f||\n|参数变量|`ARFLAGS`|函数库打包程序AR命令参数,默认值是rv||\n|参数变量|`ASFLAGS`|汇编语言编译器参数,默认值是空||\n|参数变量|`CFLAGS`|C语言编译器参数,默认为空||\n|参数变量|`CPPFLAGS`|C预处理器参数,默认为空||\n|参数变量|`CXXFLAGS`|C++语言编译器参数,默认为空||\n|参数变量|`LDFLAGS`|ld链接器参数,默认为空||\n|系统变量|`MAKELEVEL`|当前Makefile的调用层数,从0开始||\n|系统变量|`MAKECMDGOALS`|存放那个你命令行中所指定的终极目标的列表,没有指定则为空||\n|自动变量|`$@`|目标集|它代表一个量,遍历目标集,一般与依赖集相匹配|\n|自动变量|`$%`|目标集|仅当目标是函数库文件时,表示规则中的目标成员名,foo.a(bar.o),$%就是bar.o,$@就是foo.a|\n|自动变量|`$<`|依赖集|它代表一个量,遍历目标集,一般用于目标集相匹配|\n|自动变量|`$?`|依赖集|所有比目标新的依赖目标的集合,以空格分隔|\n|自动变量|`$^`|依赖集|所有依赖目标的集合,去掉重复以空格分隔|\n|自动变量|`$+`|依赖集|所有依赖目标的集合,不去掉重复以空格分隔|\n|自动变量|`$*`||对应模式的'%'及之前的部分,包括路径|\n\n**所有自动变量都可以与`D`,`F`搭配使用,表示匹配的目录部分和文件部分,如`$(@D)`**\n#### 高级用法\n* 替换`.o`到`.c`\n**方法一:**\n```bash\nfoo:=a.o b.o c.o\nbar:=$(foo:.o=.c)\n```\n**方法二:**\n```bash\n#静态模式\nfoo:=a.o b.o c.o\nbar:=$(foo:%.o=%.c)\n```\n* 强制覆盖 \n\n`override <variable>=<value>`make命令行参数可以用这个强制覆盖,否则覆盖不了\n* 替换变量中字符串\n`变量名: s/原字符串/新字符串`\n* 加前后缀\n`变量:^ \"前缀\"`\n`变量:+ \"后缀\"`\n* 取部分\n`$(VARIABLE:<option>)`,option有3个选项d(仅取路径)、b(文件名,不包括扩展)、f(文件名,包括扩展)\n### 关键字vpath\n* 用法一:`vpath <pattern> <directories>`符合模式的在指定文件夹搜索\n* 用法二:`vpath <pattern>`清除对应模式搜索目录\n* 用法三:`vpath`清除所有搜索目录\n***注意:<pattern>都必须包含%,意思是包含一个以上的匹配字符***\n### 局部作用的变量\n```bash\nprog: CFLAGS = -g\n\tprog: prog.o foo.o bar.o\n\t\t$(gcc) $(CFLAGS) prog.o foo.o bar.o\n\tprog.o: prog.c\n\t\t$(gcc) $(CFLAGS) prog.c\n\tfoo.o: foo.c\n\t\t$(gcc) $(CFLAGS) bar.c\n```\n不管全局的`$(CFLAGS)`的值是什么,prog目标及其所引发的所有规则中(prog.o foo.o bar.o),$(CFLAGS)的值都是-gl\n### 伪目标\n用`.PHONY`指明伪目标\n- 伪目标并不是文件，只是个标签,最终不产生文件\n- 只有显式地指名才能使其生效\n- 最终目标可以是伪目标,一个用法如下,使一个make文件生成多个目标:\n```bash\nall: prog1 prog2 prog3\n.PHONY: all\nprog1: prog1.o utils.o\n\tgcc -o prog1 prog1.o utils.o\nprog2: prog2.o\n\tgcc -o prog2 prog2.o\nprog3: prog3.o sort.o utils.o\n\tgcc -o prog3 prog3.o sort.o utils.o\n```\n### 静态模式:更方便定义多目标\n`<targets>: <target-pattern>: <prereq-patterns>`\n例子:\n```bash\nobjects = foo.o bar.o\nall: $(objects)\n$(objects): %.o: %.c\n\t$(gcc) -c $(CFLAGS) $< -o $@\n```\n等价于\n```bash\nfoo.o: foo.c\n\t$(gcc) -c $(CFLAGS) foo.c -o foo.o\nbar.o: bar.c\n\t$(gcc) -c $(CFLAGS) bar.c -o bar.o\n```\n### gcc -MM选项\n该选项可以为.c源文件自动生成依赖的非标准库的头文件,按习惯称为.d文件\n可以用以下模式规则来产生.d文件\n```bash\n%.d: %.c\n    @set -e; rm -f $@; \\\n    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \\\n    sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' < $@.$$$$ > $@; \\\n    rm -f $@.$$$$\n```\n然后用include\n```bash\nsources = foo.c bar.c\ninclude $(sources:.c=.d)\n```\n### `@`关键字\nmake默认会显示命令,在命令前加@可以阻止输出,例如\n`@echo 正在编译XXX模块`\n### `-`关键字\n在命令前加`-`会忽略该命令产生的错误\n### 嵌套make  \n```bash\nsubsystem:\n\tcd subdir && $(MAKE) #也可以这么写$(MAKE) -C subdir\n```\n　要想传递变量给嵌套的make,使用export,不想传递使用unexport\n　其中`SHELL`和`MAKEFLAGS`总会影响下层make,但-C、-f、-h、-o、-W几个参数并不往下传递\n### 定义命令包(即命令集)\n其实这是多行变量\n例子:\n```bash\ndefine run-yacc\nmkdir dir\nmv dir newdir\nendef\ncrap: \n\t$(run-yacc)\n```\n### 条件判断\nmake是在读取Makefile时就计算条件表达式的值,而不是运行,所以不要用自动变量\n```bash\nxx: xc\n<conditional-directive> #可以是ifeq(arg1,arg2)、ifneq、ifdef <variable-name>(不加美元符号)、ifndef\n\t<text-if-true>\nelse\n\t<text-if-false>\nendif\n```\n### 函数\n#### 调用语法\n`$(<function> <arguments>)`,参数间用','分隔\n#### 字符串函数\n\n|函数|功能|返回|\n|:-:|:-:|:-:|\n|`$(subst <from>,<to>,<text>)`|把字符串<text>中的<from>换成<to>|`被替换过的字符串`|\n|`$(patsubst <pattern>,<replacement>,<text>)`|查找<text>中的单词(以空格、Tab、回车、换行)符合<pattern>,替换<replacement>|被替换后的字符串|\n|`$(strip <string>)`|去掉<string>中开头和结尾的空字符|去掉空字符的字符串|\n|`$(findstring <find>,<in>)`|在字符串<in>中查找<find>|如果找到,返回<find>,否则返回空字符串|\n|`$(filter <pattern...>,<text>)`|以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割|返回符合<pattern>的字符串|\n|`$(filter-out <pattern...>,<text>)`|以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割|返回不符合<pattern>的字符串|\n|`$(sort <list>)`|给字符串<list>中的单词升序|返回排序后的字符串(会去掉相同的单词)|\n|`$(word <n>,<text>)`|取字符串<text>中的第<n>个单词|返回该单词,如果n过大,则返回空字符串|\n|`$(wordlist <n>,<m>,<text>)`|取第<n>-第<m>个单词|返回那些单词|\n|`$(words <text>)`|统计<text>中的单词数|返回个数|\n|`$(firstword <text>)`|返回字符串<text>中第一个单词|返回第一个单词|\n\n#### 文件名函数\n\n|格式|例子|返回值|\n|:-:|:-:|:-:|\n|`$(dir <names...>)`|`$(dir src/foo.c hacks)`|`src/ ./`|\n|`$(notdir <names...>)`|`$(notdir src/foo.c hacks)`|`foo.c hacks`|\n|`$(suffix <names...>)`|`$(suffix src/foo.c src-1.0/bar.c hacks)`|`.c .c`|\n|`$(basename <names...>)`|`$(basename src/foo.c src-1.0/bar.c hacks)`|`src/foo src-1.0/bar hacks`|\n|`$(addsuffix <suffix>,<names...>)`|`$(addsuffix .c,foo bar)`|`foo.c bar.c`|\n|`$(addprefix <prefix>,<names...>)`|`$(addprefix src/,foo bar)`|`src/foo src/bar`|\n|`$(join <list1>,<list2>)`|`$(join aaa bbb,111 222 333)`|`aaa111 bbb222`|\n\n#### foreach函数\n格式:`$(foreach <var>,<list>,<text>)`\n```bash\nnames:= a b c d\nfiles:= $(foreach n,$(names),$(n).o)\n#$(files)的值是‘a.o b.o c.o d.o’\n```\n#### if函数\n`$(if <condition>,<then-part>,<else-part>)`,<condition>若返回为非空,则执行<then-part>,其是整个函数的返回值\n#### call函数\n`$(call <expression>,<parm1>,<parm2>,<parm3>...)`;<expression>中`$(1)`,`$(2)`等,会被参数`<parm1>`、`<parm2>`等代替\n```bash\nreverse=$(2) $(1)\nfoo=$(call reverse,a,b)\n```\n此时foo的值就是'b a'\n#### shell函数\n`files:=$(shell echo *.c)`\n#### origin函数\n`$(origin <variable>)`:告知变量来源情况\n\n|返回值|含义|\n|:-:|:-:|\n|undefined|未定义|\n|default|默认定义|\n|environment|环境变量|\n|file|定义在make文件中|\n|override|被override重新定义|\n|automatic|命令运行中的自动化变量|\n|command line|命令行定义|\n\n#### error函数和warning函数\n`$(error <text ...>)`\n`$(warning <text ...>)`\nerror函数产生一个致命的错误,<text ...>是错误信息\nwarning函数只是输出警告信息,make会继续执行\n\n例1：\n```bash\nifdef ERROR_001\n\t#运行到下面的会出错跳出脚本\n    $(error error is $(ERROR_001))\nendif\n```\n例2：\n```bash\n#这里并不会出错跳出脚本\nERR = $(error found an error!)\n\n.PHONY: err\n#这里才会跳出\nerr: $(ERR)\n```\n\n### make的退出码\n* 0:表示成功执行\n* 1:表示出错\n* 2:如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。\n\n### 一些常用伪目标命名\n\n|名称|含义|\n|:-:|:-:|\n|all|这个伪目标一般是所有目标的目标,一般为编译所有的目标|\n|clean|这个伪目标的功能一般是删除所有make创建的文件|\n|install|安装已编译好的程序,其实是把目标执行文件复制到指定文件夹|\n|print|这个伪目标的功能是列出改变过的源文件|\n|tar|这个伪目标的功能是打包备份源程序|\n|dist|一般是把打包文件进行压缩|\n|tags|这个伪目标的功能用于更新所有的目标,以备完整地重新编译|\n|check、test|一般用来测试makefile文件流程|\n\n### make选项参数\n\n|短选项|长选项|含义|\n|:-:|:-:|:-:|\n|-b,-m||忽略其他版本make兼容性|\n|-B|--always-make|认为所有目标都更新(重编译)|\n|-C <dir>|--directory=<dir>|指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog”|\n|-d||相当于`-debug=a`|\n|-e|--environment-overrides|指定环境变量值,覆盖makefile文件中定义的变量值|\n|-f|--file、--makefile|指定某个makefile文件|\n|-i|--ignore-errors|在执行时忽略所有的错误|\n|-I <dir>|--include-dir=<dir>|指定一个包含makefile文件的搜索目标|\n|-j <jobsnum>|--jobs=<jobsnum>|指同时运行的命令数,如果没有这个参数,能运行多少就多少,只有最后一个-j选项有效|\n|-k|--keep-going|出错也不停止,执行其它目标,失败的目标,依赖于其上的就不会执行|\n|-l <load>|--load-average [=<load>];--max-load[=<load>]|指定make运行命令的负载|\n|-n|--just-print、--dry-run、--recon|不管目标更不更新,只打印命令,不执行|\n|-o <file>|--old-file=<file>;--assume-old=<file>|不生成指定的<file>,即使这个目标的依赖文件比他新|\n|-p|--print-database|输出makefile文件中所有数据,包括所有的规则和变量|\n|-q|--question|寻找目标,如果目标存在,什么也不输出,也不执行编译,返回0.如果目标不存在,打印一条出错信息,返回2|\n|-r|--no-builtin-rules|禁止使用任何隐式规则，会使得SUFFIXE变量为空|\n|-R|--no-builtin-variables|禁止使用任作用于变量上的何隐式规则|\n|-s|--silent;--quiet|命令运行时不显示命令的输出|\n|-S|--no-keep-going;--stop|取消-k选项的作用|\n|-t|--touch|把目标文件时间更新,但不更改目标文件,假装编译文件|\n|-w|--print-directory|输出运行makefile文件之前之后的信息,跟踪嵌套make时很有用|\n|-W <file>|--what-if=<file>;--assume-new=<file>;--new-file=<file>|假定目标<file>;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>;的修改时间为当前时间。|\n||--no-print-directory|禁止-w选项|\n||--warn-undefined-variables|警告未定义的变量|\n\n#### --debug \\<options\\>\noptions可以是以下:\n* 也就是all,输出所有的调试信息\n* 也就是basic,只输出简单的调试信息,即输出不需要重新编译的目标\n* 也就是verbose,输出的信息包括哪一个makefile文件被解析,不需要重新编译的依赖文件(或是依赖目标)\n* 也就是implicit,输出所有的隐含规则\n* 也就是jobs,输出执行规则中命令的详细信息,如PID、返回码等\n* 也就是makefile文件,输出make,读取makefile,更新makefile文件,并执行makefile文件的信息\n#### 常用组合\n- `make -qp`只输出信息而不执行\n- `make -p -f /dev/null`查看makefile前的预设变量和规则\n### 模式的匹配\n一般来说，一个目标的模式有一个有前缀或是后缀的%，或是没有前后缀，直接就是一个%。因为%代表一个或多个字符，所以在定义好了的模式中，我们把%所匹配的内容叫做“茎”，例如%.c所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有%时，依赖目标的“茎”会传给目标，当做目标中的“茎”。\n\n当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式e%t，文件src/eat匹配于该模式，于是src/a就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式c%r，那么，目标就是src/car。（“茎”被传递）\n### 一些\"老东西\"--后缀规则\n- `.c.o:`等价于`%.o : %.c`\n- `.c:`等价于`% : %.c`\n以上称为后缀规则，要想这么用，必须为默认后缀，你可以用以下来添加默认后缀\n```bash\n.SUFFIXES:              # 删除默认的后缀\n.SUFFIXES: .a .b .c c # 定义自己的后缀\n```\n### 隐含规则  \n#### 各个规则\n- C程序隐含规则:<n>.o的目标的依赖目标会是:<n>.c,命令是`$(CC) -c $(CPPFLAGS)$(CFLAGS)`\n- C++程序隐含规则:<n>.o的目标的依赖目标是:<n>.cc或<n>.C,命令是`$(CXX) -c  $(CPPFLAGS)$(CXXFLAGS)`\n- 汇编和预处理隐含规则:<n>.o的目标的依赖目标会自动推导为<n>.s，默认使用编译器as，并且其生成命令是：`$ (AS) $(ASFLAGS)`。<n>.s的目标的依赖目标会自动推导为<n>.S，默认使用C预编译器cpp，并且其生成命令是：`$(AS) $(ASFLAGS)`。\n- 链接Object文件的隐含规则:<n>目标依赖于<n>.o，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是：`$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)`。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:\n```bash\nx : y.o z.o\n```\n隐含规则执行如下(x.c、y.c、z.c都存在):\n```bash\ncc -c x.c -o x.o\ncc -c y.c -o y.o\ncc -c z.c -o z.o\ncc x.o y.o z.o -o x\nrm -f x.o\nrm -f y.o\nrm -f z.o\n```\n#### 一些tip\n- 隐式规则产生的中间目标，最终会被自动删除，被makefile指定成的目标或依赖目标不能被当作中介，但是可以通过`.INTERMEDIATE`来强制声明为中间目标。如`.intermediate: mid`\n- 也可以阻止自动删除中间目标，通过`.SECONDARY`来强制声明。如`.SECONDARY`。或以模式的方式指定(如：%.o)成为伪目标`.PRECIOUS`的依赖目标。\n- Make会优化一些特殊的隐含规则，而不生成中间文件。从文件.c直接生成执行文件，不产生目标文件\n#### 模式规则来定义一个隐含规则\n模式规则，目标的定义需要有`%`字符。依赖目标随便，与变量不同的是，模式规则的展开发生在运行期间。\n示例：\n```bash\n%.o: %.c\n $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@\n```\n#### 隐含规则搜索算法\n比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是archive(member)的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把member当作T来搜索。\n\n1) 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是src/foo.o，那么，D就是src/，N就是foo.o）\n2) 创建所有匹配于T或是N的模式规则列表。\n3) 如果在模式规则列表中有匹配所有文件的模式，如%，那么从列表中移除其它的模式。\n4) 移除列表中没有命令的规则。\n5) 对于第一个在列表中的模式规则：\n  *  推导其“茎”S，S应该是T或是N匹配于模式中%非空的部分。\n  *  计算依赖文件。把依赖文件中的%都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。\n  * 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）\n  * 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。\n6) 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：\n  * 如果规则是终止规则，那就忽略它，继续下一条模式规则。\n  * 计算依赖文件。（同第5步）\n  * 测试所有的依赖文件是否存在或是理当存在。\n  * 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。\n  * 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。\n  * 如果没有隐含规则可以使用，查看.DEFAULT规则，如果有，采用，把.DEFAULT的命令给T使用。\n### 函数库打包\n函数库文件也就是对.o文件的打包文件\n示例:\n```bash\nfoolib(hack.o xx.o): hack.o xx.o\n\tar cr foolib hack.o xx.o #foolib是库名,hack.o是包含文件\n```\n\n### Tips\n* make中遇到的第一条规则是最终目标  \n* 和bash一样用空格和\"\\\"进行换行\n* 命令总是以tab键开头,其余不是命令\n* `MAKEFILES`最好不用该环境变量,该变量类似于include动作,但其中文件中的目标不会起作用,最好置为空,以免引入未考虑到的东西,莫名奇妙出现问题时,可以查看该变量\n* 要想前面命令作用于后面命令,需要写在同一行上,用分号分隔,如下:\n```bash\nexec:\n\tcd /home/nanbert;pwd\n```\n* 可以在命令前加`-`,来忽略该命令可能执行失败,这也可用于include\n","slug":"Make","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi6w000hgwq2hw9ud36f","content":"<h3 id=\"引用其它的Makefile\"><a href=\"#引用其它的Makefile\" class=\"headerlink\" title=\"引用其它的Makefile\"></a>引用其它的Makefile</h3><p><code>include &lt;filename&gt;</code><br>make会在当前目录寻找,接着在以下目录下找:</p>\n<ul>\n<li>如果make执行时，有 -I 或 –include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。</li>\n<li>如果目录 <prefix>&#x2F;include （一般是： &#x2F;usr&#x2F;local&#x2F;bin 或 &#x2F;usr&#x2F;include ）存在的话，make也会去找。</li>\n</ul>\n<h3 id=\"变量相关\"><a href=\"#变量相关\" class=\"headerlink\" title=\"变量相关\"></a>变量相关</h3><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上<code>$</code>符号，但最好用小括号<code>()</code>或是大括号<code>&#123;&#125;</code>把变量给包括起来。如果你要使用真实的<code>$</code>字符，那么你需要用<code>$$</code>来表示</p>\n<h4 id=\"赋值操作\"><a href=\"#赋值操作\" class=\"headerlink\" title=\"赋值操作\"></a>赋值操作</h4><ul>\n<li><code>:=</code>操作符,操作符右边只能出现已定义的变量,如果是未定义的变量,则会自动忽略,用来避免递归展开 </li>\n<li><code>=</code>操作符右边可以出现未定义的变量</li>\n<li><code>?=</code>如果变量没有定义过,则使用后面的值</li>\n<li><code>+=</code>追加变量值</li>\n</ul>\n<h4 id=\"内置变量\"><a href=\"#内置变量\" class=\"headerlink\" title=\"内置变量\"></a>内置变量</h4><table>\n<thead>\n<tr>\n<th align=\"center\">变量类型</th>\n<th align=\"center\">特殊变量</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">用例或说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\"><code>VPATH</code></td>\n<td align=\"center\">寻找依赖或目标的路径,以冒号为分隔符,当前目录永远最优先</td>\n<td align=\"center\"><code>VPATH = src:../headers</code></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\"><code>SUFFIXE</code></td>\n<td align=\"center\">定义默认的后缀列表,最好不要直接改变，通过<code>.SUFFIXE</code></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.MAKEDIR</td>\n<td align=\"center\">调用make的绝对路径名</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.NULL</td>\n<td align=\"center\">空字符串</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.OS</td>\n<td align=\"center\">正在运行的操作系统名称</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.PWD</td>\n<td align=\"center\">运行时活动工作目录的绝对路径名</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.SHELL</td>\n<td align=\"center\">启动的shell类型</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>AR</code></td>\n<td align=\"center\">函数库打包程序,默认命令是ar</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>AS</code></td>\n<td align=\"center\">汇编语言编译程序,默认命令是as</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>CC</code></td>\n<td align=\"center\">C语言编译程序,默认命令是cc</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>CXX</code></td>\n<td align=\"center\">C++语言编译程序,默认命令是g++</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>CPP</code></td>\n<td align=\"center\">C程序的预处理器,默认命令是$(CC) -E</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>RM</code></td>\n<td align=\"center\">删除文件命令,默认命令是rm -f</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>ARFLAGS</code></td>\n<td align=\"center\">函数库打包程序AR命令参数,默认值是rv</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>ASFLAGS</code></td>\n<td align=\"center\">汇编语言编译器参数,默认值是空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>CFLAGS</code></td>\n<td align=\"center\">C语言编译器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>CPPFLAGS</code></td>\n<td align=\"center\">C预处理器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>CXXFLAGS</code></td>\n<td align=\"center\">C++语言编译器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>LDFLAGS</code></td>\n<td align=\"center\">ld链接器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">系统变量</td>\n<td align=\"center\"><code>MAKELEVEL</code></td>\n<td align=\"center\">当前Makefile的调用层数,从0开始</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">系统变量</td>\n<td align=\"center\"><code>MAKECMDGOALS</code></td>\n<td align=\"center\">存放那个你命令行中所指定的终极目标的列表,没有指定则为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$@</code></td>\n<td align=\"center\">目标集</td>\n<td align=\"center\">它代表一个量,遍历目标集,一般与依赖集相匹配</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$%</code></td>\n<td align=\"center\">目标集</td>\n<td align=\"center\">仅当目标是函数库文件时,表示规则中的目标成员名,foo.a(bar.o),$%就是bar.o,$@就是foo.a</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$&lt;</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">它代表一个量,遍历目标集,一般用于目标集相匹配</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$?</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">所有比目标新的依赖目标的集合,以空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$^</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">所有依赖目标的集合,去掉重复以空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$+</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">所有依赖目标的集合,不去掉重复以空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$*</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">对应模式的’%’及之前的部分,包括路径</td>\n</tr>\n</tbody></table>\n<p><strong>所有自动变量都可以与<code>D</code>,<code>F</code>搭配使用,表示匹配的目录部分和文件部分,如<code>$(@D)</code></strong></p>\n<h4 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h4><ul>\n<li>替换<code>.o</code>到<code>.c</code><br><strong>方法一:</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">foo:=a.o b.o c.o<br>bar:=$(foo:.o=.c)<br></code></pre></td></tr></table></figure>\n<strong>方法二:</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#静态模式</span><br>foo:=a.o b.o c.o<br>bar:=$(foo:%.o=%.c)<br></code></pre></td></tr></table></figure></li>\n<li>强制覆盖</li>\n</ul>\n<p><code>override &lt;variable&gt;=&lt;value&gt;</code>make命令行参数可以用这个强制覆盖,否则覆盖不了</p>\n<ul>\n<li>替换变量中字符串<br><code>变量名: s/原字符串/新字符串</code></li>\n<li>加前后缀<br><code>变量:^ &quot;前缀&quot;</code><br><code>变量:+ &quot;后缀&quot;</code></li>\n<li>取部分<br><code>$(VARIABLE:&lt;option&gt;)</code>,option有3个选项d(仅取路径)、b(文件名,不包括扩展)、f(文件名,包括扩展)</li>\n</ul>\n<h3 id=\"关键字vpath\"><a href=\"#关键字vpath\" class=\"headerlink\" title=\"关键字vpath\"></a>关键字vpath</h3><ul>\n<li>用法一:<code>vpath &lt;pattern&gt; &lt;directories&gt;</code>符合模式的在指定文件夹搜索</li>\n<li>用法二:<code>vpath &lt;pattern&gt;</code>清除对应模式搜索目录</li>\n<li>用法三:<code>vpath</code>清除所有搜索目录<br><em><strong>注意:<pattern>都必须包含%,意思是包含一个以上的匹配字符</strong></em></li>\n</ul>\n<h3 id=\"局部作用的变量\"><a href=\"#局部作用的变量\" class=\"headerlink\" title=\"局部作用的变量\"></a>局部作用的变量</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">prog: CFLAGS = -g<br>\tprog: prog.o foo.o bar.o<br>\t\t$(gcc) $(CFLAGS) prog.o foo.o bar.o<br>\tprog.o: prog.c<br>\t\t$(gcc) $(CFLAGS) prog.c<br>\tfoo.o: foo.c<br>\t\t$(gcc) $(CFLAGS) bar.c<br></code></pre></td></tr></table></figure>\n<p>不管全局的<code>$(CFLAGS)</code>的值是什么,prog目标及其所引发的所有规则中(prog.o foo.o bar.o),$(CFLAGS)的值都是-gl</p>\n<h3 id=\"伪目标\"><a href=\"#伪目标\" class=\"headerlink\" title=\"伪目标\"></a>伪目标</h3><p>用<code>.PHONY</code>指明伪目标</p>\n<ul>\n<li>伪目标并不是文件，只是个标签,最终不产生文件</li>\n<li>只有显式地指名才能使其生效</li>\n<li>最终目标可以是伪目标,一个用法如下,使一个make文件生成多个目标:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">all: prog1 prog2 prog3<br>.PHONY: all<br>prog1: prog1.o utils.o<br>\tgcc -o prog1 prog1.o utils.o<br>prog2: prog2.o<br>\tgcc -o prog2 prog2.o<br>prog3: prog3.o sort.o utils.o<br>\tgcc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"静态模式-更方便定义多目标\"><a href=\"#静态模式-更方便定义多目标\" class=\"headerlink\" title=\"静态模式:更方便定义多目标\"></a>静态模式:更方便定义多目标</h3><p><code>&lt;targets&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns&gt;</code><br>例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">objects = foo.o bar.o<br>all: $(objects)<br>$(objects): %.o: %.c<br>\t$(gcc) -c $(CFLAGS) $&lt; -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">foo.o: foo.c<br>\t$(gcc) -c $(CFLAGS) foo.c -o foo.o<br>bar.o: bar.c<br>\t$(gcc) -c $(CFLAGS) bar.c -o bar.o<br></code></pre></td></tr></table></figure>\n<h3 id=\"gcc-MM选项\"><a href=\"#gcc-MM选项\" class=\"headerlink\" title=\"gcc -MM选项\"></a>gcc -MM选项</h3><p>该选项可以为.c源文件自动生成依赖的非标准库的头文件,按习惯称为.d文件<br>可以用以下模式规则来产生.d文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">%.d: %.c<br>    @<span class=\"hljs-built_in\">set</span> -e; <span class=\"hljs-built_in\">rm</span> -f <span class=\"hljs-variable\">$@</span>; \\<br>    $(CC) -M $(CPPFLAGS) $&lt; &gt; <span class=\"hljs-variable\">$@</span>.$$$$; \\<br>    sed <span class=\"hljs-string\">&#x27;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#x27;</span> &lt; <span class=\"hljs-variable\">$@</span>.$$$$ &gt; <span class=\"hljs-variable\">$@</span>; \\<br>    <span class=\"hljs-built_in\">rm</span> -f <span class=\"hljs-variable\">$@</span>.$$$$<br></code></pre></td></tr></table></figure>\n<p>然后用include</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sources = foo.c bar.c<br>include $(sources:.c=.d)<br></code></pre></td></tr></table></figure>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"@关键字\"></a><code>@</code>关键字</h3><p>make默认会显示命令,在命令前加@可以阻止输出,例如<br><code>@echo 正在编译XXX模块</code></p>\n<h3 id=\"关键字-1\"><a href=\"#关键字-1\" class=\"headerlink\" title=\"-关键字\"></a><code>-</code>关键字</h3><p>在命令前加<code>-</code>会忽略该命令产生的错误</p>\n<h3 id=\"嵌套make\"><a href=\"#嵌套make\" class=\"headerlink\" title=\"嵌套make\"></a>嵌套make</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">subsystem:<br>\t<span class=\"hljs-built_in\">cd</span> subdir &amp;&amp; $(MAKE) <span class=\"hljs-comment\">#也可以这么写$(MAKE) -C subdir</span><br></code></pre></td></tr></table></figure>\n<p>　要想传递变量给嵌套的make,使用export,不想传递使用unexport<br>　其中<code>SHELL</code>和<code>MAKEFLAGS</code>总会影响下层make,但-C、-f、-h、-o、-W几个参数并不往下传递</p>\n<h3 id=\"定义命令包-即命令集\"><a href=\"#定义命令包-即命令集\" class=\"headerlink\" title=\"定义命令包(即命令集)\"></a>定义命令包(即命令集)</h3><p>其实这是多行变量<br>例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">define run-yacc<br><span class=\"hljs-built_in\">mkdir</span> <span class=\"hljs-built_in\">dir</span><br><span class=\"hljs-built_in\">mv</span> <span class=\"hljs-built_in\">dir</span> newdir<br>endef<br>crap: <br>\t$(run-yacc)<br></code></pre></td></tr></table></figure>\n<h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>make是在读取Makefile时就计算条件表达式的值,而不是运行,所以不要用自动变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">xx: xc<br>&lt;conditional-directive&gt; <span class=\"hljs-comment\">#可以是ifeq(arg1,arg2)、ifneq、ifdef &lt;variable-name&gt;(不加美元符号)、ifndef</span><br>\t&lt;text-if-true&gt;<br><span class=\"hljs-keyword\">else</span><br>\t&lt;text-if-false&gt;<br>endif<br></code></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"调用语法\"><a href=\"#调用语法\" class=\"headerlink\" title=\"调用语法\"></a>调用语法</h4><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code>,参数间用’,’分隔</p>\n<h4 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h4><table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">返回</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">把字符串<text>中的<from>换成<to></td>\n<td align=\"center\"><code>被替换过的字符串</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">查找<text>中的单词(以空格、Tab、回车、换行)符合<pattern>,替换<replacement></td>\n<td align=\"center\">被替换后的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(strip &lt;string&gt;)</code></td>\n<td align=\"center\">去掉<string>中开头和结尾的空字符</td>\n<td align=\"center\">去掉空字符的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(findstring &lt;find&gt;,&lt;in&gt;)</code></td>\n<td align=\"center\">在字符串<in>中查找<find></td>\n<td align=\"center\">如果找到,返回<find>,否则返回空字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(filter &lt;pattern...&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割</td>\n<td align=\"center\">返回符合<pattern>的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(filter-out &lt;pattern...&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割</td>\n<td align=\"center\">返回不符合<pattern>的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(sort &lt;list&gt;)</code></td>\n<td align=\"center\">给字符串<list>中的单词升序</td>\n<td align=\"center\">返回排序后的字符串(会去掉相同的单词)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(word &lt;n&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">取字符串<text>中的第<n>个单词</td>\n<td align=\"center\">返回该单词,如果n过大,则返回空字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(wordlist &lt;n&gt;,&lt;m&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">取第<n>-第<m>个单词</td>\n<td align=\"center\">返回那些单词</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(words &lt;text&gt;)</code></td>\n<td align=\"center\">统计<text>中的单词数</td>\n<td align=\"center\">返回个数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(firstword &lt;text&gt;)</code></td>\n<td align=\"center\">返回字符串<text>中第一个单词</td>\n<td align=\"center\">返回第一个单词</td>\n</tr>\n</tbody></table>\n<h4 id=\"文件名函数\"><a href=\"#文件名函数\" class=\"headerlink\" title=\"文件名函数\"></a>文件名函数</h4><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">例子</th>\n<th align=\"center\">返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>$(dir &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(dir src/foo.c hacks)</code></td>\n<td align=\"center\"><code>src/ ./</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(notdir &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(notdir src/foo.c hacks)</code></td>\n<td align=\"center\"><code>foo.c hacks</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(suffix &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(suffix src/foo.c src-1.0/bar.c hacks)</code></td>\n<td align=\"center\"><code>.c .c</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(basename &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(basename src/foo.c src-1.0/bar.c hacks)</code></td>\n<td align=\"center\"><code>src/foo src-1.0/bar hacks</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(addsuffix .c,foo bar)</code></td>\n<td align=\"center\"><code>foo.c bar.c</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(addprefix src/,foo bar)</code></td>\n<td align=\"center\"><code>src/foo src/bar</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code></td>\n<td align=\"center\"><code>$(join aaa bbb,111 222 333)</code></td>\n<td align=\"center\"><code>aaa111 bbb222</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"foreach函数\"><a href=\"#foreach函数\" class=\"headerlink\" title=\"foreach函数\"></a>foreach函数</h4><p>格式:<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">names:= a b c d<br>files:= $(foreach n,$(names),$(n).o)<br><span class=\"hljs-comment\">#$(files)的值是‘a.o b.o c.o d.o’</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"if函数\"><a href=\"#if函数\" class=\"headerlink\" title=\"if函数\"></a>if函数</h4><p><code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code>,<condition>若返回为非空,则执行<then-part>,其是整个函数的返回值</p>\n<h4 id=\"call函数\"><a href=\"#call函数\" class=\"headerlink\" title=\"call函数\"></a>call函数</h4><p><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code>;<expression>中<code>$(1)</code>,<code>$(2)</code>等,会被参数<code>&lt;parm1&gt;</code>、<code>&lt;parm2&gt;</code>等代替</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">reverse=$(2) $(1)<br>foo=$(call reverse,a,b)<br></code></pre></td></tr></table></figure>\n<p>此时foo的值就是’b a’</p>\n<h4 id=\"shell函数\"><a href=\"#shell函数\" class=\"headerlink\" title=\"shell函数\"></a>shell函数</h4><p><code>files:=$(shell echo *.c)</code></p>\n<h4 id=\"origin函数\"><a href=\"#origin函数\" class=\"headerlink\" title=\"origin函数\"></a>origin函数</h4><p><code>$(origin &lt;variable&gt;)</code>:告知变量来源情况</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">返回值</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">undefined</td>\n<td align=\"center\">未定义</td>\n</tr>\n<tr>\n<td align=\"center\">default</td>\n<td align=\"center\">默认定义</td>\n</tr>\n<tr>\n<td align=\"center\">environment</td>\n<td align=\"center\">环境变量</td>\n</tr>\n<tr>\n<td align=\"center\">file</td>\n<td align=\"center\">定义在make文件中</td>\n</tr>\n<tr>\n<td align=\"center\">override</td>\n<td align=\"center\">被override重新定义</td>\n</tr>\n<tr>\n<td align=\"center\">automatic</td>\n<td align=\"center\">命令运行中的自动化变量</td>\n</tr>\n<tr>\n<td align=\"center\">command line</td>\n<td align=\"center\">命令行定义</td>\n</tr>\n</tbody></table>\n<h4 id=\"error函数和warning函数\"><a href=\"#error函数和warning函数\" class=\"headerlink\" title=\"error函数和warning函数\"></a>error函数和warning函数</h4><p><code>$(error &lt;text ...&gt;)</code><br><code>$(warning &lt;text ...&gt;)</code><br>error函数产生一个致命的错误,&lt;text …&gt;是错误信息<br>warning函数只是输出警告信息,make会继续执行</p>\n<p>例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ifdef ERROR_001<br>\t<span class=\"hljs-comment\">#运行到下面的会出错跳出脚本</span><br>    $(error error is $(ERROR_001))<br>endif<br></code></pre></td></tr></table></figure>\n<p>例2：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#这里并不会出错跳出脚本</span><br>ERR = $(error found an error!)<br><br>.PHONY: err<br><span class=\"hljs-comment\">#这里才会跳出</span><br>err: $(ERR)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"make的退出码\"><a href=\"#make的退出码\" class=\"headerlink\" title=\"make的退出码\"></a>make的退出码</h3><ul>\n<li>0:表示成功执行</li>\n<li>1:表示出错</li>\n<li>2:如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li>\n</ul>\n<h3 id=\"一些常用伪目标命名\"><a href=\"#一些常用伪目标命名\" class=\"headerlink\" title=\"一些常用伪目标命名\"></a>一些常用伪目标命名</h3><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">all</td>\n<td align=\"center\">这个伪目标一般是所有目标的目标,一般为编译所有的目标</td>\n</tr>\n<tr>\n<td align=\"center\">clean</td>\n<td align=\"center\">这个伪目标的功能一般是删除所有make创建的文件</td>\n</tr>\n<tr>\n<td align=\"center\">install</td>\n<td align=\"center\">安装已编译好的程序,其实是把目标执行文件复制到指定文件夹</td>\n</tr>\n<tr>\n<td align=\"center\">print</td>\n<td align=\"center\">这个伪目标的功能是列出改变过的源文件</td>\n</tr>\n<tr>\n<td align=\"center\">tar</td>\n<td align=\"center\">这个伪目标的功能是打包备份源程序</td>\n</tr>\n<tr>\n<td align=\"center\">dist</td>\n<td align=\"center\">一般是把打包文件进行压缩</td>\n</tr>\n<tr>\n<td align=\"center\">tags</td>\n<td align=\"center\">这个伪目标的功能用于更新所有的目标,以备完整地重新编译</td>\n</tr>\n<tr>\n<td align=\"center\">check、test</td>\n<td align=\"center\">一般用来测试makefile文件流程</td>\n</tr>\n</tbody></table>\n<h3 id=\"make选项参数\"><a href=\"#make选项参数\" class=\"headerlink\" title=\"make选项参数\"></a>make选项参数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">短选项</th>\n<th align=\"center\">长选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b,-m</td>\n<td align=\"center\"></td>\n<td align=\"center\">忽略其他版本make兼容性</td>\n</tr>\n<tr>\n<td align=\"center\">-B</td>\n<td align=\"center\">–always-make</td>\n<td align=\"center\">认为所有目标都更新(重编译)</td>\n</tr>\n<tr>\n<td align=\"center\">-C <dir></td>\n<td align=\"center\">–directory&#x3D;<dir></td>\n<td align=\"center\">指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen&#x2F;test -C prog”等价于“make -C ~hchen&#x2F;test&#x2F;prog”</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\"></td>\n<td align=\"center\">相当于<code>-debug=a</code></td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">–environment-overrides</td>\n<td align=\"center\">指定环境变量值,覆盖makefile文件中定义的变量值</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">–file、–makefile</td>\n<td align=\"center\">指定某个makefile文件</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">–ignore-errors</td>\n<td align=\"center\">在执行时忽略所有的错误</td>\n</tr>\n<tr>\n<td align=\"center\">-I <dir></td>\n<td align=\"center\">–include-dir&#x3D;<dir></td>\n<td align=\"center\">指定一个包含makefile文件的搜索目标</td>\n</tr>\n<tr>\n<td align=\"center\">-j <jobsnum></td>\n<td align=\"center\">–jobs&#x3D;<jobsnum></td>\n<td align=\"center\">指同时运行的命令数,如果没有这个参数,能运行多少就多少,只有最后一个-j选项有效</td>\n</tr>\n<tr>\n<td align=\"center\">-k</td>\n<td align=\"center\">–keep-going</td>\n<td align=\"center\">出错也不停止,执行其它目标,失败的目标,依赖于其上的就不会执行</td>\n</tr>\n<tr>\n<td align=\"center\">-l <load></td>\n<td align=\"center\">–load-average [&#x3D;<load>];–max-load[&#x3D;<load>]</td>\n<td align=\"center\">指定make运行命令的负载</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">–just-print、–dry-run、–recon</td>\n<td align=\"center\">不管目标更不更新,只打印命令,不执行</td>\n</tr>\n<tr>\n<td align=\"center\">-o <file></td>\n<td align=\"center\">–old-file&#x3D;<file>;–assume-old&#x3D;<file></td>\n<td align=\"center\">不生成指定的<file>,即使这个目标的依赖文件比他新</td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">–print-database</td>\n<td align=\"center\">输出makefile文件中所有数据,包括所有的规则和变量</td>\n</tr>\n<tr>\n<td align=\"center\">-q</td>\n<td align=\"center\">–question</td>\n<td align=\"center\">寻找目标,如果目标存在,什么也不输出,也不执行编译,返回0.如果目标不存在,打印一条出错信息,返回2</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">–no-builtin-rules</td>\n<td align=\"center\">禁止使用任何隐式规则，会使得SUFFIXE变量为空</td>\n</tr>\n<tr>\n<td align=\"center\">-R</td>\n<td align=\"center\">–no-builtin-variables</td>\n<td align=\"center\">禁止使用任作用于变量上的何隐式规则</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">–silent;–quiet</td>\n<td align=\"center\">命令运行时不显示命令的输出</td>\n</tr>\n<tr>\n<td align=\"center\">-S</td>\n<td align=\"center\">–no-keep-going;–stop</td>\n<td align=\"center\">取消-k选项的作用</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">–touch</td>\n<td align=\"center\">把目标文件时间更新,但不更改目标文件,假装编译文件</td>\n</tr>\n<tr>\n<td align=\"center\">-w</td>\n<td align=\"center\">–print-directory</td>\n<td align=\"center\">输出运行makefile文件之前之后的信息,跟踪嵌套make时很有用</td>\n</tr>\n<tr>\n<td align=\"center\">-W <file></td>\n<td align=\"center\">–what-if&#x3D;<file>;–assume-new&#x3D;<file>;–new-file&#x3D;<file></td>\n<td align=\"center\">假定目标<file>;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>;的修改时间为当前时间。</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">–no-print-directory</td>\n<td align=\"center\">禁止-w选项</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">–warn-undefined-variables</td>\n<td align=\"center\">警告未定义的变量</td>\n</tr>\n</tbody></table>\n<h4 id=\"–debug\"><a href=\"#–debug\" class=\"headerlink\" title=\"–debug &lt;options&gt;\"></a>–debug &lt;options&gt;</h4><p>options可以是以下:</p>\n<ul>\n<li>也就是all,输出所有的调试信息</li>\n<li>也就是basic,只输出简单的调试信息,即输出不需要重新编译的目标</li>\n<li>也就是verbose,输出的信息包括哪一个makefile文件被解析,不需要重新编译的依赖文件(或是依赖目标)</li>\n<li>也就是implicit,输出所有的隐含规则</li>\n<li>也就是jobs,输出执行规则中命令的详细信息,如PID、返回码等</li>\n<li>也就是makefile文件,输出make,读取makefile,更新makefile文件,并执行makefile文件的信息</li>\n</ul>\n<h4 id=\"常用组合\"><a href=\"#常用组合\" class=\"headerlink\" title=\"常用组合\"></a>常用组合</h4><ul>\n<li><code>make -qp</code>只输出信息而不执行</li>\n<li><code>make -p -f /dev/null</code>查看makefile前的预设变量和规则</li>\n</ul>\n<h3 id=\"模式的匹配\"><a href=\"#模式的匹配\" class=\"headerlink\" title=\"模式的匹配\"></a>模式的匹配</h3><p>一般来说，一个目标的模式有一个有前缀或是后缀的%，或是没有前后缀，直接就是一个%。因为%代表一个或多个字符，所以在定义好了的模式中，我们把%所匹配的内容叫做“茎”，例如%.c所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有%时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p>\n<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式e%t，文件src&#x2F;eat匹配于该模式，于是src&#x2F;a就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式c%r，那么，目标就是src&#x2F;car。（“茎”被传递）</p>\n<h3 id=\"一些”老东西”–后缀规则\"><a href=\"#一些”老东西”–后缀规则\" class=\"headerlink\" title=\"一些”老东西”–后缀规则\"></a>一些”老东西”–后缀规则</h3><ul>\n<li><code>.c.o:</code>等价于<code>%.o : %.c</code></li>\n<li><code>.c:</code>等价于<code>% : %.c</code><br>以上称为后缀规则，要想这么用，必须为默认后缀，你可以用以下来添加默认后缀<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">.SUFFIXES:              <span class=\"hljs-comment\"># 删除默认的后缀</span><br>.SUFFIXES: .a .b .c c <span class=\"hljs-comment\"># 定义自己的后缀</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"隐含规则\"><a href=\"#隐含规则\" class=\"headerlink\" title=\"隐含规则\"></a>隐含规则</h3><h4 id=\"各个规则\"><a href=\"#各个规则\" class=\"headerlink\" title=\"各个规则\"></a>各个规则</h4><ul>\n<li>C程序隐含规则:<n>.o的目标的依赖目标会是:<n>.c,命令是<code>$(CC) -c $(CPPFLAGS)$(CFLAGS)</code></li>\n<li>C++程序隐含规则:<n>.o的目标的依赖目标是:<n>.cc或<n>.C,命令是<code>$(CXX) -c  $(CPPFLAGS)$(CXXFLAGS)</code></li>\n<li>汇编和预处理隐含规则:<n>.o的目标的依赖目标会自动推导为<n>.s，默认使用编译器as，并且其生成命令是：<code>$ (AS) $(ASFLAGS)</code>。<n>.s的目标的依赖目标会自动推导为<n>.S，默认使用C预编译器cpp，并且其生成命令是：<code>$(AS) $(ASFLAGS)</code>。</li>\n<li>链接Object文件的隐含规则:<n>目标依赖于<n>.o，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是：<code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code>。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">x : y.o z.o<br></code></pre></td></tr></table></figure>\n隐含规则执行如下(x.c、y.c、z.c都存在):<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">cc -c x.c -o x.o<br>cc -c y.c -o y.o<br>cc -c z.c -o z.o<br>cc x.o y.o z.o -o x<br><span class=\"hljs-built_in\">rm</span> -f x.o<br><span class=\"hljs-built_in\">rm</span> -f y.o<br><span class=\"hljs-built_in\">rm</span> -f z.o<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"一些tip\"><a href=\"#一些tip\" class=\"headerlink\" title=\"一些tip\"></a>一些tip</h4><ul>\n<li>隐式规则产生的中间目标，最终会被自动删除，被makefile指定成的目标或依赖目标不能被当作中介，但是可以通过<code>.INTERMEDIATE</code>来强制声明为中间目标。如<code>.intermediate: mid</code></li>\n<li>也可以阻止自动删除中间目标，通过<code>.SECONDARY</code>来强制声明。如<code>.SECONDARY</code>。或以模式的方式指定(如：%.o)成为伪目标<code>.PRECIOUS</code>的依赖目标。</li>\n<li>Make会优化一些特殊的隐含规则，而不生成中间文件。从文件.c直接生成执行文件，不产生目标文件</li>\n</ul>\n<h4 id=\"模式规则来定义一个隐含规则\"><a href=\"#模式规则来定义一个隐含规则\" class=\"headerlink\" title=\"模式规则来定义一个隐含规则\"></a>模式规则来定义一个隐含规则</h4><p>模式规则，目标的定义需要有<code>%</code>字符。依赖目标随便，与变量不同的是，模式规则的展开发生在运行期间。<br>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">%.o: %.c<br> $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"隐含规则搜索算法\"><a href=\"#隐含规则搜索算法\" class=\"headerlink\" title=\"隐含规则搜索算法\"></a>隐含规则搜索算法</h4><p>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是archive(member)的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把member当作T来搜索。</p>\n<ol>\n<li>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是src&#x2F;foo.o，那么，D就是src&#x2F;，N就是foo.o）</li>\n<li>创建所有匹配于T或是N的模式规则列表。</li>\n<li>如果在模式规则列表中有匹配所有文件的模式，如%，那么从列表中移除其它的模式。</li>\n<li>移除列表中没有命令的规则。</li>\n<li>对于第一个在列表中的模式规则：</li>\n</ol>\n<ul>\n<li>推导其“茎”S，S应该是T或是N匹配于模式中%非空的部分。</li>\n<li>计算依赖文件。把依赖文件中的%都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li>\n<li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）</li>\n<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>\n</ul>\n<ol start=\"6\">\n<li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：</li>\n</ol>\n<ul>\n<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li>\n<li>计算依赖文件。（同第5步）</li>\n<li>测试所有的依赖文件是否存在或是理当存在。</li>\n<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li>\n<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li>\n<li>如果没有隐含规则可以使用，查看.DEFAULT规则，如果有，采用，把.DEFAULT的命令给T使用。</li>\n</ul>\n<h3 id=\"函数库打包\"><a href=\"#函数库打包\" class=\"headerlink\" title=\"函数库打包\"></a>函数库打包</h3><p>函数库文件也就是对.o文件的打包文件<br>示例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">foolib(hack.o xx.o): hack.o xx.o<br>\tar cr foolib hack.o xx.o <span class=\"hljs-comment\">#foolib是库名,hack.o是包含文件</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ul>\n<li>make中遇到的第一条规则是最终目标  </li>\n<li>和bash一样用空格和”&quot;进行换行</li>\n<li>命令总是以tab键开头,其余不是命令</li>\n<li><code>MAKEFILES</code>最好不用该环境变量,该变量类似于include动作,但其中文件中的目标不会起作用,最好置为空,以免引入未考虑到的东西,莫名奇妙出现问题时,可以查看该变量</li>\n<li>要想前面命令作用于后面命令,需要写在同一行上,用分号分隔,如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">exec</span>:<br>\t<span class=\"hljs-built_in\">cd</span> /home/nanbert;<span class=\"hljs-built_in\">pwd</span><br></code></pre></td></tr></table></figure></li>\n<li>可以在命令前加<code>-</code>,来忽略该命令可能执行失败,这也可用于include</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"引用其它的Makefile\"><a href=\"#引用其它的Makefile\" class=\"headerlink\" title=\"引用其它的Makefile\"></a>引用其它的Makefile</h3><p><code>include &lt;filename&gt;</code><br>make会在当前目录寻找,接着在以下目录下找:</p>\n<ul>\n<li>如果make执行时，有 -I 或 –include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。</li>\n<li>如果目录 <prefix>&#x2F;include （一般是： &#x2F;usr&#x2F;local&#x2F;bin 或 &#x2F;usr&#x2F;include ）存在的话，make也会去找。</li>\n</ul>\n<h3 id=\"变量相关\"><a href=\"#变量相关\" class=\"headerlink\" title=\"变量相关\"></a>变量相关</h3><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上<code>$</code>符号，但最好用小括号<code>()</code>或是大括号<code>&#123;&#125;</code>把变量给包括起来。如果你要使用真实的<code>$</code>字符，那么你需要用<code>$$</code>来表示</p>\n<h4 id=\"赋值操作\"><a href=\"#赋值操作\" class=\"headerlink\" title=\"赋值操作\"></a>赋值操作</h4><ul>\n<li><code>:=</code>操作符,操作符右边只能出现已定义的变量,如果是未定义的变量,则会自动忽略,用来避免递归展开 </li>\n<li><code>=</code>操作符右边可以出现未定义的变量</li>\n<li><code>?=</code>如果变量没有定义过,则使用后面的值</li>\n<li><code>+=</code>追加变量值</li>\n</ul>\n<h4 id=\"内置变量\"><a href=\"#内置变量\" class=\"headerlink\" title=\"内置变量\"></a>内置变量</h4><table>\n<thead>\n<tr>\n<th align=\"center\">变量类型</th>\n<th align=\"center\">特殊变量</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">用例或说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\"><code>VPATH</code></td>\n<td align=\"center\">寻找依赖或目标的路径,以冒号为分隔符,当前目录永远最优先</td>\n<td align=\"center\"><code>VPATH = src:../headers</code></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\"><code>SUFFIXE</code></td>\n<td align=\"center\">定义默认的后缀列表,最好不要直接改变，通过<code>.SUFFIXE</code></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.MAKEDIR</td>\n<td align=\"center\">调用make的绝对路径名</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.NULL</td>\n<td align=\"center\">空字符串</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.OS</td>\n<td align=\"center\">正在运行的操作系统名称</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.PWD</td>\n<td align=\"center\">运行时活动工作目录的绝对路径名</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">特殊变量</td>\n<td align=\"center\">.SHELL</td>\n<td align=\"center\">启动的shell类型</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>AR</code></td>\n<td align=\"center\">函数库打包程序,默认命令是ar</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>AS</code></td>\n<td align=\"center\">汇编语言编译程序,默认命令是as</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>CC</code></td>\n<td align=\"center\">C语言编译程序,默认命令是cc</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>CXX</code></td>\n<td align=\"center\">C++语言编译程序,默认命令是g++</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>CPP</code></td>\n<td align=\"center\">C程序的预处理器,默认命令是$(CC) -E</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">命令变量</td>\n<td align=\"center\"><code>RM</code></td>\n<td align=\"center\">删除文件命令,默认命令是rm -f</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>ARFLAGS</code></td>\n<td align=\"center\">函数库打包程序AR命令参数,默认值是rv</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>ASFLAGS</code></td>\n<td align=\"center\">汇编语言编译器参数,默认值是空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>CFLAGS</code></td>\n<td align=\"center\">C语言编译器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>CPPFLAGS</code></td>\n<td align=\"center\">C预处理器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>CXXFLAGS</code></td>\n<td align=\"center\">C++语言编译器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">参数变量</td>\n<td align=\"center\"><code>LDFLAGS</code></td>\n<td align=\"center\">ld链接器参数,默认为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">系统变量</td>\n<td align=\"center\"><code>MAKELEVEL</code></td>\n<td align=\"center\">当前Makefile的调用层数,从0开始</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">系统变量</td>\n<td align=\"center\"><code>MAKECMDGOALS</code></td>\n<td align=\"center\">存放那个你命令行中所指定的终极目标的列表,没有指定则为空</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$@</code></td>\n<td align=\"center\">目标集</td>\n<td align=\"center\">它代表一个量,遍历目标集,一般与依赖集相匹配</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$%</code></td>\n<td align=\"center\">目标集</td>\n<td align=\"center\">仅当目标是函数库文件时,表示规则中的目标成员名,foo.a(bar.o),$%就是bar.o,$@就是foo.a</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$&lt;</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">它代表一个量,遍历目标集,一般用于目标集相匹配</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$?</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">所有比目标新的依赖目标的集合,以空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$^</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">所有依赖目标的集合,去掉重复以空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$+</code></td>\n<td align=\"center\">依赖集</td>\n<td align=\"center\">所有依赖目标的集合,不去掉重复以空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">自动变量</td>\n<td align=\"center\"><code>$*</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">对应模式的’%’及之前的部分,包括路径</td>\n</tr>\n</tbody></table>\n<p><strong>所有自动变量都可以与<code>D</code>,<code>F</code>搭配使用,表示匹配的目录部分和文件部分,如<code>$(@D)</code></strong></p>\n<h4 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h4><ul>\n<li>替换<code>.o</code>到<code>.c</code><br><strong>方法一:</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">foo:=a.o b.o c.o<br>bar:=$(foo:.o=.c)<br></code></pre></td></tr></table></figure>\n<strong>方法二:</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#静态模式</span><br>foo:=a.o b.o c.o<br>bar:=$(foo:%.o=%.c)<br></code></pre></td></tr></table></figure></li>\n<li>强制覆盖</li>\n</ul>\n<p><code>override &lt;variable&gt;=&lt;value&gt;</code>make命令行参数可以用这个强制覆盖,否则覆盖不了</p>\n<ul>\n<li>替换变量中字符串<br><code>变量名: s/原字符串/新字符串</code></li>\n<li>加前后缀<br><code>变量:^ &quot;前缀&quot;</code><br><code>变量:+ &quot;后缀&quot;</code></li>\n<li>取部分<br><code>$(VARIABLE:&lt;option&gt;)</code>,option有3个选项d(仅取路径)、b(文件名,不包括扩展)、f(文件名,包括扩展)</li>\n</ul>\n<h3 id=\"关键字vpath\"><a href=\"#关键字vpath\" class=\"headerlink\" title=\"关键字vpath\"></a>关键字vpath</h3><ul>\n<li>用法一:<code>vpath &lt;pattern&gt; &lt;directories&gt;</code>符合模式的在指定文件夹搜索</li>\n<li>用法二:<code>vpath &lt;pattern&gt;</code>清除对应模式搜索目录</li>\n<li>用法三:<code>vpath</code>清除所有搜索目录<br><em><strong>注意:<pattern>都必须包含%,意思是包含一个以上的匹配字符</strong></em></li>\n</ul>\n<h3 id=\"局部作用的变量\"><a href=\"#局部作用的变量\" class=\"headerlink\" title=\"局部作用的变量\"></a>局部作用的变量</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">prog: CFLAGS = -g<br>\tprog: prog.o foo.o bar.o<br>\t\t$(gcc) $(CFLAGS) prog.o foo.o bar.o<br>\tprog.o: prog.c<br>\t\t$(gcc) $(CFLAGS) prog.c<br>\tfoo.o: foo.c<br>\t\t$(gcc) $(CFLAGS) bar.c<br></code></pre></td></tr></table></figure>\n<p>不管全局的<code>$(CFLAGS)</code>的值是什么,prog目标及其所引发的所有规则中(prog.o foo.o bar.o),$(CFLAGS)的值都是-gl</p>\n<h3 id=\"伪目标\"><a href=\"#伪目标\" class=\"headerlink\" title=\"伪目标\"></a>伪目标</h3><p>用<code>.PHONY</code>指明伪目标</p>\n<ul>\n<li>伪目标并不是文件，只是个标签,最终不产生文件</li>\n<li>只有显式地指名才能使其生效</li>\n<li>最终目标可以是伪目标,一个用法如下,使一个make文件生成多个目标:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">all: prog1 prog2 prog3<br>.PHONY: all<br>prog1: prog1.o utils.o<br>\tgcc -o prog1 prog1.o utils.o<br>prog2: prog2.o<br>\tgcc -o prog2 prog2.o<br>prog3: prog3.o sort.o utils.o<br>\tgcc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"静态模式-更方便定义多目标\"><a href=\"#静态模式-更方便定义多目标\" class=\"headerlink\" title=\"静态模式:更方便定义多目标\"></a>静态模式:更方便定义多目标</h3><p><code>&lt;targets&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns&gt;</code><br>例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">objects = foo.o bar.o<br>all: $(objects)<br>$(objects): %.o: %.c<br>\t$(gcc) -c $(CFLAGS) $&lt; -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">foo.o: foo.c<br>\t$(gcc) -c $(CFLAGS) foo.c -o foo.o<br>bar.o: bar.c<br>\t$(gcc) -c $(CFLAGS) bar.c -o bar.o<br></code></pre></td></tr></table></figure>\n<h3 id=\"gcc-MM选项\"><a href=\"#gcc-MM选项\" class=\"headerlink\" title=\"gcc -MM选项\"></a>gcc -MM选项</h3><p>该选项可以为.c源文件自动生成依赖的非标准库的头文件,按习惯称为.d文件<br>可以用以下模式规则来产生.d文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">%.d: %.c<br>    @<span class=\"hljs-built_in\">set</span> -e; <span class=\"hljs-built_in\">rm</span> -f <span class=\"hljs-variable\">$@</span>; \\<br>    $(CC) -M $(CPPFLAGS) $&lt; &gt; <span class=\"hljs-variable\">$@</span>.$$$$; \\<br>    sed <span class=\"hljs-string\">&#x27;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#x27;</span> &lt; <span class=\"hljs-variable\">$@</span>.$$$$ &gt; <span class=\"hljs-variable\">$@</span>; \\<br>    <span class=\"hljs-built_in\">rm</span> -f <span class=\"hljs-variable\">$@</span>.$$$$<br></code></pre></td></tr></table></figure>\n<p>然后用include</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sources = foo.c bar.c<br>include $(sources:.c=.d)<br></code></pre></td></tr></table></figure>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"@关键字\"></a><code>@</code>关键字</h3><p>make默认会显示命令,在命令前加@可以阻止输出,例如<br><code>@echo 正在编译XXX模块</code></p>\n<h3 id=\"关键字-1\"><a href=\"#关键字-1\" class=\"headerlink\" title=\"-关键字\"></a><code>-</code>关键字</h3><p>在命令前加<code>-</code>会忽略该命令产生的错误</p>\n<h3 id=\"嵌套make\"><a href=\"#嵌套make\" class=\"headerlink\" title=\"嵌套make\"></a>嵌套make</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">subsystem:<br>\t<span class=\"hljs-built_in\">cd</span> subdir &amp;&amp; $(MAKE) <span class=\"hljs-comment\">#也可以这么写$(MAKE) -C subdir</span><br></code></pre></td></tr></table></figure>\n<p>　要想传递变量给嵌套的make,使用export,不想传递使用unexport<br>　其中<code>SHELL</code>和<code>MAKEFLAGS</code>总会影响下层make,但-C、-f、-h、-o、-W几个参数并不往下传递</p>\n<h3 id=\"定义命令包-即命令集\"><a href=\"#定义命令包-即命令集\" class=\"headerlink\" title=\"定义命令包(即命令集)\"></a>定义命令包(即命令集)</h3><p>其实这是多行变量<br>例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">define run-yacc<br><span class=\"hljs-built_in\">mkdir</span> <span class=\"hljs-built_in\">dir</span><br><span class=\"hljs-built_in\">mv</span> <span class=\"hljs-built_in\">dir</span> newdir<br>endef<br>crap: <br>\t$(run-yacc)<br></code></pre></td></tr></table></figure>\n<h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>make是在读取Makefile时就计算条件表达式的值,而不是运行,所以不要用自动变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">xx: xc<br>&lt;conditional-directive&gt; <span class=\"hljs-comment\">#可以是ifeq(arg1,arg2)、ifneq、ifdef &lt;variable-name&gt;(不加美元符号)、ifndef</span><br>\t&lt;text-if-true&gt;<br><span class=\"hljs-keyword\">else</span><br>\t&lt;text-if-false&gt;<br>endif<br></code></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"调用语法\"><a href=\"#调用语法\" class=\"headerlink\" title=\"调用语法\"></a>调用语法</h4><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code>,参数间用’,’分隔</p>\n<h4 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h4><table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">返回</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">把字符串<text>中的<from>换成<to></td>\n<td align=\"center\"><code>被替换过的字符串</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">查找<text>中的单词(以空格、Tab、回车、换行)符合<pattern>,替换<replacement></td>\n<td align=\"center\">被替换后的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(strip &lt;string&gt;)</code></td>\n<td align=\"center\">去掉<string>中开头和结尾的空字符</td>\n<td align=\"center\">去掉空字符的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(findstring &lt;find&gt;,&lt;in&gt;)</code></td>\n<td align=\"center\">在字符串<in>中查找<find></td>\n<td align=\"center\">如果找到,返回<find>,否则返回空字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(filter &lt;pattern...&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割</td>\n<td align=\"center\">返回符合<pattern>的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(filter-out &lt;pattern...&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割</td>\n<td align=\"center\">返回不符合<pattern>的字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(sort &lt;list&gt;)</code></td>\n<td align=\"center\">给字符串<list>中的单词升序</td>\n<td align=\"center\">返回排序后的字符串(会去掉相同的单词)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(word &lt;n&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">取字符串<text>中的第<n>个单词</td>\n<td align=\"center\">返回该单词,如果n过大,则返回空字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(wordlist &lt;n&gt;,&lt;m&gt;,&lt;text&gt;)</code></td>\n<td align=\"center\">取第<n>-第<m>个单词</td>\n<td align=\"center\">返回那些单词</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(words &lt;text&gt;)</code></td>\n<td align=\"center\">统计<text>中的单词数</td>\n<td align=\"center\">返回个数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(firstword &lt;text&gt;)</code></td>\n<td align=\"center\">返回字符串<text>中第一个单词</td>\n<td align=\"center\">返回第一个单词</td>\n</tr>\n</tbody></table>\n<h4 id=\"文件名函数\"><a href=\"#文件名函数\" class=\"headerlink\" title=\"文件名函数\"></a>文件名函数</h4><table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">例子</th>\n<th align=\"center\">返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>$(dir &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(dir src/foo.c hacks)</code></td>\n<td align=\"center\"><code>src/ ./</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(notdir &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(notdir src/foo.c hacks)</code></td>\n<td align=\"center\"><code>foo.c hacks</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(suffix &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(suffix src/foo.c src-1.0/bar.c hacks)</code></td>\n<td align=\"center\"><code>.c .c</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(basename &lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(basename src/foo.c src-1.0/bar.c hacks)</code></td>\n<td align=\"center\"><code>src/foo src-1.0/bar hacks</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(addsuffix .c,foo bar)</code></td>\n<td align=\"center\"><code>foo.c bar.c</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</code></td>\n<td align=\"center\"><code>$(addprefix src/,foo bar)</code></td>\n<td align=\"center\"><code>src/foo src/bar</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code></td>\n<td align=\"center\"><code>$(join aaa bbb,111 222 333)</code></td>\n<td align=\"center\"><code>aaa111 bbb222</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"foreach函数\"><a href=\"#foreach函数\" class=\"headerlink\" title=\"foreach函数\"></a>foreach函数</h4><p>格式:<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">names:= a b c d<br>files:= $(foreach n,$(names),$(n).o)<br><span class=\"hljs-comment\">#$(files)的值是‘a.o b.o c.o d.o’</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"if函数\"><a href=\"#if函数\" class=\"headerlink\" title=\"if函数\"></a>if函数</h4><p><code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code>,<condition>若返回为非空,则执行<then-part>,其是整个函数的返回值</p>\n<h4 id=\"call函数\"><a href=\"#call函数\" class=\"headerlink\" title=\"call函数\"></a>call函数</h4><p><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code>;<expression>中<code>$(1)</code>,<code>$(2)</code>等,会被参数<code>&lt;parm1&gt;</code>、<code>&lt;parm2&gt;</code>等代替</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">reverse=$(2) $(1)<br>foo=$(call reverse,a,b)<br></code></pre></td></tr></table></figure>\n<p>此时foo的值就是’b a’</p>\n<h4 id=\"shell函数\"><a href=\"#shell函数\" class=\"headerlink\" title=\"shell函数\"></a>shell函数</h4><p><code>files:=$(shell echo *.c)</code></p>\n<h4 id=\"origin函数\"><a href=\"#origin函数\" class=\"headerlink\" title=\"origin函数\"></a>origin函数</h4><p><code>$(origin &lt;variable&gt;)</code>:告知变量来源情况</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">返回值</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">undefined</td>\n<td align=\"center\">未定义</td>\n</tr>\n<tr>\n<td align=\"center\">default</td>\n<td align=\"center\">默认定义</td>\n</tr>\n<tr>\n<td align=\"center\">environment</td>\n<td align=\"center\">环境变量</td>\n</tr>\n<tr>\n<td align=\"center\">file</td>\n<td align=\"center\">定义在make文件中</td>\n</tr>\n<tr>\n<td align=\"center\">override</td>\n<td align=\"center\">被override重新定义</td>\n</tr>\n<tr>\n<td align=\"center\">automatic</td>\n<td align=\"center\">命令运行中的自动化变量</td>\n</tr>\n<tr>\n<td align=\"center\">command line</td>\n<td align=\"center\">命令行定义</td>\n</tr>\n</tbody></table>\n<h4 id=\"error函数和warning函数\"><a href=\"#error函数和warning函数\" class=\"headerlink\" title=\"error函数和warning函数\"></a>error函数和warning函数</h4><p><code>$(error &lt;text ...&gt;)</code><br><code>$(warning &lt;text ...&gt;)</code><br>error函数产生一个致命的错误,&lt;text …&gt;是错误信息<br>warning函数只是输出警告信息,make会继续执行</p>\n<p>例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ifdef ERROR_001<br>\t<span class=\"hljs-comment\">#运行到下面的会出错跳出脚本</span><br>    $(error error is $(ERROR_001))<br>endif<br></code></pre></td></tr></table></figure>\n<p>例2：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#这里并不会出错跳出脚本</span><br>ERR = $(error found an error!)<br><br>.PHONY: err<br><span class=\"hljs-comment\">#这里才会跳出</span><br>err: $(ERR)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"make的退出码\"><a href=\"#make的退出码\" class=\"headerlink\" title=\"make的退出码\"></a>make的退出码</h3><ul>\n<li>0:表示成功执行</li>\n<li>1:表示出错</li>\n<li>2:如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li>\n</ul>\n<h3 id=\"一些常用伪目标命名\"><a href=\"#一些常用伪目标命名\" class=\"headerlink\" title=\"一些常用伪目标命名\"></a>一些常用伪目标命名</h3><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">all</td>\n<td align=\"center\">这个伪目标一般是所有目标的目标,一般为编译所有的目标</td>\n</tr>\n<tr>\n<td align=\"center\">clean</td>\n<td align=\"center\">这个伪目标的功能一般是删除所有make创建的文件</td>\n</tr>\n<tr>\n<td align=\"center\">install</td>\n<td align=\"center\">安装已编译好的程序,其实是把目标执行文件复制到指定文件夹</td>\n</tr>\n<tr>\n<td align=\"center\">print</td>\n<td align=\"center\">这个伪目标的功能是列出改变过的源文件</td>\n</tr>\n<tr>\n<td align=\"center\">tar</td>\n<td align=\"center\">这个伪目标的功能是打包备份源程序</td>\n</tr>\n<tr>\n<td align=\"center\">dist</td>\n<td align=\"center\">一般是把打包文件进行压缩</td>\n</tr>\n<tr>\n<td align=\"center\">tags</td>\n<td align=\"center\">这个伪目标的功能用于更新所有的目标,以备完整地重新编译</td>\n</tr>\n<tr>\n<td align=\"center\">check、test</td>\n<td align=\"center\">一般用来测试makefile文件流程</td>\n</tr>\n</tbody></table>\n<h3 id=\"make选项参数\"><a href=\"#make选项参数\" class=\"headerlink\" title=\"make选项参数\"></a>make选项参数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">短选项</th>\n<th align=\"center\">长选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b,-m</td>\n<td align=\"center\"></td>\n<td align=\"center\">忽略其他版本make兼容性</td>\n</tr>\n<tr>\n<td align=\"center\">-B</td>\n<td align=\"center\">–always-make</td>\n<td align=\"center\">认为所有目标都更新(重编译)</td>\n</tr>\n<tr>\n<td align=\"center\">-C <dir></td>\n<td align=\"center\">–directory&#x3D;<dir></td>\n<td align=\"center\">指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen&#x2F;test -C prog”等价于“make -C ~hchen&#x2F;test&#x2F;prog”</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\"></td>\n<td align=\"center\">相当于<code>-debug=a</code></td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">–environment-overrides</td>\n<td align=\"center\">指定环境变量值,覆盖makefile文件中定义的变量值</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">–file、–makefile</td>\n<td align=\"center\">指定某个makefile文件</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">–ignore-errors</td>\n<td align=\"center\">在执行时忽略所有的错误</td>\n</tr>\n<tr>\n<td align=\"center\">-I <dir></td>\n<td align=\"center\">–include-dir&#x3D;<dir></td>\n<td align=\"center\">指定一个包含makefile文件的搜索目标</td>\n</tr>\n<tr>\n<td align=\"center\">-j <jobsnum></td>\n<td align=\"center\">–jobs&#x3D;<jobsnum></td>\n<td align=\"center\">指同时运行的命令数,如果没有这个参数,能运行多少就多少,只有最后一个-j选项有效</td>\n</tr>\n<tr>\n<td align=\"center\">-k</td>\n<td align=\"center\">–keep-going</td>\n<td align=\"center\">出错也不停止,执行其它目标,失败的目标,依赖于其上的就不会执行</td>\n</tr>\n<tr>\n<td align=\"center\">-l <load></td>\n<td align=\"center\">–load-average [&#x3D;<load>];–max-load[&#x3D;<load>]</td>\n<td align=\"center\">指定make运行命令的负载</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">–just-print、–dry-run、–recon</td>\n<td align=\"center\">不管目标更不更新,只打印命令,不执行</td>\n</tr>\n<tr>\n<td align=\"center\">-o <file></td>\n<td align=\"center\">–old-file&#x3D;<file>;–assume-old&#x3D;<file></td>\n<td align=\"center\">不生成指定的<file>,即使这个目标的依赖文件比他新</td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">–print-database</td>\n<td align=\"center\">输出makefile文件中所有数据,包括所有的规则和变量</td>\n</tr>\n<tr>\n<td align=\"center\">-q</td>\n<td align=\"center\">–question</td>\n<td align=\"center\">寻找目标,如果目标存在,什么也不输出,也不执行编译,返回0.如果目标不存在,打印一条出错信息,返回2</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">–no-builtin-rules</td>\n<td align=\"center\">禁止使用任何隐式规则，会使得SUFFIXE变量为空</td>\n</tr>\n<tr>\n<td align=\"center\">-R</td>\n<td align=\"center\">–no-builtin-variables</td>\n<td align=\"center\">禁止使用任作用于变量上的何隐式规则</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">–silent;–quiet</td>\n<td align=\"center\">命令运行时不显示命令的输出</td>\n</tr>\n<tr>\n<td align=\"center\">-S</td>\n<td align=\"center\">–no-keep-going;–stop</td>\n<td align=\"center\">取消-k选项的作用</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">–touch</td>\n<td align=\"center\">把目标文件时间更新,但不更改目标文件,假装编译文件</td>\n</tr>\n<tr>\n<td align=\"center\">-w</td>\n<td align=\"center\">–print-directory</td>\n<td align=\"center\">输出运行makefile文件之前之后的信息,跟踪嵌套make时很有用</td>\n</tr>\n<tr>\n<td align=\"center\">-W <file></td>\n<td align=\"center\">–what-if&#x3D;<file>;–assume-new&#x3D;<file>;–new-file&#x3D;<file></td>\n<td align=\"center\">假定目标<file>;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>;的修改时间为当前时间。</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">–no-print-directory</td>\n<td align=\"center\">禁止-w选项</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">–warn-undefined-variables</td>\n<td align=\"center\">警告未定义的变量</td>\n</tr>\n</tbody></table>\n<h4 id=\"–debug\"><a href=\"#–debug\" class=\"headerlink\" title=\"–debug &lt;options&gt;\"></a>–debug &lt;options&gt;</h4><p>options可以是以下:</p>\n<ul>\n<li>也就是all,输出所有的调试信息</li>\n<li>也就是basic,只输出简单的调试信息,即输出不需要重新编译的目标</li>\n<li>也就是verbose,输出的信息包括哪一个makefile文件被解析,不需要重新编译的依赖文件(或是依赖目标)</li>\n<li>也就是implicit,输出所有的隐含规则</li>\n<li>也就是jobs,输出执行规则中命令的详细信息,如PID、返回码等</li>\n<li>也就是makefile文件,输出make,读取makefile,更新makefile文件,并执行makefile文件的信息</li>\n</ul>\n<h4 id=\"常用组合\"><a href=\"#常用组合\" class=\"headerlink\" title=\"常用组合\"></a>常用组合</h4><ul>\n<li><code>make -qp</code>只输出信息而不执行</li>\n<li><code>make -p -f /dev/null</code>查看makefile前的预设变量和规则</li>\n</ul>\n<h3 id=\"模式的匹配\"><a href=\"#模式的匹配\" class=\"headerlink\" title=\"模式的匹配\"></a>模式的匹配</h3><p>一般来说，一个目标的模式有一个有前缀或是后缀的%，或是没有前后缀，直接就是一个%。因为%代表一个或多个字符，所以在定义好了的模式中，我们把%所匹配的内容叫做“茎”，例如%.c所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有%时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p>\n<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式e%t，文件src&#x2F;eat匹配于该模式，于是src&#x2F;a就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式c%r，那么，目标就是src&#x2F;car。（“茎”被传递）</p>\n<h3 id=\"一些”老东西”–后缀规则\"><a href=\"#一些”老东西”–后缀规则\" class=\"headerlink\" title=\"一些”老东西”–后缀规则\"></a>一些”老东西”–后缀规则</h3><ul>\n<li><code>.c.o:</code>等价于<code>%.o : %.c</code></li>\n<li><code>.c:</code>等价于<code>% : %.c</code><br>以上称为后缀规则，要想这么用，必须为默认后缀，你可以用以下来添加默认后缀<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">.SUFFIXES:              <span class=\"hljs-comment\"># 删除默认的后缀</span><br>.SUFFIXES: .a .b .c c <span class=\"hljs-comment\"># 定义自己的后缀</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"隐含规则\"><a href=\"#隐含规则\" class=\"headerlink\" title=\"隐含规则\"></a>隐含规则</h3><h4 id=\"各个规则\"><a href=\"#各个规则\" class=\"headerlink\" title=\"各个规则\"></a>各个规则</h4><ul>\n<li>C程序隐含规则:<n>.o的目标的依赖目标会是:<n>.c,命令是<code>$(CC) -c $(CPPFLAGS)$(CFLAGS)</code></li>\n<li>C++程序隐含规则:<n>.o的目标的依赖目标是:<n>.cc或<n>.C,命令是<code>$(CXX) -c  $(CPPFLAGS)$(CXXFLAGS)</code></li>\n<li>汇编和预处理隐含规则:<n>.o的目标的依赖目标会自动推导为<n>.s，默认使用编译器as，并且其生成命令是：<code>$ (AS) $(ASFLAGS)</code>。<n>.s的目标的依赖目标会自动推导为<n>.S，默认使用C预编译器cpp，并且其生成命令是：<code>$(AS) $(ASFLAGS)</code>。</li>\n<li>链接Object文件的隐含规则:<n>目标依赖于<n>.o，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是：<code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code>。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">x : y.o z.o<br></code></pre></td></tr></table></figure>\n隐含规则执行如下(x.c、y.c、z.c都存在):<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">cc -c x.c -o x.o<br>cc -c y.c -o y.o<br>cc -c z.c -o z.o<br>cc x.o y.o z.o -o x<br><span class=\"hljs-built_in\">rm</span> -f x.o<br><span class=\"hljs-built_in\">rm</span> -f y.o<br><span class=\"hljs-built_in\">rm</span> -f z.o<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"一些tip\"><a href=\"#一些tip\" class=\"headerlink\" title=\"一些tip\"></a>一些tip</h4><ul>\n<li>隐式规则产生的中间目标，最终会被自动删除，被makefile指定成的目标或依赖目标不能被当作中介，但是可以通过<code>.INTERMEDIATE</code>来强制声明为中间目标。如<code>.intermediate: mid</code></li>\n<li>也可以阻止自动删除中间目标，通过<code>.SECONDARY</code>来强制声明。如<code>.SECONDARY</code>。或以模式的方式指定(如：%.o)成为伪目标<code>.PRECIOUS</code>的依赖目标。</li>\n<li>Make会优化一些特殊的隐含规则，而不生成中间文件。从文件.c直接生成执行文件，不产生目标文件</li>\n</ul>\n<h4 id=\"模式规则来定义一个隐含规则\"><a href=\"#模式规则来定义一个隐含规则\" class=\"headerlink\" title=\"模式规则来定义一个隐含规则\"></a>模式规则来定义一个隐含规则</h4><p>模式规则，目标的定义需要有<code>%</code>字符。依赖目标随便，与变量不同的是，模式规则的展开发生在运行期间。<br>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">%.o: %.c<br> $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"隐含规则搜索算法\"><a href=\"#隐含规则搜索算法\" class=\"headerlink\" title=\"隐含规则搜索算法\"></a>隐含规则搜索算法</h4><p>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是archive(member)的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把member当作T来搜索。</p>\n<ol>\n<li>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是src&#x2F;foo.o，那么，D就是src&#x2F;，N就是foo.o）</li>\n<li>创建所有匹配于T或是N的模式规则列表。</li>\n<li>如果在模式规则列表中有匹配所有文件的模式，如%，那么从列表中移除其它的模式。</li>\n<li>移除列表中没有命令的规则。</li>\n<li>对于第一个在列表中的模式规则：</li>\n</ol>\n<ul>\n<li>推导其“茎”S，S应该是T或是N匹配于模式中%非空的部分。</li>\n<li>计算依赖文件。把依赖文件中的%都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li>\n<li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）</li>\n<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>\n</ul>\n<ol start=\"6\">\n<li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：</li>\n</ol>\n<ul>\n<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li>\n<li>计算依赖文件。（同第5步）</li>\n<li>测试所有的依赖文件是否存在或是理当存在。</li>\n<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li>\n<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li>\n<li>如果没有隐含规则可以使用，查看.DEFAULT规则，如果有，采用，把.DEFAULT的命令给T使用。</li>\n</ul>\n<h3 id=\"函数库打包\"><a href=\"#函数库打包\" class=\"headerlink\" title=\"函数库打包\"></a>函数库打包</h3><p>函数库文件也就是对.o文件的打包文件<br>示例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">foolib(hack.o xx.o): hack.o xx.o<br>\tar cr foolib hack.o xx.o <span class=\"hljs-comment\">#foolib是库名,hack.o是包含文件</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ul>\n<li>make中遇到的第一条规则是最终目标  </li>\n<li>和bash一样用空格和”&quot;进行换行</li>\n<li>命令总是以tab键开头,其余不是命令</li>\n<li><code>MAKEFILES</code>最好不用该环境变量,该变量类似于include动作,但其中文件中的目标不会起作用,最好置为空,以免引入未考虑到的东西,莫名奇妙出现问题时,可以查看该变量</li>\n<li>要想前面命令作用于后面命令,需要写在同一行上,用分号分隔,如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">exec</span>:<br>\t<span class=\"hljs-built_in\">cd</span> /home/nanbert;<span class=\"hljs-built_in\">pwd</span><br></code></pre></td></tr></table></figure></li>\n<li>可以在命令前加<code>-</code>,来忽略该命令可能执行失败,这也可用于include</li>\n</ul>\n"},{"title":"MariaDB","date":"2019-11-18T08:09:14.000Z","subtitle":null,"index_img":"/images/mariadb.jpeg","banner_img":"/images/mariadb.jpeg","_content":"# 启动/关闭  \n启动关闭用'systemctl'命令\n# `mysql`命令行工具:\n- `-h、--help`: 后接服务器地址,若是本地127.0.0.1,可以省略\n- `-p、--port`: 后接端口,默认是3306\n- `-u、--user`: 连接MariaDB服务器时用的用户名\n- `-p、--password`: 连接MariaDB服务器的密码\n- `-D、--database`: 连接MariaDB服务器时要使用的数据库\n- `--auto-rehash`: 在mysql客户端程序内输入表或列名时，使用TAB键可以自动补全\n- `--batch`: 以批处理模式(非交互模式)运行mysql客户端程序\n- `--execute、-e`: mysql客户端程序在连接MariaDB服务器的同时执行参数给出的语句\n- `--skip-column-names、-N`: 在mysql客户端中不显示查询结果中的列名\n- `--safe-updates、-U`: 以安全模式运行mysql客户端，安全模式下防止误操作\n# 文件位置\n默认数据库文件存放位置为:/var/lib/mysql\n读取配置文件顺序:/etc/my.cnf、/etc/mysql/my.cnf、~/.my.cnf\n# 创建、删除数据库\n- `CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET utf8mb4(指定字符集及排序方式)`\n- `DROP DATABASE 数据库名称`\n# 创建数据表\n- `USE test`进入指定的数据库test\n```sql\nCREATE TABLE [IF NOT EXISTS] tab_test (\ntid BIGINT NOT NULL AUTO_INCREMENT,\ntname VARCHAR(100) NOT NULL,\ntmemo TEXT NOT NULL,\nPRIMARY KEY (tid),\nINDEX ix_tname_tid (tname,tid)\n) ENGINE=InnoDB;\n```\n约束分为表约束和列约束，上述NOT NULL为列约束跟在每个列定义后面,而PRIMARY KEY为表约束可以指定多个列。\n完整性约束的基本语法格式：\n[CONSTRAINT<约束名>]<约束类型>,中括号中内容可以省略,约束类型有:NULL/NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK。 其中外键约束格式为:FOREIGN KEY REFERENCES <主表名>(<列名>),CHECK:CHECK(<约束条件>),约束条件举例:CHECK (Score>=0 AND Score<=100)\n# 查看数据表\n`SHOW CREATE TABLE test`\n修改数据表格式\n(待建设,各种情形不同处理,有点复杂)\n# 删除数据表\n`DROP TABLE <表名>`\n# 插入元组数据\n`INSERT INTO test (fd1,fd2) VALUES (1,'Matt') ON DUPLICATE KEY UPDATE fd2='Matt';`ON DUPLICATE KEY UPDATE选项可以确保若记录已存在则执行UPDATE,否则执行INSERT;\n# 检索元祖数据\n- `SELECT * FROM tab_test;`\n- `SELECT * FROM tab_test WHERE fd1=1;`\n条件查询可以有NOT、AND、OR(优先级从高到低);BETWEEN...AND...;IN(<值1>、<值2>);LIKE<字符串常量>('张％'代表姓张的人,`_力%`代表第二个字是力,%匹配0或多个字符);\n## 统计汇总查询常用函数\n- AVG:按列计算平均值\n- SUM:按列计算值的总和\n- MAX:求一列中的最大值\n- MIN:求一列中的最小值\n- COUNT:按列值计算个数\n例子:\n```sql\nSELECT MAX(Score) AS MaxScore,\n\t   MIN(Score) AS MinScore,\n\t   MAX(Score)-MIN(Score) AS Diff \n\t   FROM SC \n       WHERE(CNo='C1')\n```\n- `SELECT COUNT(DISTINCT Dept) AS DeptNum FROM S`DISTINCT关键字消除重复\n- `SELECT fd2 FROM tab_test;`\n```sql\nSELECT SNo,COUNT(*) AS SC_Num\nFROM SC\nGROUP BY SNo\nHAVING(COUNT(*)>=2)\n```\n这GROUP BY后面的属性表示若其相同，将在同一行呈现(相当于DISTINCT),但count将计算当前组的个数，而HAVING则是对GROUP BY进一步筛选,不能用where。\n```sql\nSELECT SNo,CNo,Score\nFROM SC\nWHERE CNo IN ('C2','C3','C4')\nORDER BY SNo,Score DESC\n```\n学号升序，分数降序排列\n- `SELECT * FROM tab_test\\G`注意这没有分号,按列输出记录\n## 多表内连接查询\n- 方法一:\n```sql\nSELECT T.TNo,TN,CNo\nFROM T,TC\nWHERE (T.TNo=TC.TNo) AND(TN='刘伟')\n//这里TN=‘刘伟为查询条件’T.TNo=TC.TNo为连接条件，TNo为连接字段\n```\n- 方法二:\n```sql\nSELECT T.TNo,TN,CNo \nFROM T INNER JOIN TC\nON T.TNo=TC.TNo WHERE(TN='刘伟')\n```\n## 多表外连接查询\n```sql\nSELECT S.SNo,SN,CN,Score\nFROM S\nLEFT OUTER JOIN SC\nON S.SNo=SC.SNo\nLEFT OUTER JOIN C\nON C.CNo=SC.CNo\n//外链接不符合条件的将置为NULL\n```\n## 多表交叉查询\n```sql\nSELECT * FROM S CROSS JOIN C\n//行数两个表行的乘积，列数为两个表的列数和\n```\n## 自连接查询(例子为查询所有比\"刘伟\"工资高的教师姓名、工资和刘伟的工资)\n- 方法一:\n```sql\nSELECT X.TN,X.Sal AS Sal_a,Y.Sal AS Sal_b\nFROM T AS X,T AS Y\nWHERE X.Sal>Y.Sal AND Y.TN='刘伟'\n```\n- 方法二:\n```sql\nSELECT X.TN,X.Sal,Y.Sal\nFROM T AS X INNER JOIN T AS Y\nON X.Sal>Y.Sal\nAND Y.TN='刘伟'\n```\n## 普通子查询\n```sql\nSELECT TNo,TN\nFROM T\nWHERE Prof= (SELECT Prof \n\t\tFROM T\n\t\tWHERE TN='刘伟')\n//查询与刘伟老师相同职称的老师姓名与工号\nSELECT TN\nFROM T\nWHERE (TNo = ANY (SELECT TNo\n\t\t\tFROM TC\n\t\t\tWHERE CNo = 'C5'))\n//查询讲授课程号为C5的教师姓名\n```\n## 相关子查询(它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询)\n```sql\nSELECT TN\nFROM T\nWHERE EXISTS (SELECT *\n\t\tFROM TC\n\t\tWHERE TNo=T.TNo AND CNo='C5')\n//查询讲授课程为C5的教师姓名\n```\n## 合并查询(就是把结果合并到一起)\n```sql\nSELECT SNo AS 学号,SUM(Score) AS 总分\nFROM SC\nWHERE (SNo = 'S1')\nGROUP BY SNo\nUNION\nSELECT SNo AS 学号,SUM(Score) AS 总分\nFROM SC\nWHERE (SNo = 'S5')\nGROUP BY SNo\n```\n## 存储查询\n```sql\nSELECT SNo AS 学号,SUM(Score) AS 总分\nINTO Cal_Table\nFROM SC\nGROUP BY SNo\n//如果在新表名前面加个#则是临时表，关闭则消失\n```\n# 修改元祖数据\n`UPDATE tab_test SET fd2='Brandon' WHERE fd1=1`如果没有WHERE则所有元祖的fd2都将改变，请一定小心\n`REPLACE tab_test SET fd1=1,fd2='Matt';`若记录存在执行UPDATE,否则执行INSERT,最好用INSERT加ON DUPLICATE KEY UPDATE命令,资源消耗更小。\n# 删除元祖数据\n`DELETE FROM tab_test WHERE fd1=1;`同理没有WHERE将会删除所有元组\n# 视图(是一个虚表,基于基本表，对其修改会影响基本表，但本身不占内存)\n```sql\nCREATE VIEW Sub_T\nAS SELECT TNo,TN,Prof\nFROM T\nWHERE Dept = '计算机'\n//创建一个计算机系老师情况的视图Sub_T\nALTER VIEW S_SC_C(SN,CN,Score)\nAS SELECT SN,CN,Score\n FROM S,C,SC\n WHERE S.SNo=SC.SNo AND SC.CNo=C.CNo\n//修改,就是查询内容的覆盖\n```\n对表的操作适用于视图，可以通过视图简化操作\n# 索引(待建)\n# 规则约束  \n## 创建规则\n`CREATE RULE age_rule AS@age >=18and @age <= 50`\n## 将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\n用sp_bindrule绑定规则\n`EXEC sp_bindrule 'age_rule','S.Age'`对已输入的数据不起作用\n`EXEC sp_unbindrule 'S.Age'`解绑\n## 删除规则\n`DROP RULE age_rule`删除前必须先解绑\n# 默认  \n## 创建默认\n`CREATE DEFAULT birthday_defa AS '1978-1-1'`\n## 查看默认\n`EXEC sp_helptext birthday_defa`\n## 默认的绑定与解绑\n`EXEC sp_bindefault 'birthday_defa' 'S.[Birthday]'`\n`EXEC sp_unbinefault 'S.[Birthday]'`\n## 删除默认\n`DROP DEFAULT birthday_defa`\n","source":"_posts/MariaDB.md","raw":"---\ntitle: MariaDB\ndate: 2019-11-18 16:09:14\nsubtitle:\ncategories:\ntags:\nindex_img: /images/mariadb.jpeg\nbanner_img: /images/mariadb.jpeg\n---\n# 启动/关闭  \n启动关闭用'systemctl'命令\n# `mysql`命令行工具:\n- `-h、--help`: 后接服务器地址,若是本地127.0.0.1,可以省略\n- `-p、--port`: 后接端口,默认是3306\n- `-u、--user`: 连接MariaDB服务器时用的用户名\n- `-p、--password`: 连接MariaDB服务器的密码\n- `-D、--database`: 连接MariaDB服务器时要使用的数据库\n- `--auto-rehash`: 在mysql客户端程序内输入表或列名时，使用TAB键可以自动补全\n- `--batch`: 以批处理模式(非交互模式)运行mysql客户端程序\n- `--execute、-e`: mysql客户端程序在连接MariaDB服务器的同时执行参数给出的语句\n- `--skip-column-names、-N`: 在mysql客户端中不显示查询结果中的列名\n- `--safe-updates、-U`: 以安全模式运行mysql客户端，安全模式下防止误操作\n# 文件位置\n默认数据库文件存放位置为:/var/lib/mysql\n读取配置文件顺序:/etc/my.cnf、/etc/mysql/my.cnf、~/.my.cnf\n# 创建、删除数据库\n- `CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET utf8mb4(指定字符集及排序方式)`\n- `DROP DATABASE 数据库名称`\n# 创建数据表\n- `USE test`进入指定的数据库test\n```sql\nCREATE TABLE [IF NOT EXISTS] tab_test (\ntid BIGINT NOT NULL AUTO_INCREMENT,\ntname VARCHAR(100) NOT NULL,\ntmemo TEXT NOT NULL,\nPRIMARY KEY (tid),\nINDEX ix_tname_tid (tname,tid)\n) ENGINE=InnoDB;\n```\n约束分为表约束和列约束，上述NOT NULL为列约束跟在每个列定义后面,而PRIMARY KEY为表约束可以指定多个列。\n完整性约束的基本语法格式：\n[CONSTRAINT<约束名>]<约束类型>,中括号中内容可以省略,约束类型有:NULL/NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK。 其中外键约束格式为:FOREIGN KEY REFERENCES <主表名>(<列名>),CHECK:CHECK(<约束条件>),约束条件举例:CHECK (Score>=0 AND Score<=100)\n# 查看数据表\n`SHOW CREATE TABLE test`\n修改数据表格式\n(待建设,各种情形不同处理,有点复杂)\n# 删除数据表\n`DROP TABLE <表名>`\n# 插入元组数据\n`INSERT INTO test (fd1,fd2) VALUES (1,'Matt') ON DUPLICATE KEY UPDATE fd2='Matt';`ON DUPLICATE KEY UPDATE选项可以确保若记录已存在则执行UPDATE,否则执行INSERT;\n# 检索元祖数据\n- `SELECT * FROM tab_test;`\n- `SELECT * FROM tab_test WHERE fd1=1;`\n条件查询可以有NOT、AND、OR(优先级从高到低);BETWEEN...AND...;IN(<值1>、<值2>);LIKE<字符串常量>('张％'代表姓张的人,`_力%`代表第二个字是力,%匹配0或多个字符);\n## 统计汇总查询常用函数\n- AVG:按列计算平均值\n- SUM:按列计算值的总和\n- MAX:求一列中的最大值\n- MIN:求一列中的最小值\n- COUNT:按列值计算个数\n例子:\n```sql\nSELECT MAX(Score) AS MaxScore,\n\t   MIN(Score) AS MinScore,\n\t   MAX(Score)-MIN(Score) AS Diff \n\t   FROM SC \n       WHERE(CNo='C1')\n```\n- `SELECT COUNT(DISTINCT Dept) AS DeptNum FROM S`DISTINCT关键字消除重复\n- `SELECT fd2 FROM tab_test;`\n```sql\nSELECT SNo,COUNT(*) AS SC_Num\nFROM SC\nGROUP BY SNo\nHAVING(COUNT(*)>=2)\n```\n这GROUP BY后面的属性表示若其相同，将在同一行呈现(相当于DISTINCT),但count将计算当前组的个数，而HAVING则是对GROUP BY进一步筛选,不能用where。\n```sql\nSELECT SNo,CNo,Score\nFROM SC\nWHERE CNo IN ('C2','C3','C4')\nORDER BY SNo,Score DESC\n```\n学号升序，分数降序排列\n- `SELECT * FROM tab_test\\G`注意这没有分号,按列输出记录\n## 多表内连接查询\n- 方法一:\n```sql\nSELECT T.TNo,TN,CNo\nFROM T,TC\nWHERE (T.TNo=TC.TNo) AND(TN='刘伟')\n//这里TN=‘刘伟为查询条件’T.TNo=TC.TNo为连接条件，TNo为连接字段\n```\n- 方法二:\n```sql\nSELECT T.TNo,TN,CNo \nFROM T INNER JOIN TC\nON T.TNo=TC.TNo WHERE(TN='刘伟')\n```\n## 多表外连接查询\n```sql\nSELECT S.SNo,SN,CN,Score\nFROM S\nLEFT OUTER JOIN SC\nON S.SNo=SC.SNo\nLEFT OUTER JOIN C\nON C.CNo=SC.CNo\n//外链接不符合条件的将置为NULL\n```\n## 多表交叉查询\n```sql\nSELECT * FROM S CROSS JOIN C\n//行数两个表行的乘积，列数为两个表的列数和\n```\n## 自连接查询(例子为查询所有比\"刘伟\"工资高的教师姓名、工资和刘伟的工资)\n- 方法一:\n```sql\nSELECT X.TN,X.Sal AS Sal_a,Y.Sal AS Sal_b\nFROM T AS X,T AS Y\nWHERE X.Sal>Y.Sal AND Y.TN='刘伟'\n```\n- 方法二:\n```sql\nSELECT X.TN,X.Sal,Y.Sal\nFROM T AS X INNER JOIN T AS Y\nON X.Sal>Y.Sal\nAND Y.TN='刘伟'\n```\n## 普通子查询\n```sql\nSELECT TNo,TN\nFROM T\nWHERE Prof= (SELECT Prof \n\t\tFROM T\n\t\tWHERE TN='刘伟')\n//查询与刘伟老师相同职称的老师姓名与工号\nSELECT TN\nFROM T\nWHERE (TNo = ANY (SELECT TNo\n\t\t\tFROM TC\n\t\t\tWHERE CNo = 'C5'))\n//查询讲授课程号为C5的教师姓名\n```\n## 相关子查询(它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询)\n```sql\nSELECT TN\nFROM T\nWHERE EXISTS (SELECT *\n\t\tFROM TC\n\t\tWHERE TNo=T.TNo AND CNo='C5')\n//查询讲授课程为C5的教师姓名\n```\n## 合并查询(就是把结果合并到一起)\n```sql\nSELECT SNo AS 学号,SUM(Score) AS 总分\nFROM SC\nWHERE (SNo = 'S1')\nGROUP BY SNo\nUNION\nSELECT SNo AS 学号,SUM(Score) AS 总分\nFROM SC\nWHERE (SNo = 'S5')\nGROUP BY SNo\n```\n## 存储查询\n```sql\nSELECT SNo AS 学号,SUM(Score) AS 总分\nINTO Cal_Table\nFROM SC\nGROUP BY SNo\n//如果在新表名前面加个#则是临时表，关闭则消失\n```\n# 修改元祖数据\n`UPDATE tab_test SET fd2='Brandon' WHERE fd1=1`如果没有WHERE则所有元祖的fd2都将改变，请一定小心\n`REPLACE tab_test SET fd1=1,fd2='Matt';`若记录存在执行UPDATE,否则执行INSERT,最好用INSERT加ON DUPLICATE KEY UPDATE命令,资源消耗更小。\n# 删除元祖数据\n`DELETE FROM tab_test WHERE fd1=1;`同理没有WHERE将会删除所有元组\n# 视图(是一个虚表,基于基本表，对其修改会影响基本表，但本身不占内存)\n```sql\nCREATE VIEW Sub_T\nAS SELECT TNo,TN,Prof\nFROM T\nWHERE Dept = '计算机'\n//创建一个计算机系老师情况的视图Sub_T\nALTER VIEW S_SC_C(SN,CN,Score)\nAS SELECT SN,CN,Score\n FROM S,C,SC\n WHERE S.SNo=SC.SNo AND SC.CNo=C.CNo\n//修改,就是查询内容的覆盖\n```\n对表的操作适用于视图，可以通过视图简化操作\n# 索引(待建)\n# 规则约束  \n## 创建规则\n`CREATE RULE age_rule AS@age >=18and @age <= 50`\n## 将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\n用sp_bindrule绑定规则\n`EXEC sp_bindrule 'age_rule','S.Age'`对已输入的数据不起作用\n`EXEC sp_unbindrule 'S.Age'`解绑\n## 删除规则\n`DROP RULE age_rule`删除前必须先解绑\n# 默认  \n## 创建默认\n`CREATE DEFAULT birthday_defa AS '1978-1-1'`\n## 查看默认\n`EXEC sp_helptext birthday_defa`\n## 默认的绑定与解绑\n`EXEC sp_bindefault 'birthday_defa' 'S.[Birthday]'`\n`EXEC sp_unbinefault 'S.[Birthday]'`\n## 删除默认\n`DROP DEFAULT birthday_defa`\n","slug":"MariaDB","published":1,"updated":"2024-08-22T22:04:29.715Z","_id":"clq1yvi6x000ngwq2bxsyfvi4","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"启动-关闭\"><a href=\"#启动-关闭\" class=\"headerlink\" title=\"启动&#x2F;关闭\"></a>启动&#x2F;关闭</h1><p>启动关闭用’systemctl’命令</p>\n<h1 id=\"mysql命令行工具\"><a href=\"#mysql命令行工具\" class=\"headerlink\" title=\"mysql命令行工具:\"></a><code>mysql</code>命令行工具:</h1><ul>\n<li><code>-h、--help</code>: 后接服务器地址,若是本地127.0.0.1,可以省略</li>\n<li><code>-p、--port</code>: 后接端口,默认是3306</li>\n<li><code>-u、--user</code>: 连接MariaDB服务器时用的用户名</li>\n<li><code>-p、--password</code>: 连接MariaDB服务器的密码</li>\n<li><code>-D、--database</code>: 连接MariaDB服务器时要使用的数据库</li>\n<li><code>--auto-rehash</code>: 在mysql客户端程序内输入表或列名时，使用TAB键可以自动补全</li>\n<li><code>--batch</code>: 以批处理模式(非交互模式)运行mysql客户端程序</li>\n<li><code>--execute、-e</code>: mysql客户端程序在连接MariaDB服务器的同时执行参数给出的语句</li>\n<li><code>--skip-column-names、-N</code>: 在mysql客户端中不显示查询结果中的列名</li>\n<li><code>--safe-updates、-U</code>: 以安全模式运行mysql客户端，安全模式下防止误操作</li>\n</ul>\n<h1 id=\"文件位置\"><a href=\"#文件位置\" class=\"headerlink\" title=\"文件位置\"></a>文件位置</h1><p>默认数据库文件存放位置为:&#x2F;var&#x2F;lib&#x2F;mysql<br>读取配置文件顺序:&#x2F;etc&#x2F;my.cnf、&#x2F;etc&#x2F;mysql&#x2F;my.cnf、~&#x2F;.my.cnf</p>\n<h1 id=\"创建、删除数据库\"><a href=\"#创建、删除数据库\" class=\"headerlink\" title=\"创建、删除数据库\"></a>创建、删除数据库</h1><ul>\n<li><code>CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET utf8mb4(指定字符集及排序方式)</code></li>\n<li><code>DROP DATABASE 数据库名称</code></li>\n</ul>\n<h1 id=\"创建数据表\"><a href=\"#创建数据表\" class=\"headerlink\" title=\"创建数据表\"></a>创建数据表</h1><ul>\n<li><code>USE test</code>进入指定的数据库test<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> [IF <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span>] tab_test (<br>tid <span class=\"hljs-type\">BIGINT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT,<br>tname <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,<br>tmemo TEXT <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,<br><span class=\"hljs-keyword\">PRIMARY</span> KEY (tid),<br>INDEX ix_tname_tid (tname,tid)<br>) ENGINE<span class=\"hljs-operator\">=</span>InnoDB;<br></code></pre></td></tr></table></figure>\n约束分为表约束和列约束，上述NOT NULL为列约束跟在每个列定义后面,而PRIMARY KEY为表约束可以指定多个列。<br>完整性约束的基本语法格式：<br>[CONSTRAINT&lt;约束名&gt;]&lt;约束类型&gt;,中括号中内容可以省略,约束类型有:NULL&#x2F;NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK。 其中外键约束格式为:FOREIGN KEY REFERENCES &lt;主表名&gt;(&lt;列名&gt;),CHECK:CHECK(&lt;约束条件&gt;),约束条件举例:CHECK (Score&gt;&#x3D;0 AND Score&lt;&#x3D;100)</li>\n</ul>\n<h1 id=\"查看数据表\"><a href=\"#查看数据表\" class=\"headerlink\" title=\"查看数据表\"></a>查看数据表</h1><p><code>SHOW CREATE TABLE test</code><br>修改数据表格式<br>(待建设,各种情形不同处理,有点复杂)</p>\n<h1 id=\"删除数据表\"><a href=\"#删除数据表\" class=\"headerlink\" title=\"删除数据表\"></a>删除数据表</h1><p><code>DROP TABLE &lt;表名&gt;</code></p>\n<h1 id=\"插入元组数据\"><a href=\"#插入元组数据\" class=\"headerlink\" title=\"插入元组数据\"></a>插入元组数据</h1><p><code>INSERT INTO test (fd1,fd2) VALUES (1,&#39;Matt&#39;) ON DUPLICATE KEY UPDATE fd2=&#39;Matt&#39;;</code>ON DUPLICATE KEY UPDATE选项可以确保若记录已存在则执行UPDATE,否则执行INSERT;</p>\n<h1 id=\"检索元祖数据\"><a href=\"#检索元祖数据\" class=\"headerlink\" title=\"检索元祖数据\"></a>检索元祖数据</h1><ul>\n<li><code>SELECT * FROM tab_test;</code></li>\n<li><code>SELECT * FROM tab_test WHERE fd1=1;</code><br>条件查询可以有NOT、AND、OR(优先级从高到低);BETWEEN…AND…;IN(&lt;值1&gt;、&lt;值2&gt;);LIKE&lt;字符串常量&gt;(‘张％’代表姓张的人,<code>_力%</code>代表第二个字是力,%匹配0或多个字符);</li>\n</ul>\n<h2 id=\"统计汇总查询常用函数\"><a href=\"#统计汇总查询常用函数\" class=\"headerlink\" title=\"统计汇总查询常用函数\"></a>统计汇总查询常用函数</h2><ul>\n<li>AVG:按列计算平均值</li>\n<li>SUM:按列计算值的总和</li>\n<li>MAX:求一列中的最大值</li>\n<li>MIN:求一列中的最小值</li>\n<li>COUNT:按列值计算个数<br>例子:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">MAX</span>(Score) <span class=\"hljs-keyword\">AS</span> MaxScore,<br>\t   <span class=\"hljs-built_in\">MIN</span>(Score) <span class=\"hljs-keyword\">AS</span> MinScore,<br>\t   <span class=\"hljs-built_in\">MAX</span>(Score)<span class=\"hljs-operator\">-</span><span class=\"hljs-built_in\">MIN</span>(Score) <span class=\"hljs-keyword\">AS</span> Diff <br>\t   <span class=\"hljs-keyword\">FROM</span> SC <br>       <span class=\"hljs-keyword\">WHERE</span>(CNo<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;C1&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><code>SELECT COUNT(DISTINCT Dept) AS DeptNum FROM S</code>DISTINCT关键字消除重复</li>\n<li><code>SELECT fd2 FROM tab_test;</code><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo,<span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> SC_Num<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br><span class=\"hljs-keyword\">HAVING</span>(<span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>)<span class=\"hljs-operator\">&gt;=</span><span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n这GROUP BY后面的属性表示若其相同，将在同一行呈现(相当于DISTINCT),但count将计算当前组的个数，而HAVING则是对GROUP BY进一步筛选,不能用where。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo,CNo,Score<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">WHERE</span> CNo <span class=\"hljs-keyword\">IN</span> (<span class=\"hljs-string\">&#x27;C2&#x27;</span>,<span class=\"hljs-string\">&#x27;C3&#x27;</span>,<span class=\"hljs-string\">&#x27;C4&#x27;</span>)<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> SNo,Score <span class=\"hljs-keyword\">DESC</span><br></code></pre></td></tr></table></figure>\n学号升序，分数降序排列</li>\n<li><code>SELECT * FROM tab_test\\G</code>注意这没有分号,按列输出记录</li>\n</ul>\n<h2 id=\"多表内连接查询\"><a href=\"#多表内连接查询\" class=\"headerlink\" title=\"多表内连接查询\"></a>多表内连接查询</h2><ul>\n<li>方法一:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> T.TNo,TN,CNo<br><span class=\"hljs-keyword\">FROM</span> T,TC<br><span class=\"hljs-keyword\">WHERE</span> (T.TNo<span class=\"hljs-operator\">=</span>TC.TNo) <span class=\"hljs-keyword\">AND</span>(TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span>)<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>这里TN<span class=\"hljs-operator\">=</span>‘刘伟为查询条件’T.TNo<span class=\"hljs-operator\">=</span>TC.TNo为连接条件，TNo为连接字段<br></code></pre></td></tr></table></figure></li>\n<li>方法二:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> T.TNo,TN,CNo <br><span class=\"hljs-keyword\">FROM</span> T <span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> TC<br><span class=\"hljs-keyword\">ON</span> T.TNo<span class=\"hljs-operator\">=</span>TC.TNo <span class=\"hljs-keyword\">WHERE</span>(TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"多表外连接查询\"><a href=\"#多表外连接查询\" class=\"headerlink\" title=\"多表外连接查询\"></a>多表外连接查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> S.SNo,SN,CN,Score<br><span class=\"hljs-keyword\">FROM</span> S<br><span class=\"hljs-keyword\">LEFT</span> <span class=\"hljs-keyword\">OUTER</span> <span class=\"hljs-keyword\">JOIN</span> SC<br><span class=\"hljs-keyword\">ON</span> S.SNo<span class=\"hljs-operator\">=</span>SC.SNo<br><span class=\"hljs-keyword\">LEFT</span> <span class=\"hljs-keyword\">OUTER</span> <span class=\"hljs-keyword\">JOIN</span> C<br><span class=\"hljs-keyword\">ON</span> C.CNo<span class=\"hljs-operator\">=</span>SC.CNo<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>外链接不符合条件的将置为<span class=\"hljs-keyword\">NULL</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"多表交叉查询\"><a href=\"#多表交叉查询\" class=\"headerlink\" title=\"多表交叉查询\"></a>多表交叉查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> S <span class=\"hljs-keyword\">CROSS</span> <span class=\"hljs-keyword\">JOIN</span> C<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>行数两个表行的乘积，列数为两个表的列数和<br></code></pre></td></tr></table></figure>\n<h2 id=\"自连接查询-例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资\"><a href=\"#自连接查询-例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资\" class=\"headerlink\" title=\"自连接查询(例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资)\"></a>自连接查询(例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资)</h2><ul>\n<li>方法一:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> X.TN,X.Sal <span class=\"hljs-keyword\">AS</span> Sal_a,Y.Sal <span class=\"hljs-keyword\">AS</span> Sal_b<br><span class=\"hljs-keyword\">FROM</span> T <span class=\"hljs-keyword\">AS</span> X,T <span class=\"hljs-keyword\">AS</span> Y<br><span class=\"hljs-keyword\">WHERE</span> X.Sal<span class=\"hljs-operator\">&gt;</span>Y.Sal <span class=\"hljs-keyword\">AND</span> Y.TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>方法二:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> X.TN,X.Sal,Y.Sal<br><span class=\"hljs-keyword\">FROM</span> T <span class=\"hljs-keyword\">AS</span> X <span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> T <span class=\"hljs-keyword\">AS</span> Y<br><span class=\"hljs-keyword\">ON</span> X.Sal<span class=\"hljs-operator\">&gt;</span>Y.Sal<br><span class=\"hljs-keyword\">AND</span> Y.TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"普通子查询\"><a href=\"#普通子查询\" class=\"headerlink\" title=\"普通子查询\"></a>普通子查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> TNo,TN<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> Prof<span class=\"hljs-operator\">=</span> (<span class=\"hljs-keyword\">SELECT</span> Prof <br>\t\t<span class=\"hljs-keyword\">FROM</span> T<br>\t\t<span class=\"hljs-keyword\">WHERE</span> TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span>)<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>查询与刘伟老师相同职称的老师姓名与工号<br><span class=\"hljs-keyword\">SELECT</span> TN<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> (TNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">ANY</span> (<span class=\"hljs-keyword\">SELECT</span> TNo<br>\t\t\t<span class=\"hljs-keyword\">FROM</span> TC<br>\t\t\t<span class=\"hljs-keyword\">WHERE</span> CNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;C5&#x27;</span>))<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>查询讲授课程号为C5的教师姓名<br></code></pre></td></tr></table></figure>\n<h2 id=\"相关子查询-它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询\"><a href=\"#相关子查询-它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询\" class=\"headerlink\" title=\"相关子查询(它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询)\"></a>相关子查询(它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询)</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> TN<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">EXISTS</span> (<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span><br>\t\t<span class=\"hljs-keyword\">FROM</span> TC<br>\t\t<span class=\"hljs-keyword\">WHERE</span> TNo<span class=\"hljs-operator\">=</span>T.TNo <span class=\"hljs-keyword\">AND</span> CNo<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;C5&#x27;</span>)<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>查询讲授课程为C5的教师姓名<br></code></pre></td></tr></table></figure>\n<h2 id=\"合并查询-就是把结果合并到一起\"><a href=\"#合并查询-就是把结果合并到一起\" class=\"headerlink\" title=\"合并查询(就是把结果合并到一起)\"></a>合并查询(就是把结果合并到一起)</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo <span class=\"hljs-keyword\">AS</span> 学号,<span class=\"hljs-built_in\">SUM</span>(Score) <span class=\"hljs-keyword\">AS</span> 总分<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">WHERE</span> (SNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;S1&#x27;</span>)<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br><span class=\"hljs-keyword\">UNION</span><br><span class=\"hljs-keyword\">SELECT</span> SNo <span class=\"hljs-keyword\">AS</span> 学号,<span class=\"hljs-built_in\">SUM</span>(Score) <span class=\"hljs-keyword\">AS</span> 总分<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">WHERE</span> (SNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;S5&#x27;</span>)<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br></code></pre></td></tr></table></figure>\n<h2 id=\"存储查询\"><a href=\"#存储查询\" class=\"headerlink\" title=\"存储查询\"></a>存储查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo <span class=\"hljs-keyword\">AS</span> 学号,<span class=\"hljs-built_in\">SUM</span>(Score) <span class=\"hljs-keyword\">AS</span> 总分<br><span class=\"hljs-keyword\">INTO</span> Cal_Table<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>如果在新表名前面加个#则是临时表，关闭则消失<br></code></pre></td></tr></table></figure>\n<h1 id=\"修改元祖数据\"><a href=\"#修改元祖数据\" class=\"headerlink\" title=\"修改元祖数据\"></a>修改元祖数据</h1><p><code>UPDATE tab_test SET fd2=&#39;Brandon&#39; WHERE fd1=1</code>如果没有WHERE则所有元祖的fd2都将改变，请一定小心<br><code>REPLACE tab_test SET fd1=1,fd2=&#39;Matt&#39;;</code>若记录存在执行UPDATE,否则执行INSERT,最好用INSERT加ON DUPLICATE KEY UPDATE命令,资源消耗更小。</p>\n<h1 id=\"删除元祖数据\"><a href=\"#删除元祖数据\" class=\"headerlink\" title=\"删除元祖数据\"></a>删除元祖数据</h1><p><code>DELETE FROM tab_test WHERE fd1=1;</code>同理没有WHERE将会删除所有元组</p>\n<h1 id=\"视图-是一个虚表-基于基本表，对其修改会影响基本表，但本身不占内存\"><a href=\"#视图-是一个虚表-基于基本表，对其修改会影响基本表，但本身不占内存\" class=\"headerlink\" title=\"视图(是一个虚表,基于基本表，对其修改会影响基本表，但本身不占内存)\"></a>视图(是一个虚表,基于基本表，对其修改会影响基本表，但本身不占内存)</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> Sub_T<br><span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> TNo,TN,Prof<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> Dept <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;计算机&#x27;</span><br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>创建一个计算机系老师情况的视图Sub_T<br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">VIEW</span> S_SC_C(SN,CN,Score)<br><span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> SN,CN,Score<br> <span class=\"hljs-keyword\">FROM</span> S,C,SC<br> <span class=\"hljs-keyword\">WHERE</span> S.SNo<span class=\"hljs-operator\">=</span>SC.SNo <span class=\"hljs-keyword\">AND</span> SC.CNo<span class=\"hljs-operator\">=</span>C.CNo<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>修改,就是查询内容的覆盖<br></code></pre></td></tr></table></figure>\n<p>对表的操作适用于视图，可以通过视图简化操作</p>\n<h1 id=\"索引-待建\"><a href=\"#索引-待建\" class=\"headerlink\" title=\"索引(待建)\"></a>索引(待建)</h1><h1 id=\"规则约束\"><a href=\"#规则约束\" class=\"headerlink\" title=\"规则约束\"></a>规则约束</h1><h2 id=\"创建规则\"><a href=\"#创建规则\" class=\"headerlink\" title=\"创建规则\"></a>创建规则</h2><p><code>CREATE RULE age_rule AS@age &gt;=18and @age &lt;= 50</code></p>\n<h2 id=\"将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\"><a href=\"#将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\" class=\"headerlink\" title=\"将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\"></a>将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑</h2><p>用sp_bindrule绑定规则<br><code>EXEC sp_bindrule &#39;age_rule&#39;,&#39;S.Age&#39;</code>对已输入的数据不起作用<br><code>EXEC sp_unbindrule &#39;S.Age&#39;</code>解绑</p>\n<h2 id=\"删除规则\"><a href=\"#删除规则\" class=\"headerlink\" title=\"删除规则\"></a>删除规则</h2><p><code>DROP RULE age_rule</code>删除前必须先解绑</p>\n<h1 id=\"默认\"><a href=\"#默认\" class=\"headerlink\" title=\"默认\"></a>默认</h1><h2 id=\"创建默认\"><a href=\"#创建默认\" class=\"headerlink\" title=\"创建默认\"></a>创建默认</h2><p><code>CREATE DEFAULT birthday_defa AS &#39;1978-1-1&#39;</code></p>\n<h2 id=\"查看默认\"><a href=\"#查看默认\" class=\"headerlink\" title=\"查看默认\"></a>查看默认</h2><p><code>EXEC sp_helptext birthday_defa</code></p>\n<h2 id=\"默认的绑定与解绑\"><a href=\"#默认的绑定与解绑\" class=\"headerlink\" title=\"默认的绑定与解绑\"></a>默认的绑定与解绑</h2><p><code>EXEC sp_bindefault &#39;birthday_defa&#39; &#39;S.[Birthday]&#39;</code><br><code>EXEC sp_unbinefault &#39;S.[Birthday]&#39;</code></p>\n<h2 id=\"删除默认\"><a href=\"#删除默认\" class=\"headerlink\" title=\"删除默认\"></a>删除默认</h2><p><code>DROP DEFAULT birthday_defa</code></p>\n","excerpt":"","more":"<h1 id=\"启动-关闭\"><a href=\"#启动-关闭\" class=\"headerlink\" title=\"启动&#x2F;关闭\"></a>启动&#x2F;关闭</h1><p>启动关闭用’systemctl’命令</p>\n<h1 id=\"mysql命令行工具\"><a href=\"#mysql命令行工具\" class=\"headerlink\" title=\"mysql命令行工具:\"></a><code>mysql</code>命令行工具:</h1><ul>\n<li><code>-h、--help</code>: 后接服务器地址,若是本地127.0.0.1,可以省略</li>\n<li><code>-p、--port</code>: 后接端口,默认是3306</li>\n<li><code>-u、--user</code>: 连接MariaDB服务器时用的用户名</li>\n<li><code>-p、--password</code>: 连接MariaDB服务器的密码</li>\n<li><code>-D、--database</code>: 连接MariaDB服务器时要使用的数据库</li>\n<li><code>--auto-rehash</code>: 在mysql客户端程序内输入表或列名时，使用TAB键可以自动补全</li>\n<li><code>--batch</code>: 以批处理模式(非交互模式)运行mysql客户端程序</li>\n<li><code>--execute、-e</code>: mysql客户端程序在连接MariaDB服务器的同时执行参数给出的语句</li>\n<li><code>--skip-column-names、-N</code>: 在mysql客户端中不显示查询结果中的列名</li>\n<li><code>--safe-updates、-U</code>: 以安全模式运行mysql客户端，安全模式下防止误操作</li>\n</ul>\n<h1 id=\"文件位置\"><a href=\"#文件位置\" class=\"headerlink\" title=\"文件位置\"></a>文件位置</h1><p>默认数据库文件存放位置为:&#x2F;var&#x2F;lib&#x2F;mysql<br>读取配置文件顺序:&#x2F;etc&#x2F;my.cnf、&#x2F;etc&#x2F;mysql&#x2F;my.cnf、~&#x2F;.my.cnf</p>\n<h1 id=\"创建、删除数据库\"><a href=\"#创建、删除数据库\" class=\"headerlink\" title=\"创建、删除数据库\"></a>创建、删除数据库</h1><ul>\n<li><code>CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET utf8mb4(指定字符集及排序方式)</code></li>\n<li><code>DROP DATABASE 数据库名称</code></li>\n</ul>\n<h1 id=\"创建数据表\"><a href=\"#创建数据表\" class=\"headerlink\" title=\"创建数据表\"></a>创建数据表</h1><ul>\n<li><code>USE test</code>进入指定的数据库test<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> [IF <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span>] tab_test (<br>tid <span class=\"hljs-type\">BIGINT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT,<br>tname <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,<br>tmemo TEXT <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,<br><span class=\"hljs-keyword\">PRIMARY</span> KEY (tid),<br>INDEX ix_tname_tid (tname,tid)<br>) ENGINE<span class=\"hljs-operator\">=</span>InnoDB;<br></code></pre></td></tr></table></figure>\n约束分为表约束和列约束，上述NOT NULL为列约束跟在每个列定义后面,而PRIMARY KEY为表约束可以指定多个列。<br>完整性约束的基本语法格式：<br>[CONSTRAINT&lt;约束名&gt;]&lt;约束类型&gt;,中括号中内容可以省略,约束类型有:NULL&#x2F;NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK。 其中外键约束格式为:FOREIGN KEY REFERENCES &lt;主表名&gt;(&lt;列名&gt;),CHECK:CHECK(&lt;约束条件&gt;),约束条件举例:CHECK (Score&gt;&#x3D;0 AND Score&lt;&#x3D;100)</li>\n</ul>\n<h1 id=\"查看数据表\"><a href=\"#查看数据表\" class=\"headerlink\" title=\"查看数据表\"></a>查看数据表</h1><p><code>SHOW CREATE TABLE test</code><br>修改数据表格式<br>(待建设,各种情形不同处理,有点复杂)</p>\n<h1 id=\"删除数据表\"><a href=\"#删除数据表\" class=\"headerlink\" title=\"删除数据表\"></a>删除数据表</h1><p><code>DROP TABLE &lt;表名&gt;</code></p>\n<h1 id=\"插入元组数据\"><a href=\"#插入元组数据\" class=\"headerlink\" title=\"插入元组数据\"></a>插入元组数据</h1><p><code>INSERT INTO test (fd1,fd2) VALUES (1,&#39;Matt&#39;) ON DUPLICATE KEY UPDATE fd2=&#39;Matt&#39;;</code>ON DUPLICATE KEY UPDATE选项可以确保若记录已存在则执行UPDATE,否则执行INSERT;</p>\n<h1 id=\"检索元祖数据\"><a href=\"#检索元祖数据\" class=\"headerlink\" title=\"检索元祖数据\"></a>检索元祖数据</h1><ul>\n<li><code>SELECT * FROM tab_test;</code></li>\n<li><code>SELECT * FROM tab_test WHERE fd1=1;</code><br>条件查询可以有NOT、AND、OR(优先级从高到低);BETWEEN…AND…;IN(&lt;值1&gt;、&lt;值2&gt;);LIKE&lt;字符串常量&gt;(‘张％’代表姓张的人,<code>_力%</code>代表第二个字是力,%匹配0或多个字符);</li>\n</ul>\n<h2 id=\"统计汇总查询常用函数\"><a href=\"#统计汇总查询常用函数\" class=\"headerlink\" title=\"统计汇总查询常用函数\"></a>统计汇总查询常用函数</h2><ul>\n<li>AVG:按列计算平均值</li>\n<li>SUM:按列计算值的总和</li>\n<li>MAX:求一列中的最大值</li>\n<li>MIN:求一列中的最小值</li>\n<li>COUNT:按列值计算个数<br>例子:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">MAX</span>(Score) <span class=\"hljs-keyword\">AS</span> MaxScore,<br>\t   <span class=\"hljs-built_in\">MIN</span>(Score) <span class=\"hljs-keyword\">AS</span> MinScore,<br>\t   <span class=\"hljs-built_in\">MAX</span>(Score)<span class=\"hljs-operator\">-</span><span class=\"hljs-built_in\">MIN</span>(Score) <span class=\"hljs-keyword\">AS</span> Diff <br>\t   <span class=\"hljs-keyword\">FROM</span> SC <br>       <span class=\"hljs-keyword\">WHERE</span>(CNo<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;C1&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><code>SELECT COUNT(DISTINCT Dept) AS DeptNum FROM S</code>DISTINCT关键字消除重复</li>\n<li><code>SELECT fd2 FROM tab_test;</code><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo,<span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> SC_Num<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br><span class=\"hljs-keyword\">HAVING</span>(<span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>)<span class=\"hljs-operator\">&gt;=</span><span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n这GROUP BY后面的属性表示若其相同，将在同一行呈现(相当于DISTINCT),但count将计算当前组的个数，而HAVING则是对GROUP BY进一步筛选,不能用where。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo,CNo,Score<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">WHERE</span> CNo <span class=\"hljs-keyword\">IN</span> (<span class=\"hljs-string\">&#x27;C2&#x27;</span>,<span class=\"hljs-string\">&#x27;C3&#x27;</span>,<span class=\"hljs-string\">&#x27;C4&#x27;</span>)<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> SNo,Score <span class=\"hljs-keyword\">DESC</span><br></code></pre></td></tr></table></figure>\n学号升序，分数降序排列</li>\n<li><code>SELECT * FROM tab_test\\G</code>注意这没有分号,按列输出记录</li>\n</ul>\n<h2 id=\"多表内连接查询\"><a href=\"#多表内连接查询\" class=\"headerlink\" title=\"多表内连接查询\"></a>多表内连接查询</h2><ul>\n<li>方法一:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> T.TNo,TN,CNo<br><span class=\"hljs-keyword\">FROM</span> T,TC<br><span class=\"hljs-keyword\">WHERE</span> (T.TNo<span class=\"hljs-operator\">=</span>TC.TNo) <span class=\"hljs-keyword\">AND</span>(TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span>)<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>这里TN<span class=\"hljs-operator\">=</span>‘刘伟为查询条件’T.TNo<span class=\"hljs-operator\">=</span>TC.TNo为连接条件，TNo为连接字段<br></code></pre></td></tr></table></figure></li>\n<li>方法二:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> T.TNo,TN,CNo <br><span class=\"hljs-keyword\">FROM</span> T <span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> TC<br><span class=\"hljs-keyword\">ON</span> T.TNo<span class=\"hljs-operator\">=</span>TC.TNo <span class=\"hljs-keyword\">WHERE</span>(TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"多表外连接查询\"><a href=\"#多表外连接查询\" class=\"headerlink\" title=\"多表外连接查询\"></a>多表外连接查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> S.SNo,SN,CN,Score<br><span class=\"hljs-keyword\">FROM</span> S<br><span class=\"hljs-keyword\">LEFT</span> <span class=\"hljs-keyword\">OUTER</span> <span class=\"hljs-keyword\">JOIN</span> SC<br><span class=\"hljs-keyword\">ON</span> S.SNo<span class=\"hljs-operator\">=</span>SC.SNo<br><span class=\"hljs-keyword\">LEFT</span> <span class=\"hljs-keyword\">OUTER</span> <span class=\"hljs-keyword\">JOIN</span> C<br><span class=\"hljs-keyword\">ON</span> C.CNo<span class=\"hljs-operator\">=</span>SC.CNo<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>外链接不符合条件的将置为<span class=\"hljs-keyword\">NULL</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"多表交叉查询\"><a href=\"#多表交叉查询\" class=\"headerlink\" title=\"多表交叉查询\"></a>多表交叉查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> S <span class=\"hljs-keyword\">CROSS</span> <span class=\"hljs-keyword\">JOIN</span> C<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>行数两个表行的乘积，列数为两个表的列数和<br></code></pre></td></tr></table></figure>\n<h2 id=\"自连接查询-例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资\"><a href=\"#自连接查询-例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资\" class=\"headerlink\" title=\"自连接查询(例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资)\"></a>自连接查询(例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资)</h2><ul>\n<li>方法一:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> X.TN,X.Sal <span class=\"hljs-keyword\">AS</span> Sal_a,Y.Sal <span class=\"hljs-keyword\">AS</span> Sal_b<br><span class=\"hljs-keyword\">FROM</span> T <span class=\"hljs-keyword\">AS</span> X,T <span class=\"hljs-keyword\">AS</span> Y<br><span class=\"hljs-keyword\">WHERE</span> X.Sal<span class=\"hljs-operator\">&gt;</span>Y.Sal <span class=\"hljs-keyword\">AND</span> Y.TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>方法二:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> X.TN,X.Sal,Y.Sal<br><span class=\"hljs-keyword\">FROM</span> T <span class=\"hljs-keyword\">AS</span> X <span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> T <span class=\"hljs-keyword\">AS</span> Y<br><span class=\"hljs-keyword\">ON</span> X.Sal<span class=\"hljs-operator\">&gt;</span>Y.Sal<br><span class=\"hljs-keyword\">AND</span> Y.TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"普通子查询\"><a href=\"#普通子查询\" class=\"headerlink\" title=\"普通子查询\"></a>普通子查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> TNo,TN<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> Prof<span class=\"hljs-operator\">=</span> (<span class=\"hljs-keyword\">SELECT</span> Prof <br>\t\t<span class=\"hljs-keyword\">FROM</span> T<br>\t\t<span class=\"hljs-keyword\">WHERE</span> TN<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;刘伟&#x27;</span>)<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>查询与刘伟老师相同职称的老师姓名与工号<br><span class=\"hljs-keyword\">SELECT</span> TN<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> (TNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">ANY</span> (<span class=\"hljs-keyword\">SELECT</span> TNo<br>\t\t\t<span class=\"hljs-keyword\">FROM</span> TC<br>\t\t\t<span class=\"hljs-keyword\">WHERE</span> CNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;C5&#x27;</span>))<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>查询讲授课程号为C5的教师姓名<br></code></pre></td></tr></table></figure>\n<h2 id=\"相关子查询-它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询\"><a href=\"#相关子查询-它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询\" class=\"headerlink\" title=\"相关子查询(它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询)\"></a>相关子查询(它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询)</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> TN<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">EXISTS</span> (<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span><br>\t\t<span class=\"hljs-keyword\">FROM</span> TC<br>\t\t<span class=\"hljs-keyword\">WHERE</span> TNo<span class=\"hljs-operator\">=</span>T.TNo <span class=\"hljs-keyword\">AND</span> CNo<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;C5&#x27;</span>)<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>查询讲授课程为C5的教师姓名<br></code></pre></td></tr></table></figure>\n<h2 id=\"合并查询-就是把结果合并到一起\"><a href=\"#合并查询-就是把结果合并到一起\" class=\"headerlink\" title=\"合并查询(就是把结果合并到一起)\"></a>合并查询(就是把结果合并到一起)</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo <span class=\"hljs-keyword\">AS</span> 学号,<span class=\"hljs-built_in\">SUM</span>(Score) <span class=\"hljs-keyword\">AS</span> 总分<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">WHERE</span> (SNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;S1&#x27;</span>)<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br><span class=\"hljs-keyword\">UNION</span><br><span class=\"hljs-keyword\">SELECT</span> SNo <span class=\"hljs-keyword\">AS</span> 学号,<span class=\"hljs-built_in\">SUM</span>(Score) <span class=\"hljs-keyword\">AS</span> 总分<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">WHERE</span> (SNo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;S5&#x27;</span>)<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br></code></pre></td></tr></table></figure>\n<h2 id=\"存储查询\"><a href=\"#存储查询\" class=\"headerlink\" title=\"存储查询\"></a>存储查询</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> SNo <span class=\"hljs-keyword\">AS</span> 学号,<span class=\"hljs-built_in\">SUM</span>(Score) <span class=\"hljs-keyword\">AS</span> 总分<br><span class=\"hljs-keyword\">INTO</span> Cal_Table<br><span class=\"hljs-keyword\">FROM</span> SC<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> SNo<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>如果在新表名前面加个#则是临时表，关闭则消失<br></code></pre></td></tr></table></figure>\n<h1 id=\"修改元祖数据\"><a href=\"#修改元祖数据\" class=\"headerlink\" title=\"修改元祖数据\"></a>修改元祖数据</h1><p><code>UPDATE tab_test SET fd2=&#39;Brandon&#39; WHERE fd1=1</code>如果没有WHERE则所有元祖的fd2都将改变，请一定小心<br><code>REPLACE tab_test SET fd1=1,fd2=&#39;Matt&#39;;</code>若记录存在执行UPDATE,否则执行INSERT,最好用INSERT加ON DUPLICATE KEY UPDATE命令,资源消耗更小。</p>\n<h1 id=\"删除元祖数据\"><a href=\"#删除元祖数据\" class=\"headerlink\" title=\"删除元祖数据\"></a>删除元祖数据</h1><p><code>DELETE FROM tab_test WHERE fd1=1;</code>同理没有WHERE将会删除所有元组</p>\n<h1 id=\"视图-是一个虚表-基于基本表，对其修改会影响基本表，但本身不占内存\"><a href=\"#视图-是一个虚表-基于基本表，对其修改会影响基本表，但本身不占内存\" class=\"headerlink\" title=\"视图(是一个虚表,基于基本表，对其修改会影响基本表，但本身不占内存)\"></a>视图(是一个虚表,基于基本表，对其修改会影响基本表，但本身不占内存)</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> Sub_T<br><span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> TNo,TN,Prof<br><span class=\"hljs-keyword\">FROM</span> T<br><span class=\"hljs-keyword\">WHERE</span> Dept <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;计算机&#x27;</span><br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>创建一个计算机系老师情况的视图Sub_T<br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">VIEW</span> S_SC_C(SN,CN,Score)<br><span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> SN,CN,Score<br> <span class=\"hljs-keyword\">FROM</span> S,C,SC<br> <span class=\"hljs-keyword\">WHERE</span> S.SNo<span class=\"hljs-operator\">=</span>SC.SNo <span class=\"hljs-keyword\">AND</span> SC.CNo<span class=\"hljs-operator\">=</span>C.CNo<br><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>修改,就是查询内容的覆盖<br></code></pre></td></tr></table></figure>\n<p>对表的操作适用于视图，可以通过视图简化操作</p>\n<h1 id=\"索引-待建\"><a href=\"#索引-待建\" class=\"headerlink\" title=\"索引(待建)\"></a>索引(待建)</h1><h1 id=\"规则约束\"><a href=\"#规则约束\" class=\"headerlink\" title=\"规则约束\"></a>规则约束</h1><h2 id=\"创建规则\"><a href=\"#创建规则\" class=\"headerlink\" title=\"创建规则\"></a>创建规则</h2><p><code>CREATE RULE age_rule AS@age &gt;=18and @age &lt;= 50</code></p>\n<h2 id=\"将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\"><a href=\"#将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\" class=\"headerlink\" title=\"将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑\"></a>将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑</h2><p>用sp_bindrule绑定规则<br><code>EXEC sp_bindrule &#39;age_rule&#39;,&#39;S.Age&#39;</code>对已输入的数据不起作用<br><code>EXEC sp_unbindrule &#39;S.Age&#39;</code>解绑</p>\n<h2 id=\"删除规则\"><a href=\"#删除规则\" class=\"headerlink\" title=\"删除规则\"></a>删除规则</h2><p><code>DROP RULE age_rule</code>删除前必须先解绑</p>\n<h1 id=\"默认\"><a href=\"#默认\" class=\"headerlink\" title=\"默认\"></a>默认</h1><h2 id=\"创建默认\"><a href=\"#创建默认\" class=\"headerlink\" title=\"创建默认\"></a>创建默认</h2><p><code>CREATE DEFAULT birthday_defa AS &#39;1978-1-1&#39;</code></p>\n<h2 id=\"查看默认\"><a href=\"#查看默认\" class=\"headerlink\" title=\"查看默认\"></a>查看默认</h2><p><code>EXEC sp_helptext birthday_defa</code></p>\n<h2 id=\"默认的绑定与解绑\"><a href=\"#默认的绑定与解绑\" class=\"headerlink\" title=\"默认的绑定与解绑\"></a>默认的绑定与解绑</h2><p><code>EXEC sp_bindefault &#39;birthday_defa&#39; &#39;S.[Birthday]&#39;</code><br><code>EXEC sp_unbinefault &#39;S.[Birthday]&#39;</code></p>\n<h2 id=\"删除默认\"><a href=\"#删除默认\" class=\"headerlink\" title=\"删除默认\"></a>删除默认</h2><p><code>DROP DEFAULT birthday_defa</code></p>\n"},{"title":"TCP/IP","date":"2022-10-03T02:52:48.000Z","subtitle":null,"banner_img":"/images/TCP_IP.png","index_img":"/images/TCP_IP.png","_content":"\n# UDP存在的意义\n![](/images/UDP.png)\n- 无需建立连接，不会引入建立连接的时延\n- 无连接状态，tcp需要维护接发缓存、拥塞控制参数、序号及确认号的参数\n- 分组首部更小\n- 无拥塞控制，对于不希望过分延迟报文段的传送并且容忍数据丢失的场景适用\n# 校验和的计算\n- 发送方对UDP报文段中的所有16比特字进行累加，溢出将回卷，并取反得到校验和。\n- 接收方将所有16比特字(包括校验和)进行累加,无错即得到全1\n# TCP\n![](/images/TCP.png)\n## 涉及概念\n- ACK:肯定确认,在TCP头部中表示当前对确认字段中的值是有效的,明显第一次握手时，该值置为0\n- NAK:否定确儿（TCP中没有，只需确认最后一次接收到的分组即可）\n- GBN:回退N步\n- SR:选择重传\n- MSS:最大报文长度,不包括头40字节\n- MTU:最大传输单元，链路层的最大帧长度(以太网中为1500字节)，MSS=MTU-40(TCP+IP首部长度)\n- RTT:往返时间\n## 六比特标识位\n- URG:用于指示报文段里存在着被发送端的上层实体置为紧急的数据(一般不用)\n- ACK:用于指示确认字段的值是有效的\n- PSH:用于指示接收方应立即将数据交给上层(一般不用)\n- RST:用于告诉源：我没有那个报文段的套接字(即端口号未开)，不要再发送该报文,udp遇到这种情况会发送一个ICMP的数据报\n- SYN:用于建立连接\n- FIN:用于拆除连接\n## 流量控制\n- rwnd(接受窗口)=RcvBuffer-[LastByteRcvd-LastByteRead]\n## 三次握手\n![](/images/handshake.png)\n- 第一次：SYN为1,ACK为0,随机初始化一个seq(client_isn)\n- 第二次：SYN为1,ACK为1,随机初始化一个seq(server_isn),并设置确认号ack(client_isn+1)，此时服务器可能分配缓存和变量（此时分配会受到SYN洪泛攻击）\n- 第三次：SYN为1,ACK为1,客户分配缓存和变量，并可以携带有效数据\n### 为啥3次(反证法)\n- 只有一次：无法证明自己发送和接受是否正常,无法证明接收方发送和接受是否正常\n- 两次：接受方无法确认发送方的接受是否正常以及自己的发送是否正常\n### 为啥3次(比喻)\n1. 你听到吗？\n2. 我能，你能听到我吗？\n3. 我也能，那啥你把。。。。\n### 为啥3次(正经版)\nTCP连接：用于保证可靠性和流控制机制的信息，包括Socket,序列号以及窗口大小叫做连接。\n所以通信双方要对这三种信息达成共识，socket就是ip+端口号，窗口大小用于流控制，序列号用于用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。问题转化为为啥3次才可以初始花这三个信息呢？\n从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：\n- **通过三次握手才能阻止重复历史连接的初始化**(最主要)\n- 通过三次握手才能对通信双方的初始序列号进行初始化；\n- 讨论其他次数握手建立连接的可能性；\n#### point1\nRFC793指出：连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。\n所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：\n- 如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；\n- 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；\n使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。\n#### point2\n另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：\n- 数据包被发送方多次发送造成数据的重复；\n- 数据包在传输的过程中被路由或者其他节点丢失；\n- 数据包到达接收方可能无法按照发送顺序；\n为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：\n- 接收方可以通过序列号对重复的数据包进行去重；\n- 发送方会在对应数据包未被 ACK 时进行重复发送；\n- 接收方可以根据数据包的序列号对它们进行重新排序；\n序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。\n除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。\n#### point3\n当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以使用更多的通信次数交换相同的信息，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。\n这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。\n#### 结论\nTCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：\n- 『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；\n- 『四次握手』：TCP 协议的设计可以让我们同时传递 ACK 和 SYN 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；\n\n### 第一次握手时可以携带应用数据吗\n不行，因为此时连接还没有建立。\n是否可以由接收方将应用数据缓存起来，等到三次握手完成，连接建立之后，再由接收方交给上层应用呢？\n也不行，这样会放大 TCP SYN Flood 攻击，如果攻击者伪造了大量的携带数据报文，那么接收方就需要大量的内存来临时存储应用数据，最终导致内存耗尽。\n### 第二次握手时可以携带应用数据吗？\n第二次握手是接收方向发送方发送数据，虽然可以携带数据，但是没有任何实质意义。\n\n### 第三次握手时可以携带应用数据吗？\n可以。\n发送第三次握手之前，发送方此时已经进入 ESTABLISHED 状态，所以只要第三次握手的报文到达接收方，那么接收方的状态也会进入 ESTABLISHED 状态，连接就算建立完成了。\n此时接收方将发送方在第三次握手时携带的应用数据，转交给上层应用即可。\n那这样就不会引发 TCP SYN Flood 攻击吗？\n作为攻击者来说，也是需要考虑攻击成本的，如果在第三次握手携带应用数据，就会建立起正常的 TCP 连接，攻击者同样需要资源来存储建立的连接，对于攻击者来说，这是本末倒置的。如果攻击者是远程操纵 “肉鸡” 进行攻击的话，直接在连接建立完成后，让 “肉鸡” 发送海量应用请求就可以了，没有必要在第三次握手时携带应用数据。\n\n## 四次挥手\n![](/images/byebye.png)\n- 第一次(假设客户端先手)：FIN为1，ACK=0,随机一个seq,此时不发送有效数据，仍然可以接受数据\n- 第二次：ACK=1,ackNum为seq+1,此时服务器仍然可以发送数据\n- 第三次：FIN为1，ACK=0,随机一个seq，此时服务器不发送有效数据\n- 第四次：ACK=1,ackNum为seq+1\n## 拥塞控制\n- 发送方跟踪额外的变量:拥塞窗口(cwnd),注意这与流量控制不同，**不体现在tcp头部中**\n- LastByteSent-LastByteAcked<=min{cwnd,rwnd}\n- 初始化时，cwnd通常为1个MSS，然后进入慢启动(指数增长),遇到拥塞，cwnd减半，并设置ssthresh=cwnd/2(慢启动阈值),结束慢启动\n- TCP的拥塞控制：每个RTT内cwnd线性增加1个MSS，出现3个冗余ACK时，cwnd减半（加性增、乘性减）\n# IP\n## ipv4\n![](/images/IP.png)\n### 关键字段\n- 版本号：4比特，定义是ipv4还是ipv6\n- 首部长度：4比特，定义首部长度\n- 服务类型：8比特，服务类型(延时低，高吞吐等)\n- 数据包长度：ip数据报总长度（首部+数据）\n- 标识、标志、偏移：ip分片有关\n- 寿命：8字节，没经过一个路由减1,为0时丢弃\n- 协议：表示上层协议（UDP还是）\n- 首部校验和：只针对头部计算，注意由于寿命会变，所以需要不断的更新\n- 源和目的ip地址：没啥好说\n- 选项：很少使用，ipv6中就没有\n- 有效数据\n### 数据报分片\n![](/images/IP_fra.png)\n- 之前提到过，一个链路层帧能承载的最大数据量叫做**最大传送单元（MTU）**\n- 广域网和局域网可能MTU不同所以要分片\n- 分片的重组放在端系统中，路由器不负责重组\n- 最后一片标志被置为0\n### ipv4编址\n- 接口：主机与物理链路之间的边界叫做接口\n- ip地址：IP协议要求每台主机和路由器的接口拥有自己的IP地址\n**从技术上来讲一个ip地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联**\n- 子网掩码：a.b.c.d/x,x最高比特构成了IP地址的网络部分，为网络前缀\n- CIDR：无类别域间路由选择，这种更灵活\n- 分类编址（不灵活）：A类子网(8bit)，B类子网(16bit)，C类子网(24bit),会有c类太少，b类太大的烦恼\n### DHCP动态主机配置协议\n性质：基于UDP的应用层协议,默认端口67\n作用： 除了分配IP地址外，DHCP还允许获取其他信息子网掩码，默认网关（第一跳路由器），本地DNS服务器地址\n![](/images/DHCP.png)\n### 网络地址转换-NAT\n- 会改写IP地址和端口号\n![](/images/NAT.png)\n## ipv6\n![](/images/IPV6.png)\n- 版本：显然设为6\n- 流量类型：与ipv4服务类型类似\n- 流标签：标识一条数据报的流，还未完全确定\n- 有效载荷长度\n- 跳限制：计数为0丢弃\n### ipv4->ipv6:隧道\n![](/images/tunneling.png)\n## 通用转发和SDN\n- OpenFLow标准\n- SDN\n- 就是根据各层的头信息执行特定转发，有更大灵活性，跳出IP转发的局限性\n\n","source":"_posts/TCP-IP.md","raw":"---\ntitle: TCP/IP\ndate: 2022-10-03 10:52:48\nsubtitle:\ncategories:\ntags:\nbanner_img: /images/TCP_IP.png\nindex_img: /images/TCP_IP.png\n---\n\n# UDP存在的意义\n![](/images/UDP.png)\n- 无需建立连接，不会引入建立连接的时延\n- 无连接状态，tcp需要维护接发缓存、拥塞控制参数、序号及确认号的参数\n- 分组首部更小\n- 无拥塞控制，对于不希望过分延迟报文段的传送并且容忍数据丢失的场景适用\n# 校验和的计算\n- 发送方对UDP报文段中的所有16比特字进行累加，溢出将回卷，并取反得到校验和。\n- 接收方将所有16比特字(包括校验和)进行累加,无错即得到全1\n# TCP\n![](/images/TCP.png)\n## 涉及概念\n- ACK:肯定确认,在TCP头部中表示当前对确认字段中的值是有效的,明显第一次握手时，该值置为0\n- NAK:否定确儿（TCP中没有，只需确认最后一次接收到的分组即可）\n- GBN:回退N步\n- SR:选择重传\n- MSS:最大报文长度,不包括头40字节\n- MTU:最大传输单元，链路层的最大帧长度(以太网中为1500字节)，MSS=MTU-40(TCP+IP首部长度)\n- RTT:往返时间\n## 六比特标识位\n- URG:用于指示报文段里存在着被发送端的上层实体置为紧急的数据(一般不用)\n- ACK:用于指示确认字段的值是有效的\n- PSH:用于指示接收方应立即将数据交给上层(一般不用)\n- RST:用于告诉源：我没有那个报文段的套接字(即端口号未开)，不要再发送该报文,udp遇到这种情况会发送一个ICMP的数据报\n- SYN:用于建立连接\n- FIN:用于拆除连接\n## 流量控制\n- rwnd(接受窗口)=RcvBuffer-[LastByteRcvd-LastByteRead]\n## 三次握手\n![](/images/handshake.png)\n- 第一次：SYN为1,ACK为0,随机初始化一个seq(client_isn)\n- 第二次：SYN为1,ACK为1,随机初始化一个seq(server_isn),并设置确认号ack(client_isn+1)，此时服务器可能分配缓存和变量（此时分配会受到SYN洪泛攻击）\n- 第三次：SYN为1,ACK为1,客户分配缓存和变量，并可以携带有效数据\n### 为啥3次(反证法)\n- 只有一次：无法证明自己发送和接受是否正常,无法证明接收方发送和接受是否正常\n- 两次：接受方无法确认发送方的接受是否正常以及自己的发送是否正常\n### 为啥3次(比喻)\n1. 你听到吗？\n2. 我能，你能听到我吗？\n3. 我也能，那啥你把。。。。\n### 为啥3次(正经版)\nTCP连接：用于保证可靠性和流控制机制的信息，包括Socket,序列号以及窗口大小叫做连接。\n所以通信双方要对这三种信息达成共识，socket就是ip+端口号，窗口大小用于流控制，序列号用于用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。问题转化为为啥3次才可以初始花这三个信息呢？\n从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：\n- **通过三次握手才能阻止重复历史连接的初始化**(最主要)\n- 通过三次握手才能对通信双方的初始序列号进行初始化；\n- 讨论其他次数握手建立连接的可能性；\n#### point1\nRFC793指出：连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。\n所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：\n- 如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；\n- 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；\n使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。\n#### point2\n另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：\n- 数据包被发送方多次发送造成数据的重复；\n- 数据包在传输的过程中被路由或者其他节点丢失；\n- 数据包到达接收方可能无法按照发送顺序；\n为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：\n- 接收方可以通过序列号对重复的数据包进行去重；\n- 发送方会在对应数据包未被 ACK 时进行重复发送；\n- 接收方可以根据数据包的序列号对它们进行重新排序；\n序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。\n除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。\n#### point3\n当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以使用更多的通信次数交换相同的信息，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。\n这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。\n#### 结论\nTCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：\n- 『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；\n- 『四次握手』：TCP 协议的设计可以让我们同时传递 ACK 和 SYN 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；\n\n### 第一次握手时可以携带应用数据吗\n不行，因为此时连接还没有建立。\n是否可以由接收方将应用数据缓存起来，等到三次握手完成，连接建立之后，再由接收方交给上层应用呢？\n也不行，这样会放大 TCP SYN Flood 攻击，如果攻击者伪造了大量的携带数据报文，那么接收方就需要大量的内存来临时存储应用数据，最终导致内存耗尽。\n### 第二次握手时可以携带应用数据吗？\n第二次握手是接收方向发送方发送数据，虽然可以携带数据，但是没有任何实质意义。\n\n### 第三次握手时可以携带应用数据吗？\n可以。\n发送第三次握手之前，发送方此时已经进入 ESTABLISHED 状态，所以只要第三次握手的报文到达接收方，那么接收方的状态也会进入 ESTABLISHED 状态，连接就算建立完成了。\n此时接收方将发送方在第三次握手时携带的应用数据，转交给上层应用即可。\n那这样就不会引发 TCP SYN Flood 攻击吗？\n作为攻击者来说，也是需要考虑攻击成本的，如果在第三次握手携带应用数据，就会建立起正常的 TCP 连接，攻击者同样需要资源来存储建立的连接，对于攻击者来说，这是本末倒置的。如果攻击者是远程操纵 “肉鸡” 进行攻击的话，直接在连接建立完成后，让 “肉鸡” 发送海量应用请求就可以了，没有必要在第三次握手时携带应用数据。\n\n## 四次挥手\n![](/images/byebye.png)\n- 第一次(假设客户端先手)：FIN为1，ACK=0,随机一个seq,此时不发送有效数据，仍然可以接受数据\n- 第二次：ACK=1,ackNum为seq+1,此时服务器仍然可以发送数据\n- 第三次：FIN为1，ACK=0,随机一个seq，此时服务器不发送有效数据\n- 第四次：ACK=1,ackNum为seq+1\n## 拥塞控制\n- 发送方跟踪额外的变量:拥塞窗口(cwnd),注意这与流量控制不同，**不体现在tcp头部中**\n- LastByteSent-LastByteAcked<=min{cwnd,rwnd}\n- 初始化时，cwnd通常为1个MSS，然后进入慢启动(指数增长),遇到拥塞，cwnd减半，并设置ssthresh=cwnd/2(慢启动阈值),结束慢启动\n- TCP的拥塞控制：每个RTT内cwnd线性增加1个MSS，出现3个冗余ACK时，cwnd减半（加性增、乘性减）\n# IP\n## ipv4\n![](/images/IP.png)\n### 关键字段\n- 版本号：4比特，定义是ipv4还是ipv6\n- 首部长度：4比特，定义首部长度\n- 服务类型：8比特，服务类型(延时低，高吞吐等)\n- 数据包长度：ip数据报总长度（首部+数据）\n- 标识、标志、偏移：ip分片有关\n- 寿命：8字节，没经过一个路由减1,为0时丢弃\n- 协议：表示上层协议（UDP还是）\n- 首部校验和：只针对头部计算，注意由于寿命会变，所以需要不断的更新\n- 源和目的ip地址：没啥好说\n- 选项：很少使用，ipv6中就没有\n- 有效数据\n### 数据报分片\n![](/images/IP_fra.png)\n- 之前提到过，一个链路层帧能承载的最大数据量叫做**最大传送单元（MTU）**\n- 广域网和局域网可能MTU不同所以要分片\n- 分片的重组放在端系统中，路由器不负责重组\n- 最后一片标志被置为0\n### ipv4编址\n- 接口：主机与物理链路之间的边界叫做接口\n- ip地址：IP协议要求每台主机和路由器的接口拥有自己的IP地址\n**从技术上来讲一个ip地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联**\n- 子网掩码：a.b.c.d/x,x最高比特构成了IP地址的网络部分，为网络前缀\n- CIDR：无类别域间路由选择，这种更灵活\n- 分类编址（不灵活）：A类子网(8bit)，B类子网(16bit)，C类子网(24bit),会有c类太少，b类太大的烦恼\n### DHCP动态主机配置协议\n性质：基于UDP的应用层协议,默认端口67\n作用： 除了分配IP地址外，DHCP还允许获取其他信息子网掩码，默认网关（第一跳路由器），本地DNS服务器地址\n![](/images/DHCP.png)\n### 网络地址转换-NAT\n- 会改写IP地址和端口号\n![](/images/NAT.png)\n## ipv6\n![](/images/IPV6.png)\n- 版本：显然设为6\n- 流量类型：与ipv4服务类型类似\n- 流标签：标识一条数据报的流，还未完全确定\n- 有效载荷长度\n- 跳限制：计数为0丢弃\n### ipv4->ipv6:隧道\n![](/images/tunneling.png)\n## 通用转发和SDN\n- OpenFLow标准\n- SDN\n- 就是根据各层的头信息执行特定转发，有更大灵活性，跳出IP转发的局限性\n\n","slug":"TCP-IP","published":1,"updated":"2024-10-07T04:20:58.863Z","_id":"clq1yvi6y000ogwq23ia3d0mp","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"UDP存在的意义\"><a href=\"#UDP存在的意义\" class=\"headerlink\" title=\"UDP存在的意义\"></a>UDP存在的意义</h1><p><img src=\"/images/UDP.png\"></p>\n<ul>\n<li>无需建立连接，不会引入建立连接的时延</li>\n<li>无连接状态，tcp需要维护接发缓存、拥塞控制参数、序号及确认号的参数</li>\n<li>分组首部更小</li>\n<li>无拥塞控制，对于不希望过分延迟报文段的传送并且容忍数据丢失的场景适用</li>\n</ul>\n<h1 id=\"校验和的计算\"><a href=\"#校验和的计算\" class=\"headerlink\" title=\"校验和的计算\"></a>校验和的计算</h1><ul>\n<li>发送方对UDP报文段中的所有16比特字进行累加，溢出将回卷，并取反得到校验和。</li>\n<li>接收方将所有16比特字(包括校验和)进行累加,无错即得到全1</li>\n</ul>\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p><img src=\"/images/TCP.png\"></p>\n<h2 id=\"涉及概念\"><a href=\"#涉及概念\" class=\"headerlink\" title=\"涉及概念\"></a>涉及概念</h2><ul>\n<li>ACK:肯定确认,在TCP头部中表示当前对确认字段中的值是有效的,明显第一次握手时，该值置为0</li>\n<li>NAK:否定确儿（TCP中没有，只需确认最后一次接收到的分组即可）</li>\n<li>GBN:回退N步</li>\n<li>SR:选择重传</li>\n<li>MSS:最大报文长度,不包括头40字节</li>\n<li>MTU:最大传输单元，链路层的最大帧长度(以太网中为1500字节)，MSS&#x3D;MTU-40(TCP+IP首部长度)</li>\n<li>RTT:往返时间</li>\n</ul>\n<h2 id=\"六比特标识位\"><a href=\"#六比特标识位\" class=\"headerlink\" title=\"六比特标识位\"></a>六比特标识位</h2><ul>\n<li>URG:用于指示报文段里存在着被发送端的上层实体置为紧急的数据(一般不用)</li>\n<li>ACK:用于指示确认字段的值是有效的</li>\n<li>PSH:用于指示接收方应立即将数据交给上层(一般不用)</li>\n<li>RST:用于告诉源：我没有那个报文段的套接字(即端口号未开)，不要再发送该报文,udp遇到这种情况会发送一个ICMP的数据报</li>\n<li>SYN:用于建立连接</li>\n<li>FIN:用于拆除连接</li>\n</ul>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><ul>\n<li>rwnd(接受窗口)&#x3D;RcvBuffer-[LastByteRcvd-LastByteRead]</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><img src=\"/images/handshake.png\"></p>\n<ul>\n<li>第一次：SYN为1,ACK为0,随机初始化一个seq(client_isn)</li>\n<li>第二次：SYN为1,ACK为1,随机初始化一个seq(server_isn),并设置确认号ack(client_isn+1)，此时服务器可能分配缓存和变量（此时分配会受到SYN洪泛攻击）</li>\n<li>第三次：SYN为1,ACK为1,客户分配缓存和变量，并可以携带有效数据</li>\n</ul>\n<h3 id=\"为啥3次-反证法\"><a href=\"#为啥3次-反证法\" class=\"headerlink\" title=\"为啥3次(反证法)\"></a>为啥3次(反证法)</h3><ul>\n<li>只有一次：无法证明自己发送和接受是否正常,无法证明接收方发送和接受是否正常</li>\n<li>两次：接受方无法确认发送方的接受是否正常以及自己的发送是否正常</li>\n</ul>\n<h3 id=\"为啥3次-比喻\"><a href=\"#为啥3次-比喻\" class=\"headerlink\" title=\"为啥3次(比喻)\"></a>为啥3次(比喻)</h3><ol>\n<li>你听到吗？</li>\n<li>我能，你能听到我吗？</li>\n<li>我也能，那啥你把。。。。</li>\n</ol>\n<h3 id=\"为啥3次-正经版\"><a href=\"#为啥3次-正经版\" class=\"headerlink\" title=\"为啥3次(正经版)\"></a>为啥3次(正经版)</h3><p>TCP连接：用于保证可靠性和流控制机制的信息，包括Socket,序列号以及窗口大小叫做连接。<br>所以通信双方要对这三种信息达成共识，socket就是ip+端口号，窗口大小用于流控制，序列号用于用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。问题转化为为啥3次才可以初始花这三个信息呢？<br>从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>\n<ul>\n<li><strong>通过三次握手才能阻止重复历史连接的初始化</strong>(最主要)</li>\n<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>\n<li>讨论其他次数握手建立连接的可能性；</li>\n</ul>\n<h4 id=\"point1\"><a href=\"#point1\" class=\"headerlink\" title=\"point1\"></a>point1</h4><p>RFC793指出：连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。<br>所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：</p>\n<ul>\n<li>如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；</li>\n<li>如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；<br>使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。</li>\n</ul>\n<h4 id=\"point2\"><a href=\"#point2\" class=\"headerlink\" title=\"point2\"></a>point2</h4><p>另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>\n<ul>\n<li>数据包被发送方多次发送造成数据的重复；</li>\n<li>数据包在传输的过程中被路由或者其他节点丢失；</li>\n<li>数据包到达接收方可能无法按照发送顺序；<br>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</li>\n<li>接收方可以通过序列号对重复的数据包进行去重；</li>\n<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>\n<li>接收方可以根据数据包的序列号对它们进行重新排序；<br>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。<br>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</li>\n</ul>\n<h4 id=\"point3\"><a href=\"#point3\" class=\"headerlink\" title=\"point3\"></a>point3</h4><p>当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以使用更多的通信次数交换相同的信息，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。<br>这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>\n<ul>\n<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>\n<li>『四次握手』：TCP 协议的设计可以让我们同时传递 ACK 和 SYN 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>\n</ul>\n<h3 id=\"第一次握手时可以携带应用数据吗\"><a href=\"#第一次握手时可以携带应用数据吗\" class=\"headerlink\" title=\"第一次握手时可以携带应用数据吗\"></a>第一次握手时可以携带应用数据吗</h3><p>不行，因为此时连接还没有建立。<br>是否可以由接收方将应用数据缓存起来，等到三次握手完成，连接建立之后，再由接收方交给上层应用呢？<br>也不行，这样会放大 TCP SYN Flood 攻击，如果攻击者伪造了大量的携带数据报文，那么接收方就需要大量的内存来临时存储应用数据，最终导致内存耗尽。</p>\n<h3 id=\"第二次握手时可以携带应用数据吗？\"><a href=\"#第二次握手时可以携带应用数据吗？\" class=\"headerlink\" title=\"第二次握手时可以携带应用数据吗？\"></a>第二次握手时可以携带应用数据吗？</h3><p>第二次握手是接收方向发送方发送数据，虽然可以携带数据，但是没有任何实质意义。</p>\n<h3 id=\"第三次握手时可以携带应用数据吗？\"><a href=\"#第三次握手时可以携带应用数据吗？\" class=\"headerlink\" title=\"第三次握手时可以携带应用数据吗？\"></a>第三次握手时可以携带应用数据吗？</h3><p>可以。<br>发送第三次握手之前，发送方此时已经进入 ESTABLISHED 状态，所以只要第三次握手的报文到达接收方，那么接收方的状态也会进入 ESTABLISHED 状态，连接就算建立完成了。<br>此时接收方将发送方在第三次握手时携带的应用数据，转交给上层应用即可。<br>那这样就不会引发 TCP SYN Flood 攻击吗？<br>作为攻击者来说，也是需要考虑攻击成本的，如果在第三次握手携带应用数据，就会建立起正常的 TCP 连接，攻击者同样需要资源来存储建立的连接，对于攻击者来说，这是本末倒置的。如果攻击者是远程操纵 “肉鸡” 进行攻击的话，直接在连接建立完成后，让 “肉鸡” 发送海量应用请求就可以了，没有必要在第三次握手时携带应用数据。</p>\n<h2 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h2><p><img src=\"/images/byebye.png\"></p>\n<ul>\n<li>第一次(假设客户端先手)：FIN为1，ACK&#x3D;0,随机一个seq,此时不发送有效数据，仍然可以接受数据</li>\n<li>第二次：ACK&#x3D;1,ackNum为seq+1,此时服务器仍然可以发送数据</li>\n<li>第三次：FIN为1，ACK&#x3D;0,随机一个seq，此时服务器不发送有效数据</li>\n<li>第四次：ACK&#x3D;1,ackNum为seq+1</li>\n</ul>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><ul>\n<li>发送方跟踪额外的变量:拥塞窗口(cwnd),注意这与流量控制不同，<strong>不体现在tcp头部中</strong></li>\n<li>LastByteSent-LastByteAcked&lt;&#x3D;min{cwnd,rwnd}</li>\n<li>初始化时，cwnd通常为1个MSS，然后进入慢启动(指数增长),遇到拥塞，cwnd减半，并设置ssthresh&#x3D;cwnd&#x2F;2(慢启动阈值),结束慢启动</li>\n<li>TCP的拥塞控制：每个RTT内cwnd线性增加1个MSS，出现3个冗余ACK时，cwnd减半（加性增、乘性减）</li>\n</ul>\n<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><h2 id=\"ipv4\"><a href=\"#ipv4\" class=\"headerlink\" title=\"ipv4\"></a>ipv4</h2><p><img src=\"/images/IP.png\"></p>\n<h3 id=\"关键字段\"><a href=\"#关键字段\" class=\"headerlink\" title=\"关键字段\"></a>关键字段</h3><ul>\n<li>版本号：4比特，定义是ipv4还是ipv6</li>\n<li>首部长度：4比特，定义首部长度</li>\n<li>服务类型：8比特，服务类型(延时低，高吞吐等)</li>\n<li>数据包长度：ip数据报总长度（首部+数据）</li>\n<li>标识、标志、偏移：ip分片有关</li>\n<li>寿命：8字节，没经过一个路由减1,为0时丢弃</li>\n<li>协议：表示上层协议（UDP还是）</li>\n<li>首部校验和：只针对头部计算，注意由于寿命会变，所以需要不断的更新</li>\n<li>源和目的ip地址：没啥好说</li>\n<li>选项：很少使用，ipv6中就没有</li>\n<li>有效数据</li>\n</ul>\n<h3 id=\"数据报分片\"><a href=\"#数据报分片\" class=\"headerlink\" title=\"数据报分片\"></a>数据报分片</h3><p><img src=\"/images/IP_fra.png\"></p>\n<ul>\n<li>之前提到过，一个链路层帧能承载的最大数据量叫做<strong>最大传送单元（MTU）</strong></li>\n<li>广域网和局域网可能MTU不同所以要分片</li>\n<li>分片的重组放在端系统中，路由器不负责重组</li>\n<li>最后一片标志被置为0</li>\n</ul>\n<h3 id=\"ipv4编址\"><a href=\"#ipv4编址\" class=\"headerlink\" title=\"ipv4编址\"></a>ipv4编址</h3><ul>\n<li>接口：主机与物理链路之间的边界叫做接口</li>\n<li>ip地址：IP协议要求每台主机和路由器的接口拥有自己的IP地址<br><strong>从技术上来讲一个ip地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联</strong></li>\n<li>子网掩码：a.b.c.d&#x2F;x,x最高比特构成了IP地址的网络部分，为网络前缀</li>\n<li>CIDR：无类别域间路由选择，这种更灵活</li>\n<li>分类编址（不灵活）：A类子网(8bit)，B类子网(16bit)，C类子网(24bit),会有c类太少，b类太大的烦恼</li>\n</ul>\n<h3 id=\"DHCP动态主机配置协议\"><a href=\"#DHCP动态主机配置协议\" class=\"headerlink\" title=\"DHCP动态主机配置协议\"></a>DHCP动态主机配置协议</h3><p>性质：基于UDP的应用层协议,默认端口67<br>作用： 除了分配IP地址外，DHCP还允许获取其他信息子网掩码，默认网关（第一跳路由器），本地DNS服务器地址<br><img src=\"/images/DHCP.png\"></p>\n<h3 id=\"网络地址转换-NAT\"><a href=\"#网络地址转换-NAT\" class=\"headerlink\" title=\"网络地址转换-NAT\"></a>网络地址转换-NAT</h3><ul>\n<li>会改写IP地址和端口号<br><img src=\"/images/NAT.png\"></li>\n</ul>\n<h2 id=\"ipv6\"><a href=\"#ipv6\" class=\"headerlink\" title=\"ipv6\"></a>ipv6</h2><p><img src=\"/images/IPV6.png\"></p>\n<ul>\n<li>版本：显然设为6</li>\n<li>流量类型：与ipv4服务类型类似</li>\n<li>流标签：标识一条数据报的流，还未完全确定</li>\n<li>有效载荷长度</li>\n<li>跳限制：计数为0丢弃</li>\n</ul>\n<h3 id=\"ipv4-ipv6-隧道\"><a href=\"#ipv4-ipv6-隧道\" class=\"headerlink\" title=\"ipv4-&gt;ipv6:隧道\"></a>ipv4-&gt;ipv6:隧道</h3><p><img src=\"/images/tunneling.png\"></p>\n<h2 id=\"通用转发和SDN\"><a href=\"#通用转发和SDN\" class=\"headerlink\" title=\"通用转发和SDN\"></a>通用转发和SDN</h2><ul>\n<li>OpenFLow标准</li>\n<li>SDN</li>\n<li>就是根据各层的头信息执行特定转发，有更大灵活性，跳出IP转发的局限性</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"UDP存在的意义\"><a href=\"#UDP存在的意义\" class=\"headerlink\" title=\"UDP存在的意义\"></a>UDP存在的意义</h1><p><img src=\"/images/UDP.png\"></p>\n<ul>\n<li>无需建立连接，不会引入建立连接的时延</li>\n<li>无连接状态，tcp需要维护接发缓存、拥塞控制参数、序号及确认号的参数</li>\n<li>分组首部更小</li>\n<li>无拥塞控制，对于不希望过分延迟报文段的传送并且容忍数据丢失的场景适用</li>\n</ul>\n<h1 id=\"校验和的计算\"><a href=\"#校验和的计算\" class=\"headerlink\" title=\"校验和的计算\"></a>校验和的计算</h1><ul>\n<li>发送方对UDP报文段中的所有16比特字进行累加，溢出将回卷，并取反得到校验和。</li>\n<li>接收方将所有16比特字(包括校验和)进行累加,无错即得到全1</li>\n</ul>\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p><img src=\"/images/TCP.png\"></p>\n<h2 id=\"涉及概念\"><a href=\"#涉及概念\" class=\"headerlink\" title=\"涉及概念\"></a>涉及概念</h2><ul>\n<li>ACK:肯定确认,在TCP头部中表示当前对确认字段中的值是有效的,明显第一次握手时，该值置为0</li>\n<li>NAK:否定确儿（TCP中没有，只需确认最后一次接收到的分组即可）</li>\n<li>GBN:回退N步</li>\n<li>SR:选择重传</li>\n<li>MSS:最大报文长度,不包括头40字节</li>\n<li>MTU:最大传输单元，链路层的最大帧长度(以太网中为1500字节)，MSS&#x3D;MTU-40(TCP+IP首部长度)</li>\n<li>RTT:往返时间</li>\n</ul>\n<h2 id=\"六比特标识位\"><a href=\"#六比特标识位\" class=\"headerlink\" title=\"六比特标识位\"></a>六比特标识位</h2><ul>\n<li>URG:用于指示报文段里存在着被发送端的上层实体置为紧急的数据(一般不用)</li>\n<li>ACK:用于指示确认字段的值是有效的</li>\n<li>PSH:用于指示接收方应立即将数据交给上层(一般不用)</li>\n<li>RST:用于告诉源：我没有那个报文段的套接字(即端口号未开)，不要再发送该报文,udp遇到这种情况会发送一个ICMP的数据报</li>\n<li>SYN:用于建立连接</li>\n<li>FIN:用于拆除连接</li>\n</ul>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><ul>\n<li>rwnd(接受窗口)&#x3D;RcvBuffer-[LastByteRcvd-LastByteRead]</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><img src=\"/images/handshake.png\"></p>\n<ul>\n<li>第一次：SYN为1,ACK为0,随机初始化一个seq(client_isn)</li>\n<li>第二次：SYN为1,ACK为1,随机初始化一个seq(server_isn),并设置确认号ack(client_isn+1)，此时服务器可能分配缓存和变量（此时分配会受到SYN洪泛攻击）</li>\n<li>第三次：SYN为1,ACK为1,客户分配缓存和变量，并可以携带有效数据</li>\n</ul>\n<h3 id=\"为啥3次-反证法\"><a href=\"#为啥3次-反证法\" class=\"headerlink\" title=\"为啥3次(反证法)\"></a>为啥3次(反证法)</h3><ul>\n<li>只有一次：无法证明自己发送和接受是否正常,无法证明接收方发送和接受是否正常</li>\n<li>两次：接受方无法确认发送方的接受是否正常以及自己的发送是否正常</li>\n</ul>\n<h3 id=\"为啥3次-比喻\"><a href=\"#为啥3次-比喻\" class=\"headerlink\" title=\"为啥3次(比喻)\"></a>为啥3次(比喻)</h3><ol>\n<li>你听到吗？</li>\n<li>我能，你能听到我吗？</li>\n<li>我也能，那啥你把。。。。</li>\n</ol>\n<h3 id=\"为啥3次-正经版\"><a href=\"#为啥3次-正经版\" class=\"headerlink\" title=\"为啥3次(正经版)\"></a>为啥3次(正经版)</h3><p>TCP连接：用于保证可靠性和流控制机制的信息，包括Socket,序列号以及窗口大小叫做连接。<br>所以通信双方要对这三种信息达成共识，socket就是ip+端口号，窗口大小用于流控制，序列号用于用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。问题转化为为啥3次才可以初始花这三个信息呢？<br>从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>\n<ul>\n<li><strong>通过三次握手才能阻止重复历史连接的初始化</strong>(最主要)</li>\n<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>\n<li>讨论其他次数握手建立连接的可能性；</li>\n</ul>\n<h4 id=\"point1\"><a href=\"#point1\" class=\"headerlink\" title=\"point1\"></a>point1</h4><p>RFC793指出：连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。<br>所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：</p>\n<ul>\n<li>如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；</li>\n<li>如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；<br>使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。</li>\n</ul>\n<h4 id=\"point2\"><a href=\"#point2\" class=\"headerlink\" title=\"point2\"></a>point2</h4><p>另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>\n<ul>\n<li>数据包被发送方多次发送造成数据的重复；</li>\n<li>数据包在传输的过程中被路由或者其他节点丢失；</li>\n<li>数据包到达接收方可能无法按照发送顺序；<br>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</li>\n<li>接收方可以通过序列号对重复的数据包进行去重；</li>\n<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>\n<li>接收方可以根据数据包的序列号对它们进行重新排序；<br>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。<br>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</li>\n</ul>\n<h4 id=\"point3\"><a href=\"#point3\" class=\"headerlink\" title=\"point3\"></a>point3</h4><p>当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以使用更多的通信次数交换相同的信息，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。<br>这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>\n<ul>\n<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>\n<li>『四次握手』：TCP 协议的设计可以让我们同时传递 ACK 和 SYN 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>\n</ul>\n<h3 id=\"第一次握手时可以携带应用数据吗\"><a href=\"#第一次握手时可以携带应用数据吗\" class=\"headerlink\" title=\"第一次握手时可以携带应用数据吗\"></a>第一次握手时可以携带应用数据吗</h3><p>不行，因为此时连接还没有建立。<br>是否可以由接收方将应用数据缓存起来，等到三次握手完成，连接建立之后，再由接收方交给上层应用呢？<br>也不行，这样会放大 TCP SYN Flood 攻击，如果攻击者伪造了大量的携带数据报文，那么接收方就需要大量的内存来临时存储应用数据，最终导致内存耗尽。</p>\n<h3 id=\"第二次握手时可以携带应用数据吗？\"><a href=\"#第二次握手时可以携带应用数据吗？\" class=\"headerlink\" title=\"第二次握手时可以携带应用数据吗？\"></a>第二次握手时可以携带应用数据吗？</h3><p>第二次握手是接收方向发送方发送数据，虽然可以携带数据，但是没有任何实质意义。</p>\n<h3 id=\"第三次握手时可以携带应用数据吗？\"><a href=\"#第三次握手时可以携带应用数据吗？\" class=\"headerlink\" title=\"第三次握手时可以携带应用数据吗？\"></a>第三次握手时可以携带应用数据吗？</h3><p>可以。<br>发送第三次握手之前，发送方此时已经进入 ESTABLISHED 状态，所以只要第三次握手的报文到达接收方，那么接收方的状态也会进入 ESTABLISHED 状态，连接就算建立完成了。<br>此时接收方将发送方在第三次握手时携带的应用数据，转交给上层应用即可。<br>那这样就不会引发 TCP SYN Flood 攻击吗？<br>作为攻击者来说，也是需要考虑攻击成本的，如果在第三次握手携带应用数据，就会建立起正常的 TCP 连接，攻击者同样需要资源来存储建立的连接，对于攻击者来说，这是本末倒置的。如果攻击者是远程操纵 “肉鸡” 进行攻击的话，直接在连接建立完成后，让 “肉鸡” 发送海量应用请求就可以了，没有必要在第三次握手时携带应用数据。</p>\n<h2 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h2><p><img src=\"/images/byebye.png\"></p>\n<ul>\n<li>第一次(假设客户端先手)：FIN为1，ACK&#x3D;0,随机一个seq,此时不发送有效数据，仍然可以接受数据</li>\n<li>第二次：ACK&#x3D;1,ackNum为seq+1,此时服务器仍然可以发送数据</li>\n<li>第三次：FIN为1，ACK&#x3D;0,随机一个seq，此时服务器不发送有效数据</li>\n<li>第四次：ACK&#x3D;1,ackNum为seq+1</li>\n</ul>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><ul>\n<li>发送方跟踪额外的变量:拥塞窗口(cwnd),注意这与流量控制不同，<strong>不体现在tcp头部中</strong></li>\n<li>LastByteSent-LastByteAcked&lt;&#x3D;min{cwnd,rwnd}</li>\n<li>初始化时，cwnd通常为1个MSS，然后进入慢启动(指数增长),遇到拥塞，cwnd减半，并设置ssthresh&#x3D;cwnd&#x2F;2(慢启动阈值),结束慢启动</li>\n<li>TCP的拥塞控制：每个RTT内cwnd线性增加1个MSS，出现3个冗余ACK时，cwnd减半（加性增、乘性减）</li>\n</ul>\n<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><h2 id=\"ipv4\"><a href=\"#ipv4\" class=\"headerlink\" title=\"ipv4\"></a>ipv4</h2><p><img src=\"/images/IP.png\"></p>\n<h3 id=\"关键字段\"><a href=\"#关键字段\" class=\"headerlink\" title=\"关键字段\"></a>关键字段</h3><ul>\n<li>版本号：4比特，定义是ipv4还是ipv6</li>\n<li>首部长度：4比特，定义首部长度</li>\n<li>服务类型：8比特，服务类型(延时低，高吞吐等)</li>\n<li>数据包长度：ip数据报总长度（首部+数据）</li>\n<li>标识、标志、偏移：ip分片有关</li>\n<li>寿命：8字节，没经过一个路由减1,为0时丢弃</li>\n<li>协议：表示上层协议（UDP还是）</li>\n<li>首部校验和：只针对头部计算，注意由于寿命会变，所以需要不断的更新</li>\n<li>源和目的ip地址：没啥好说</li>\n<li>选项：很少使用，ipv6中就没有</li>\n<li>有效数据</li>\n</ul>\n<h3 id=\"数据报分片\"><a href=\"#数据报分片\" class=\"headerlink\" title=\"数据报分片\"></a>数据报分片</h3><p><img src=\"/images/IP_fra.png\"></p>\n<ul>\n<li>之前提到过，一个链路层帧能承载的最大数据量叫做<strong>最大传送单元（MTU）</strong></li>\n<li>广域网和局域网可能MTU不同所以要分片</li>\n<li>分片的重组放在端系统中，路由器不负责重组</li>\n<li>最后一片标志被置为0</li>\n</ul>\n<h3 id=\"ipv4编址\"><a href=\"#ipv4编址\" class=\"headerlink\" title=\"ipv4编址\"></a>ipv4编址</h3><ul>\n<li>接口：主机与物理链路之间的边界叫做接口</li>\n<li>ip地址：IP协议要求每台主机和路由器的接口拥有自己的IP地址<br><strong>从技术上来讲一个ip地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联</strong></li>\n<li>子网掩码：a.b.c.d&#x2F;x,x最高比特构成了IP地址的网络部分，为网络前缀</li>\n<li>CIDR：无类别域间路由选择，这种更灵活</li>\n<li>分类编址（不灵活）：A类子网(8bit)，B类子网(16bit)，C类子网(24bit),会有c类太少，b类太大的烦恼</li>\n</ul>\n<h3 id=\"DHCP动态主机配置协议\"><a href=\"#DHCP动态主机配置协议\" class=\"headerlink\" title=\"DHCP动态主机配置协议\"></a>DHCP动态主机配置协议</h3><p>性质：基于UDP的应用层协议,默认端口67<br>作用： 除了分配IP地址外，DHCP还允许获取其他信息子网掩码，默认网关（第一跳路由器），本地DNS服务器地址<br><img src=\"/images/DHCP.png\"></p>\n<h3 id=\"网络地址转换-NAT\"><a href=\"#网络地址转换-NAT\" class=\"headerlink\" title=\"网络地址转换-NAT\"></a>网络地址转换-NAT</h3><ul>\n<li>会改写IP地址和端口号<br><img src=\"/images/NAT.png\"></li>\n</ul>\n<h2 id=\"ipv6\"><a href=\"#ipv6\" class=\"headerlink\" title=\"ipv6\"></a>ipv6</h2><p><img src=\"/images/IPV6.png\"></p>\n<ul>\n<li>版本：显然设为6</li>\n<li>流量类型：与ipv4服务类型类似</li>\n<li>流标签：标识一条数据报的流，还未完全确定</li>\n<li>有效载荷长度</li>\n<li>跳限制：计数为0丢弃</li>\n</ul>\n<h3 id=\"ipv4-ipv6-隧道\"><a href=\"#ipv4-ipv6-隧道\" class=\"headerlink\" title=\"ipv4-&gt;ipv6:隧道\"></a>ipv4-&gt;ipv6:隧道</h3><p><img src=\"/images/tunneling.png\"></p>\n<h2 id=\"通用转发和SDN\"><a href=\"#通用转发和SDN\" class=\"headerlink\" title=\"通用转发和SDN\"></a>通用转发和SDN</h2><ul>\n<li>OpenFLow标准</li>\n<li>SDN</li>\n<li>就是根据各层的头信息执行特定转发，有更大灵活性，跳出IP转发的局限性</li>\n</ul>\n"},{"title":"curl和https","date":"2022-03-15T12:35:58.000Z","subtitle":null,"index_img":"/images/curl.png","banner_img":"/images/curl.png","_content":"## HTTP\n- HTTP/2和HTTP/3的头部通常会被curl压缩发送，但是-v选项总是把它们解压成HTTP/1.1的样子\n- HTTP默认端口：80，HTTPS默认端口：443\n- HTTP有4种方法：GET，POST，HEAD，PUT,OPTIONS\n- curl默认的http版本为HTTP/1.1,默认的https版本为HTTP/2\n### 返回码\n- 1XX：瞬态响应，更多内容即将发生\n- 2XX：成功\n- 3XX：重定向\n  - 301:永久重定向，当一个url第一次返回该值时，重定向的内容将被浏览器缓存，下次该url不起作用，直接访问重定向内容(浏览器总是使用GET，即使第一次访问时用的是POST),curl永远不会缓存\n  - 302:暂时重定向，不会缓存,重定向总是使用GET\n  - 303:同302,但是更接近于间接访问的概念\n  - 307:暂时重定向，不会缓存，区别在于它会保持第一次访问的方法\n  - 308:永久重定向，区别在于它会保持第一次访问的方法\n- 4XX：服务器无法提供或不会提供要求的内容\n  - 401:服务器需要一个认证，通常包含头`WWW-Authenticate:`,包含了服务器支持的认证方法(Basic)\n  - 407:代理服务器需要一个认证，通常包含头`Proxy-Authenticate:`,包含了代理支持的认证方法\n- 5XX：服务器出现问题\n### GET\n通过URL来形成HTTP头\n![](/images/httpRequest.png)\n**request例子**：\n```bash\nGET / HTTP/1.1\nUser-agent: curl/2000\nHost: example.com\n```\n**response例子**\n```bash\nHTTP/1.1 200 OK\nServer: example-server/1.1\nContent-Length: 5\nContent-Type: plain/text\n\nhello\n```\n### Transfer-Encoding: chunked\n有时response可能没有Content-Length，而是**Transfer-Encoding: chunked**，这只有HTTP1.1服务才有，它表示内容是一系列的块，每块开头有显示该块的十六进制大小，结束时，也会有表示结束的0块。curl会自动解码\n### Content-Encoding: gzip\nbody是经过压缩的,curl会自动解压\n### Expect:100-continue\n很少有服务器支持这一特性，且HTTP/2及以上支持在没关闭连接的情况下停止持续传输,这使得该特性无意义。(该特性到底是啥不懂)post时，curl会默认\n### 透明压缩\n过于老式，不常用，可以使用--tr-encoding来使用，前提是服务器支持\n### Etag\n服务器通过**Etag**来标识一个资源的版本，这样便于客户判断是否资源更新\n### Multipart formposts\n这对应html中form的enctype=multiparg/form-data,可以通过-F选项指定form:\n`curl -F person=anonymous -F secret=@file.txt http://example.com/submit.cgi`\n**Header内容：**\n```bash\nPOST /submit.cgi HTTP/1.1\nHost: example.com\nUser-Agent: curl/7.46.0\nAccept: */*\nContent-Length: 313\nExpect: 100-continue\nContent-Type: multipart/form-data; boundary=------------------------d74496d66958873e\n```\n**Body内容：**\n```bash\n--------------------------d74496d66958873e\nContent-Disposition: form-data; name=\"person\"\n\nanonymous\n--------------------------d74496d66958873e\nContent-Disposition: form-data; name=\"secret\"; filename=\"file.txt\"\nContent-Type: text/plain\n\ncontents of the file\n--------------------------d74496d66958873e--\n```\nhtml的form表单中enctype默认为`application/x-www-form-urlencoded`,此时只需要-d选项即可\n### 重定向\n- 有时服务器不会直接返回内容，而是告诉你该资源所在位置，此时响应中包含关键字`Location:`\n- 有时重定向会指向不同主机，此时用户名密码或证书等可能无法使用，无论如何信任的话，可以使用--location-trusted\n- 浏览器支持更多的重定向方式，curl不支持他们，比如html里meta元素，javascript的动态重定向\n### Set-Cookie\ncookie设置的一个头\n### Upgrade\n强制升级http版本的头，过老的服务器可能会出错\n### Alt-Svc\n响应体中的头，告诉客户还有哪些主机可以获得同样资源,只能在https中使用，并且这是使用http3的唯一方法（截至2019）\n### http3\nhttp3是实验版本，是为了适应QUIC协议（一个基于UDP的可靠安全的协议），只能通过https,curl没有针对http3连结失败时作自动降级处理，而是直接返回错误\n## 代理(就是web缓存服务器)\n- HTTP代理为了安全，使用**CONNECT**方法\n- HTTP代理可以代理FTP,此时curl将认为就是HTTP,FTP所有特性无效\n- MITM代理可以监控加密的流量\n- 代理认证失败，拒绝代理，会返回407\n- HTTPS代理的默认端口为443\n- curl中与代理相关的环境变量\n  - [scheme]_proxy:指定某个协议的默认代理,等价于-x选项,除了http_proxy只能全部小写(CGI的原因),其他形式可以用全部大写\n  ```bash\n\thttp_proxy=http://proxy.example.com:80\n\tcurl -v www.example.com\n  ```\n  - ALL_PROXY:所有url都走该代理\n  - NO_PROXY:某些url不走该代理，用`,`分隔多个url，等效于--noproxy\n## FTP\n- FTP协议使用两个tcp连接，一个用来建立认证，并进入到正确的文件夹内(控制连接)，一个用来传输文件，curl默认是被动连接（即客户端发送PASV或EPSV命令给服务器,服务器新开个端口，curl用该端口连接传输）,主动连接见-P，被动连接见--ftp-pasv\n- curl传输文件时有三种方法(见--ftp-method)：\n- FTPS的默认端口是990,可以通过`scheme:ftps://`指定，抑或使用`--ssl,--ssl-reqd`\n- FTPS无法推广的原因是，FTP的第二个连接是新建的tcp连接，防火墙和其他网络工具检查辨别是FTP传输并采取一些规则或设置应用到该连接,但如果加密，防火墙等就无法判断，并无法应用一些规则\n## URLs(URIs)\n需要注意的是现代浏览器的地址栏里支持IRIs,一个URLs的超集(更强大，支持空白字符等等)\n### Scheme\nscheme就是分隔符前面的内容,是协议吗？不可以包含任何空格\n- 分隔符:`://`curl只支持双斜杠的，有标准是单斜杠的\n- curl会自动纠错一些scheme格式以及自动推测(通过选项--proto-default设置)\n### Name and password(非主流)\nscheme及分隔符之后可能跟着用户名和密码,不过这风险很大,正慢慢淘汰,同时你也可以通过选项等方式来指定。一般格式如下：\n`curl ftp://user:password@example.com/`\n### host\nhost就是主机，可以是数字地址本身或简单的域名\n- ipv4:`curl http://127.0.0.1/`\n- ipv6:`curl http://[::1]/`\n### port number\n如果端口号没指明，那么就会使用各个协议的默认端口。\n通常在主机名后指明,用冒号和数字。为十进制数范围在[0-65535]\n- ipv4:`curl http://example.com:8080/`\n- ipv6:`curl http://[fdea::1]:8080/`\n### path\n每个url包含路径,如果没指明则是根目录`/`,如下是等价的\n`https://example.com`==>`https://example.com/`\n### FTP type(FTP特有很少用的特性)\n该特性可以让你指明文件类型,指定不同的类型ftp协议相应的用不同传输,curl默认以二进制格式传递FTP协议\n- A:指明传输类型为ASCII\n`curl \"ftp://example.com/foo;type=A\"`\n- I:指明传输类型为二进制\n`curl \"ftp://example.com/foo;type=I\"`\n- D:指明传输类型为目录(此时不要以斜杠结尾)\n`curl \"ftp://example.com/foo;type=D\"`\n### Fragment\n由`#`标识\n- URLs提供fragment，但curl传递时，会忽略它,(就是浏览器中的定位,跟网页屏幕位置有关)\n- 有时`#`处于路径中,为了方便你可用`%23`来代替`#`\n`https://www.example.com/info.html#the-plot`==>`curl https://www.example.com/info.html%23the-plot`\n### curl与URLs\ncurl支持许多选项，不是可选项内容的都是URLs，可以支持多个URLs,从左到右一个个解析\n- curl总是返回最后一个URL的错误代码(可以用--fail-early改变),\n- curl的选项总是应用所有URLs(当然存在例外(-o、-O)),要想应用不同的URL不同的option,可以使用`--next、-:`\n- 指定多个URLs,可以节省时间(如果多个URLs有相同主机，TCP将会一直保持链接)\n- 默认是串行,可以指定并行(-Z),并行时的进度条和串行时有区别，该进度条是所有当前运行的并行任务的实时情况\n#### globbing\n有时想传递同一主机下的一系列资源，可以用`{}`和`[]`来指定，处于它们之间的内容称为[globbing],并且他们可以混用，此时为防止shell的副作用，应该用引号括起来URL，\n- `[]`\n  - `curl -O \"http://example.com/[1-100].png\"`\n  - `curl -O \"http://example.com/[001-100].png\"`支持前导0\n  - `curl -O \"http://example.com/[001-100:2].png\"`取奇数\n  - `curl -O \"http://example.com/[a-z].png\"`支持字母\n- `{}`\n  - `curl -O \"http://example.com/{one,two,three,alpha,beta}.html\"`\n- -o选项里面可以通过`#[num]`来代表globbing内容,num从1开始编号\n  - `curl \"http://{one,two}.example.com\" -o \"file_#1.txt\"`\n  - `curl \"http://{site,host}.host[1-5].example.com\" -o \"subdir/#1_#2\"`\nglobbing有时还可以用于-T选项，上传多个文件:\n`curl -T 'image[1-99].jpg' ftp://ftp.example.com/upload/`\n## curl\n### 配置文件curlrc\n按以下优先级读取文件：\n1) \"$CURL_HOME/.curlrc\"\n2) \"$XDG_CONFIG_HOME/.curlrc\"\n3) \"$HOME/.curlrc\"\n## 选项\n### -A/--user-agent\n指明`User-Agent:`的值\n### --alt-svc [cacheFile]\n会尝试cacheFile定义中的可获得同样资源的主机地址，如果server响应并更新了`Alt-Svc:`,则也会自动更新到cacheFile中。\n### --anyauth\ncurl首先不使用认证，如果服务器需要，curl将会尝试使用认证\n### -B\n以二进制形式传输，curl默认就是二进制\n### -b [cookiesFile]\n从文件中读取cookie，-c选项是写cookie\n### --basic\n使用Basic认证方法，默认的认证方法\n### -c [cookieFile]\n写入cookie到一个文件中\n### -C/--continue-at [num/-]\n指明从num byte offset开始继续下载或`-`curl根据已有的下载文件确定从哪开始继续下载。\n**例1**:`curl --continue-at 100 ftp://example.com/bigfile`\n**例2**:`curl --continue-at - http://example.com/bigfile -O`\n### --cacert [path]\n设置CA证书路径\n### --cert [file:passwd]\nTLS指定客户端的证书文件,待学习相关知识\n```bash\ncurl --cert mycert:mypassword https://example.com\ncurl --cert mycert:mypassword --key mykey https://example.com\ncurl --cert mycert:mypassword --cert-type PEM \\\n     --key mykey --key-type PEM https://example.com\n```\n### --cert-type\n见--cert例子\n### --cert-status\n这个TLS特性为OCSP stapling,比较新，目前仅有openssl,gnutls,nss支持，一般不使用\n### --ciphers\nTLS中ciphers,除非你知道你在干啥，否则慎用。\n### --connect-to [source name:source port:destination name:destination port]\n有时负载均衡，一个host name其实由多个服务提供，有时你只想测试其中一个服务，可以用此选项，如下：\n`curl --connect-to www.example.com:80:load1.example.com:80 http://www.example.com`\n### --connect-timeout [num]\n指定tcp连接多长时间没反应算失败，单位秒，可以给出float类型数字\n### --compressed\nhttp/https,请求服务器提供压缩版本的内容，curl会在数据到达后自动解压，这只是加快传输速度，注意不能和另一个--tr-encoding混用，因为两者采用不同压缩\n### -d/--data [string or num]\n发送的数据,simple POST,一下两种方式等价\n```bash\ncurl -d 'name=admin&shoesize=12' http://example.com/\ncurl -d name=admin -d shoesize=12 http://example.com/\n#从某个文件读取\ncurl -d @filename http://example.com\n```\n从文件中读取时，会去除回车和换行，如果不想这样见--data-binary\n### --data-binary\n该选项从文件读取时，不会去除回车和换行\n### --data-raw\n-d选项的补充，主要是为了下面的情况:\n`curl --data-raw '@string' https://example.com`\n### --data-urlencode\n把post内容使用url的安全编码(即把空格和一些不安全字符使用%xx%编码)，接受以下形式(只对内容进行编码):\n- content\n- =content\n- name=content\n- @filename\n- name@filename\n### --digest\ndigest的认证方式\n### --dns-interface\n指定dns走的网卡？\n### --dns-ipv4-addr\n指定ipv4的dns服务器\n### --dns-ipv6-addr\n指定ipv6的dns服务器\n### --dns-servers\n指定一个dns服务器\n### -e/--referer\n当在浏览器中，从一个页面，点击另一个页面，会形成一个`Referer:`的头，它说明是从哪个网站进去的，例如：\n`curl --referer http://comes-from.example.com https://www.example.com/`\n### --etag-save [etagSavedFile]\n把该资源的Etag保存到某文件中\n### --etag-compare [etagFile]\n与本地文件中保存Etag做对比，只下载更新的，可以与--etag-save连用，达到自动更新的目的\n`curl --etag-compare etag.txt --etag-save etag.txt https://example.com/file -o output`\n### -f/--fail\n一般http返回4xx码时，curl也会认为是成功的一次传输，如果启用该选项，如果是4xx，curl将以22退出\n### -F\nhttp的方法将是POST\n### --fail-early\n### --fail-with-body\n同--fail\n### --ftp-method [multicwd/nocwd/singlecwd]\n- multicwd(curl默认方法)：`curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt`\n等价于\n```bash\nCWD one < 250 OK. Current directory is /one CWD two < 250 OK. Current directory is /one/two CWD three < 250 OK. Current directory is /one/two/three RETR file.txt\n```\n- nocwd(并不符合标准):`curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt`\n等价于\n```bash\nRETR one/two/three/file.txt\n```\n- singlecwd(服务器不一定支持):`curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt`\n等价于\n```bash\nCWD one/two/three < 250 OK. Current directory is /one/two/three RETR file.txt\n```\n### --ftp-pasv\ncurl默认就是ftp被动连接，这个选项是重新设置为被动连接\n### --ftp-skip-pasv-ip\n有时服务器对于PASV被动建立连接命令会故意返回一个错的ip地址，此时该选项可以忽略该地址，使用控制连接的地址\n### -G/--get\n当指定-d等选项时，默认为post方法，此选项可以强制转成get，所有数据都追加在url末尾，以`?`分割\n### -h/--help\n### -H [header content]\n- 自定义头部内容\n`curl -H \"Host: www.example.com\" http://localhost/`\n- 去除curl自动形成的头，只要不给值就行：\n`curl -H \"User-Agent:\" http://example.com/`\n- 去除所有头\n`curl -H \"Empty;\" http://example.com`\n### --hsts [hstsFile]\nHSTS是一个严格的传输安全协议，它保护https不被降级和中间cookie注入，整个过程中不能使用明文。该选项使curl读入某个server的HSTS缓存,然后自动更新，并且自动转换http为https:\n`curl --hsts hsts.txt https://example.com`\n### --http0.9\n该版本非常不成熟，响应只有body，没有header,使用该选项是告诉curl接受该种响应\n### --http1.0\n尝试使用http1.0\n### --http1.1\n尝试使用http1.1\n### --http2\n尝试使用http2\n### --http2-prior-knowledge\n前提你确定已经知道服务器支持http2了，这个加快negotiate的速度\n### --http3\n尝试使用http3\n### -I\nHTTP方法将是HEAD\n### --ignore-content-length\n忽略头部的Content-Length信息（早期数据不可以超过2g,content-length可能是负的），直接接受数据\n### --interface [ip addr or some interface]\n指定哪个网络接口来传输流量，或者使用哪个原始ip地址（前提你有多个ip）这个不影响dns的接口，dns接口可用--dns-interface\n### -j/--junk-session-cookies\n模拟浏览器重新打开，一个新的会话cookie\n`curl -j -b cookies.txt http://example.com/`\n### -J/--remote-header-name\nHTTP头可能提供`Content-Disposition:`,这其中包含了建议的文件名，这个选项使用该文件名作为输出，如果该内容存在，会覆盖-O选项。\n- 它只会保留文件名部分，忽略目录\n- CURL不会帮你解码，可能是个URL原码格式的文件名（浏览器会解码）\n### --json\n该选项是为了更好的post json格式的内容，等价于下面三个选项\n```bash\n--data [jsonformat]\n--header \"Content-Type: application/json\"\n--header \"Accept: application/json\"\n```\n注意多次使用该选项时，curl只是简单的字符串拼接，并不会帮你合并，所以应该像下面这样使用：\n`curl --json @json.txt --json \", \"end\": \"true\"}' https://example.com/`\n### -k/--insecure\ntls/ssh协议中，curl会跳过检查known_hosts文件及本地安全证书，直接信任\n### -K/--config\n`-K <fileName>`\n此选项是为了帮助过长的选项不好输在命令行中，fileName则可以保存这些选项\n- 一行一个选项，长选项可以省略`--`\n- 可以用`#`注释\n- 选项和参数内容间可以用`=`或`:`使结构清晰\n- 参数如果含空格，必须用双引号括起来,括号内只可以用下面这些转义字符`\\\\,\\\",\\t,\\n,\\r,\\v`,如果不用双引号,则遇到第一个空格就结束读取\n- 文件内也可以指明url，必须如下格式\n`url = \"http://example.com\"`\n### --keepalive-time [num]\ncurl默认会保持无流量的tcp连接长达60s,这可以更改时间，单位为秒\n### --key\n指定cert健，见--cert\n### --key-type\n见--cert\n### -l/--list-only\nFTP协议中相当与使用NLST命令，可能不会list符号链接和目录\n### -L/--location\n如果返回重定向，则继续访问重定向的地址。默认最多50个。curl默认不会访问重定向的内容,\n### --limit-rate <num>\n参数是个数字，默认单位是byte，可以跟K/M/G，整个过程的平均速度将不超过这个值,也同样适用于上传速率\n### --location-trusted\n永远信任重定向的任何主机，默认是不信任，因为，可能重定向不同主机\n### --local-port [num or range]\n通常不需要指定本地端口，但有时只有某些端口是开放的，指定curl的本地端口，可以指定一个范围，因为一个可能被占用了,最好不要指定1024以下的端口\n### -m/--max-time [num]\n整个命令允许运行的最长时间，即使正在下载，也会立刻退出(退出码28)\n### --mail-from\nsmtp中指定发件人\n### --mail-rcpt\nsmtp中指定收件人\n### --manual\n### --max-filesize [num]\n单位是byte，如果curl在传输开始可以获得将要下载的内容大小，该选项才会起作用，如果超过该大小，curl将会自动放弃。\n### --max-redirs [num]\n指定最多重定向次数，默认50个\n### -n/--netrc\n读取`~/.netrc`配置文件，该文件存储用户名密码，例子如下\n```bash\n#以下的值都不许有空格，且可以写在一行\nmachine example.com #可以填default,此时不需要machine关键字\nlogin nanbert\npassword xxx \nmacdef xxx #该选项curl不支持，会忽略\n```\n### --negotiate\nnegotiate的认证方式\n### -netrc-file [path]\n不读默认`~/.netrc`文件，而是具体某个文件\n### --netrc-optional\n这与`--netrc`区别在于，使得默认配置内容是可选的,不是强制的\n### --next\n### --no-eprt\nftp协议中禁止使用命令EPRT，该命令比PORT更新\n### --no-epsv\nftp协议中进制使用命令EPSV，该命令比PASV更新\n### --no-keepalive\n默认curl会保持tcp(无流量)连接60s,这个会关闭该功能\n### --noproxy\n不使用全局环境变量代理\n### --no-verbose\n### --ntlm\nntlm的认证方式\n### -o\n输出到某个文件，一个该选项对应一个url,想要指明多个，必须声明多个-o\n### -O/--remote-name\n把结果输出到使用远程服务器的原始文件名,一个该选项对应一个url,想要指明多个，必须声明多个-O\n### --path-as-is\n在url指定路径时，如果出现`/../`或`/./`,curl会替换它们，再发送给服务器，比如`/hello/sir/../`变成`/hello/`,`/hello/./sir`变成`/hello/sir/`,而该选项会保留`..`和`.`\n### -P/--ftp-port [ip/-]\n这其实是使用命令PORT或EPRT，即服务器建立新连接到客户,但经常不指定一个确切的port,直接使用`-`,总是为，信息来时的地址，如下：  \n`curl -P - ftp://example.com/foobar.txt`\n### --post301\n返回301重定向时，保持初始的方法\n### --post302\n返回302重定向时，保持初始的方法\n### --post303\n返回303重定向时，保持初始的方法\n### -p/--proxytunnel\n使用隧道对代理加密\n`curl -p -x http://proxy.example.com:80 ftp://ftp.example.com/file.txt`\n### --parallel-max\n### --pinnedpubkey [sha256//hashnum1;hashnum2;..]\nTLS协议中，Certifiate pinning中直接指定sha256值\n### --proto-default\n### --proxy1.0 [ip addr]\n指定代理，和`--x`一样，只是使用HTTP/1.0\n### --proxy-anyauth\n任意一种代理用户名认证方式,根据代理服务器要求自动匹配或者不使用认证\n### --proxy-digest\n一种代理用户名认证方式\n### --proxy-header\n该头只发送给代理，真正的远程服务器不会收到，这比--header更精细化\n`curl --proxy-header \"User-Agent: magic/3000\" -x proxy https://example.com/`\n### --proxy-negotiate\n一种代理用户名认证方式\n### --proxy-ntlm\n一种代理用户名认证方式\n### -Q/--quote [ftp cmd]\n发送命令给ftp服务器\n- 在传输之前发送NOOP命令`curl -Q NOOP ftp://example.com/file`\n- 在传输之后发送NOOP命令`curl -Q -NOOP ftp://example.com/file`\n- 不知什么时候发`curl -Q +NOOP ftp://example.com/file`\n发送的命令发生错误时会导致curl退出，有时可以在命令前加`*`，忽略可能发送错误，如：\n`curl -Q \"-*DELE file\" ftp://example.com/moo`\n### -r/--range [num1-num2,num3-,0-num3,...]\n只下num1 byte offset至num2 byte offset的内容,服务器可以选择性的实现该功能，也就是说，即使你这么请求，服务器也可能返回全部内容\n### --remote-name-all\n所有结果均输出保存到服务器上的原始文件名\n### --remote-time\n使得下载到本地的文件的时间戳和远程服务器文件的时间戳一样，常和-z -o选项搭配  \n`curl -z file.html -o file.html --remote-time https://example.com/file.html`\n### --resolve [host name:port:ip address]\ndns重定向，这会保存到curl的cache中\n`curl --resolve example.com:80:127.0.0.1 http://example.com/`\n### -s/--silent\n此选项关闭进度条，并不显示错误，但是-S/--show-error不受此选项影响\n### -S/--show-error\n默认情况下curl会输出错误，该选项主要是抵消-s的作用\n### --speed-time [num]\n经常和--speed-limit一起用,下面的意思是速度小于1000并且持续15s就退出\n`curl --speed-time 15 --speed-limit 1000 https://example.com/`\n### --speed-limit [num]\n见--speed-time\n### --ssl\n尝试ssl加密(FTP,IMAP,POP3,SMTP)\n### --sslv2\n使用SSL2版本\n### --sslv3\n使用SSL3版本\n### --ssl-reqd\n强制ssl加密(FTP,IMAP,POP3,SMTP)\n### --raw\n禁用内容或传输编码的所有内部http解码，而是使用未经修改的原始数据,这经常用在curl为一个代理的情况\n### --retry [num]\ncurl会在发生transient error时，会重新尝试num次，默认失败一次就不会尝试，transient error包括以下：超时，FTP 4XX返回码，http5xx返回码\n### --request-target\n获取的资源路径，这个一般直接写在url中，但这配合OPTIONS方法，有个特殊用法：\n`curl -X OPTIONS --request-target \"*\" http://example.com/`\n会形成下面的头：\n`OPTIONS * HTTP/1.1`\n### --retry-all-errors\n有时你确定一个服务器是好的，出现任何错误都想重试，该选项就可以帮你\n### --retry-connrefused\n重试只会发生在transient error时，但拒绝访问不属于，有时你确认服务器只是重启或其他原因，该选项可以使得出现拒绝访问时，也可以重试。\n### --retry-max-time [num]\n第一次重试之前,curl会等1s,然后第二次重试会等2s,如此指数增长下去，直到达到10min，该选项会指明等待时间不少于num秒，--max-time选项仍会起作用\n### -T\n- HTTP PUT就是上传某个完整资源上传或替换远程的现有资源，很少被服务器启用\n- FTP或TFTP 上传文件，如下\n`curl -T uploadthis ftp://example.com/this/directory/`\n`curl -T uploadthis ftp://example.com/this/directory/remotename`\n- SMTP上传body内容，通常需要其他选项(有关header的选项)配合（--mail-from,等）\n`curl -T mail smtp://mail.example.com/ --mail-from user@example.com`\n### -t/--telnet-option [keyword=value]\ntelnet选项特有，传递以下三个参数：\n- TTYPE=[term]:设置终端类型\n- XDISPLOC=[X display]:设置X展示位置\n- NEW_ENV=[var,val]:设置环境变量值\n### --tftp-blksize [num]\ntftp通信传输块默认大小为512,此选项可以修改，支持8-65464\n### --tftp-no-options\n有些tftp服务器不接受任何选项，此时该选项可以应用\n### --tlspassword [passwd]\nTLS的特性，可以在命令行中直接使用用户名和密码\n`curl --tlsuser daniel --tlspassword secret https://example.com`\n### --tlsuser [name]\n见--tlspassword\n### --tlsv1/--tlsv1.0\n使用TLS>=1.0的版本\n### --tlsv1.1\n使用TLS>=1.0的版本\n### --tlsv1.2\n使用TLS>=1.2的版本\n### --tlsv1.3\n使用TLS>=1.3的版本,curl默认\n### --tr-encoding\n采用Transfer-Encoded压缩传输内容，curl会自动解压,不能和--compressed混用,且该选项不常用\n### --trace [filename]\n会跟踪每拍接受的内容，以16进制显示,每行开头的十六进制加冒号代表该内容的byte offset\n### --trace-ascii [filename]\n会跟踪每拍接受的内容，以ascii码可读形式显示\n### --trace-time\n化学选项：-v/--verbose,--trace和--trace-ascii\n这个选项会帮助化学选项所输出内容之前加高精度的时间。\n### -u/--user\n指定用户名和密码，冒号分隔`user:passwd`,这种明文，最好不用，协议层方面使用https和ftps等，如果非要使用明文,可以选择选项`--digest`,`--negotiate`,`--ntlm`,或者直接通过配置文件###1禁用。\n```bash\ncurl --digest --user daniel:secret http://example.com/\ncurl --negotiate --user daniel:secret http://example.com/\ncurl --ntlm --user daniel:secret http://example.com/\n```\n### -U/--proxy-user [user:passwd]\n指定代理的用户名和密码\n`curl -U daniel:secr3t -x myproxy:80 http://example.com`\n### --upload-file\n指定上传内容文件，用于smtp\n### --use-ascii\n使用ascii传输，而不是二进制\n### -v/--verbose\n该选项会使curl显示更多的内容，具体格式如下：\n- `*`后面跟解释性内容\n- `>`后面跟客户端发送的头协议，（FTP,SMTP,POP3等没有头协议的，命令和返回当成头）\n- `<`后面跟从服务端接受的返回头协议\nHTTP/2和HTTP/3协议头是压缩的，但在此选项下会展开和HTTP/1.1一样的格式\n### -V/--version\n会输出版本相关的信息，各行含义如下:\n**第一行:**版本号+平台+第三方依赖信息\n**第二行:**版本发布日期\n**第三行:**支持的协议\n**第四行:**支持的特性\n### -w/--write-out \n参数:`<formatted string>`或`@[filename或-]`\n该选项会在每个传输完毕后，在末尾加上formatted string或文件中的内容,%可以使用`\\n,\\r,\\t`转义字符，特殊的变量跟在`%`后,`%%`输出真正的%\n有以下formatted string:\n\n|格式|含义|\n|:-:|:-:|\n|`%{content_type}`|字面义，有的内容没有类型|\n|`%{errormsg}`|字面义，无错误为空|\n|`%{exitcode}`|传输的退出码，无错返回0|\n|`%{filename_effective}`|最终传输内容所保存的文件名，只当指定-o或--remote-name选项有意义|\n|`%{ftp_entry_path}`|登陆ftp的初始路径|\n|`%{http_code}`|也就是response_code|\n|`%{http_connect}`|待探索|\n|`%{http_version}`|字面义|\n|`%{json}`|所有write-out的变量生成json格式|\n|`%{local_ip}`|最近一次连接的ipv4或ipv6的本地地址|\n|`%{local_port}`|最近一次连接的本地端口|\n|`%{method}`|最近请求的方法|\n|`%{num_connects}`|最近传输的新连接数量|\n|`%{num_headers}`|上一次传输的反应头的数量|\n|`%{num_redirects}`|请求的重定向次数|\n|`%{onerror}`|如果传输发生错误，输出之后的string,内容，否则不输出|\n|`%{proxy_ssl_verify_result}`|与代理通信时请求的SSL对等证书验证的结果,0表示成功|\n|`%{redirect_url}`|当发出HTTP请求而没有-L重定向时，重定向会将您带到的实际URL|\n|`%{remote_ip}`|远程的ipv4或6地址|\n|`%{remote_port}`|远程的端口|\n|`%{response_code}`|字面义|\n|`%{scheme}`|url的scheme|\n|`%{size_download}`|字面义|\n|`%{size_header}`|头部的大小|\n|`%{size_request}`|请求的大小|\n|`%{size_upload}`|上传大小|\n|`%{speed_download}`|平均下载速度|\n|`%{speed_upload}`|平均上传速度|\n|`%{ssl_verify_result}`|请求SSL对等证书验证的结果，0表示成功|\n|`%{stderr}`|接下来的内容输出到标准错误|\n|`%{stdout}`|接下来的内容输出到标准输出|\n|`%{time_appconnect}`|从开始到完成SSL/SSH/etc到远程主机的连接/握手花费的时间，单位秒|\n|`%{time_connect}`|从一开始直到TCP连接到远程主机（或代理）完成花费的时间，单位秒|\n|`%{time_namelookup}`|从一开始直到名字解析完成所花费的时间,单位秒|\n|`%{time_pretransfer}`|从一开始直到文件传输即将开始所花费的时间，单位秒|\n|`%{time_redirect}`|所有重定向步骤，包括名称查找，连接，预传输和最终事务开始之前的传输所花费的时间,单位秒|\n|`%{time_starttransfer}`|从一凯斯直到第一个字节即将被传输，这包括time_pretransfer和服务器计算结果所需的时间|\n|`%{time_total}`|完整操作持续的总时间，时间为秒，精度达到毫秒|\n|`%{url}`|命令行中指定url|\n|`%{url_effective}`|真实有效的url|\n|`%{urlnum}`|url的编号，从0开始计数|\n### -X/--request\n指定http的方法，一般curl会根据选项自动判断，无需特地指定该选项，错误的方法可能使得curl行为怪异\n### -x/--proxy [ip addr]\n- 指定代理，默认scheme为http,默认端口为1080\n`curl -x 192.168.0.1:8080 http://example.com/`\n- 指定SOCKS协议代理，这可以直接使用各个版本，而不用-x，说明如下：\n```bash\n#SOCKS4版本\ncurl -x socks4://proxy.example.com http://www.example.com/\ncurl --socks4 proxy.example.com http://www.example.com/\n#SOCKS4a版本\ncurl -x socks4a://proxy.example.com http://www.example.com/\ncurl --socks4a proxy.example.com http://www.example.com/\n#SOCKS5版本\ncurl -x socks5://proxy.example.com http://www.example.com/\ncurl --socks5 proxy.example.com http://www.example.com/\n#SOCKS5h版本\ncurl -x socks5h://proxy.example.com http://www.example.com/\ncurl --socks5-ostname proxy.example.com http://www.example.com/\n```\n### --xattr\n\n### -Z/--parallel\n### -z/--time-cond [time stamp/file]\n对下载的内容做时间限制(可早，可晚)，时间格式可以是常见的格式，或者指定比某个本地文件新\n```bash\ncurl -z \"Jan 10, 2017\" https://example.com/file -O#只下载比该时间戳新的\ncurl --time-cond \"Sun, 12 Sep 2004 15:05:58 -0700\" https://www.example.org/file.html#只下载比该时间早的\ncurl -z file.html https://example.com/file.html -O#比file.html新的\n```\n### -:\n### -#/--progress-bar\n当内容重定向时，进度条是默认打开的,该选项会展示一种简单的进度条，有时进度条无法估计时间\n### @作用\n传参数可以把参数放到文件里，如下:\n`curl -d @json http://example.com`\n## curl退出码\n- 1：不支持的协议\n- 2：初始化失败，libcurl可能出了问题\n- 3：url格式不对\n- 4：某个请求需要某个特性或选项未能满足\n- 5：无法解析代理\n- 6：无法解析主机\n- 7：无法连接主机。可能端口，主机名或防火墙的问题\n- 8：未知的ftp服务返回。可能未支持，也可能未启用选项\n- 9：ftp拒绝访问。没该文件或用户名或没权限\n- 10：ftp接受失败。\n- 11：ftp奇怪的PASS回复\n- 12：在等待服务器连接的活动FTP会话期间，超过限期\n- 13：FTP PASV命令未知的反应。通过--ftp-port选项可能解决该问题\n- 14：未知FTP227格式。这肯定是个坏服务器，或者可以通过--ftp-port解决该问题\n- 15：FTP无法获得主机\n- 16：HTTP/2 error\n- 17：FTP无法设置binary传输。坏的服务器\n- 18：只传输了部分文件\n- 19：FTP无法获得下载该文件。RETR命令失败\n- 20：（保留）\n- 21：引用错误。IMAP、POP3、SMTP、FTP发送自定义命令时出错，建议查看报头\n- 22：HTTP页面未抓取。对应400反应码以上的错误，出现该错误只能在-f选项启用的时候\n- 23：写错误。写到本地时发生的错误\n- 24：（保留）\n- 25：上传失败。服务器空间已满或拒绝上传\n- 26：读错误。从本地读取时发生错误\n- 27：内存不够。系统分配给curl内存不足\n- 28：操作超时。由各种选项设置的各种超时\n- 29：（保留）\n- 30：FTP PORT命令错误。PORT命令有点非主流，可以试试PASV\n- 31：FTP无法使用REST。可以在没有范围或恢复的情况下重试\n- 32：（保留）\n- 33：HTTP范围错误\n- 34：HTTP post错误,需要反馈BUG\n- 35：TLS/SSL连接错误\n- 36：无法恢复下载。FILE,FTP,SFTP会发生此错误\n- 37：无法读取该文件。FILE协议，可能不存在或没权限\n- 38：绑定LDAP失败。可能用户密码错误\n- 39：LDAP搜索失败。\n- 40：（保留）\n- 41：（保留）\n- 42：回调错误。开发者编程的错误\n- 43：错误函数参数。libcurl的调用问题\n- 44：（保留）\n- 45：网络接口错误\n- 46：（保留）\n- 47：太多重定向。默认最多50个，可以通过--max-redirs改变\n- 48：libcurl未知选项。可能curl和libcurl版本不一\n- 49：telnet错误的选项\n- 50：（保留）\n- 51：SSL/TLS、SSH认证失败\n- 52：服务器未返回任何内容。可能是服务器有意为之\n- 53：未发现SSL引擎\n- 54：无法设置SSL加密引擎为默认\n- 55：无法发送网络数据。网络底层的错误，需要Wireshark等工具查看\n- 56：无法接受网络数据。网络底层错误。\n- 57：（保留）\n- 58：本地认证有问题。\n- 59：无法使用ssl密码。密码有格式标准\n- 60：对等证书无法使用已知ca认证\n- 61：无法识别传输编码\n- 62：无效LDAP URL\n- 63：超过最大文件大小限制\n- 64：FTP SSL失败\n- 65：发送之前帧失败\n- 66：初始化SSL引擎失败\n- 67：用户名密码CURL无法登陆\n- 68：TFTP服务没有该文件\n- 69：TFTP服务权限问题\n- 70：TFTP服务没有空间\n- 71：非法TFTP操作\n- 72：未知TFTP传输id\n- 73：TFTP文件已存在\n- 74：TFTP没有该用户\n- 75：字符转换失败\n- 76：需要字符转换函数\n- 77：读SSL CA认证时发生问题\n- 78：URL中的资源不存在\n- 79：在SSH会话中发生错误\n- 80：关闭SSL连接失败\n- 81：（保留）\n- 82：无法下载CRL文件，错误格式\n- 83：TLS认证检查失败\n- 84：FTP PRET命令失败\n- 85：RTSP:CSeq数字不匹配\n- 86：RTSP:会话标识符不匹配\n- 87：无法解析ftp文件列表\n- 88：FTP 块回掉错误\n- 89：没有可用的连接，会话将排队\n- 90：SSL公钥不匹配固定公钥\n- 91：无效SSL认证状态\n- 92：HTTP/2流错误\n- 93：API回调错误\n- 94：认证错误\n- 95：HTTP/3错误\n- 96：QUIC连接错误\n## curl与浏览器的区别\n- 浏览器会对接受的数据进行二次解码,更易懂些，curl就直接解码\n- 有的服务器会根据不同客户端(甚至不同的浏览器)提供更适配的内容\n- 你可以使用f12然后选中network,右键点击你想要的资源，选中`copy cURL`就可以复制相应的命令\n## POP3(curl读邮件使用的协议)\n```bash\n#To list message numbers and sizes:\ncurl pop3://mail.example.com/\n#To download message 1:\ncurl pop3://mail.example.com/1\n#To delete message 1:\ncurl --request DELE pop3://mail.example.com/1\n```\n**TLS加密**\n```bash\ncurl pop3://mail.example.com/ --ssl-reqd\ncurl pop3s://mail.example.com/\n```\n## IMAP(curl读邮件使用的协议，更常用现代)\n```bash\n#Get the mail using the UID 57 from mailbox 'stuff':\ncurl imap://server.example.com/stuff;UID=57\n#get the mail with index 57 from the mailbox 'fun'\ncurl imap://server.example.com/fun;MAILINDEX=57\n#List the mails in the mailbox 'boring':\ncurl imap://server.example.com/boring\n#List the mails in the mailbox 'boring' and provide user and password:\ncurl imap://server.example.com/boring -u user:password\n```\n**TLS加密**\n```bash\ncurl --ssl imap://mail.example.com/inbox\ncurl imaps://mail.example.com/inbox\n```\n## SMTP(cURL写邮件使用的协议)\n必须指定收发邮箱，以及内容,默认端口587\n```bash\ncurl smtp://mail.example.com --mail-from myself@example.com --mail-rcpt \\\nreceiver@example.com --upload-file email.txt\n```\nemail.txt:\n```bash\nFrom: John Smith <john@example.com>\nTo: Joe Smith <smith@example.com>\nSubject: an example.com example email\nDate: Mon, 7 Nov 2016 08:45:16\n\nDear Joe,\nWelcome to this example email. What a lovely day.\n```\n和POP3、IMAP一样，可以使用SSL/TLS加密，schema改成smtps即可，或者使用--ssl或--ssl-reqd,此时默认端口为465\n## MQTT\n订阅推送的协议，不太懂\n## TFTP\n小文件传输协议，使用的是UDP\n- 下载`curl -O tftp://localserver/file.boot`\n- 上传`curl -T file.boot tftp://localserver/`\n## TELNET\n即时通信协议，默认端口23\n## DICT\n字典查询的协议\nalias:\n- m:match和find\n- d:define和lookup\n例子：\n```bash\ncurl dict://dict.org/m:curl\ncurl dict://dict.org/d:heisenbug:jargon\ncurl dict://dict.org/d:daniel:gcide\ncurl dict://dict.org/find:curl\n```\n## TLS/SSL\nTLS是建立于TCP上一层的安全加密层，SSL是旧称(且所有ssl版本都在淘汰中)，两个是一个概念。\n各个版本协议都有TLS版本：\n- HTTP-HTTPS\n- LDAP-LDAPS\n- FTP-FTPS\n- POP3-POP3S\n- IMAP-IMAPS\n- SMTP-SMTPS\nTLS属于third-party,你可以通过--version查看，如果你feature中有MultiSSL的特性，证明curl是支持多版本的，你可以通过`CURL_SSL_BACKEND`来设置使用那个版二\n### 版本历史\nSSL2(1995)->SSL3->TLS1.0(1999)->TLS1.1(2006)->TLS1.2(2008)->TLS1.3(2018)\n### CA的存储\n一般都是内建的，但你也可以用--cacert指定路径（一定要是PEM格式），或者设置CURL-CA_BUNDLE环境变量\n\n## wget\n- ![](https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/wget.html)\n","source":"_posts/curl和https.md","raw":"---\ntitle: curl和https\ndate: 2022-03-15 20:35:58\nsubtitle:\ncategories:\ntags:\nindex_img: /images/curl.png\nbanner_img: /images/curl.png\n---\n## HTTP\n- HTTP/2和HTTP/3的头部通常会被curl压缩发送，但是-v选项总是把它们解压成HTTP/1.1的样子\n- HTTP默认端口：80，HTTPS默认端口：443\n- HTTP有4种方法：GET，POST，HEAD，PUT,OPTIONS\n- curl默认的http版本为HTTP/1.1,默认的https版本为HTTP/2\n### 返回码\n- 1XX：瞬态响应，更多内容即将发生\n- 2XX：成功\n- 3XX：重定向\n  - 301:永久重定向，当一个url第一次返回该值时，重定向的内容将被浏览器缓存，下次该url不起作用，直接访问重定向内容(浏览器总是使用GET，即使第一次访问时用的是POST),curl永远不会缓存\n  - 302:暂时重定向，不会缓存,重定向总是使用GET\n  - 303:同302,但是更接近于间接访问的概念\n  - 307:暂时重定向，不会缓存，区别在于它会保持第一次访问的方法\n  - 308:永久重定向，区别在于它会保持第一次访问的方法\n- 4XX：服务器无法提供或不会提供要求的内容\n  - 401:服务器需要一个认证，通常包含头`WWW-Authenticate:`,包含了服务器支持的认证方法(Basic)\n  - 407:代理服务器需要一个认证，通常包含头`Proxy-Authenticate:`,包含了代理支持的认证方法\n- 5XX：服务器出现问题\n### GET\n通过URL来形成HTTP头\n![](/images/httpRequest.png)\n**request例子**：\n```bash\nGET / HTTP/1.1\nUser-agent: curl/2000\nHost: example.com\n```\n**response例子**\n```bash\nHTTP/1.1 200 OK\nServer: example-server/1.1\nContent-Length: 5\nContent-Type: plain/text\n\nhello\n```\n### Transfer-Encoding: chunked\n有时response可能没有Content-Length，而是**Transfer-Encoding: chunked**，这只有HTTP1.1服务才有，它表示内容是一系列的块，每块开头有显示该块的十六进制大小，结束时，也会有表示结束的0块。curl会自动解码\n### Content-Encoding: gzip\nbody是经过压缩的,curl会自动解压\n### Expect:100-continue\n很少有服务器支持这一特性，且HTTP/2及以上支持在没关闭连接的情况下停止持续传输,这使得该特性无意义。(该特性到底是啥不懂)post时，curl会默认\n### 透明压缩\n过于老式，不常用，可以使用--tr-encoding来使用，前提是服务器支持\n### Etag\n服务器通过**Etag**来标识一个资源的版本，这样便于客户判断是否资源更新\n### Multipart formposts\n这对应html中form的enctype=multiparg/form-data,可以通过-F选项指定form:\n`curl -F person=anonymous -F secret=@file.txt http://example.com/submit.cgi`\n**Header内容：**\n```bash\nPOST /submit.cgi HTTP/1.1\nHost: example.com\nUser-Agent: curl/7.46.0\nAccept: */*\nContent-Length: 313\nExpect: 100-continue\nContent-Type: multipart/form-data; boundary=------------------------d74496d66958873e\n```\n**Body内容：**\n```bash\n--------------------------d74496d66958873e\nContent-Disposition: form-data; name=\"person\"\n\nanonymous\n--------------------------d74496d66958873e\nContent-Disposition: form-data; name=\"secret\"; filename=\"file.txt\"\nContent-Type: text/plain\n\ncontents of the file\n--------------------------d74496d66958873e--\n```\nhtml的form表单中enctype默认为`application/x-www-form-urlencoded`,此时只需要-d选项即可\n### 重定向\n- 有时服务器不会直接返回内容，而是告诉你该资源所在位置，此时响应中包含关键字`Location:`\n- 有时重定向会指向不同主机，此时用户名密码或证书等可能无法使用，无论如何信任的话，可以使用--location-trusted\n- 浏览器支持更多的重定向方式，curl不支持他们，比如html里meta元素，javascript的动态重定向\n### Set-Cookie\ncookie设置的一个头\n### Upgrade\n强制升级http版本的头，过老的服务器可能会出错\n### Alt-Svc\n响应体中的头，告诉客户还有哪些主机可以获得同样资源,只能在https中使用，并且这是使用http3的唯一方法（截至2019）\n### http3\nhttp3是实验版本，是为了适应QUIC协议（一个基于UDP的可靠安全的协议），只能通过https,curl没有针对http3连结失败时作自动降级处理，而是直接返回错误\n## 代理(就是web缓存服务器)\n- HTTP代理为了安全，使用**CONNECT**方法\n- HTTP代理可以代理FTP,此时curl将认为就是HTTP,FTP所有特性无效\n- MITM代理可以监控加密的流量\n- 代理认证失败，拒绝代理，会返回407\n- HTTPS代理的默认端口为443\n- curl中与代理相关的环境变量\n  - [scheme]_proxy:指定某个协议的默认代理,等价于-x选项,除了http_proxy只能全部小写(CGI的原因),其他形式可以用全部大写\n  ```bash\n\thttp_proxy=http://proxy.example.com:80\n\tcurl -v www.example.com\n  ```\n  - ALL_PROXY:所有url都走该代理\n  - NO_PROXY:某些url不走该代理，用`,`分隔多个url，等效于--noproxy\n## FTP\n- FTP协议使用两个tcp连接，一个用来建立认证，并进入到正确的文件夹内(控制连接)，一个用来传输文件，curl默认是被动连接（即客户端发送PASV或EPSV命令给服务器,服务器新开个端口，curl用该端口连接传输）,主动连接见-P，被动连接见--ftp-pasv\n- curl传输文件时有三种方法(见--ftp-method)：\n- FTPS的默认端口是990,可以通过`scheme:ftps://`指定，抑或使用`--ssl,--ssl-reqd`\n- FTPS无法推广的原因是，FTP的第二个连接是新建的tcp连接，防火墙和其他网络工具检查辨别是FTP传输并采取一些规则或设置应用到该连接,但如果加密，防火墙等就无法判断，并无法应用一些规则\n## URLs(URIs)\n需要注意的是现代浏览器的地址栏里支持IRIs,一个URLs的超集(更强大，支持空白字符等等)\n### Scheme\nscheme就是分隔符前面的内容,是协议吗？不可以包含任何空格\n- 分隔符:`://`curl只支持双斜杠的，有标准是单斜杠的\n- curl会自动纠错一些scheme格式以及自动推测(通过选项--proto-default设置)\n### Name and password(非主流)\nscheme及分隔符之后可能跟着用户名和密码,不过这风险很大,正慢慢淘汰,同时你也可以通过选项等方式来指定。一般格式如下：\n`curl ftp://user:password@example.com/`\n### host\nhost就是主机，可以是数字地址本身或简单的域名\n- ipv4:`curl http://127.0.0.1/`\n- ipv6:`curl http://[::1]/`\n### port number\n如果端口号没指明，那么就会使用各个协议的默认端口。\n通常在主机名后指明,用冒号和数字。为十进制数范围在[0-65535]\n- ipv4:`curl http://example.com:8080/`\n- ipv6:`curl http://[fdea::1]:8080/`\n### path\n每个url包含路径,如果没指明则是根目录`/`,如下是等价的\n`https://example.com`==>`https://example.com/`\n### FTP type(FTP特有很少用的特性)\n该特性可以让你指明文件类型,指定不同的类型ftp协议相应的用不同传输,curl默认以二进制格式传递FTP协议\n- A:指明传输类型为ASCII\n`curl \"ftp://example.com/foo;type=A\"`\n- I:指明传输类型为二进制\n`curl \"ftp://example.com/foo;type=I\"`\n- D:指明传输类型为目录(此时不要以斜杠结尾)\n`curl \"ftp://example.com/foo;type=D\"`\n### Fragment\n由`#`标识\n- URLs提供fragment，但curl传递时，会忽略它,(就是浏览器中的定位,跟网页屏幕位置有关)\n- 有时`#`处于路径中,为了方便你可用`%23`来代替`#`\n`https://www.example.com/info.html#the-plot`==>`curl https://www.example.com/info.html%23the-plot`\n### curl与URLs\ncurl支持许多选项，不是可选项内容的都是URLs，可以支持多个URLs,从左到右一个个解析\n- curl总是返回最后一个URL的错误代码(可以用--fail-early改变),\n- curl的选项总是应用所有URLs(当然存在例外(-o、-O)),要想应用不同的URL不同的option,可以使用`--next、-:`\n- 指定多个URLs,可以节省时间(如果多个URLs有相同主机，TCP将会一直保持链接)\n- 默认是串行,可以指定并行(-Z),并行时的进度条和串行时有区别，该进度条是所有当前运行的并行任务的实时情况\n#### globbing\n有时想传递同一主机下的一系列资源，可以用`{}`和`[]`来指定，处于它们之间的内容称为[globbing],并且他们可以混用，此时为防止shell的副作用，应该用引号括起来URL，\n- `[]`\n  - `curl -O \"http://example.com/[1-100].png\"`\n  - `curl -O \"http://example.com/[001-100].png\"`支持前导0\n  - `curl -O \"http://example.com/[001-100:2].png\"`取奇数\n  - `curl -O \"http://example.com/[a-z].png\"`支持字母\n- `{}`\n  - `curl -O \"http://example.com/{one,two,three,alpha,beta}.html\"`\n- -o选项里面可以通过`#[num]`来代表globbing内容,num从1开始编号\n  - `curl \"http://{one,two}.example.com\" -o \"file_#1.txt\"`\n  - `curl \"http://{site,host}.host[1-5].example.com\" -o \"subdir/#1_#2\"`\nglobbing有时还可以用于-T选项，上传多个文件:\n`curl -T 'image[1-99].jpg' ftp://ftp.example.com/upload/`\n## curl\n### 配置文件curlrc\n按以下优先级读取文件：\n1) \"$CURL_HOME/.curlrc\"\n2) \"$XDG_CONFIG_HOME/.curlrc\"\n3) \"$HOME/.curlrc\"\n## 选项\n### -A/--user-agent\n指明`User-Agent:`的值\n### --alt-svc [cacheFile]\n会尝试cacheFile定义中的可获得同样资源的主机地址，如果server响应并更新了`Alt-Svc:`,则也会自动更新到cacheFile中。\n### --anyauth\ncurl首先不使用认证，如果服务器需要，curl将会尝试使用认证\n### -B\n以二进制形式传输，curl默认就是二进制\n### -b [cookiesFile]\n从文件中读取cookie，-c选项是写cookie\n### --basic\n使用Basic认证方法，默认的认证方法\n### -c [cookieFile]\n写入cookie到一个文件中\n### -C/--continue-at [num/-]\n指明从num byte offset开始继续下载或`-`curl根据已有的下载文件确定从哪开始继续下载。\n**例1**:`curl --continue-at 100 ftp://example.com/bigfile`\n**例2**:`curl --continue-at - http://example.com/bigfile -O`\n### --cacert [path]\n设置CA证书路径\n### --cert [file:passwd]\nTLS指定客户端的证书文件,待学习相关知识\n```bash\ncurl --cert mycert:mypassword https://example.com\ncurl --cert mycert:mypassword --key mykey https://example.com\ncurl --cert mycert:mypassword --cert-type PEM \\\n     --key mykey --key-type PEM https://example.com\n```\n### --cert-type\n见--cert例子\n### --cert-status\n这个TLS特性为OCSP stapling,比较新，目前仅有openssl,gnutls,nss支持，一般不使用\n### --ciphers\nTLS中ciphers,除非你知道你在干啥，否则慎用。\n### --connect-to [source name:source port:destination name:destination port]\n有时负载均衡，一个host name其实由多个服务提供，有时你只想测试其中一个服务，可以用此选项，如下：\n`curl --connect-to www.example.com:80:load1.example.com:80 http://www.example.com`\n### --connect-timeout [num]\n指定tcp连接多长时间没反应算失败，单位秒，可以给出float类型数字\n### --compressed\nhttp/https,请求服务器提供压缩版本的内容，curl会在数据到达后自动解压，这只是加快传输速度，注意不能和另一个--tr-encoding混用，因为两者采用不同压缩\n### -d/--data [string or num]\n发送的数据,simple POST,一下两种方式等价\n```bash\ncurl -d 'name=admin&shoesize=12' http://example.com/\ncurl -d name=admin -d shoesize=12 http://example.com/\n#从某个文件读取\ncurl -d @filename http://example.com\n```\n从文件中读取时，会去除回车和换行，如果不想这样见--data-binary\n### --data-binary\n该选项从文件读取时，不会去除回车和换行\n### --data-raw\n-d选项的补充，主要是为了下面的情况:\n`curl --data-raw '@string' https://example.com`\n### --data-urlencode\n把post内容使用url的安全编码(即把空格和一些不安全字符使用%xx%编码)，接受以下形式(只对内容进行编码):\n- content\n- =content\n- name=content\n- @filename\n- name@filename\n### --digest\ndigest的认证方式\n### --dns-interface\n指定dns走的网卡？\n### --dns-ipv4-addr\n指定ipv4的dns服务器\n### --dns-ipv6-addr\n指定ipv6的dns服务器\n### --dns-servers\n指定一个dns服务器\n### -e/--referer\n当在浏览器中，从一个页面，点击另一个页面，会形成一个`Referer:`的头，它说明是从哪个网站进去的，例如：\n`curl --referer http://comes-from.example.com https://www.example.com/`\n### --etag-save [etagSavedFile]\n把该资源的Etag保存到某文件中\n### --etag-compare [etagFile]\n与本地文件中保存Etag做对比，只下载更新的，可以与--etag-save连用，达到自动更新的目的\n`curl --etag-compare etag.txt --etag-save etag.txt https://example.com/file -o output`\n### -f/--fail\n一般http返回4xx码时，curl也会认为是成功的一次传输，如果启用该选项，如果是4xx，curl将以22退出\n### -F\nhttp的方法将是POST\n### --fail-early\n### --fail-with-body\n同--fail\n### --ftp-method [multicwd/nocwd/singlecwd]\n- multicwd(curl默认方法)：`curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt`\n等价于\n```bash\nCWD one < 250 OK. Current directory is /one CWD two < 250 OK. Current directory is /one/two CWD three < 250 OK. Current directory is /one/two/three RETR file.txt\n```\n- nocwd(并不符合标准):`curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt`\n等价于\n```bash\nRETR one/two/three/file.txt\n```\n- singlecwd(服务器不一定支持):`curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt`\n等价于\n```bash\nCWD one/two/three < 250 OK. Current directory is /one/two/three RETR file.txt\n```\n### --ftp-pasv\ncurl默认就是ftp被动连接，这个选项是重新设置为被动连接\n### --ftp-skip-pasv-ip\n有时服务器对于PASV被动建立连接命令会故意返回一个错的ip地址，此时该选项可以忽略该地址，使用控制连接的地址\n### -G/--get\n当指定-d等选项时，默认为post方法，此选项可以强制转成get，所有数据都追加在url末尾，以`?`分割\n### -h/--help\n### -H [header content]\n- 自定义头部内容\n`curl -H \"Host: www.example.com\" http://localhost/`\n- 去除curl自动形成的头，只要不给值就行：\n`curl -H \"User-Agent:\" http://example.com/`\n- 去除所有头\n`curl -H \"Empty;\" http://example.com`\n### --hsts [hstsFile]\nHSTS是一个严格的传输安全协议，它保护https不被降级和中间cookie注入，整个过程中不能使用明文。该选项使curl读入某个server的HSTS缓存,然后自动更新，并且自动转换http为https:\n`curl --hsts hsts.txt https://example.com`\n### --http0.9\n该版本非常不成熟，响应只有body，没有header,使用该选项是告诉curl接受该种响应\n### --http1.0\n尝试使用http1.0\n### --http1.1\n尝试使用http1.1\n### --http2\n尝试使用http2\n### --http2-prior-knowledge\n前提你确定已经知道服务器支持http2了，这个加快negotiate的速度\n### --http3\n尝试使用http3\n### -I\nHTTP方法将是HEAD\n### --ignore-content-length\n忽略头部的Content-Length信息（早期数据不可以超过2g,content-length可能是负的），直接接受数据\n### --interface [ip addr or some interface]\n指定哪个网络接口来传输流量，或者使用哪个原始ip地址（前提你有多个ip）这个不影响dns的接口，dns接口可用--dns-interface\n### -j/--junk-session-cookies\n模拟浏览器重新打开，一个新的会话cookie\n`curl -j -b cookies.txt http://example.com/`\n### -J/--remote-header-name\nHTTP头可能提供`Content-Disposition:`,这其中包含了建议的文件名，这个选项使用该文件名作为输出，如果该内容存在，会覆盖-O选项。\n- 它只会保留文件名部分，忽略目录\n- CURL不会帮你解码，可能是个URL原码格式的文件名（浏览器会解码）\n### --json\n该选项是为了更好的post json格式的内容，等价于下面三个选项\n```bash\n--data [jsonformat]\n--header \"Content-Type: application/json\"\n--header \"Accept: application/json\"\n```\n注意多次使用该选项时，curl只是简单的字符串拼接，并不会帮你合并，所以应该像下面这样使用：\n`curl --json @json.txt --json \", \"end\": \"true\"}' https://example.com/`\n### -k/--insecure\ntls/ssh协议中，curl会跳过检查known_hosts文件及本地安全证书，直接信任\n### -K/--config\n`-K <fileName>`\n此选项是为了帮助过长的选项不好输在命令行中，fileName则可以保存这些选项\n- 一行一个选项，长选项可以省略`--`\n- 可以用`#`注释\n- 选项和参数内容间可以用`=`或`:`使结构清晰\n- 参数如果含空格，必须用双引号括起来,括号内只可以用下面这些转义字符`\\\\,\\\",\\t,\\n,\\r,\\v`,如果不用双引号,则遇到第一个空格就结束读取\n- 文件内也可以指明url，必须如下格式\n`url = \"http://example.com\"`\n### --keepalive-time [num]\ncurl默认会保持无流量的tcp连接长达60s,这可以更改时间，单位为秒\n### --key\n指定cert健，见--cert\n### --key-type\n见--cert\n### -l/--list-only\nFTP协议中相当与使用NLST命令，可能不会list符号链接和目录\n### -L/--location\n如果返回重定向，则继续访问重定向的地址。默认最多50个。curl默认不会访问重定向的内容,\n### --limit-rate <num>\n参数是个数字，默认单位是byte，可以跟K/M/G，整个过程的平均速度将不超过这个值,也同样适用于上传速率\n### --location-trusted\n永远信任重定向的任何主机，默认是不信任，因为，可能重定向不同主机\n### --local-port [num or range]\n通常不需要指定本地端口，但有时只有某些端口是开放的，指定curl的本地端口，可以指定一个范围，因为一个可能被占用了,最好不要指定1024以下的端口\n### -m/--max-time [num]\n整个命令允许运行的最长时间，即使正在下载，也会立刻退出(退出码28)\n### --mail-from\nsmtp中指定发件人\n### --mail-rcpt\nsmtp中指定收件人\n### --manual\n### --max-filesize [num]\n单位是byte，如果curl在传输开始可以获得将要下载的内容大小，该选项才会起作用，如果超过该大小，curl将会自动放弃。\n### --max-redirs [num]\n指定最多重定向次数，默认50个\n### -n/--netrc\n读取`~/.netrc`配置文件，该文件存储用户名密码，例子如下\n```bash\n#以下的值都不许有空格，且可以写在一行\nmachine example.com #可以填default,此时不需要machine关键字\nlogin nanbert\npassword xxx \nmacdef xxx #该选项curl不支持，会忽略\n```\n### --negotiate\nnegotiate的认证方式\n### -netrc-file [path]\n不读默认`~/.netrc`文件，而是具体某个文件\n### --netrc-optional\n这与`--netrc`区别在于，使得默认配置内容是可选的,不是强制的\n### --next\n### --no-eprt\nftp协议中禁止使用命令EPRT，该命令比PORT更新\n### --no-epsv\nftp协议中进制使用命令EPSV，该命令比PASV更新\n### --no-keepalive\n默认curl会保持tcp(无流量)连接60s,这个会关闭该功能\n### --noproxy\n不使用全局环境变量代理\n### --no-verbose\n### --ntlm\nntlm的认证方式\n### -o\n输出到某个文件，一个该选项对应一个url,想要指明多个，必须声明多个-o\n### -O/--remote-name\n把结果输出到使用远程服务器的原始文件名,一个该选项对应一个url,想要指明多个，必须声明多个-O\n### --path-as-is\n在url指定路径时，如果出现`/../`或`/./`,curl会替换它们，再发送给服务器，比如`/hello/sir/../`变成`/hello/`,`/hello/./sir`变成`/hello/sir/`,而该选项会保留`..`和`.`\n### -P/--ftp-port [ip/-]\n这其实是使用命令PORT或EPRT，即服务器建立新连接到客户,但经常不指定一个确切的port,直接使用`-`,总是为，信息来时的地址，如下：  \n`curl -P - ftp://example.com/foobar.txt`\n### --post301\n返回301重定向时，保持初始的方法\n### --post302\n返回302重定向时，保持初始的方法\n### --post303\n返回303重定向时，保持初始的方法\n### -p/--proxytunnel\n使用隧道对代理加密\n`curl -p -x http://proxy.example.com:80 ftp://ftp.example.com/file.txt`\n### --parallel-max\n### --pinnedpubkey [sha256//hashnum1;hashnum2;..]\nTLS协议中，Certifiate pinning中直接指定sha256值\n### --proto-default\n### --proxy1.0 [ip addr]\n指定代理，和`--x`一样，只是使用HTTP/1.0\n### --proxy-anyauth\n任意一种代理用户名认证方式,根据代理服务器要求自动匹配或者不使用认证\n### --proxy-digest\n一种代理用户名认证方式\n### --proxy-header\n该头只发送给代理，真正的远程服务器不会收到，这比--header更精细化\n`curl --proxy-header \"User-Agent: magic/3000\" -x proxy https://example.com/`\n### --proxy-negotiate\n一种代理用户名认证方式\n### --proxy-ntlm\n一种代理用户名认证方式\n### -Q/--quote [ftp cmd]\n发送命令给ftp服务器\n- 在传输之前发送NOOP命令`curl -Q NOOP ftp://example.com/file`\n- 在传输之后发送NOOP命令`curl -Q -NOOP ftp://example.com/file`\n- 不知什么时候发`curl -Q +NOOP ftp://example.com/file`\n发送的命令发生错误时会导致curl退出，有时可以在命令前加`*`，忽略可能发送错误，如：\n`curl -Q \"-*DELE file\" ftp://example.com/moo`\n### -r/--range [num1-num2,num3-,0-num3,...]\n只下num1 byte offset至num2 byte offset的内容,服务器可以选择性的实现该功能，也就是说，即使你这么请求，服务器也可能返回全部内容\n### --remote-name-all\n所有结果均输出保存到服务器上的原始文件名\n### --remote-time\n使得下载到本地的文件的时间戳和远程服务器文件的时间戳一样，常和-z -o选项搭配  \n`curl -z file.html -o file.html --remote-time https://example.com/file.html`\n### --resolve [host name:port:ip address]\ndns重定向，这会保存到curl的cache中\n`curl --resolve example.com:80:127.0.0.1 http://example.com/`\n### -s/--silent\n此选项关闭进度条，并不显示错误，但是-S/--show-error不受此选项影响\n### -S/--show-error\n默认情况下curl会输出错误，该选项主要是抵消-s的作用\n### --speed-time [num]\n经常和--speed-limit一起用,下面的意思是速度小于1000并且持续15s就退出\n`curl --speed-time 15 --speed-limit 1000 https://example.com/`\n### --speed-limit [num]\n见--speed-time\n### --ssl\n尝试ssl加密(FTP,IMAP,POP3,SMTP)\n### --sslv2\n使用SSL2版本\n### --sslv3\n使用SSL3版本\n### --ssl-reqd\n强制ssl加密(FTP,IMAP,POP3,SMTP)\n### --raw\n禁用内容或传输编码的所有内部http解码，而是使用未经修改的原始数据,这经常用在curl为一个代理的情况\n### --retry [num]\ncurl会在发生transient error时，会重新尝试num次，默认失败一次就不会尝试，transient error包括以下：超时，FTP 4XX返回码，http5xx返回码\n### --request-target\n获取的资源路径，这个一般直接写在url中，但这配合OPTIONS方法，有个特殊用法：\n`curl -X OPTIONS --request-target \"*\" http://example.com/`\n会形成下面的头：\n`OPTIONS * HTTP/1.1`\n### --retry-all-errors\n有时你确定一个服务器是好的，出现任何错误都想重试，该选项就可以帮你\n### --retry-connrefused\n重试只会发生在transient error时，但拒绝访问不属于，有时你确认服务器只是重启或其他原因，该选项可以使得出现拒绝访问时，也可以重试。\n### --retry-max-time [num]\n第一次重试之前,curl会等1s,然后第二次重试会等2s,如此指数增长下去，直到达到10min，该选项会指明等待时间不少于num秒，--max-time选项仍会起作用\n### -T\n- HTTP PUT就是上传某个完整资源上传或替换远程的现有资源，很少被服务器启用\n- FTP或TFTP 上传文件，如下\n`curl -T uploadthis ftp://example.com/this/directory/`\n`curl -T uploadthis ftp://example.com/this/directory/remotename`\n- SMTP上传body内容，通常需要其他选项(有关header的选项)配合（--mail-from,等）\n`curl -T mail smtp://mail.example.com/ --mail-from user@example.com`\n### -t/--telnet-option [keyword=value]\ntelnet选项特有，传递以下三个参数：\n- TTYPE=[term]:设置终端类型\n- XDISPLOC=[X display]:设置X展示位置\n- NEW_ENV=[var,val]:设置环境变量值\n### --tftp-blksize [num]\ntftp通信传输块默认大小为512,此选项可以修改，支持8-65464\n### --tftp-no-options\n有些tftp服务器不接受任何选项，此时该选项可以应用\n### --tlspassword [passwd]\nTLS的特性，可以在命令行中直接使用用户名和密码\n`curl --tlsuser daniel --tlspassword secret https://example.com`\n### --tlsuser [name]\n见--tlspassword\n### --tlsv1/--tlsv1.0\n使用TLS>=1.0的版本\n### --tlsv1.1\n使用TLS>=1.0的版本\n### --tlsv1.2\n使用TLS>=1.2的版本\n### --tlsv1.3\n使用TLS>=1.3的版本,curl默认\n### --tr-encoding\n采用Transfer-Encoded压缩传输内容，curl会自动解压,不能和--compressed混用,且该选项不常用\n### --trace [filename]\n会跟踪每拍接受的内容，以16进制显示,每行开头的十六进制加冒号代表该内容的byte offset\n### --trace-ascii [filename]\n会跟踪每拍接受的内容，以ascii码可读形式显示\n### --trace-time\n化学选项：-v/--verbose,--trace和--trace-ascii\n这个选项会帮助化学选项所输出内容之前加高精度的时间。\n### -u/--user\n指定用户名和密码，冒号分隔`user:passwd`,这种明文，最好不用，协议层方面使用https和ftps等，如果非要使用明文,可以选择选项`--digest`,`--negotiate`,`--ntlm`,或者直接通过配置文件###1禁用。\n```bash\ncurl --digest --user daniel:secret http://example.com/\ncurl --negotiate --user daniel:secret http://example.com/\ncurl --ntlm --user daniel:secret http://example.com/\n```\n### -U/--proxy-user [user:passwd]\n指定代理的用户名和密码\n`curl -U daniel:secr3t -x myproxy:80 http://example.com`\n### --upload-file\n指定上传内容文件，用于smtp\n### --use-ascii\n使用ascii传输，而不是二进制\n### -v/--verbose\n该选项会使curl显示更多的内容，具体格式如下：\n- `*`后面跟解释性内容\n- `>`后面跟客户端发送的头协议，（FTP,SMTP,POP3等没有头协议的，命令和返回当成头）\n- `<`后面跟从服务端接受的返回头协议\nHTTP/2和HTTP/3协议头是压缩的，但在此选项下会展开和HTTP/1.1一样的格式\n### -V/--version\n会输出版本相关的信息，各行含义如下:\n**第一行:**版本号+平台+第三方依赖信息\n**第二行:**版本发布日期\n**第三行:**支持的协议\n**第四行:**支持的特性\n### -w/--write-out \n参数:`<formatted string>`或`@[filename或-]`\n该选项会在每个传输完毕后，在末尾加上formatted string或文件中的内容,%可以使用`\\n,\\r,\\t`转义字符，特殊的变量跟在`%`后,`%%`输出真正的%\n有以下formatted string:\n\n|格式|含义|\n|:-:|:-:|\n|`%{content_type}`|字面义，有的内容没有类型|\n|`%{errormsg}`|字面义，无错误为空|\n|`%{exitcode}`|传输的退出码，无错返回0|\n|`%{filename_effective}`|最终传输内容所保存的文件名，只当指定-o或--remote-name选项有意义|\n|`%{ftp_entry_path}`|登陆ftp的初始路径|\n|`%{http_code}`|也就是response_code|\n|`%{http_connect}`|待探索|\n|`%{http_version}`|字面义|\n|`%{json}`|所有write-out的变量生成json格式|\n|`%{local_ip}`|最近一次连接的ipv4或ipv6的本地地址|\n|`%{local_port}`|最近一次连接的本地端口|\n|`%{method}`|最近请求的方法|\n|`%{num_connects}`|最近传输的新连接数量|\n|`%{num_headers}`|上一次传输的反应头的数量|\n|`%{num_redirects}`|请求的重定向次数|\n|`%{onerror}`|如果传输发生错误，输出之后的string,内容，否则不输出|\n|`%{proxy_ssl_verify_result}`|与代理通信时请求的SSL对等证书验证的结果,0表示成功|\n|`%{redirect_url}`|当发出HTTP请求而没有-L重定向时，重定向会将您带到的实际URL|\n|`%{remote_ip}`|远程的ipv4或6地址|\n|`%{remote_port}`|远程的端口|\n|`%{response_code}`|字面义|\n|`%{scheme}`|url的scheme|\n|`%{size_download}`|字面义|\n|`%{size_header}`|头部的大小|\n|`%{size_request}`|请求的大小|\n|`%{size_upload}`|上传大小|\n|`%{speed_download}`|平均下载速度|\n|`%{speed_upload}`|平均上传速度|\n|`%{ssl_verify_result}`|请求SSL对等证书验证的结果，0表示成功|\n|`%{stderr}`|接下来的内容输出到标准错误|\n|`%{stdout}`|接下来的内容输出到标准输出|\n|`%{time_appconnect}`|从开始到完成SSL/SSH/etc到远程主机的连接/握手花费的时间，单位秒|\n|`%{time_connect}`|从一开始直到TCP连接到远程主机（或代理）完成花费的时间，单位秒|\n|`%{time_namelookup}`|从一开始直到名字解析完成所花费的时间,单位秒|\n|`%{time_pretransfer}`|从一开始直到文件传输即将开始所花费的时间，单位秒|\n|`%{time_redirect}`|所有重定向步骤，包括名称查找，连接，预传输和最终事务开始之前的传输所花费的时间,单位秒|\n|`%{time_starttransfer}`|从一凯斯直到第一个字节即将被传输，这包括time_pretransfer和服务器计算结果所需的时间|\n|`%{time_total}`|完整操作持续的总时间，时间为秒，精度达到毫秒|\n|`%{url}`|命令行中指定url|\n|`%{url_effective}`|真实有效的url|\n|`%{urlnum}`|url的编号，从0开始计数|\n### -X/--request\n指定http的方法，一般curl会根据选项自动判断，无需特地指定该选项，错误的方法可能使得curl行为怪异\n### -x/--proxy [ip addr]\n- 指定代理，默认scheme为http,默认端口为1080\n`curl -x 192.168.0.1:8080 http://example.com/`\n- 指定SOCKS协议代理，这可以直接使用各个版本，而不用-x，说明如下：\n```bash\n#SOCKS4版本\ncurl -x socks4://proxy.example.com http://www.example.com/\ncurl --socks4 proxy.example.com http://www.example.com/\n#SOCKS4a版本\ncurl -x socks4a://proxy.example.com http://www.example.com/\ncurl --socks4a proxy.example.com http://www.example.com/\n#SOCKS5版本\ncurl -x socks5://proxy.example.com http://www.example.com/\ncurl --socks5 proxy.example.com http://www.example.com/\n#SOCKS5h版本\ncurl -x socks5h://proxy.example.com http://www.example.com/\ncurl --socks5-ostname proxy.example.com http://www.example.com/\n```\n### --xattr\n\n### -Z/--parallel\n### -z/--time-cond [time stamp/file]\n对下载的内容做时间限制(可早，可晚)，时间格式可以是常见的格式，或者指定比某个本地文件新\n```bash\ncurl -z \"Jan 10, 2017\" https://example.com/file -O#只下载比该时间戳新的\ncurl --time-cond \"Sun, 12 Sep 2004 15:05:58 -0700\" https://www.example.org/file.html#只下载比该时间早的\ncurl -z file.html https://example.com/file.html -O#比file.html新的\n```\n### -:\n### -#/--progress-bar\n当内容重定向时，进度条是默认打开的,该选项会展示一种简单的进度条，有时进度条无法估计时间\n### @作用\n传参数可以把参数放到文件里，如下:\n`curl -d @json http://example.com`\n## curl退出码\n- 1：不支持的协议\n- 2：初始化失败，libcurl可能出了问题\n- 3：url格式不对\n- 4：某个请求需要某个特性或选项未能满足\n- 5：无法解析代理\n- 6：无法解析主机\n- 7：无法连接主机。可能端口，主机名或防火墙的问题\n- 8：未知的ftp服务返回。可能未支持，也可能未启用选项\n- 9：ftp拒绝访问。没该文件或用户名或没权限\n- 10：ftp接受失败。\n- 11：ftp奇怪的PASS回复\n- 12：在等待服务器连接的活动FTP会话期间，超过限期\n- 13：FTP PASV命令未知的反应。通过--ftp-port选项可能解决该问题\n- 14：未知FTP227格式。这肯定是个坏服务器，或者可以通过--ftp-port解决该问题\n- 15：FTP无法获得主机\n- 16：HTTP/2 error\n- 17：FTP无法设置binary传输。坏的服务器\n- 18：只传输了部分文件\n- 19：FTP无法获得下载该文件。RETR命令失败\n- 20：（保留）\n- 21：引用错误。IMAP、POP3、SMTP、FTP发送自定义命令时出错，建议查看报头\n- 22：HTTP页面未抓取。对应400反应码以上的错误，出现该错误只能在-f选项启用的时候\n- 23：写错误。写到本地时发生的错误\n- 24：（保留）\n- 25：上传失败。服务器空间已满或拒绝上传\n- 26：读错误。从本地读取时发生错误\n- 27：内存不够。系统分配给curl内存不足\n- 28：操作超时。由各种选项设置的各种超时\n- 29：（保留）\n- 30：FTP PORT命令错误。PORT命令有点非主流，可以试试PASV\n- 31：FTP无法使用REST。可以在没有范围或恢复的情况下重试\n- 32：（保留）\n- 33：HTTP范围错误\n- 34：HTTP post错误,需要反馈BUG\n- 35：TLS/SSL连接错误\n- 36：无法恢复下载。FILE,FTP,SFTP会发生此错误\n- 37：无法读取该文件。FILE协议，可能不存在或没权限\n- 38：绑定LDAP失败。可能用户密码错误\n- 39：LDAP搜索失败。\n- 40：（保留）\n- 41：（保留）\n- 42：回调错误。开发者编程的错误\n- 43：错误函数参数。libcurl的调用问题\n- 44：（保留）\n- 45：网络接口错误\n- 46：（保留）\n- 47：太多重定向。默认最多50个，可以通过--max-redirs改变\n- 48：libcurl未知选项。可能curl和libcurl版本不一\n- 49：telnet错误的选项\n- 50：（保留）\n- 51：SSL/TLS、SSH认证失败\n- 52：服务器未返回任何内容。可能是服务器有意为之\n- 53：未发现SSL引擎\n- 54：无法设置SSL加密引擎为默认\n- 55：无法发送网络数据。网络底层的错误，需要Wireshark等工具查看\n- 56：无法接受网络数据。网络底层错误。\n- 57：（保留）\n- 58：本地认证有问题。\n- 59：无法使用ssl密码。密码有格式标准\n- 60：对等证书无法使用已知ca认证\n- 61：无法识别传输编码\n- 62：无效LDAP URL\n- 63：超过最大文件大小限制\n- 64：FTP SSL失败\n- 65：发送之前帧失败\n- 66：初始化SSL引擎失败\n- 67：用户名密码CURL无法登陆\n- 68：TFTP服务没有该文件\n- 69：TFTP服务权限问题\n- 70：TFTP服务没有空间\n- 71：非法TFTP操作\n- 72：未知TFTP传输id\n- 73：TFTP文件已存在\n- 74：TFTP没有该用户\n- 75：字符转换失败\n- 76：需要字符转换函数\n- 77：读SSL CA认证时发生问题\n- 78：URL中的资源不存在\n- 79：在SSH会话中发生错误\n- 80：关闭SSL连接失败\n- 81：（保留）\n- 82：无法下载CRL文件，错误格式\n- 83：TLS认证检查失败\n- 84：FTP PRET命令失败\n- 85：RTSP:CSeq数字不匹配\n- 86：RTSP:会话标识符不匹配\n- 87：无法解析ftp文件列表\n- 88：FTP 块回掉错误\n- 89：没有可用的连接，会话将排队\n- 90：SSL公钥不匹配固定公钥\n- 91：无效SSL认证状态\n- 92：HTTP/2流错误\n- 93：API回调错误\n- 94：认证错误\n- 95：HTTP/3错误\n- 96：QUIC连接错误\n## curl与浏览器的区别\n- 浏览器会对接受的数据进行二次解码,更易懂些，curl就直接解码\n- 有的服务器会根据不同客户端(甚至不同的浏览器)提供更适配的内容\n- 你可以使用f12然后选中network,右键点击你想要的资源，选中`copy cURL`就可以复制相应的命令\n## POP3(curl读邮件使用的协议)\n```bash\n#To list message numbers and sizes:\ncurl pop3://mail.example.com/\n#To download message 1:\ncurl pop3://mail.example.com/1\n#To delete message 1:\ncurl --request DELE pop3://mail.example.com/1\n```\n**TLS加密**\n```bash\ncurl pop3://mail.example.com/ --ssl-reqd\ncurl pop3s://mail.example.com/\n```\n## IMAP(curl读邮件使用的协议，更常用现代)\n```bash\n#Get the mail using the UID 57 from mailbox 'stuff':\ncurl imap://server.example.com/stuff;UID=57\n#get the mail with index 57 from the mailbox 'fun'\ncurl imap://server.example.com/fun;MAILINDEX=57\n#List the mails in the mailbox 'boring':\ncurl imap://server.example.com/boring\n#List the mails in the mailbox 'boring' and provide user and password:\ncurl imap://server.example.com/boring -u user:password\n```\n**TLS加密**\n```bash\ncurl --ssl imap://mail.example.com/inbox\ncurl imaps://mail.example.com/inbox\n```\n## SMTP(cURL写邮件使用的协议)\n必须指定收发邮箱，以及内容,默认端口587\n```bash\ncurl smtp://mail.example.com --mail-from myself@example.com --mail-rcpt \\\nreceiver@example.com --upload-file email.txt\n```\nemail.txt:\n```bash\nFrom: John Smith <john@example.com>\nTo: Joe Smith <smith@example.com>\nSubject: an example.com example email\nDate: Mon, 7 Nov 2016 08:45:16\n\nDear Joe,\nWelcome to this example email. What a lovely day.\n```\n和POP3、IMAP一样，可以使用SSL/TLS加密，schema改成smtps即可，或者使用--ssl或--ssl-reqd,此时默认端口为465\n## MQTT\n订阅推送的协议，不太懂\n## TFTP\n小文件传输协议，使用的是UDP\n- 下载`curl -O tftp://localserver/file.boot`\n- 上传`curl -T file.boot tftp://localserver/`\n## TELNET\n即时通信协议，默认端口23\n## DICT\n字典查询的协议\nalias:\n- m:match和find\n- d:define和lookup\n例子：\n```bash\ncurl dict://dict.org/m:curl\ncurl dict://dict.org/d:heisenbug:jargon\ncurl dict://dict.org/d:daniel:gcide\ncurl dict://dict.org/find:curl\n```\n## TLS/SSL\nTLS是建立于TCP上一层的安全加密层，SSL是旧称(且所有ssl版本都在淘汰中)，两个是一个概念。\n各个版本协议都有TLS版本：\n- HTTP-HTTPS\n- LDAP-LDAPS\n- FTP-FTPS\n- POP3-POP3S\n- IMAP-IMAPS\n- SMTP-SMTPS\nTLS属于third-party,你可以通过--version查看，如果你feature中有MultiSSL的特性，证明curl是支持多版本的，你可以通过`CURL_SSL_BACKEND`来设置使用那个版二\n### 版本历史\nSSL2(1995)->SSL3->TLS1.0(1999)->TLS1.1(2006)->TLS1.2(2008)->TLS1.3(2018)\n### CA的存储\n一般都是内建的，但你也可以用--cacert指定路径（一定要是PEM格式），或者设置CURL-CA_BUNDLE环境变量\n\n## wget\n- ![](https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/wget.html)\n","slug":"curl和https","published":1,"updated":"2024-04-30T21:04:04.582Z","_id":"clq1yvi70000sgwq2bg7m1d68","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><ul>\n<li>HTTP&#x2F;2和HTTP&#x2F;3的头部通常会被curl压缩发送，但是-v选项总是把它们解压成HTTP&#x2F;1.1的样子</li>\n<li>HTTP默认端口：80，HTTPS默认端口：443</li>\n<li>HTTP有4种方法：GET，POST，HEAD，PUT,OPTIONS</li>\n<li>curl默认的http版本为HTTP&#x2F;1.1,默认的https版本为HTTP&#x2F;2</li>\n</ul>\n<h3 id=\"返回码\"><a href=\"#返回码\" class=\"headerlink\" title=\"返回码\"></a>返回码</h3><ul>\n<li>1XX：瞬态响应，更多内容即将发生</li>\n<li>2XX：成功</li>\n<li>3XX：重定向<ul>\n<li>301:永久重定向，当一个url第一次返回该值时，重定向的内容将被浏览器缓存，下次该url不起作用，直接访问重定向内容(浏览器总是使用GET，即使第一次访问时用的是POST),curl永远不会缓存</li>\n<li>302:暂时重定向，不会缓存,重定向总是使用GET</li>\n<li>303:同302,但是更接近于间接访问的概念</li>\n<li>307:暂时重定向，不会缓存，区别在于它会保持第一次访问的方法</li>\n<li>308:永久重定向，区别在于它会保持第一次访问的方法</li>\n</ul>\n</li>\n<li>4XX：服务器无法提供或不会提供要求的内容<ul>\n<li>401:服务器需要一个认证，通常包含头<code>WWW-Authenticate:</code>,包含了服务器支持的认证方法(Basic)</li>\n<li>407:代理服务器需要一个认证，通常包含头<code>Proxy-Authenticate:</code>,包含了代理支持的认证方法</li>\n</ul>\n</li>\n<li>5XX：服务器出现问题</li>\n</ul>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>通过URL来形成HTTP头<br><img src=\"/images/httpRequest.png\"><br><strong>request例子</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">GET / HTTP/1.1<br>User-agent: curl/2000<br>Host: example.com<br></code></pre></td></tr></table></figure>\n<p><strong>response例子</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">HTTP/1.1 200 OK<br>Server: example-server/1.1<br>Content-Length: 5<br>Content-Type: plain/text<br><br>hello<br></code></pre></td></tr></table></figure>\n<h3 id=\"Transfer-Encoding-chunked\"><a href=\"#Transfer-Encoding-chunked\" class=\"headerlink\" title=\"Transfer-Encoding: chunked\"></a>Transfer-Encoding: chunked</h3><p>有时response可能没有Content-Length，而是<strong>Transfer-Encoding: chunked</strong>，这只有HTTP1.1服务才有，它表示内容是一系列的块，每块开头有显示该块的十六进制大小，结束时，也会有表示结束的0块。curl会自动解码</p>\n<h3 id=\"Content-Encoding-gzip\"><a href=\"#Content-Encoding-gzip\" class=\"headerlink\" title=\"Content-Encoding: gzip\"></a>Content-Encoding: gzip</h3><p>body是经过压缩的,curl会自动解压</p>\n<h3 id=\"Expect-100-continue\"><a href=\"#Expect-100-continue\" class=\"headerlink\" title=\"Expect:100-continue\"></a>Expect:100-continue</h3><p>很少有服务器支持这一特性，且HTTP&#x2F;2及以上支持在没关闭连接的情况下停止持续传输,这使得该特性无意义。(该特性到底是啥不懂)post时，curl会默认</p>\n<h3 id=\"透明压缩\"><a href=\"#透明压缩\" class=\"headerlink\" title=\"透明压缩\"></a>透明压缩</h3><p>过于老式，不常用，可以使用–tr-encoding来使用，前提是服务器支持</p>\n<h3 id=\"Etag\"><a href=\"#Etag\" class=\"headerlink\" title=\"Etag\"></a>Etag</h3><p>服务器通过<strong>Etag</strong>来标识一个资源的版本，这样便于客户判断是否资源更新</p>\n<h3 id=\"Multipart-formposts\"><a href=\"#Multipart-formposts\" class=\"headerlink\" title=\"Multipart formposts\"></a>Multipart formposts</h3><p>这对应html中form的enctype&#x3D;multiparg&#x2F;form-data,可以通过-F选项指定form:<br><code>curl -F person=anonymous -F secret=@file.txt http://example.com/submit.cgi</code><br><strong>Header内容：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">POST /submit.cgi HTTP/1.1<br>Host: example.com<br>User-Agent: curl/7.46.0<br>Accept: */*<br>Content-Length: 313<br>Expect: 100-<span class=\"hljs-built_in\">continue</span><br>Content-Type: multipart/form-data; boundary=------------------------d74496d66958873e<br></code></pre></td></tr></table></figure>\n<p><strong>Body内容：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">--------------------------d74496d66958873e<br>Content-Disposition: form-data; name=<span class=\"hljs-string\">&quot;person&quot;</span><br><br>anonymous<br>--------------------------d74496d66958873e<br>Content-Disposition: form-data; name=<span class=\"hljs-string\">&quot;secret&quot;</span>; filename=<span class=\"hljs-string\">&quot;file.txt&quot;</span><br>Content-Type: text/plain<br><br>contents of the file<br>--------------------------d74496d66958873e--<br></code></pre></td></tr></table></figure>\n<p>html的form表单中enctype默认为<code>application/x-www-form-urlencoded</code>,此时只需要-d选项即可</p>\n<h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><ul>\n<li>有时服务器不会直接返回内容，而是告诉你该资源所在位置，此时响应中包含关键字<code>Location:</code></li>\n<li>有时重定向会指向不同主机，此时用户名密码或证书等可能无法使用，无论如何信任的话，可以使用–location-trusted</li>\n<li>浏览器支持更多的重定向方式，curl不支持他们，比如html里meta元素，javascript的动态重定向</li>\n</ul>\n<h3 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h3><p>cookie设置的一个头</p>\n<h3 id=\"Upgrade\"><a href=\"#Upgrade\" class=\"headerlink\" title=\"Upgrade\"></a>Upgrade</h3><p>强制升级http版本的头，过老的服务器可能会出错</p>\n<h3 id=\"Alt-Svc\"><a href=\"#Alt-Svc\" class=\"headerlink\" title=\"Alt-Svc\"></a>Alt-Svc</h3><p>响应体中的头，告诉客户还有哪些主机可以获得同样资源,只能在https中使用，并且这是使用http3的唯一方法（截至2019）</p>\n<h3 id=\"http3\"><a href=\"#http3\" class=\"headerlink\" title=\"http3\"></a>http3</h3><p>http3是实验版本，是为了适应QUIC协议（一个基于UDP的可靠安全的协议），只能通过https,curl没有针对http3连结失败时作自动降级处理，而是直接返回错误</p>\n<h2 id=\"代理-就是web缓存服务器\"><a href=\"#代理-就是web缓存服务器\" class=\"headerlink\" title=\"代理(就是web缓存服务器)\"></a>代理(就是web缓存服务器)</h2><ul>\n<li>HTTP代理为了安全，使用<strong>CONNECT</strong>方法</li>\n<li>HTTP代理可以代理FTP,此时curl将认为就是HTTP,FTP所有特性无效</li>\n<li>MITM代理可以监控加密的流量</li>\n<li>代理认证失败，拒绝代理，会返回407</li>\n<li>HTTPS代理的默认端口为443</li>\n<li>curl中与代理相关的环境变量<ul>\n<li>[scheme]_proxy:指定某个协议的默认代理,等价于-x选项,除了http_proxy只能全部小写(CGI的原因),其他形式可以用全部大写<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">http_proxy=http://proxy.example.com:80<br>curl -v www.example.com<br></code></pre></td></tr></table></figure></li>\n<li>ALL_PROXY:所有url都走该代理</li>\n<li>NO_PROXY:某些url不走该代理，用<code>,</code>分隔多个url，等效于–noproxy</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"FTP\"><a href=\"#FTP\" class=\"headerlink\" title=\"FTP\"></a>FTP</h2><ul>\n<li>FTP协议使用两个tcp连接，一个用来建立认证，并进入到正确的文件夹内(控制连接)，一个用来传输文件，curl默认是被动连接（即客户端发送PASV或EPSV命令给服务器,服务器新开个端口，curl用该端口连接传输）,主动连接见-P，被动连接见–ftp-pasv</li>\n<li>curl传输文件时有三种方法(见–ftp-method)：</li>\n<li>FTPS的默认端口是990,可以通过<code>scheme:ftps://</code>指定，抑或使用<code>--ssl,--ssl-reqd</code></li>\n<li>FTPS无法推广的原因是，FTP的第二个连接是新建的tcp连接，防火墙和其他网络工具检查辨别是FTP传输并采取一些规则或设置应用到该连接,但如果加密，防火墙等就无法判断，并无法应用一些规则</li>\n</ul>\n<h2 id=\"URLs-URIs\"><a href=\"#URLs-URIs\" class=\"headerlink\" title=\"URLs(URIs)\"></a>URLs(URIs)</h2><p>需要注意的是现代浏览器的地址栏里支持IRIs,一个URLs的超集(更强大，支持空白字符等等)</p>\n<h3 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h3><p>scheme就是分隔符前面的内容,是协议吗？不可以包含任何空格</p>\n<ul>\n<li>分隔符:<code>://</code>curl只支持双斜杠的，有标准是单斜杠的</li>\n<li>curl会自动纠错一些scheme格式以及自动推测(通过选项–proto-default设置)</li>\n</ul>\n<h3 id=\"Name-and-password-非主流\"><a href=\"#Name-and-password-非主流\" class=\"headerlink\" title=\"Name and password(非主流)\"></a>Name and password(非主流)</h3><p>scheme及分隔符之后可能跟着用户名和密码,不过这风险很大,正慢慢淘汰,同时你也可以通过选项等方式来指定。一般格式如下：<br><code>curl ftp://user:password@example.com/</code></p>\n<h3 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h3><p>host就是主机，可以是数字地址本身或简单的域名</p>\n<ul>\n<li>ipv4:<code>curl http://127.0.0.1/</code></li>\n<li>ipv6:<code>curl http://[::1]/</code></li>\n</ul>\n<h3 id=\"port-number\"><a href=\"#port-number\" class=\"headerlink\" title=\"port number\"></a>port number</h3><p>如果端口号没指明，那么就会使用各个协议的默认端口。<br>通常在主机名后指明,用冒号和数字。为十进制数范围在[0-65535]</p>\n<ul>\n<li>ipv4:<code>curl http://example.com:8080/</code></li>\n<li>ipv6:<code>curl http://[fdea::1]:8080/</code></li>\n</ul>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>每个url包含路径,如果没指明则是根目录<code>/</code>,如下是等价的<br><code>https://example.com</code>&#x3D;&#x3D;&gt;<code>https://example.com/</code></p>\n<h3 id=\"FTP-type-FTP特有很少用的特性\"><a href=\"#FTP-type-FTP特有很少用的特性\" class=\"headerlink\" title=\"FTP type(FTP特有很少用的特性)\"></a>FTP type(FTP特有很少用的特性)</h3><p>该特性可以让你指明文件类型,指定不同的类型ftp协议相应的用不同传输,curl默认以二进制格式传递FTP协议</p>\n<ul>\n<li>A:指明传输类型为ASCII<br><code>curl &quot;ftp://example.com/foo;type=A&quot;</code></li>\n<li>I:指明传输类型为二进制<br><code>curl &quot;ftp://example.com/foo;type=I&quot;</code></li>\n<li>D:指明传输类型为目录(此时不要以斜杠结尾)<br><code>curl &quot;ftp://example.com/foo;type=D&quot;</code></li>\n</ul>\n<h3 id=\"Fragment\"><a href=\"#Fragment\" class=\"headerlink\" title=\"Fragment\"></a>Fragment</h3><p>由<code>#</code>标识</p>\n<ul>\n<li>URLs提供fragment，但curl传递时，会忽略它,(就是浏览器中的定位,跟网页屏幕位置有关)</li>\n<li>有时<code>#</code>处于路径中,为了方便你可用<code>%23</code>来代替<code>#</code><br><code>https://www.example.com/info.html#the-plot</code>&#x3D;&#x3D;&gt;<code>curl https://www.example.com/info.html%23the-plot</code></li>\n</ul>\n<h3 id=\"curl与URLs\"><a href=\"#curl与URLs\" class=\"headerlink\" title=\"curl与URLs\"></a>curl与URLs</h3><p>curl支持许多选项，不是可选项内容的都是URLs，可以支持多个URLs,从左到右一个个解析</p>\n<ul>\n<li>curl总是返回最后一个URL的错误代码(可以用–fail-early改变),</li>\n<li>curl的选项总是应用所有URLs(当然存在例外(-o、-O)),要想应用不同的URL不同的option,可以使用<code>--next、-:</code></li>\n<li>指定多个URLs,可以节省时间(如果多个URLs有相同主机，TCP将会一直保持链接)</li>\n<li>默认是串行,可以指定并行(-Z),并行时的进度条和串行时有区别，该进度条是所有当前运行的并行任务的实时情况</li>\n</ul>\n<h4 id=\"globbing\"><a href=\"#globbing\" class=\"headerlink\" title=\"globbing\"></a>globbing</h4><p>有时想传递同一主机下的一系列资源，可以用<code>&#123;&#125;</code>和<code>[]</code>来指定，处于它们之间的内容称为[globbing],并且他们可以混用，此时为防止shell的副作用，应该用引号括起来URL，</p>\n<ul>\n<li><code>[]</code><ul>\n<li><code>curl -O &quot;http://example.com/[1-100].png&quot;</code></li>\n<li><code>curl -O &quot;http://example.com/[001-100].png&quot;</code>支持前导0</li>\n<li><code>curl -O &quot;http://example.com/[001-100:2].png&quot;</code>取奇数</li>\n<li><code>curl -O &quot;http://example.com/[a-z].png&quot;</code>支持字母</li>\n</ul>\n</li>\n<li><code>&#123;&#125;</code><ul>\n<li><code>curl -O &quot;http://example.com/&#123;one,two,three,alpha,beta&#125;.html&quot;</code></li>\n</ul>\n</li>\n<li>-o选项里面可以通过<code>#[num]</code>来代表globbing内容,num从1开始编号<ul>\n<li><code>curl &quot;http://&#123;one,two&#125;.example.com&quot; -o &quot;file_#1.txt&quot;</code></li>\n<li><code>curl &quot;http://&#123;site,host&#125;.host[1-5].example.com&quot; -o &quot;subdir/#1_#2&quot;</code><br>globbing有时还可以用于-T选项，上传多个文件:<br><code>curl -T &#39;image[1-99].jpg&#39; ftp://ftp.example.com/upload/</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"curl\"><a href=\"#curl\" class=\"headerlink\" title=\"curl\"></a>curl</h2><h3 id=\"配置文件curlrc\"><a href=\"#配置文件curlrc\" class=\"headerlink\" title=\"配置文件curlrc\"></a>配置文件curlrc</h3><p>按以下优先级读取文件：</p>\n<ol>\n<li>“$CURL_HOME&#x2F;.curlrc”</li>\n<li>“$XDG_CONFIG_HOME&#x2F;.curlrc”</li>\n<li>“$HOME&#x2F;.curlrc”</li>\n</ol>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><h3 id=\"A-–user-agent\"><a href=\"#A-–user-agent\" class=\"headerlink\" title=\"-A&#x2F;–user-agent\"></a>-A&#x2F;–user-agent</h3><p>指明<code>User-Agent:</code>的值</p>\n<h3 id=\"–alt-svc-cacheFile\"><a href=\"#–alt-svc-cacheFile\" class=\"headerlink\" title=\"–alt-svc [cacheFile]\"></a>–alt-svc [cacheFile]</h3><p>会尝试cacheFile定义中的可获得同样资源的主机地址，如果server响应并更新了<code>Alt-Svc:</code>,则也会自动更新到cacheFile中。</p>\n<h3 id=\"–anyauth\"><a href=\"#–anyauth\" class=\"headerlink\" title=\"–anyauth\"></a>–anyauth</h3><p>curl首先不使用认证，如果服务器需要，curl将会尝试使用认证</p>\n<h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"-B\"></a>-B</h3><p>以二进制形式传输，curl默认就是二进制</p>\n<h3 id=\"b-cookiesFile\"><a href=\"#b-cookiesFile\" class=\"headerlink\" title=\"-b [cookiesFile]\"></a>-b [cookiesFile]</h3><p>从文件中读取cookie，-c选项是写cookie</p>\n<h3 id=\"–basic\"><a href=\"#–basic\" class=\"headerlink\" title=\"–basic\"></a>–basic</h3><p>使用Basic认证方法，默认的认证方法</p>\n<h3 id=\"c-cookieFile\"><a href=\"#c-cookieFile\" class=\"headerlink\" title=\"-c [cookieFile]\"></a>-c [cookieFile]</h3><p>写入cookie到一个文件中</p>\n<h3 id=\"C-–continue-at-num\"><a href=\"#C-–continue-at-num\" class=\"headerlink\" title=\"-C&#x2F;–continue-at [num&#x2F;-]\"></a>-C&#x2F;–continue-at [num&#x2F;-]</h3><p>指明从num byte offset开始继续下载或<code>-</code>curl根据已有的下载文件确定从哪开始继续下载。<br><strong>例1</strong>:<code>curl --continue-at 100 ftp://example.com/bigfile</code><br><strong>例2</strong>:<code>curl --continue-at - http://example.com/bigfile -O</code></p>\n<h3 id=\"–cacert-path\"><a href=\"#–cacert-path\" class=\"headerlink\" title=\"–cacert [path]\"></a>–cacert [path]</h3><p>设置CA证书路径</p>\n<h3 id=\"–cert-file-passwd\"><a href=\"#–cert-file-passwd\" class=\"headerlink\" title=\"–cert [file:passwd]\"></a>–cert [file:passwd]</h3><p>TLS指定客户端的证书文件,待学习相关知识</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl --cert mycert:mypassword https://example.com<br>curl --cert mycert:mypassword --key mykey https://example.com<br>curl --cert mycert:mypassword --cert-type PEM \\<br>     --key mykey --key-type PEM https://example.com<br></code></pre></td></tr></table></figure>\n<h3 id=\"–cert-type\"><a href=\"#–cert-type\" class=\"headerlink\" title=\"–cert-type\"></a>–cert-type</h3><p>见–cert例子</p>\n<h3 id=\"–cert-status\"><a href=\"#–cert-status\" class=\"headerlink\" title=\"–cert-status\"></a>–cert-status</h3><p>这个TLS特性为OCSP stapling,比较新，目前仅有openssl,gnutls,nss支持，一般不使用</p>\n<h3 id=\"–ciphers\"><a href=\"#–ciphers\" class=\"headerlink\" title=\"–ciphers\"></a>–ciphers</h3><p>TLS中ciphers,除非你知道你在干啥，否则慎用。</p>\n<h3 id=\"–connect-to-source-name-source-port-destination-name-destination-port\"><a href=\"#–connect-to-source-name-source-port-destination-name-destination-port\" class=\"headerlink\" title=\"–connect-to [source name:source port:destination name:destination port]\"></a>–connect-to [source name:source port:destination name:destination port]</h3><p>有时负载均衡，一个host name其实由多个服务提供，有时你只想测试其中一个服务，可以用此选项，如下：<br><code>curl --connect-to www.example.com:80:load1.example.com:80 http://www.example.com</code></p>\n<h3 id=\"–connect-timeout-num\"><a href=\"#–connect-timeout-num\" class=\"headerlink\" title=\"–connect-timeout [num]\"></a>–connect-timeout [num]</h3><p>指定tcp连接多长时间没反应算失败，单位秒，可以给出float类型数字</p>\n<h3 id=\"–compressed\"><a href=\"#–compressed\" class=\"headerlink\" title=\"–compressed\"></a>–compressed</h3><p>http&#x2F;https,请求服务器提供压缩版本的内容，curl会在数据到达后自动解压，这只是加快传输速度，注意不能和另一个–tr-encoding混用，因为两者采用不同压缩</p>\n<h3 id=\"d-–data-string-or-num\"><a href=\"#d-–data-string-or-num\" class=\"headerlink\" title=\"-d&#x2F;–data [string or num]\"></a>-d&#x2F;–data [string or num]</h3><p>发送的数据,simple POST,一下两种方式等价</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl -d <span class=\"hljs-string\">&#x27;name=admin&amp;shoesize=12&#x27;</span> http://example.com/<br>curl -d name=admin -d shoesize=12 http://example.com/<br><span class=\"hljs-comment\">#从某个文件读取</span><br>curl -d @filename http://example.com<br></code></pre></td></tr></table></figure>\n<p>从文件中读取时，会去除回车和换行，如果不想这样见–data-binary</p>\n<h3 id=\"–data-binary\"><a href=\"#–data-binary\" class=\"headerlink\" title=\"–data-binary\"></a>–data-binary</h3><p>该选项从文件读取时，不会去除回车和换行</p>\n<h3 id=\"–data-raw\"><a href=\"#–data-raw\" class=\"headerlink\" title=\"–data-raw\"></a>–data-raw</h3><p>-d选项的补充，主要是为了下面的情况:<br><code>curl --data-raw &#39;@string&#39; https://example.com</code></p>\n<h3 id=\"–data-urlencode\"><a href=\"#–data-urlencode\" class=\"headerlink\" title=\"–data-urlencode\"></a>–data-urlencode</h3><p>把post内容使用url的安全编码(即把空格和一些不安全字符使用%xx%编码)，接受以下形式(只对内容进行编码):</p>\n<ul>\n<li>content</li>\n<li>&#x3D;content</li>\n<li>name&#x3D;content</li>\n<li>@filename</li>\n<li>name@filename</li>\n</ul>\n<h3 id=\"–digest\"><a href=\"#–digest\" class=\"headerlink\" title=\"–digest\"></a>–digest</h3><p>digest的认证方式</p>\n<h3 id=\"–dns-interface\"><a href=\"#–dns-interface\" class=\"headerlink\" title=\"–dns-interface\"></a>–dns-interface</h3><p>指定dns走的网卡？</p>\n<h3 id=\"–dns-ipv4-addr\"><a href=\"#–dns-ipv4-addr\" class=\"headerlink\" title=\"–dns-ipv4-addr\"></a>–dns-ipv4-addr</h3><p>指定ipv4的dns服务器</p>\n<h3 id=\"–dns-ipv6-addr\"><a href=\"#–dns-ipv6-addr\" class=\"headerlink\" title=\"–dns-ipv6-addr\"></a>–dns-ipv6-addr</h3><p>指定ipv6的dns服务器</p>\n<h3 id=\"–dns-servers\"><a href=\"#–dns-servers\" class=\"headerlink\" title=\"–dns-servers\"></a>–dns-servers</h3><p>指定一个dns服务器</p>\n<h3 id=\"e-–referer\"><a href=\"#e-–referer\" class=\"headerlink\" title=\"-e&#x2F;–referer\"></a>-e&#x2F;–referer</h3><p>当在浏览器中，从一个页面，点击另一个页面，会形成一个<code>Referer:</code>的头，它说明是从哪个网站进去的，例如：<br><code>curl --referer http://comes-from.example.com https://www.example.com/</code></p>\n<h3 id=\"–etag-save-etagSavedFile\"><a href=\"#–etag-save-etagSavedFile\" class=\"headerlink\" title=\"–etag-save [etagSavedFile]\"></a>–etag-save [etagSavedFile]</h3><p>把该资源的Etag保存到某文件中</p>\n<h3 id=\"–etag-compare-etagFile\"><a href=\"#–etag-compare-etagFile\" class=\"headerlink\" title=\"–etag-compare [etagFile]\"></a>–etag-compare [etagFile]</h3><p>与本地文件中保存Etag做对比，只下载更新的，可以与–etag-save连用，达到自动更新的目的<br><code>curl --etag-compare etag.txt --etag-save etag.txt https://example.com/file -o output</code></p>\n<h3 id=\"f-–fail\"><a href=\"#f-–fail\" class=\"headerlink\" title=\"-f&#x2F;–fail\"></a>-f&#x2F;–fail</h3><p>一般http返回4xx码时，curl也会认为是成功的一次传输，如果启用该选项，如果是4xx，curl将以22退出</p>\n<h3 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"-F\"></a>-F</h3><p>http的方法将是POST</p>\n<h3 id=\"–fail-early\"><a href=\"#–fail-early\" class=\"headerlink\" title=\"–fail-early\"></a>–fail-early</h3><h3 id=\"–fail-with-body\"><a href=\"#–fail-with-body\" class=\"headerlink\" title=\"–fail-with-body\"></a>–fail-with-body</h3><p>同–fail</p>\n<h3 id=\"–ftp-method-multicwd-nocwd-singlecwd\"><a href=\"#–ftp-method-multicwd-nocwd-singlecwd\" class=\"headerlink\" title=\"–ftp-method [multicwd&#x2F;nocwd&#x2F;singlecwd]\"></a>–ftp-method [multicwd&#x2F;nocwd&#x2F;singlecwd]</h3><ul>\n<li>multicwd(curl默认方法)：<code>curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">CWD one &lt; 250 OK. Current directory is /one CWD two &lt; 250 OK. Current directory is /one/two CWD three &lt; 250 OK. Current directory is /one/two/three RETR file.txt<br></code></pre></td></tr></table></figure></li>\n<li>nocwd(并不符合标准):<code>curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">RETR one/two/three/file.txt<br></code></pre></td></tr></table></figure></li>\n<li>singlecwd(服务器不一定支持):<code>curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">CWD one/two/three &lt; 250 OK. Current directory is /one/two/three RETR file.txt<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"–ftp-pasv\"><a href=\"#–ftp-pasv\" class=\"headerlink\" title=\"–ftp-pasv\"></a>–ftp-pasv</h3><p>curl默认就是ftp被动连接，这个选项是重新设置为被动连接</p>\n<h3 id=\"–ftp-skip-pasv-ip\"><a href=\"#–ftp-skip-pasv-ip\" class=\"headerlink\" title=\"–ftp-skip-pasv-ip\"></a>–ftp-skip-pasv-ip</h3><p>有时服务器对于PASV被动建立连接命令会故意返回一个错的ip地址，此时该选项可以忽略该地址，使用控制连接的地址</p>\n<h3 id=\"G-–get\"><a href=\"#G-–get\" class=\"headerlink\" title=\"-G&#x2F;–get\"></a>-G&#x2F;–get</h3><p>当指定-d等选项时，默认为post方法，此选项可以强制转成get，所有数据都追加在url末尾，以<code>?</code>分割</p>\n<h3 id=\"h-–help\"><a href=\"#h-–help\" class=\"headerlink\" title=\"-h&#x2F;–help\"></a>-h&#x2F;–help</h3><h3 id=\"H-header-content\"><a href=\"#H-header-content\" class=\"headerlink\" title=\"-H [header content]\"></a>-H [header content]</h3><ul>\n<li>自定义头部内容<br><code>curl -H &quot;Host: www.example.com&quot; http://localhost/</code></li>\n<li>去除curl自动形成的头，只要不给值就行：<br><code>curl -H &quot;User-Agent:&quot; http://example.com/</code></li>\n<li>去除所有头<br><code>curl -H &quot;Empty;&quot; http://example.com</code></li>\n</ul>\n<h3 id=\"–hsts-hstsFile\"><a href=\"#–hsts-hstsFile\" class=\"headerlink\" title=\"–hsts [hstsFile]\"></a>–hsts [hstsFile]</h3><p>HSTS是一个严格的传输安全协议，它保护https不被降级和中间cookie注入，整个过程中不能使用明文。该选项使curl读入某个server的HSTS缓存,然后自动更新，并且自动转换http为https:<br><code>curl --hsts hsts.txt https://example.com</code></p>\n<h3 id=\"–http0-9\"><a href=\"#–http0-9\" class=\"headerlink\" title=\"–http0.9\"></a>–http0.9</h3><p>该版本非常不成熟，响应只有body，没有header,使用该选项是告诉curl接受该种响应</p>\n<h3 id=\"–http1-0\"><a href=\"#–http1-0\" class=\"headerlink\" title=\"–http1.0\"></a>–http1.0</h3><p>尝试使用http1.0</p>\n<h3 id=\"–http1-1\"><a href=\"#–http1-1\" class=\"headerlink\" title=\"–http1.1\"></a>–http1.1</h3><p>尝试使用http1.1</p>\n<h3 id=\"–http2\"><a href=\"#–http2\" class=\"headerlink\" title=\"–http2\"></a>–http2</h3><p>尝试使用http2</p>\n<h3 id=\"–http2-prior-knowledge\"><a href=\"#–http2-prior-knowledge\" class=\"headerlink\" title=\"–http2-prior-knowledge\"></a>–http2-prior-knowledge</h3><p>前提你确定已经知道服务器支持http2了，这个加快negotiate的速度</p>\n<h3 id=\"–http3\"><a href=\"#–http3\" class=\"headerlink\" title=\"–http3\"></a>–http3</h3><p>尝试使用http3</p>\n<h3 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"-I\"></a>-I</h3><p>HTTP方法将是HEAD</p>\n<h3 id=\"–ignore-content-length\"><a href=\"#–ignore-content-length\" class=\"headerlink\" title=\"–ignore-content-length\"></a>–ignore-content-length</h3><p>忽略头部的Content-Length信息（早期数据不可以超过2g,content-length可能是负的），直接接受数据</p>\n<h3 id=\"–interface-ip-addr-or-some-interface\"><a href=\"#–interface-ip-addr-or-some-interface\" class=\"headerlink\" title=\"–interface [ip addr or some interface]\"></a>–interface [ip addr or some interface]</h3><p>指定哪个网络接口来传输流量，或者使用哪个原始ip地址（前提你有多个ip）这个不影响dns的接口，dns接口可用–dns-interface</p>\n<h3 id=\"j-–junk-session-cookies\"><a href=\"#j-–junk-session-cookies\" class=\"headerlink\" title=\"-j&#x2F;–junk-session-cookies\"></a>-j&#x2F;–junk-session-cookies</h3><p>模拟浏览器重新打开，一个新的会话cookie<br><code>curl -j -b cookies.txt http://example.com/</code></p>\n<h3 id=\"J-–remote-header-name\"><a href=\"#J-–remote-header-name\" class=\"headerlink\" title=\"-J&#x2F;–remote-header-name\"></a>-J&#x2F;–remote-header-name</h3><p>HTTP头可能提供<code>Content-Disposition:</code>,这其中包含了建议的文件名，这个选项使用该文件名作为输出，如果该内容存在，会覆盖-O选项。</p>\n<ul>\n<li>它只会保留文件名部分，忽略目录</li>\n<li>CURL不会帮你解码，可能是个URL原码格式的文件名（浏览器会解码）</li>\n</ul>\n<h3 id=\"–json\"><a href=\"#–json\" class=\"headerlink\" title=\"–json\"></a>–json</h3><p>该选项是为了更好的post json格式的内容，等价于下面三个选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">--data [jsonformat]<br>--header <span class=\"hljs-string\">&quot;Content-Type: application/json&quot;</span><br>--header <span class=\"hljs-string\">&quot;Accept: application/json&quot;</span><br></code></pre></td></tr></table></figure>\n<p>注意多次使用该选项时，curl只是简单的字符串拼接，并不会帮你合并，所以应该像下面这样使用：<br><code>curl --json @json.txt --json &quot;, &quot;end&quot;: &quot;true&quot;&#125;&#39; https://example.com/</code></p>\n<h3 id=\"k-–insecure\"><a href=\"#k-–insecure\" class=\"headerlink\" title=\"-k&#x2F;–insecure\"></a>-k&#x2F;–insecure</h3><p>tls&#x2F;ssh协议中，curl会跳过检查known_hosts文件及本地安全证书，直接信任</p>\n<h3 id=\"K-–config\"><a href=\"#K-–config\" class=\"headerlink\" title=\"-K&#x2F;–config\"></a>-K&#x2F;–config</h3><p><code>-K &lt;fileName&gt;</code><br>此选项是为了帮助过长的选项不好输在命令行中，fileName则可以保存这些选项</p>\n<ul>\n<li>一行一个选项，长选项可以省略<code>--</code></li>\n<li>可以用<code>#</code>注释</li>\n<li>选项和参数内容间可以用<code>=</code>或<code>:</code>使结构清晰</li>\n<li>参数如果含空格，必须用双引号括起来,括号内只可以用下面这些转义字符<code>\\\\,\\&quot;,\\t,\\n,\\r,\\v</code>,如果不用双引号,则遇到第一个空格就结束读取</li>\n<li>文件内也可以指明url，必须如下格式<br><code>url = &quot;http://example.com&quot;</code></li>\n</ul>\n<h3 id=\"–keepalive-time-num\"><a href=\"#–keepalive-time-num\" class=\"headerlink\" title=\"–keepalive-time [num]\"></a>–keepalive-time [num]</h3><p>curl默认会保持无流量的tcp连接长达60s,这可以更改时间，单位为秒</p>\n<h3 id=\"–key\"><a href=\"#–key\" class=\"headerlink\" title=\"–key\"></a>–key</h3><p>指定cert健，见–cert</p>\n<h3 id=\"–key-type\"><a href=\"#–key-type\" class=\"headerlink\" title=\"–key-type\"></a>–key-type</h3><p>见–cert</p>\n<h3 id=\"l-–list-only\"><a href=\"#l-–list-only\" class=\"headerlink\" title=\"-l&#x2F;–list-only\"></a>-l&#x2F;–list-only</h3><p>FTP协议中相当与使用NLST命令，可能不会list符号链接和目录</p>\n<h3 id=\"L-–location\"><a href=\"#L-–location\" class=\"headerlink\" title=\"-L&#x2F;–location\"></a>-L&#x2F;–location</h3><p>如果返回重定向，则继续访问重定向的地址。默认最多50个。curl默认不会访问重定向的内容,</p>\n<h3 id=\"–limit-rate\"><a href=\"#–limit-rate\" class=\"headerlink\" title=\"–limit-rate \"></a>–limit-rate <num></h3><p>参数是个数字，默认单位是byte，可以跟K&#x2F;M&#x2F;G，整个过程的平均速度将不超过这个值,也同样适用于上传速率</p>\n<h3 id=\"–location-trusted\"><a href=\"#–location-trusted\" class=\"headerlink\" title=\"–location-trusted\"></a>–location-trusted</h3><p>永远信任重定向的任何主机，默认是不信任，因为，可能重定向不同主机</p>\n<h3 id=\"–local-port-num-or-range\"><a href=\"#–local-port-num-or-range\" class=\"headerlink\" title=\"–local-port [num or range]\"></a>–local-port [num or range]</h3><p>通常不需要指定本地端口，但有时只有某些端口是开放的，指定curl的本地端口，可以指定一个范围，因为一个可能被占用了,最好不要指定1024以下的端口</p>\n<h3 id=\"m-–max-time-num\"><a href=\"#m-–max-time-num\" class=\"headerlink\" title=\"-m&#x2F;–max-time [num]\"></a>-m&#x2F;–max-time [num]</h3><p>整个命令允许运行的最长时间，即使正在下载，也会立刻退出(退出码28)</p>\n<h3 id=\"–mail-from\"><a href=\"#–mail-from\" class=\"headerlink\" title=\"–mail-from\"></a>–mail-from</h3><p>smtp中指定发件人</p>\n<h3 id=\"–mail-rcpt\"><a href=\"#–mail-rcpt\" class=\"headerlink\" title=\"–mail-rcpt\"></a>–mail-rcpt</h3><p>smtp中指定收件人</p>\n<h3 id=\"–manual\"><a href=\"#–manual\" class=\"headerlink\" title=\"–manual\"></a>–manual</h3><h3 id=\"–max-filesize-num\"><a href=\"#–max-filesize-num\" class=\"headerlink\" title=\"–max-filesize [num]\"></a>–max-filesize [num]</h3><p>单位是byte，如果curl在传输开始可以获得将要下载的内容大小，该选项才会起作用，如果超过该大小，curl将会自动放弃。</p>\n<h3 id=\"–max-redirs-num\"><a href=\"#–max-redirs-num\" class=\"headerlink\" title=\"–max-redirs [num]\"></a>–max-redirs [num]</h3><p>指定最多重定向次数，默认50个</p>\n<h3 id=\"n-–netrc\"><a href=\"#n-–netrc\" class=\"headerlink\" title=\"-n&#x2F;–netrc\"></a>-n&#x2F;–netrc</h3><p>读取<code>~/.netrc</code>配置文件，该文件存储用户名密码，例子如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#以下的值都不许有空格，且可以写在一行</span><br>machine example.com <span class=\"hljs-comment\">#可以填default,此时不需要machine关键字</span><br>login nanbert<br>password xxx <br>macdef xxx <span class=\"hljs-comment\">#该选项curl不支持，会忽略</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"–negotiate\"><a href=\"#–negotiate\" class=\"headerlink\" title=\"–negotiate\"></a>–negotiate</h3><p>negotiate的认证方式</p>\n<h3 id=\"netrc-file-path\"><a href=\"#netrc-file-path\" class=\"headerlink\" title=\"-netrc-file [path]\"></a>-netrc-file [path]</h3><p>不读默认<code>~/.netrc</code>文件，而是具体某个文件</p>\n<h3 id=\"–netrc-optional\"><a href=\"#–netrc-optional\" class=\"headerlink\" title=\"–netrc-optional\"></a>–netrc-optional</h3><p>这与<code>--netrc</code>区别在于，使得默认配置内容是可选的,不是强制的</p>\n<h3 id=\"–next\"><a href=\"#–next\" class=\"headerlink\" title=\"–next\"></a>–next</h3><h3 id=\"–no-eprt\"><a href=\"#–no-eprt\" class=\"headerlink\" title=\"–no-eprt\"></a>–no-eprt</h3><p>ftp协议中禁止使用命令EPRT，该命令比PORT更新</p>\n<h3 id=\"–no-epsv\"><a href=\"#–no-epsv\" class=\"headerlink\" title=\"–no-epsv\"></a>–no-epsv</h3><p>ftp协议中进制使用命令EPSV，该命令比PASV更新</p>\n<h3 id=\"–no-keepalive\"><a href=\"#–no-keepalive\" class=\"headerlink\" title=\"–no-keepalive\"></a>–no-keepalive</h3><p>默认curl会保持tcp(无流量)连接60s,这个会关闭该功能</p>\n<h3 id=\"–noproxy\"><a href=\"#–noproxy\" class=\"headerlink\" title=\"–noproxy\"></a>–noproxy</h3><p>不使用全局环境变量代理</p>\n<h3 id=\"–no-verbose\"><a href=\"#–no-verbose\" class=\"headerlink\" title=\"–no-verbose\"></a>–no-verbose</h3><h3 id=\"–ntlm\"><a href=\"#–ntlm\" class=\"headerlink\" title=\"–ntlm\"></a>–ntlm</h3><p>ntlm的认证方式</p>\n<h3 id=\"o\"><a href=\"#o\" class=\"headerlink\" title=\"-o\"></a>-o</h3><p>输出到某个文件，一个该选项对应一个url,想要指明多个，必须声明多个-o</p>\n<h3 id=\"O-–remote-name\"><a href=\"#O-–remote-name\" class=\"headerlink\" title=\"-O&#x2F;–remote-name\"></a>-O&#x2F;–remote-name</h3><p>把结果输出到使用远程服务器的原始文件名,一个该选项对应一个url,想要指明多个，必须声明多个-O</p>\n<h3 id=\"–path-as-is\"><a href=\"#–path-as-is\" class=\"headerlink\" title=\"–path-as-is\"></a>–path-as-is</h3><p>在url指定路径时，如果出现<code>/../</code>或<code>/./</code>,curl会替换它们，再发送给服务器，比如<code>/hello/sir/../</code>变成<code>/hello/</code>,<code>/hello/./sir</code>变成<code>/hello/sir/</code>,而该选项会保留<code>..</code>和<code>.</code></p>\n<h3 id=\"P-–ftp-port-ip\"><a href=\"#P-–ftp-port-ip\" class=\"headerlink\" title=\"-P&#x2F;–ftp-port [ip&#x2F;-]\"></a>-P&#x2F;–ftp-port [ip&#x2F;-]</h3><p>这其实是使用命令PORT或EPRT，即服务器建立新连接到客户,但经常不指定一个确切的port,直接使用<code>-</code>,总是为，信息来时的地址，如下：<br><code>curl -P - ftp://example.com/foobar.txt</code></p>\n<h3 id=\"–post301\"><a href=\"#–post301\" class=\"headerlink\" title=\"–post301\"></a>–post301</h3><p>返回301重定向时，保持初始的方法</p>\n<h3 id=\"–post302\"><a href=\"#–post302\" class=\"headerlink\" title=\"–post302\"></a>–post302</h3><p>返回302重定向时，保持初始的方法</p>\n<h3 id=\"–post303\"><a href=\"#–post303\" class=\"headerlink\" title=\"–post303\"></a>–post303</h3><p>返回303重定向时，保持初始的方法</p>\n<h3 id=\"p-–proxytunnel\"><a href=\"#p-–proxytunnel\" class=\"headerlink\" title=\"-p&#x2F;–proxytunnel\"></a>-p&#x2F;–proxytunnel</h3><p>使用隧道对代理加密<br><code>curl -p -x http://proxy.example.com:80 ftp://ftp.example.com/file.txt</code></p>\n<h3 id=\"–parallel-max\"><a href=\"#–parallel-max\" class=\"headerlink\" title=\"–parallel-max\"></a>–parallel-max</h3><h3 id=\"–pinnedpubkey-sha256-hashnum1-hashnum2\"><a href=\"#–pinnedpubkey-sha256-hashnum1-hashnum2\" class=\"headerlink\" title=\"–pinnedpubkey [sha256&#x2F;&#x2F;hashnum1;hashnum2;..]\"></a>–pinnedpubkey [sha256&#x2F;&#x2F;hashnum1;hashnum2;..]</h3><p>TLS协议中，Certifiate pinning中直接指定sha256值</p>\n<h3 id=\"–proto-default\"><a href=\"#–proto-default\" class=\"headerlink\" title=\"–proto-default\"></a>–proto-default</h3><h3 id=\"–proxy1-0-ip-addr\"><a href=\"#–proxy1-0-ip-addr\" class=\"headerlink\" title=\"–proxy1.0 [ip addr]\"></a>–proxy1.0 [ip addr]</h3><p>指定代理，和<code>--x</code>一样，只是使用HTTP&#x2F;1.0</p>\n<h3 id=\"–proxy-anyauth\"><a href=\"#–proxy-anyauth\" class=\"headerlink\" title=\"–proxy-anyauth\"></a>–proxy-anyauth</h3><p>任意一种代理用户名认证方式,根据代理服务器要求自动匹配或者不使用认证</p>\n<h3 id=\"–proxy-digest\"><a href=\"#–proxy-digest\" class=\"headerlink\" title=\"–proxy-digest\"></a>–proxy-digest</h3><p>一种代理用户名认证方式</p>\n<h3 id=\"–proxy-header\"><a href=\"#–proxy-header\" class=\"headerlink\" title=\"–proxy-header\"></a>–proxy-header</h3><p>该头只发送给代理，真正的远程服务器不会收到，这比–header更精细化<br><code>curl --proxy-header &quot;User-Agent: magic/3000&quot; -x proxy https://example.com/</code></p>\n<h3 id=\"–proxy-negotiate\"><a href=\"#–proxy-negotiate\" class=\"headerlink\" title=\"–proxy-negotiate\"></a>–proxy-negotiate</h3><p>一种代理用户名认证方式</p>\n<h3 id=\"–proxy-ntlm\"><a href=\"#–proxy-ntlm\" class=\"headerlink\" title=\"–proxy-ntlm\"></a>–proxy-ntlm</h3><p>一种代理用户名认证方式</p>\n<h3 id=\"Q-–quote-ftp-cmd\"><a href=\"#Q-–quote-ftp-cmd\" class=\"headerlink\" title=\"-Q&#x2F;–quote [ftp cmd]\"></a>-Q&#x2F;–quote [ftp cmd]</h3><p>发送命令给ftp服务器</p>\n<ul>\n<li>在传输之前发送NOOP命令<code>curl -Q NOOP ftp://example.com/file</code></li>\n<li>在传输之后发送NOOP命令<code>curl -Q -NOOP ftp://example.com/file</code></li>\n<li>不知什么时候发<code>curl -Q +NOOP ftp://example.com/file</code><br>发送的命令发生错误时会导致curl退出，有时可以在命令前加<code>*</code>，忽略可能发送错误，如：<br><code>curl -Q &quot;-*DELE file&quot; ftp://example.com/moo</code></li>\n</ul>\n<h3 id=\"r-–range-num1-num2-num3-0-num3-…\"><a href=\"#r-–range-num1-num2-num3-0-num3-…\" class=\"headerlink\" title=\"-r&#x2F;–range [num1-num2,num3-,0-num3,…]\"></a>-r&#x2F;–range [num1-num2,num3-,0-num3,…]</h3><p>只下num1 byte offset至num2 byte offset的内容,服务器可以选择性的实现该功能，也就是说，即使你这么请求，服务器也可能返回全部内容</p>\n<h3 id=\"–remote-name-all\"><a href=\"#–remote-name-all\" class=\"headerlink\" title=\"–remote-name-all\"></a>–remote-name-all</h3><p>所有结果均输出保存到服务器上的原始文件名</p>\n<h3 id=\"–remote-time\"><a href=\"#–remote-time\" class=\"headerlink\" title=\"–remote-time\"></a>–remote-time</h3><p>使得下载到本地的文件的时间戳和远程服务器文件的时间戳一样，常和-z -o选项搭配<br><code>curl -z file.html -o file.html --remote-time https://example.com/file.html</code></p>\n<h3 id=\"–resolve-host-name-port-ip-address\"><a href=\"#–resolve-host-name-port-ip-address\" class=\"headerlink\" title=\"–resolve [host name:port:ip address]\"></a>–resolve [host name:port:ip address]</h3><p>dns重定向，这会保存到curl的cache中<br><code>curl --resolve example.com:80:127.0.0.1 http://example.com/</code></p>\n<h3 id=\"s-–silent\"><a href=\"#s-–silent\" class=\"headerlink\" title=\"-s&#x2F;–silent\"></a>-s&#x2F;–silent</h3><p>此选项关闭进度条，并不显示错误，但是-S&#x2F;–show-error不受此选项影响</p>\n<h3 id=\"S-–show-error\"><a href=\"#S-–show-error\" class=\"headerlink\" title=\"-S&#x2F;–show-error\"></a>-S&#x2F;–show-error</h3><p>默认情况下curl会输出错误，该选项主要是抵消-s的作用</p>\n<h3 id=\"–speed-time-num\"><a href=\"#–speed-time-num\" class=\"headerlink\" title=\"–speed-time [num]\"></a>–speed-time [num]</h3><p>经常和–speed-limit一起用,下面的意思是速度小于1000并且持续15s就退出<br><code>curl --speed-time 15 --speed-limit 1000 https://example.com/</code></p>\n<h3 id=\"–speed-limit-num\"><a href=\"#–speed-limit-num\" class=\"headerlink\" title=\"–speed-limit [num]\"></a>–speed-limit [num]</h3><p>见–speed-time</p>\n<h3 id=\"–ssl\"><a href=\"#–ssl\" class=\"headerlink\" title=\"–ssl\"></a>–ssl</h3><p>尝试ssl加密(FTP,IMAP,POP3,SMTP)</p>\n<h3 id=\"–sslv2\"><a href=\"#–sslv2\" class=\"headerlink\" title=\"–sslv2\"></a>–sslv2</h3><p>使用SSL2版本</p>\n<h3 id=\"–sslv3\"><a href=\"#–sslv3\" class=\"headerlink\" title=\"–sslv3\"></a>–sslv3</h3><p>使用SSL3版本</p>\n<h3 id=\"–ssl-reqd\"><a href=\"#–ssl-reqd\" class=\"headerlink\" title=\"–ssl-reqd\"></a>–ssl-reqd</h3><p>强制ssl加密(FTP,IMAP,POP3,SMTP)</p>\n<h3 id=\"–raw\"><a href=\"#–raw\" class=\"headerlink\" title=\"–raw\"></a>–raw</h3><p>禁用内容或传输编码的所有内部http解码，而是使用未经修改的原始数据,这经常用在curl为一个代理的情况</p>\n<h3 id=\"–retry-num\"><a href=\"#–retry-num\" class=\"headerlink\" title=\"–retry [num]\"></a>–retry [num]</h3><p>curl会在发生transient error时，会重新尝试num次，默认失败一次就不会尝试，transient error包括以下：超时，FTP 4XX返回码，http5xx返回码</p>\n<h3 id=\"–request-target\"><a href=\"#–request-target\" class=\"headerlink\" title=\"–request-target\"></a>–request-target</h3><p>获取的资源路径，这个一般直接写在url中，但这配合OPTIONS方法，有个特殊用法：<br><code>curl -X OPTIONS --request-target &quot;*&quot; http://example.com/</code><br>会形成下面的头：<br><code>OPTIONS * HTTP/1.1</code></p>\n<h3 id=\"–retry-all-errors\"><a href=\"#–retry-all-errors\" class=\"headerlink\" title=\"–retry-all-errors\"></a>–retry-all-errors</h3><p>有时你确定一个服务器是好的，出现任何错误都想重试，该选项就可以帮你</p>\n<h3 id=\"–retry-connrefused\"><a href=\"#–retry-connrefused\" class=\"headerlink\" title=\"–retry-connrefused\"></a>–retry-connrefused</h3><p>重试只会发生在transient error时，但拒绝访问不属于，有时你确认服务器只是重启或其他原因，该选项可以使得出现拒绝访问时，也可以重试。</p>\n<h3 id=\"–retry-max-time-num\"><a href=\"#–retry-max-time-num\" class=\"headerlink\" title=\"–retry-max-time [num]\"></a>–retry-max-time [num]</h3><p>第一次重试之前,curl会等1s,然后第二次重试会等2s,如此指数增长下去，直到达到10min，该选项会指明等待时间不少于num秒，–max-time选项仍会起作用</p>\n<h3 id=\"T\"><a href=\"#T\" class=\"headerlink\" title=\"-T\"></a>-T</h3><ul>\n<li>HTTP PUT就是上传某个完整资源上传或替换远程的现有资源，很少被服务器启用</li>\n<li>FTP或TFTP 上传文件，如下<br><code>curl -T uploadthis ftp://example.com/this/directory/</code><br><code>curl -T uploadthis ftp://example.com/this/directory/remotename</code></li>\n<li>SMTP上传body内容，通常需要其他选项(有关header的选项)配合（–mail-from,等）<br><code>curl -T mail smtp://mail.example.com/ --mail-from user@example.com</code></li>\n</ul>\n<h3 id=\"t-–telnet-option-keyword-value\"><a href=\"#t-–telnet-option-keyword-value\" class=\"headerlink\" title=\"-t&#x2F;–telnet-option [keyword&#x3D;value]\"></a>-t&#x2F;–telnet-option [keyword&#x3D;value]</h3><p>telnet选项特有，传递以下三个参数：</p>\n<ul>\n<li>TTYPE&#x3D;[term]:设置终端类型</li>\n<li>XDISPLOC&#x3D;[X display]:设置X展示位置</li>\n<li>NEW_ENV&#x3D;[var,val]:设置环境变量值</li>\n</ul>\n<h3 id=\"–tftp-blksize-num\"><a href=\"#–tftp-blksize-num\" class=\"headerlink\" title=\"–tftp-blksize [num]\"></a>–tftp-blksize [num]</h3><p>tftp通信传输块默认大小为512,此选项可以修改，支持8-65464</p>\n<h3 id=\"–tftp-no-options\"><a href=\"#–tftp-no-options\" class=\"headerlink\" title=\"–tftp-no-options\"></a>–tftp-no-options</h3><p>有些tftp服务器不接受任何选项，此时该选项可以应用</p>\n<h3 id=\"–tlspassword-passwd\"><a href=\"#–tlspassword-passwd\" class=\"headerlink\" title=\"–tlspassword [passwd]\"></a>–tlspassword [passwd]</h3><p>TLS的特性，可以在命令行中直接使用用户名和密码<br><code>curl --tlsuser daniel --tlspassword secret https://example.com</code></p>\n<h3 id=\"–tlsuser-name\"><a href=\"#–tlsuser-name\" class=\"headerlink\" title=\"–tlsuser [name]\"></a>–tlsuser [name]</h3><p>见–tlspassword</p>\n<h3 id=\"–tlsv1-–tlsv1-0\"><a href=\"#–tlsv1-–tlsv1-0\" class=\"headerlink\" title=\"–tlsv1&#x2F;–tlsv1.0\"></a>–tlsv1&#x2F;–tlsv1.0</h3><p>使用TLS&gt;&#x3D;1.0的版本</p>\n<h3 id=\"–tlsv1-1\"><a href=\"#–tlsv1-1\" class=\"headerlink\" title=\"–tlsv1.1\"></a>–tlsv1.1</h3><p>使用TLS&gt;&#x3D;1.0的版本</p>\n<h3 id=\"–tlsv1-2\"><a href=\"#–tlsv1-2\" class=\"headerlink\" title=\"–tlsv1.2\"></a>–tlsv1.2</h3><p>使用TLS&gt;&#x3D;1.2的版本</p>\n<h3 id=\"–tlsv1-3\"><a href=\"#–tlsv1-3\" class=\"headerlink\" title=\"–tlsv1.3\"></a>–tlsv1.3</h3><p>使用TLS&gt;&#x3D;1.3的版本,curl默认</p>\n<h3 id=\"–tr-encoding\"><a href=\"#–tr-encoding\" class=\"headerlink\" title=\"–tr-encoding\"></a>–tr-encoding</h3><p>采用Transfer-Encoded压缩传输内容，curl会自动解压,不能和–compressed混用,且该选项不常用</p>\n<h3 id=\"–trace-filename\"><a href=\"#–trace-filename\" class=\"headerlink\" title=\"–trace [filename]\"></a>–trace [filename]</h3><p>会跟踪每拍接受的内容，以16进制显示,每行开头的十六进制加冒号代表该内容的byte offset</p>\n<h3 id=\"–trace-ascii-filename\"><a href=\"#–trace-ascii-filename\" class=\"headerlink\" title=\"–trace-ascii [filename]\"></a>–trace-ascii [filename]</h3><p>会跟踪每拍接受的内容，以ascii码可读形式显示</p>\n<h3 id=\"–trace-time\"><a href=\"#–trace-time\" class=\"headerlink\" title=\"–trace-time\"></a>–trace-time</h3><p>化学选项：-v&#x2F;–verbose,–trace和–trace-ascii<br>这个选项会帮助化学选项所输出内容之前加高精度的时间。</p>\n<h3 id=\"u-–user\"><a href=\"#u-–user\" class=\"headerlink\" title=\"-u&#x2F;–user\"></a>-u&#x2F;–user</h3><p>指定用户名和密码，冒号分隔<code>user:passwd</code>,这种明文，最好不用，协议层方面使用https和ftps等，如果非要使用明文,可以选择选项<code>--digest</code>,<code>--negotiate</code>,<code>--ntlm</code>,或者直接通过配置文件###1禁用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl --digest --user daniel:secret http://example.com/<br>curl --negotiate --user daniel:secret http://example.com/<br>curl --ntlm --user daniel:secret http://example.com/<br></code></pre></td></tr></table></figure>\n<h3 id=\"U-–proxy-user-user-passwd\"><a href=\"#U-–proxy-user-user-passwd\" class=\"headerlink\" title=\"-U&#x2F;–proxy-user [user:passwd]\"></a>-U&#x2F;–proxy-user [user:passwd]</h3><p>指定代理的用户名和密码<br><code>curl -U daniel:secr3t -x myproxy:80 http://example.com</code></p>\n<h3 id=\"–upload-file\"><a href=\"#–upload-file\" class=\"headerlink\" title=\"–upload-file\"></a>–upload-file</h3><p>指定上传内容文件，用于smtp</p>\n<h3 id=\"–use-ascii\"><a href=\"#–use-ascii\" class=\"headerlink\" title=\"–use-ascii\"></a>–use-ascii</h3><p>使用ascii传输，而不是二进制</p>\n<h3 id=\"v-–verbose\"><a href=\"#v-–verbose\" class=\"headerlink\" title=\"-v&#x2F;–verbose\"></a>-v&#x2F;–verbose</h3><p>该选项会使curl显示更多的内容，具体格式如下：</p>\n<ul>\n<li><code>*</code>后面跟解释性内容</li>\n<li><code>&gt;</code>后面跟客户端发送的头协议，（FTP,SMTP,POP3等没有头协议的，命令和返回当成头）</li>\n<li><code>&lt;</code>后面跟从服务端接受的返回头协议<br>HTTP&#x2F;2和HTTP&#x2F;3协议头是压缩的，但在此选项下会展开和HTTP&#x2F;1.1一样的格式</li>\n</ul>\n<h3 id=\"V-–version\"><a href=\"#V-–version\" class=\"headerlink\" title=\"-V&#x2F;–version\"></a>-V&#x2F;–version</h3><p>会输出版本相关的信息，各行含义如下:<br>**第一行:**版本号+平台+第三方依赖信息<br>**第二行:**版本发布日期<br>**第三行:**支持的协议<br>**第四行:**支持的特性</p>\n<h3 id=\"w-–write-out\"><a href=\"#w-–write-out\" class=\"headerlink\" title=\"-w&#x2F;–write-out\"></a>-w&#x2F;–write-out</h3><p>参数:<code>&lt;formatted string&gt;</code>或<code>@[filename或-]</code><br>该选项会在每个传输完毕后，在末尾加上formatted string或文件中的内容,%可以使用<code>\\n,\\r,\\t</code>转义字符，特殊的变量跟在<code>%</code>后,<code>%%</code>输出真正的%<br>有以下formatted string:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>%&#123;content_type&#125;</code></td>\n<td align=\"center\">字面义，有的内容没有类型</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;errormsg&#125;</code></td>\n<td align=\"center\">字面义，无错误为空</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;exitcode&#125;</code></td>\n<td align=\"center\">传输的退出码，无错返回0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;filename_effective&#125;</code></td>\n<td align=\"center\">最终传输内容所保存的文件名，只当指定-o或–remote-name选项有意义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;ftp_entry_path&#125;</code></td>\n<td align=\"center\">登陆ftp的初始路径</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;http_code&#125;</code></td>\n<td align=\"center\">也就是response_code</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;http_connect&#125;</code></td>\n<td align=\"center\">待探索</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;http_version&#125;</code></td>\n<td align=\"center\">字面义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;json&#125;</code></td>\n<td align=\"center\">所有write-out的变量生成json格式</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;local_ip&#125;</code></td>\n<td align=\"center\">最近一次连接的ipv4或ipv6的本地地址</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;local_port&#125;</code></td>\n<td align=\"center\">最近一次连接的本地端口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;method&#125;</code></td>\n<td align=\"center\">最近请求的方法</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;num_connects&#125;</code></td>\n<td align=\"center\">最近传输的新连接数量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;num_headers&#125;</code></td>\n<td align=\"center\">上一次传输的反应头的数量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;num_redirects&#125;</code></td>\n<td align=\"center\">请求的重定向次数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;onerror&#125;</code></td>\n<td align=\"center\">如果传输发生错误，输出之后的string,内容，否则不输出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;proxy_ssl_verify_result&#125;</code></td>\n<td align=\"center\">与代理通信时请求的SSL对等证书验证的结果,0表示成功</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;redirect_url&#125;</code></td>\n<td align=\"center\">当发出HTTP请求而没有-L重定向时，重定向会将您带到的实际URL</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;remote_ip&#125;</code></td>\n<td align=\"center\">远程的ipv4或6地址</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;remote_port&#125;</code></td>\n<td align=\"center\">远程的端口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;response_code&#125;</code></td>\n<td align=\"center\">字面义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;scheme&#125;</code></td>\n<td align=\"center\">url的scheme</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_download&#125;</code></td>\n<td align=\"center\">字面义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_header&#125;</code></td>\n<td align=\"center\">头部的大小</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_request&#125;</code></td>\n<td align=\"center\">请求的大小</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_upload&#125;</code></td>\n<td align=\"center\">上传大小</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;speed_download&#125;</code></td>\n<td align=\"center\">平均下载速度</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;speed_upload&#125;</code></td>\n<td align=\"center\">平均上传速度</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;ssl_verify_result&#125;</code></td>\n<td align=\"center\">请求SSL对等证书验证的结果，0表示成功</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;stderr&#125;</code></td>\n<td align=\"center\">接下来的内容输出到标准错误</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;stdout&#125;</code></td>\n<td align=\"center\">接下来的内容输出到标准输出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_appconnect&#125;</code></td>\n<td align=\"center\">从开始到完成SSL&#x2F;SSH&#x2F;etc到远程主机的连接&#x2F;握手花费的时间，单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_connect&#125;</code></td>\n<td align=\"center\">从一开始直到TCP连接到远程主机（或代理）完成花费的时间，单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_namelookup&#125;</code></td>\n<td align=\"center\">从一开始直到名字解析完成所花费的时间,单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_pretransfer&#125;</code></td>\n<td align=\"center\">从一开始直到文件传输即将开始所花费的时间，单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_redirect&#125;</code></td>\n<td align=\"center\">所有重定向步骤，包括名称查找，连接，预传输和最终事务开始之前的传输所花费的时间,单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_starttransfer&#125;</code></td>\n<td align=\"center\">从一凯斯直到第一个字节即将被传输，这包括time_pretransfer和服务器计算结果所需的时间</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_total&#125;</code></td>\n<td align=\"center\">完整操作持续的总时间，时间为秒，精度达到毫秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;url&#125;</code></td>\n<td align=\"center\">命令行中指定url</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;url_effective&#125;</code></td>\n<td align=\"center\">真实有效的url</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;urlnum&#125;</code></td>\n<td align=\"center\">url的编号，从0开始计数</td>\n</tr>\n</tbody></table>\n<h3 id=\"X-–request\"><a href=\"#X-–request\" class=\"headerlink\" title=\"-X&#x2F;–request\"></a>-X&#x2F;–request</h3><p>指定http的方法，一般curl会根据选项自动判断，无需特地指定该选项，错误的方法可能使得curl行为怪异</p>\n<h3 id=\"x-–proxy-ip-addr\"><a href=\"#x-–proxy-ip-addr\" class=\"headerlink\" title=\"-x&#x2F;–proxy [ip addr]\"></a>-x&#x2F;–proxy [ip addr]</h3><ul>\n<li>指定代理，默认scheme为http,默认端口为1080<br><code>curl -x 192.168.0.1:8080 http://example.com/</code></li>\n<li>指定SOCKS协议代理，这可以直接使用各个版本，而不用-x，说明如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#SOCKS4版本</span><br>curl -x socks4://proxy.example.com http://www.example.com/<br>curl --socks4 proxy.example.com http://www.example.com/<br><span class=\"hljs-comment\">#SOCKS4a版本</span><br>curl -x socks4a://proxy.example.com http://www.example.com/<br>curl --socks4a proxy.example.com http://www.example.com/<br><span class=\"hljs-comment\">#SOCKS5版本</span><br>curl -x socks5://proxy.example.com http://www.example.com/<br>curl --socks5 proxy.example.com http://www.example.com/<br><span class=\"hljs-comment\">#SOCKS5h版本</span><br>curl -x socks5h://proxy.example.com http://www.example.com/<br>curl --socks5-ostname proxy.example.com http://www.example.com/<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"–xattr\"><a href=\"#–xattr\" class=\"headerlink\" title=\"–xattr\"></a>–xattr</h3><h3 id=\"Z-–parallel\"><a href=\"#Z-–parallel\" class=\"headerlink\" title=\"-Z&#x2F;–parallel\"></a>-Z&#x2F;–parallel</h3><h3 id=\"z-–time-cond-time-stamp-file\"><a href=\"#z-–time-cond-time-stamp-file\" class=\"headerlink\" title=\"-z&#x2F;–time-cond [time stamp&#x2F;file]\"></a>-z&#x2F;–time-cond [time stamp&#x2F;file]</h3><p>对下载的内容做时间限制(可早，可晚)，时间格式可以是常见的格式，或者指定比某个本地文件新</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl -z <span class=\"hljs-string\">&quot;Jan 10, 2017&quot;</span> https://example.com/file -O<span class=\"hljs-comment\">#只下载比该时间戳新的</span><br>curl --time-cond <span class=\"hljs-string\">&quot;Sun, 12 Sep 2004 15:05:58 -0700&quot;</span> https://www.example.org/file.html<span class=\"hljs-comment\">#只下载比该时间早的</span><br>curl -z file.html https://example.com/file.html -O<span class=\"hljs-comment\">#比file.html新的</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"-:\"></a>-:</h3><h3 id=\"–progress-bar\"><a href=\"#–progress-bar\" class=\"headerlink\" title=\"-#&#x2F;–progress-bar\"></a>-#&#x2F;–progress-bar</h3><p>当内容重定向时，进度条是默认打开的,该选项会展示一种简单的进度条，有时进度条无法估计时间</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"@作用\"></a>@作用</h3><p>传参数可以把参数放到文件里，如下:<br><code>curl -d @json http://example.com</code></p>\n<h2 id=\"curl退出码\"><a href=\"#curl退出码\" class=\"headerlink\" title=\"curl退出码\"></a>curl退出码</h2><ul>\n<li>1：不支持的协议</li>\n<li>2：初始化失败，libcurl可能出了问题</li>\n<li>3：url格式不对</li>\n<li>4：某个请求需要某个特性或选项未能满足</li>\n<li>5：无法解析代理</li>\n<li>6：无法解析主机</li>\n<li>7：无法连接主机。可能端口，主机名或防火墙的问题</li>\n<li>8：未知的ftp服务返回。可能未支持，也可能未启用选项</li>\n<li>9：ftp拒绝访问。没该文件或用户名或没权限</li>\n<li>10：ftp接受失败。</li>\n<li>11：ftp奇怪的PASS回复</li>\n<li>12：在等待服务器连接的活动FTP会话期间，超过限期</li>\n<li>13：FTP PASV命令未知的反应。通过–ftp-port选项可能解决该问题</li>\n<li>14：未知FTP227格式。这肯定是个坏服务器，或者可以通过–ftp-port解决该问题</li>\n<li>15：FTP无法获得主机</li>\n<li>16：HTTP&#x2F;2 error</li>\n<li>17：FTP无法设置binary传输。坏的服务器</li>\n<li>18：只传输了部分文件</li>\n<li>19：FTP无法获得下载该文件。RETR命令失败</li>\n<li>20：（保留）</li>\n<li>21：引用错误。IMAP、POP3、SMTP、FTP发送自定义命令时出错，建议查看报头</li>\n<li>22：HTTP页面未抓取。对应400反应码以上的错误，出现该错误只能在-f选项启用的时候</li>\n<li>23：写错误。写到本地时发生的错误</li>\n<li>24：（保留）</li>\n<li>25：上传失败。服务器空间已满或拒绝上传</li>\n<li>26：读错误。从本地读取时发生错误</li>\n<li>27：内存不够。系统分配给curl内存不足</li>\n<li>28：操作超时。由各种选项设置的各种超时</li>\n<li>29：（保留）</li>\n<li>30：FTP PORT命令错误。PORT命令有点非主流，可以试试PASV</li>\n<li>31：FTP无法使用REST。可以在没有范围或恢复的情况下重试</li>\n<li>32：（保留）</li>\n<li>33：HTTP范围错误</li>\n<li>34：HTTP post错误,需要反馈BUG</li>\n<li>35：TLS&#x2F;SSL连接错误</li>\n<li>36：无法恢复下载。FILE,FTP,SFTP会发生此错误</li>\n<li>37：无法读取该文件。FILE协议，可能不存在或没权限</li>\n<li>38：绑定LDAP失败。可能用户密码错误</li>\n<li>39：LDAP搜索失败。</li>\n<li>40：（保留）</li>\n<li>41：（保留）</li>\n<li>42：回调错误。开发者编程的错误</li>\n<li>43：错误函数参数。libcurl的调用问题</li>\n<li>44：（保留）</li>\n<li>45：网络接口错误</li>\n<li>46：（保留）</li>\n<li>47：太多重定向。默认最多50个，可以通过–max-redirs改变</li>\n<li>48：libcurl未知选项。可能curl和libcurl版本不一</li>\n<li>49：telnet错误的选项</li>\n<li>50：（保留）</li>\n<li>51：SSL&#x2F;TLS、SSH认证失败</li>\n<li>52：服务器未返回任何内容。可能是服务器有意为之</li>\n<li>53：未发现SSL引擎</li>\n<li>54：无法设置SSL加密引擎为默认</li>\n<li>55：无法发送网络数据。网络底层的错误，需要Wireshark等工具查看</li>\n<li>56：无法接受网络数据。网络底层错误。</li>\n<li>57：（保留）</li>\n<li>58：本地认证有问题。</li>\n<li>59：无法使用ssl密码。密码有格式标准</li>\n<li>60：对等证书无法使用已知ca认证</li>\n<li>61：无法识别传输编码</li>\n<li>62：无效LDAP URL</li>\n<li>63：超过最大文件大小限制</li>\n<li>64：FTP SSL失败</li>\n<li>65：发送之前帧失败</li>\n<li>66：初始化SSL引擎失败</li>\n<li>67：用户名密码CURL无法登陆</li>\n<li>68：TFTP服务没有该文件</li>\n<li>69：TFTP服务权限问题</li>\n<li>70：TFTP服务没有空间</li>\n<li>71：非法TFTP操作</li>\n<li>72：未知TFTP传输id</li>\n<li>73：TFTP文件已存在</li>\n<li>74：TFTP没有该用户</li>\n<li>75：字符转换失败</li>\n<li>76：需要字符转换函数</li>\n<li>77：读SSL CA认证时发生问题</li>\n<li>78：URL中的资源不存在</li>\n<li>79：在SSH会话中发生错误</li>\n<li>80：关闭SSL连接失败</li>\n<li>81：（保留）</li>\n<li>82：无法下载CRL文件，错误格式</li>\n<li>83：TLS认证检查失败</li>\n<li>84：FTP PRET命令失败</li>\n<li>85：RTSP:CSeq数字不匹配</li>\n<li>86：RTSP:会话标识符不匹配</li>\n<li>87：无法解析ftp文件列表</li>\n<li>88：FTP 块回掉错误</li>\n<li>89：没有可用的连接，会话将排队</li>\n<li>90：SSL公钥不匹配固定公钥</li>\n<li>91：无效SSL认证状态</li>\n<li>92：HTTP&#x2F;2流错误</li>\n<li>93：API回调错误</li>\n<li>94：认证错误</li>\n<li>95：HTTP&#x2F;3错误</li>\n<li>96：QUIC连接错误</li>\n</ul>\n<h2 id=\"curl与浏览器的区别\"><a href=\"#curl与浏览器的区别\" class=\"headerlink\" title=\"curl与浏览器的区别\"></a>curl与浏览器的区别</h2><ul>\n<li>浏览器会对接受的数据进行二次解码,更易懂些，curl就直接解码</li>\n<li>有的服务器会根据不同客户端(甚至不同的浏览器)提供更适配的内容</li>\n<li>你可以使用f12然后选中network,右键点击你想要的资源，选中<code>copy cURL</code>就可以复制相应的命令</li>\n</ul>\n<h2 id=\"POP3-curl读邮件使用的协议\"><a href=\"#POP3-curl读邮件使用的协议\" class=\"headerlink\" title=\"POP3(curl读邮件使用的协议)\"></a>POP3(curl读邮件使用的协议)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#To list message numbers and sizes:</span><br>curl pop3://mail.example.com/<br><span class=\"hljs-comment\">#To download message 1:</span><br>curl pop3://mail.example.com/1<br><span class=\"hljs-comment\">#To delete message 1:</span><br>curl --request DELE pop3://mail.example.com/1<br></code></pre></td></tr></table></figure>\n<p><strong>TLS加密</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl pop3://mail.example.com/ --ssl-reqd<br>curl pop3s://mail.example.com/<br></code></pre></td></tr></table></figure>\n<h2 id=\"IMAP-curl读邮件使用的协议，更常用现代\"><a href=\"#IMAP-curl读邮件使用的协议，更常用现代\" class=\"headerlink\" title=\"IMAP(curl读邮件使用的协议，更常用现代)\"></a>IMAP(curl读邮件使用的协议，更常用现代)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#Get the mail using the UID 57 from mailbox &#x27;stuff&#x27;:</span><br>curl imap://server.example.com/stuff;UID=57<br><span class=\"hljs-comment\">#get the mail with index 57 from the mailbox &#x27;fun&#x27;</span><br>curl imap://server.example.com/fun;MAILINDEX=57<br><span class=\"hljs-comment\">#List the mails in the mailbox &#x27;boring&#x27;:</span><br>curl imap://server.example.com/boring<br><span class=\"hljs-comment\">#List the mails in the mailbox &#x27;boring&#x27; and provide user and password:</span><br>curl imap://server.example.com/boring -u user:password<br></code></pre></td></tr></table></figure>\n<p><strong>TLS加密</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl --ssl imap://mail.example.com/inbox<br>curl imaps://mail.example.com/inbox<br></code></pre></td></tr></table></figure>\n<h2 id=\"SMTP-cURL写邮件使用的协议\"><a href=\"#SMTP-cURL写邮件使用的协议\" class=\"headerlink\" title=\"SMTP(cURL写邮件使用的协议)\"></a>SMTP(cURL写邮件使用的协议)</h2><p>必须指定收发邮箱，以及内容,默认端口587</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl smtp://mail.example.com --mail-from myself@example.com --mail-rcpt \\<br>receiver@example.com --upload-file email.txt<br></code></pre></td></tr></table></figure>\n<p>email.txt:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">From: John Smith &lt;john@example.com&gt;<br>To: Joe Smith &lt;smith@example.com&gt;<br>Subject: an example.com example email<br>Date: Mon, 7 Nov 2016 08:45:16<br><br>Dear Joe,<br>Welcome to this example email. What a lovely day.<br></code></pre></td></tr></table></figure>\n<p>和POP3、IMAP一样，可以使用SSL&#x2F;TLS加密，schema改成smtps即可，或者使用–ssl或–ssl-reqd,此时默认端口为465</p>\n<h2 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h2><p>订阅推送的协议，不太懂</p>\n<h2 id=\"TFTP\"><a href=\"#TFTP\" class=\"headerlink\" title=\"TFTP\"></a>TFTP</h2><p>小文件传输协议，使用的是UDP</p>\n<ul>\n<li>下载<code>curl -O tftp://localserver/file.boot</code></li>\n<li>上传<code>curl -T file.boot tftp://localserver/</code></li>\n</ul>\n<h2 id=\"TELNET\"><a href=\"#TELNET\" class=\"headerlink\" title=\"TELNET\"></a>TELNET</h2><p>即时通信协议，默认端口23</p>\n<h2 id=\"DICT\"><a href=\"#DICT\" class=\"headerlink\" title=\"DICT\"></a>DICT</h2><p>字典查询的协议<br>alias:</p>\n<ul>\n<li>m:match和find</li>\n<li>d:define和lookup<br>例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl dict://dict.org/m:curl<br>curl dict://dict.org/d:heisenbug:jargon<br>curl dict://dict.org/d:daniel:gcide<br>curl dict://dict.org/find:curl<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"TLS-SSL\"><a href=\"#TLS-SSL\" class=\"headerlink\" title=\"TLS&#x2F;SSL\"></a>TLS&#x2F;SSL</h2><p>TLS是建立于TCP上一层的安全加密层，SSL是旧称(且所有ssl版本都在淘汰中)，两个是一个概念。<br>各个版本协议都有TLS版本：</p>\n<ul>\n<li>HTTP-HTTPS</li>\n<li>LDAP-LDAPS</li>\n<li>FTP-FTPS</li>\n<li>POP3-POP3S</li>\n<li>IMAP-IMAPS</li>\n<li>SMTP-SMTPS<br>TLS属于third-party,你可以通过–version查看，如果你feature中有MultiSSL的特性，证明curl是支持多版本的，你可以通过<code>CURL_SSL_BACKEND</code>来设置使用那个版二</li>\n</ul>\n<h3 id=\"版本历史\"><a href=\"#版本历史\" class=\"headerlink\" title=\"版本历史\"></a>版本历史</h3><p>SSL2(1995)-&gt;SSL3-&gt;TLS1.0(1999)-&gt;TLS1.1(2006)-&gt;TLS1.2(2008)-&gt;TLS1.3(2018)</p>\n<h3 id=\"CA的存储\"><a href=\"#CA的存储\" class=\"headerlink\" title=\"CA的存储\"></a>CA的存储</h3><p>一般都是内建的，但你也可以用–cacert指定路径（一定要是PEM格式），或者设置CURL-CA_BUNDLE环境变量</p>\n<h2 id=\"wget\"><a href=\"#wget\" class=\"headerlink\" title=\"wget\"></a>wget</h2><ul>\n<li><img src=\"https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/wget.html\"></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><ul>\n<li>HTTP&#x2F;2和HTTP&#x2F;3的头部通常会被curl压缩发送，但是-v选项总是把它们解压成HTTP&#x2F;1.1的样子</li>\n<li>HTTP默认端口：80，HTTPS默认端口：443</li>\n<li>HTTP有4种方法：GET，POST，HEAD，PUT,OPTIONS</li>\n<li>curl默认的http版本为HTTP&#x2F;1.1,默认的https版本为HTTP&#x2F;2</li>\n</ul>\n<h3 id=\"返回码\"><a href=\"#返回码\" class=\"headerlink\" title=\"返回码\"></a>返回码</h3><ul>\n<li>1XX：瞬态响应，更多内容即将发生</li>\n<li>2XX：成功</li>\n<li>3XX：重定向<ul>\n<li>301:永久重定向，当一个url第一次返回该值时，重定向的内容将被浏览器缓存，下次该url不起作用，直接访问重定向内容(浏览器总是使用GET，即使第一次访问时用的是POST),curl永远不会缓存</li>\n<li>302:暂时重定向，不会缓存,重定向总是使用GET</li>\n<li>303:同302,但是更接近于间接访问的概念</li>\n<li>307:暂时重定向，不会缓存，区别在于它会保持第一次访问的方法</li>\n<li>308:永久重定向，区别在于它会保持第一次访问的方法</li>\n</ul>\n</li>\n<li>4XX：服务器无法提供或不会提供要求的内容<ul>\n<li>401:服务器需要一个认证，通常包含头<code>WWW-Authenticate:</code>,包含了服务器支持的认证方法(Basic)</li>\n<li>407:代理服务器需要一个认证，通常包含头<code>Proxy-Authenticate:</code>,包含了代理支持的认证方法</li>\n</ul>\n</li>\n<li>5XX：服务器出现问题</li>\n</ul>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>通过URL来形成HTTP头<br><img src=\"/images/httpRequest.png\"><br><strong>request例子</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">GET / HTTP/1.1<br>User-agent: curl/2000<br>Host: example.com<br></code></pre></td></tr></table></figure>\n<p><strong>response例子</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">HTTP/1.1 200 OK<br>Server: example-server/1.1<br>Content-Length: 5<br>Content-Type: plain/text<br><br>hello<br></code></pre></td></tr></table></figure>\n<h3 id=\"Transfer-Encoding-chunked\"><a href=\"#Transfer-Encoding-chunked\" class=\"headerlink\" title=\"Transfer-Encoding: chunked\"></a>Transfer-Encoding: chunked</h3><p>有时response可能没有Content-Length，而是<strong>Transfer-Encoding: chunked</strong>，这只有HTTP1.1服务才有，它表示内容是一系列的块，每块开头有显示该块的十六进制大小，结束时，也会有表示结束的0块。curl会自动解码</p>\n<h3 id=\"Content-Encoding-gzip\"><a href=\"#Content-Encoding-gzip\" class=\"headerlink\" title=\"Content-Encoding: gzip\"></a>Content-Encoding: gzip</h3><p>body是经过压缩的,curl会自动解压</p>\n<h3 id=\"Expect-100-continue\"><a href=\"#Expect-100-continue\" class=\"headerlink\" title=\"Expect:100-continue\"></a>Expect:100-continue</h3><p>很少有服务器支持这一特性，且HTTP&#x2F;2及以上支持在没关闭连接的情况下停止持续传输,这使得该特性无意义。(该特性到底是啥不懂)post时，curl会默认</p>\n<h3 id=\"透明压缩\"><a href=\"#透明压缩\" class=\"headerlink\" title=\"透明压缩\"></a>透明压缩</h3><p>过于老式，不常用，可以使用–tr-encoding来使用，前提是服务器支持</p>\n<h3 id=\"Etag\"><a href=\"#Etag\" class=\"headerlink\" title=\"Etag\"></a>Etag</h3><p>服务器通过<strong>Etag</strong>来标识一个资源的版本，这样便于客户判断是否资源更新</p>\n<h3 id=\"Multipart-formposts\"><a href=\"#Multipart-formposts\" class=\"headerlink\" title=\"Multipart formposts\"></a>Multipart formposts</h3><p>这对应html中form的enctype&#x3D;multiparg&#x2F;form-data,可以通过-F选项指定form:<br><code>curl -F person=anonymous -F secret=@file.txt http://example.com/submit.cgi</code><br><strong>Header内容：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">POST /submit.cgi HTTP/1.1<br>Host: example.com<br>User-Agent: curl/7.46.0<br>Accept: */*<br>Content-Length: 313<br>Expect: 100-<span class=\"hljs-built_in\">continue</span><br>Content-Type: multipart/form-data; boundary=------------------------d74496d66958873e<br></code></pre></td></tr></table></figure>\n<p><strong>Body内容：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">--------------------------d74496d66958873e<br>Content-Disposition: form-data; name=<span class=\"hljs-string\">&quot;person&quot;</span><br><br>anonymous<br>--------------------------d74496d66958873e<br>Content-Disposition: form-data; name=<span class=\"hljs-string\">&quot;secret&quot;</span>; filename=<span class=\"hljs-string\">&quot;file.txt&quot;</span><br>Content-Type: text/plain<br><br>contents of the file<br>--------------------------d74496d66958873e--<br></code></pre></td></tr></table></figure>\n<p>html的form表单中enctype默认为<code>application/x-www-form-urlencoded</code>,此时只需要-d选项即可</p>\n<h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><ul>\n<li>有时服务器不会直接返回内容，而是告诉你该资源所在位置，此时响应中包含关键字<code>Location:</code></li>\n<li>有时重定向会指向不同主机，此时用户名密码或证书等可能无法使用，无论如何信任的话，可以使用–location-trusted</li>\n<li>浏览器支持更多的重定向方式，curl不支持他们，比如html里meta元素，javascript的动态重定向</li>\n</ul>\n<h3 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h3><p>cookie设置的一个头</p>\n<h3 id=\"Upgrade\"><a href=\"#Upgrade\" class=\"headerlink\" title=\"Upgrade\"></a>Upgrade</h3><p>强制升级http版本的头，过老的服务器可能会出错</p>\n<h3 id=\"Alt-Svc\"><a href=\"#Alt-Svc\" class=\"headerlink\" title=\"Alt-Svc\"></a>Alt-Svc</h3><p>响应体中的头，告诉客户还有哪些主机可以获得同样资源,只能在https中使用，并且这是使用http3的唯一方法（截至2019）</p>\n<h3 id=\"http3\"><a href=\"#http3\" class=\"headerlink\" title=\"http3\"></a>http3</h3><p>http3是实验版本，是为了适应QUIC协议（一个基于UDP的可靠安全的协议），只能通过https,curl没有针对http3连结失败时作自动降级处理，而是直接返回错误</p>\n<h2 id=\"代理-就是web缓存服务器\"><a href=\"#代理-就是web缓存服务器\" class=\"headerlink\" title=\"代理(就是web缓存服务器)\"></a>代理(就是web缓存服务器)</h2><ul>\n<li>HTTP代理为了安全，使用<strong>CONNECT</strong>方法</li>\n<li>HTTP代理可以代理FTP,此时curl将认为就是HTTP,FTP所有特性无效</li>\n<li>MITM代理可以监控加密的流量</li>\n<li>代理认证失败，拒绝代理，会返回407</li>\n<li>HTTPS代理的默认端口为443</li>\n<li>curl中与代理相关的环境变量<ul>\n<li>[scheme]_proxy:指定某个协议的默认代理,等价于-x选项,除了http_proxy只能全部小写(CGI的原因),其他形式可以用全部大写<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">http_proxy=http://proxy.example.com:80<br>curl -v www.example.com<br></code></pre></td></tr></table></figure></li>\n<li>ALL_PROXY:所有url都走该代理</li>\n<li>NO_PROXY:某些url不走该代理，用<code>,</code>分隔多个url，等效于–noproxy</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"FTP\"><a href=\"#FTP\" class=\"headerlink\" title=\"FTP\"></a>FTP</h2><ul>\n<li>FTP协议使用两个tcp连接，一个用来建立认证，并进入到正确的文件夹内(控制连接)，一个用来传输文件，curl默认是被动连接（即客户端发送PASV或EPSV命令给服务器,服务器新开个端口，curl用该端口连接传输）,主动连接见-P，被动连接见–ftp-pasv</li>\n<li>curl传输文件时有三种方法(见–ftp-method)：</li>\n<li>FTPS的默认端口是990,可以通过<code>scheme:ftps://</code>指定，抑或使用<code>--ssl,--ssl-reqd</code></li>\n<li>FTPS无法推广的原因是，FTP的第二个连接是新建的tcp连接，防火墙和其他网络工具检查辨别是FTP传输并采取一些规则或设置应用到该连接,但如果加密，防火墙等就无法判断，并无法应用一些规则</li>\n</ul>\n<h2 id=\"URLs-URIs\"><a href=\"#URLs-URIs\" class=\"headerlink\" title=\"URLs(URIs)\"></a>URLs(URIs)</h2><p>需要注意的是现代浏览器的地址栏里支持IRIs,一个URLs的超集(更强大，支持空白字符等等)</p>\n<h3 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h3><p>scheme就是分隔符前面的内容,是协议吗？不可以包含任何空格</p>\n<ul>\n<li>分隔符:<code>://</code>curl只支持双斜杠的，有标准是单斜杠的</li>\n<li>curl会自动纠错一些scheme格式以及自动推测(通过选项–proto-default设置)</li>\n</ul>\n<h3 id=\"Name-and-password-非主流\"><a href=\"#Name-and-password-非主流\" class=\"headerlink\" title=\"Name and password(非主流)\"></a>Name and password(非主流)</h3><p>scheme及分隔符之后可能跟着用户名和密码,不过这风险很大,正慢慢淘汰,同时你也可以通过选项等方式来指定。一般格式如下：<br><code>curl ftp://user:password@example.com/</code></p>\n<h3 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h3><p>host就是主机，可以是数字地址本身或简单的域名</p>\n<ul>\n<li>ipv4:<code>curl http://127.0.0.1/</code></li>\n<li>ipv6:<code>curl http://[::1]/</code></li>\n</ul>\n<h3 id=\"port-number\"><a href=\"#port-number\" class=\"headerlink\" title=\"port number\"></a>port number</h3><p>如果端口号没指明，那么就会使用各个协议的默认端口。<br>通常在主机名后指明,用冒号和数字。为十进制数范围在[0-65535]</p>\n<ul>\n<li>ipv4:<code>curl http://example.com:8080/</code></li>\n<li>ipv6:<code>curl http://[fdea::1]:8080/</code></li>\n</ul>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>每个url包含路径,如果没指明则是根目录<code>/</code>,如下是等价的<br><code>https://example.com</code>&#x3D;&#x3D;&gt;<code>https://example.com/</code></p>\n<h3 id=\"FTP-type-FTP特有很少用的特性\"><a href=\"#FTP-type-FTP特有很少用的特性\" class=\"headerlink\" title=\"FTP type(FTP特有很少用的特性)\"></a>FTP type(FTP特有很少用的特性)</h3><p>该特性可以让你指明文件类型,指定不同的类型ftp协议相应的用不同传输,curl默认以二进制格式传递FTP协议</p>\n<ul>\n<li>A:指明传输类型为ASCII<br><code>curl &quot;ftp://example.com/foo;type=A&quot;</code></li>\n<li>I:指明传输类型为二进制<br><code>curl &quot;ftp://example.com/foo;type=I&quot;</code></li>\n<li>D:指明传输类型为目录(此时不要以斜杠结尾)<br><code>curl &quot;ftp://example.com/foo;type=D&quot;</code></li>\n</ul>\n<h3 id=\"Fragment\"><a href=\"#Fragment\" class=\"headerlink\" title=\"Fragment\"></a>Fragment</h3><p>由<code>#</code>标识</p>\n<ul>\n<li>URLs提供fragment，但curl传递时，会忽略它,(就是浏览器中的定位,跟网页屏幕位置有关)</li>\n<li>有时<code>#</code>处于路径中,为了方便你可用<code>%23</code>来代替<code>#</code><br><code>https://www.example.com/info.html#the-plot</code>&#x3D;&#x3D;&gt;<code>curl https://www.example.com/info.html%23the-plot</code></li>\n</ul>\n<h3 id=\"curl与URLs\"><a href=\"#curl与URLs\" class=\"headerlink\" title=\"curl与URLs\"></a>curl与URLs</h3><p>curl支持许多选项，不是可选项内容的都是URLs，可以支持多个URLs,从左到右一个个解析</p>\n<ul>\n<li>curl总是返回最后一个URL的错误代码(可以用–fail-early改变),</li>\n<li>curl的选项总是应用所有URLs(当然存在例外(-o、-O)),要想应用不同的URL不同的option,可以使用<code>--next、-:</code></li>\n<li>指定多个URLs,可以节省时间(如果多个URLs有相同主机，TCP将会一直保持链接)</li>\n<li>默认是串行,可以指定并行(-Z),并行时的进度条和串行时有区别，该进度条是所有当前运行的并行任务的实时情况</li>\n</ul>\n<h4 id=\"globbing\"><a href=\"#globbing\" class=\"headerlink\" title=\"globbing\"></a>globbing</h4><p>有时想传递同一主机下的一系列资源，可以用<code>&#123;&#125;</code>和<code>[]</code>来指定，处于它们之间的内容称为[globbing],并且他们可以混用，此时为防止shell的副作用，应该用引号括起来URL，</p>\n<ul>\n<li><code>[]</code><ul>\n<li><code>curl -O &quot;http://example.com/[1-100].png&quot;</code></li>\n<li><code>curl -O &quot;http://example.com/[001-100].png&quot;</code>支持前导0</li>\n<li><code>curl -O &quot;http://example.com/[001-100:2].png&quot;</code>取奇数</li>\n<li><code>curl -O &quot;http://example.com/[a-z].png&quot;</code>支持字母</li>\n</ul>\n</li>\n<li><code>&#123;&#125;</code><ul>\n<li><code>curl -O &quot;http://example.com/&#123;one,two,three,alpha,beta&#125;.html&quot;</code></li>\n</ul>\n</li>\n<li>-o选项里面可以通过<code>#[num]</code>来代表globbing内容,num从1开始编号<ul>\n<li><code>curl &quot;http://&#123;one,two&#125;.example.com&quot; -o &quot;file_#1.txt&quot;</code></li>\n<li><code>curl &quot;http://&#123;site,host&#125;.host[1-5].example.com&quot; -o &quot;subdir/#1_#2&quot;</code><br>globbing有时还可以用于-T选项，上传多个文件:<br><code>curl -T &#39;image[1-99].jpg&#39; ftp://ftp.example.com/upload/</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"curl\"><a href=\"#curl\" class=\"headerlink\" title=\"curl\"></a>curl</h2><h3 id=\"配置文件curlrc\"><a href=\"#配置文件curlrc\" class=\"headerlink\" title=\"配置文件curlrc\"></a>配置文件curlrc</h3><p>按以下优先级读取文件：</p>\n<ol>\n<li>“$CURL_HOME&#x2F;.curlrc”</li>\n<li>“$XDG_CONFIG_HOME&#x2F;.curlrc”</li>\n<li>“$HOME&#x2F;.curlrc”</li>\n</ol>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><h3 id=\"A-–user-agent\"><a href=\"#A-–user-agent\" class=\"headerlink\" title=\"-A&#x2F;–user-agent\"></a>-A&#x2F;–user-agent</h3><p>指明<code>User-Agent:</code>的值</p>\n<h3 id=\"–alt-svc-cacheFile\"><a href=\"#–alt-svc-cacheFile\" class=\"headerlink\" title=\"–alt-svc [cacheFile]\"></a>–alt-svc [cacheFile]</h3><p>会尝试cacheFile定义中的可获得同样资源的主机地址，如果server响应并更新了<code>Alt-Svc:</code>,则也会自动更新到cacheFile中。</p>\n<h3 id=\"–anyauth\"><a href=\"#–anyauth\" class=\"headerlink\" title=\"–anyauth\"></a>–anyauth</h3><p>curl首先不使用认证，如果服务器需要，curl将会尝试使用认证</p>\n<h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"-B\"></a>-B</h3><p>以二进制形式传输，curl默认就是二进制</p>\n<h3 id=\"b-cookiesFile\"><a href=\"#b-cookiesFile\" class=\"headerlink\" title=\"-b [cookiesFile]\"></a>-b [cookiesFile]</h3><p>从文件中读取cookie，-c选项是写cookie</p>\n<h3 id=\"–basic\"><a href=\"#–basic\" class=\"headerlink\" title=\"–basic\"></a>–basic</h3><p>使用Basic认证方法，默认的认证方法</p>\n<h3 id=\"c-cookieFile\"><a href=\"#c-cookieFile\" class=\"headerlink\" title=\"-c [cookieFile]\"></a>-c [cookieFile]</h3><p>写入cookie到一个文件中</p>\n<h3 id=\"C-–continue-at-num\"><a href=\"#C-–continue-at-num\" class=\"headerlink\" title=\"-C&#x2F;–continue-at [num&#x2F;-]\"></a>-C&#x2F;–continue-at [num&#x2F;-]</h3><p>指明从num byte offset开始继续下载或<code>-</code>curl根据已有的下载文件确定从哪开始继续下载。<br><strong>例1</strong>:<code>curl --continue-at 100 ftp://example.com/bigfile</code><br><strong>例2</strong>:<code>curl --continue-at - http://example.com/bigfile -O</code></p>\n<h3 id=\"–cacert-path\"><a href=\"#–cacert-path\" class=\"headerlink\" title=\"–cacert [path]\"></a>–cacert [path]</h3><p>设置CA证书路径</p>\n<h3 id=\"–cert-file-passwd\"><a href=\"#–cert-file-passwd\" class=\"headerlink\" title=\"–cert [file:passwd]\"></a>–cert [file:passwd]</h3><p>TLS指定客户端的证书文件,待学习相关知识</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl --cert mycert:mypassword https://example.com<br>curl --cert mycert:mypassword --key mykey https://example.com<br>curl --cert mycert:mypassword --cert-type PEM \\<br>     --key mykey --key-type PEM https://example.com<br></code></pre></td></tr></table></figure>\n<h3 id=\"–cert-type\"><a href=\"#–cert-type\" class=\"headerlink\" title=\"–cert-type\"></a>–cert-type</h3><p>见–cert例子</p>\n<h3 id=\"–cert-status\"><a href=\"#–cert-status\" class=\"headerlink\" title=\"–cert-status\"></a>–cert-status</h3><p>这个TLS特性为OCSP stapling,比较新，目前仅有openssl,gnutls,nss支持，一般不使用</p>\n<h3 id=\"–ciphers\"><a href=\"#–ciphers\" class=\"headerlink\" title=\"–ciphers\"></a>–ciphers</h3><p>TLS中ciphers,除非你知道你在干啥，否则慎用。</p>\n<h3 id=\"–connect-to-source-name-source-port-destination-name-destination-port\"><a href=\"#–connect-to-source-name-source-port-destination-name-destination-port\" class=\"headerlink\" title=\"–connect-to [source name:source port:destination name:destination port]\"></a>–connect-to [source name:source port:destination name:destination port]</h3><p>有时负载均衡，一个host name其实由多个服务提供，有时你只想测试其中一个服务，可以用此选项，如下：<br><code>curl --connect-to www.example.com:80:load1.example.com:80 http://www.example.com</code></p>\n<h3 id=\"–connect-timeout-num\"><a href=\"#–connect-timeout-num\" class=\"headerlink\" title=\"–connect-timeout [num]\"></a>–connect-timeout [num]</h3><p>指定tcp连接多长时间没反应算失败，单位秒，可以给出float类型数字</p>\n<h3 id=\"–compressed\"><a href=\"#–compressed\" class=\"headerlink\" title=\"–compressed\"></a>–compressed</h3><p>http&#x2F;https,请求服务器提供压缩版本的内容，curl会在数据到达后自动解压，这只是加快传输速度，注意不能和另一个–tr-encoding混用，因为两者采用不同压缩</p>\n<h3 id=\"d-–data-string-or-num\"><a href=\"#d-–data-string-or-num\" class=\"headerlink\" title=\"-d&#x2F;–data [string or num]\"></a>-d&#x2F;–data [string or num]</h3><p>发送的数据,simple POST,一下两种方式等价</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl -d <span class=\"hljs-string\">&#x27;name=admin&amp;shoesize=12&#x27;</span> http://example.com/<br>curl -d name=admin -d shoesize=12 http://example.com/<br><span class=\"hljs-comment\">#从某个文件读取</span><br>curl -d @filename http://example.com<br></code></pre></td></tr></table></figure>\n<p>从文件中读取时，会去除回车和换行，如果不想这样见–data-binary</p>\n<h3 id=\"–data-binary\"><a href=\"#–data-binary\" class=\"headerlink\" title=\"–data-binary\"></a>–data-binary</h3><p>该选项从文件读取时，不会去除回车和换行</p>\n<h3 id=\"–data-raw\"><a href=\"#–data-raw\" class=\"headerlink\" title=\"–data-raw\"></a>–data-raw</h3><p>-d选项的补充，主要是为了下面的情况:<br><code>curl --data-raw &#39;@string&#39; https://example.com</code></p>\n<h3 id=\"–data-urlencode\"><a href=\"#–data-urlencode\" class=\"headerlink\" title=\"–data-urlencode\"></a>–data-urlencode</h3><p>把post内容使用url的安全编码(即把空格和一些不安全字符使用%xx%编码)，接受以下形式(只对内容进行编码):</p>\n<ul>\n<li>content</li>\n<li>&#x3D;content</li>\n<li>name&#x3D;content</li>\n<li>@filename</li>\n<li>name@filename</li>\n</ul>\n<h3 id=\"–digest\"><a href=\"#–digest\" class=\"headerlink\" title=\"–digest\"></a>–digest</h3><p>digest的认证方式</p>\n<h3 id=\"–dns-interface\"><a href=\"#–dns-interface\" class=\"headerlink\" title=\"–dns-interface\"></a>–dns-interface</h3><p>指定dns走的网卡？</p>\n<h3 id=\"–dns-ipv4-addr\"><a href=\"#–dns-ipv4-addr\" class=\"headerlink\" title=\"–dns-ipv4-addr\"></a>–dns-ipv4-addr</h3><p>指定ipv4的dns服务器</p>\n<h3 id=\"–dns-ipv6-addr\"><a href=\"#–dns-ipv6-addr\" class=\"headerlink\" title=\"–dns-ipv6-addr\"></a>–dns-ipv6-addr</h3><p>指定ipv6的dns服务器</p>\n<h3 id=\"–dns-servers\"><a href=\"#–dns-servers\" class=\"headerlink\" title=\"–dns-servers\"></a>–dns-servers</h3><p>指定一个dns服务器</p>\n<h3 id=\"e-–referer\"><a href=\"#e-–referer\" class=\"headerlink\" title=\"-e&#x2F;–referer\"></a>-e&#x2F;–referer</h3><p>当在浏览器中，从一个页面，点击另一个页面，会形成一个<code>Referer:</code>的头，它说明是从哪个网站进去的，例如：<br><code>curl --referer http://comes-from.example.com https://www.example.com/</code></p>\n<h3 id=\"–etag-save-etagSavedFile\"><a href=\"#–etag-save-etagSavedFile\" class=\"headerlink\" title=\"–etag-save [etagSavedFile]\"></a>–etag-save [etagSavedFile]</h3><p>把该资源的Etag保存到某文件中</p>\n<h3 id=\"–etag-compare-etagFile\"><a href=\"#–etag-compare-etagFile\" class=\"headerlink\" title=\"–etag-compare [etagFile]\"></a>–etag-compare [etagFile]</h3><p>与本地文件中保存Etag做对比，只下载更新的，可以与–etag-save连用，达到自动更新的目的<br><code>curl --etag-compare etag.txt --etag-save etag.txt https://example.com/file -o output</code></p>\n<h3 id=\"f-–fail\"><a href=\"#f-–fail\" class=\"headerlink\" title=\"-f&#x2F;–fail\"></a>-f&#x2F;–fail</h3><p>一般http返回4xx码时，curl也会认为是成功的一次传输，如果启用该选项，如果是4xx，curl将以22退出</p>\n<h3 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"-F\"></a>-F</h3><p>http的方法将是POST</p>\n<h3 id=\"–fail-early\"><a href=\"#–fail-early\" class=\"headerlink\" title=\"–fail-early\"></a>–fail-early</h3><h3 id=\"–fail-with-body\"><a href=\"#–fail-with-body\" class=\"headerlink\" title=\"–fail-with-body\"></a>–fail-with-body</h3><p>同–fail</p>\n<h3 id=\"–ftp-method-multicwd-nocwd-singlecwd\"><a href=\"#–ftp-method-multicwd-nocwd-singlecwd\" class=\"headerlink\" title=\"–ftp-method [multicwd&#x2F;nocwd&#x2F;singlecwd]\"></a>–ftp-method [multicwd&#x2F;nocwd&#x2F;singlecwd]</h3><ul>\n<li>multicwd(curl默认方法)：<code>curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">CWD one &lt; 250 OK. Current directory is /one CWD two &lt; 250 OK. Current directory is /one/two CWD three &lt; 250 OK. Current directory is /one/two/three RETR file.txt<br></code></pre></td></tr></table></figure></li>\n<li>nocwd(并不符合标准):<code>curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">RETR one/two/three/file.txt<br></code></pre></td></tr></table></figure></li>\n<li>singlecwd(服务器不一定支持):<code>curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">CWD one/two/three &lt; 250 OK. Current directory is /one/two/three RETR file.txt<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"–ftp-pasv\"><a href=\"#–ftp-pasv\" class=\"headerlink\" title=\"–ftp-pasv\"></a>–ftp-pasv</h3><p>curl默认就是ftp被动连接，这个选项是重新设置为被动连接</p>\n<h3 id=\"–ftp-skip-pasv-ip\"><a href=\"#–ftp-skip-pasv-ip\" class=\"headerlink\" title=\"–ftp-skip-pasv-ip\"></a>–ftp-skip-pasv-ip</h3><p>有时服务器对于PASV被动建立连接命令会故意返回一个错的ip地址，此时该选项可以忽略该地址，使用控制连接的地址</p>\n<h3 id=\"G-–get\"><a href=\"#G-–get\" class=\"headerlink\" title=\"-G&#x2F;–get\"></a>-G&#x2F;–get</h3><p>当指定-d等选项时，默认为post方法，此选项可以强制转成get，所有数据都追加在url末尾，以<code>?</code>分割</p>\n<h3 id=\"h-–help\"><a href=\"#h-–help\" class=\"headerlink\" title=\"-h&#x2F;–help\"></a>-h&#x2F;–help</h3><h3 id=\"H-header-content\"><a href=\"#H-header-content\" class=\"headerlink\" title=\"-H [header content]\"></a>-H [header content]</h3><ul>\n<li>自定义头部内容<br><code>curl -H &quot;Host: www.example.com&quot; http://localhost/</code></li>\n<li>去除curl自动形成的头，只要不给值就行：<br><code>curl -H &quot;User-Agent:&quot; http://example.com/</code></li>\n<li>去除所有头<br><code>curl -H &quot;Empty;&quot; http://example.com</code></li>\n</ul>\n<h3 id=\"–hsts-hstsFile\"><a href=\"#–hsts-hstsFile\" class=\"headerlink\" title=\"–hsts [hstsFile]\"></a>–hsts [hstsFile]</h3><p>HSTS是一个严格的传输安全协议，它保护https不被降级和中间cookie注入，整个过程中不能使用明文。该选项使curl读入某个server的HSTS缓存,然后自动更新，并且自动转换http为https:<br><code>curl --hsts hsts.txt https://example.com</code></p>\n<h3 id=\"–http0-9\"><a href=\"#–http0-9\" class=\"headerlink\" title=\"–http0.9\"></a>–http0.9</h3><p>该版本非常不成熟，响应只有body，没有header,使用该选项是告诉curl接受该种响应</p>\n<h3 id=\"–http1-0\"><a href=\"#–http1-0\" class=\"headerlink\" title=\"–http1.0\"></a>–http1.0</h3><p>尝试使用http1.0</p>\n<h3 id=\"–http1-1\"><a href=\"#–http1-1\" class=\"headerlink\" title=\"–http1.1\"></a>–http1.1</h3><p>尝试使用http1.1</p>\n<h3 id=\"–http2\"><a href=\"#–http2\" class=\"headerlink\" title=\"–http2\"></a>–http2</h3><p>尝试使用http2</p>\n<h3 id=\"–http2-prior-knowledge\"><a href=\"#–http2-prior-knowledge\" class=\"headerlink\" title=\"–http2-prior-knowledge\"></a>–http2-prior-knowledge</h3><p>前提你确定已经知道服务器支持http2了，这个加快negotiate的速度</p>\n<h3 id=\"–http3\"><a href=\"#–http3\" class=\"headerlink\" title=\"–http3\"></a>–http3</h3><p>尝试使用http3</p>\n<h3 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"-I\"></a>-I</h3><p>HTTP方法将是HEAD</p>\n<h3 id=\"–ignore-content-length\"><a href=\"#–ignore-content-length\" class=\"headerlink\" title=\"–ignore-content-length\"></a>–ignore-content-length</h3><p>忽略头部的Content-Length信息（早期数据不可以超过2g,content-length可能是负的），直接接受数据</p>\n<h3 id=\"–interface-ip-addr-or-some-interface\"><a href=\"#–interface-ip-addr-or-some-interface\" class=\"headerlink\" title=\"–interface [ip addr or some interface]\"></a>–interface [ip addr or some interface]</h3><p>指定哪个网络接口来传输流量，或者使用哪个原始ip地址（前提你有多个ip）这个不影响dns的接口，dns接口可用–dns-interface</p>\n<h3 id=\"j-–junk-session-cookies\"><a href=\"#j-–junk-session-cookies\" class=\"headerlink\" title=\"-j&#x2F;–junk-session-cookies\"></a>-j&#x2F;–junk-session-cookies</h3><p>模拟浏览器重新打开，一个新的会话cookie<br><code>curl -j -b cookies.txt http://example.com/</code></p>\n<h3 id=\"J-–remote-header-name\"><a href=\"#J-–remote-header-name\" class=\"headerlink\" title=\"-J&#x2F;–remote-header-name\"></a>-J&#x2F;–remote-header-name</h3><p>HTTP头可能提供<code>Content-Disposition:</code>,这其中包含了建议的文件名，这个选项使用该文件名作为输出，如果该内容存在，会覆盖-O选项。</p>\n<ul>\n<li>它只会保留文件名部分，忽略目录</li>\n<li>CURL不会帮你解码，可能是个URL原码格式的文件名（浏览器会解码）</li>\n</ul>\n<h3 id=\"–json\"><a href=\"#–json\" class=\"headerlink\" title=\"–json\"></a>–json</h3><p>该选项是为了更好的post json格式的内容，等价于下面三个选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">--data [jsonformat]<br>--header <span class=\"hljs-string\">&quot;Content-Type: application/json&quot;</span><br>--header <span class=\"hljs-string\">&quot;Accept: application/json&quot;</span><br></code></pre></td></tr></table></figure>\n<p>注意多次使用该选项时，curl只是简单的字符串拼接，并不会帮你合并，所以应该像下面这样使用：<br><code>curl --json @json.txt --json &quot;, &quot;end&quot;: &quot;true&quot;&#125;&#39; https://example.com/</code></p>\n<h3 id=\"k-–insecure\"><a href=\"#k-–insecure\" class=\"headerlink\" title=\"-k&#x2F;–insecure\"></a>-k&#x2F;–insecure</h3><p>tls&#x2F;ssh协议中，curl会跳过检查known_hosts文件及本地安全证书，直接信任</p>\n<h3 id=\"K-–config\"><a href=\"#K-–config\" class=\"headerlink\" title=\"-K&#x2F;–config\"></a>-K&#x2F;–config</h3><p><code>-K &lt;fileName&gt;</code><br>此选项是为了帮助过长的选项不好输在命令行中，fileName则可以保存这些选项</p>\n<ul>\n<li>一行一个选项，长选项可以省略<code>--</code></li>\n<li>可以用<code>#</code>注释</li>\n<li>选项和参数内容间可以用<code>=</code>或<code>:</code>使结构清晰</li>\n<li>参数如果含空格，必须用双引号括起来,括号内只可以用下面这些转义字符<code>\\\\,\\&quot;,\\t,\\n,\\r,\\v</code>,如果不用双引号,则遇到第一个空格就结束读取</li>\n<li>文件内也可以指明url，必须如下格式<br><code>url = &quot;http://example.com&quot;</code></li>\n</ul>\n<h3 id=\"–keepalive-time-num\"><a href=\"#–keepalive-time-num\" class=\"headerlink\" title=\"–keepalive-time [num]\"></a>–keepalive-time [num]</h3><p>curl默认会保持无流量的tcp连接长达60s,这可以更改时间，单位为秒</p>\n<h3 id=\"–key\"><a href=\"#–key\" class=\"headerlink\" title=\"–key\"></a>–key</h3><p>指定cert健，见–cert</p>\n<h3 id=\"–key-type\"><a href=\"#–key-type\" class=\"headerlink\" title=\"–key-type\"></a>–key-type</h3><p>见–cert</p>\n<h3 id=\"l-–list-only\"><a href=\"#l-–list-only\" class=\"headerlink\" title=\"-l&#x2F;–list-only\"></a>-l&#x2F;–list-only</h3><p>FTP协议中相当与使用NLST命令，可能不会list符号链接和目录</p>\n<h3 id=\"L-–location\"><a href=\"#L-–location\" class=\"headerlink\" title=\"-L&#x2F;–location\"></a>-L&#x2F;–location</h3><p>如果返回重定向，则继续访问重定向的地址。默认最多50个。curl默认不会访问重定向的内容,</p>\n<h3 id=\"–limit-rate\"><a href=\"#–limit-rate\" class=\"headerlink\" title=\"–limit-rate \"></a>–limit-rate <num></h3><p>参数是个数字，默认单位是byte，可以跟K&#x2F;M&#x2F;G，整个过程的平均速度将不超过这个值,也同样适用于上传速率</p>\n<h3 id=\"–location-trusted\"><a href=\"#–location-trusted\" class=\"headerlink\" title=\"–location-trusted\"></a>–location-trusted</h3><p>永远信任重定向的任何主机，默认是不信任，因为，可能重定向不同主机</p>\n<h3 id=\"–local-port-num-or-range\"><a href=\"#–local-port-num-or-range\" class=\"headerlink\" title=\"–local-port [num or range]\"></a>–local-port [num or range]</h3><p>通常不需要指定本地端口，但有时只有某些端口是开放的，指定curl的本地端口，可以指定一个范围，因为一个可能被占用了,最好不要指定1024以下的端口</p>\n<h3 id=\"m-–max-time-num\"><a href=\"#m-–max-time-num\" class=\"headerlink\" title=\"-m&#x2F;–max-time [num]\"></a>-m&#x2F;–max-time [num]</h3><p>整个命令允许运行的最长时间，即使正在下载，也会立刻退出(退出码28)</p>\n<h3 id=\"–mail-from\"><a href=\"#–mail-from\" class=\"headerlink\" title=\"–mail-from\"></a>–mail-from</h3><p>smtp中指定发件人</p>\n<h3 id=\"–mail-rcpt\"><a href=\"#–mail-rcpt\" class=\"headerlink\" title=\"–mail-rcpt\"></a>–mail-rcpt</h3><p>smtp中指定收件人</p>\n<h3 id=\"–manual\"><a href=\"#–manual\" class=\"headerlink\" title=\"–manual\"></a>–manual</h3><h3 id=\"–max-filesize-num\"><a href=\"#–max-filesize-num\" class=\"headerlink\" title=\"–max-filesize [num]\"></a>–max-filesize [num]</h3><p>单位是byte，如果curl在传输开始可以获得将要下载的内容大小，该选项才会起作用，如果超过该大小，curl将会自动放弃。</p>\n<h3 id=\"–max-redirs-num\"><a href=\"#–max-redirs-num\" class=\"headerlink\" title=\"–max-redirs [num]\"></a>–max-redirs [num]</h3><p>指定最多重定向次数，默认50个</p>\n<h3 id=\"n-–netrc\"><a href=\"#n-–netrc\" class=\"headerlink\" title=\"-n&#x2F;–netrc\"></a>-n&#x2F;–netrc</h3><p>读取<code>~/.netrc</code>配置文件，该文件存储用户名密码，例子如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#以下的值都不许有空格，且可以写在一行</span><br>machine example.com <span class=\"hljs-comment\">#可以填default,此时不需要machine关键字</span><br>login nanbert<br>password xxx <br>macdef xxx <span class=\"hljs-comment\">#该选项curl不支持，会忽略</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"–negotiate\"><a href=\"#–negotiate\" class=\"headerlink\" title=\"–negotiate\"></a>–negotiate</h3><p>negotiate的认证方式</p>\n<h3 id=\"netrc-file-path\"><a href=\"#netrc-file-path\" class=\"headerlink\" title=\"-netrc-file [path]\"></a>-netrc-file [path]</h3><p>不读默认<code>~/.netrc</code>文件，而是具体某个文件</p>\n<h3 id=\"–netrc-optional\"><a href=\"#–netrc-optional\" class=\"headerlink\" title=\"–netrc-optional\"></a>–netrc-optional</h3><p>这与<code>--netrc</code>区别在于，使得默认配置内容是可选的,不是强制的</p>\n<h3 id=\"–next\"><a href=\"#–next\" class=\"headerlink\" title=\"–next\"></a>–next</h3><h3 id=\"–no-eprt\"><a href=\"#–no-eprt\" class=\"headerlink\" title=\"–no-eprt\"></a>–no-eprt</h3><p>ftp协议中禁止使用命令EPRT，该命令比PORT更新</p>\n<h3 id=\"–no-epsv\"><a href=\"#–no-epsv\" class=\"headerlink\" title=\"–no-epsv\"></a>–no-epsv</h3><p>ftp协议中进制使用命令EPSV，该命令比PASV更新</p>\n<h3 id=\"–no-keepalive\"><a href=\"#–no-keepalive\" class=\"headerlink\" title=\"–no-keepalive\"></a>–no-keepalive</h3><p>默认curl会保持tcp(无流量)连接60s,这个会关闭该功能</p>\n<h3 id=\"–noproxy\"><a href=\"#–noproxy\" class=\"headerlink\" title=\"–noproxy\"></a>–noproxy</h3><p>不使用全局环境变量代理</p>\n<h3 id=\"–no-verbose\"><a href=\"#–no-verbose\" class=\"headerlink\" title=\"–no-verbose\"></a>–no-verbose</h3><h3 id=\"–ntlm\"><a href=\"#–ntlm\" class=\"headerlink\" title=\"–ntlm\"></a>–ntlm</h3><p>ntlm的认证方式</p>\n<h3 id=\"o\"><a href=\"#o\" class=\"headerlink\" title=\"-o\"></a>-o</h3><p>输出到某个文件，一个该选项对应一个url,想要指明多个，必须声明多个-o</p>\n<h3 id=\"O-–remote-name\"><a href=\"#O-–remote-name\" class=\"headerlink\" title=\"-O&#x2F;–remote-name\"></a>-O&#x2F;–remote-name</h3><p>把结果输出到使用远程服务器的原始文件名,一个该选项对应一个url,想要指明多个，必须声明多个-O</p>\n<h3 id=\"–path-as-is\"><a href=\"#–path-as-is\" class=\"headerlink\" title=\"–path-as-is\"></a>–path-as-is</h3><p>在url指定路径时，如果出现<code>/../</code>或<code>/./</code>,curl会替换它们，再发送给服务器，比如<code>/hello/sir/../</code>变成<code>/hello/</code>,<code>/hello/./sir</code>变成<code>/hello/sir/</code>,而该选项会保留<code>..</code>和<code>.</code></p>\n<h3 id=\"P-–ftp-port-ip\"><a href=\"#P-–ftp-port-ip\" class=\"headerlink\" title=\"-P&#x2F;–ftp-port [ip&#x2F;-]\"></a>-P&#x2F;–ftp-port [ip&#x2F;-]</h3><p>这其实是使用命令PORT或EPRT，即服务器建立新连接到客户,但经常不指定一个确切的port,直接使用<code>-</code>,总是为，信息来时的地址，如下：<br><code>curl -P - ftp://example.com/foobar.txt</code></p>\n<h3 id=\"–post301\"><a href=\"#–post301\" class=\"headerlink\" title=\"–post301\"></a>–post301</h3><p>返回301重定向时，保持初始的方法</p>\n<h3 id=\"–post302\"><a href=\"#–post302\" class=\"headerlink\" title=\"–post302\"></a>–post302</h3><p>返回302重定向时，保持初始的方法</p>\n<h3 id=\"–post303\"><a href=\"#–post303\" class=\"headerlink\" title=\"–post303\"></a>–post303</h3><p>返回303重定向时，保持初始的方法</p>\n<h3 id=\"p-–proxytunnel\"><a href=\"#p-–proxytunnel\" class=\"headerlink\" title=\"-p&#x2F;–proxytunnel\"></a>-p&#x2F;–proxytunnel</h3><p>使用隧道对代理加密<br><code>curl -p -x http://proxy.example.com:80 ftp://ftp.example.com/file.txt</code></p>\n<h3 id=\"–parallel-max\"><a href=\"#–parallel-max\" class=\"headerlink\" title=\"–parallel-max\"></a>–parallel-max</h3><h3 id=\"–pinnedpubkey-sha256-hashnum1-hashnum2\"><a href=\"#–pinnedpubkey-sha256-hashnum1-hashnum2\" class=\"headerlink\" title=\"–pinnedpubkey [sha256&#x2F;&#x2F;hashnum1;hashnum2;..]\"></a>–pinnedpubkey [sha256&#x2F;&#x2F;hashnum1;hashnum2;..]</h3><p>TLS协议中，Certifiate pinning中直接指定sha256值</p>\n<h3 id=\"–proto-default\"><a href=\"#–proto-default\" class=\"headerlink\" title=\"–proto-default\"></a>–proto-default</h3><h3 id=\"–proxy1-0-ip-addr\"><a href=\"#–proxy1-0-ip-addr\" class=\"headerlink\" title=\"–proxy1.0 [ip addr]\"></a>–proxy1.0 [ip addr]</h3><p>指定代理，和<code>--x</code>一样，只是使用HTTP&#x2F;1.0</p>\n<h3 id=\"–proxy-anyauth\"><a href=\"#–proxy-anyauth\" class=\"headerlink\" title=\"–proxy-anyauth\"></a>–proxy-anyauth</h3><p>任意一种代理用户名认证方式,根据代理服务器要求自动匹配或者不使用认证</p>\n<h3 id=\"–proxy-digest\"><a href=\"#–proxy-digest\" class=\"headerlink\" title=\"–proxy-digest\"></a>–proxy-digest</h3><p>一种代理用户名认证方式</p>\n<h3 id=\"–proxy-header\"><a href=\"#–proxy-header\" class=\"headerlink\" title=\"–proxy-header\"></a>–proxy-header</h3><p>该头只发送给代理，真正的远程服务器不会收到，这比–header更精细化<br><code>curl --proxy-header &quot;User-Agent: magic/3000&quot; -x proxy https://example.com/</code></p>\n<h3 id=\"–proxy-negotiate\"><a href=\"#–proxy-negotiate\" class=\"headerlink\" title=\"–proxy-negotiate\"></a>–proxy-negotiate</h3><p>一种代理用户名认证方式</p>\n<h3 id=\"–proxy-ntlm\"><a href=\"#–proxy-ntlm\" class=\"headerlink\" title=\"–proxy-ntlm\"></a>–proxy-ntlm</h3><p>一种代理用户名认证方式</p>\n<h3 id=\"Q-–quote-ftp-cmd\"><a href=\"#Q-–quote-ftp-cmd\" class=\"headerlink\" title=\"-Q&#x2F;–quote [ftp cmd]\"></a>-Q&#x2F;–quote [ftp cmd]</h3><p>发送命令给ftp服务器</p>\n<ul>\n<li>在传输之前发送NOOP命令<code>curl -Q NOOP ftp://example.com/file</code></li>\n<li>在传输之后发送NOOP命令<code>curl -Q -NOOP ftp://example.com/file</code></li>\n<li>不知什么时候发<code>curl -Q +NOOP ftp://example.com/file</code><br>发送的命令发生错误时会导致curl退出，有时可以在命令前加<code>*</code>，忽略可能发送错误，如：<br><code>curl -Q &quot;-*DELE file&quot; ftp://example.com/moo</code></li>\n</ul>\n<h3 id=\"r-–range-num1-num2-num3-0-num3-…\"><a href=\"#r-–range-num1-num2-num3-0-num3-…\" class=\"headerlink\" title=\"-r&#x2F;–range [num1-num2,num3-,0-num3,…]\"></a>-r&#x2F;–range [num1-num2,num3-,0-num3,…]</h3><p>只下num1 byte offset至num2 byte offset的内容,服务器可以选择性的实现该功能，也就是说，即使你这么请求，服务器也可能返回全部内容</p>\n<h3 id=\"–remote-name-all\"><a href=\"#–remote-name-all\" class=\"headerlink\" title=\"–remote-name-all\"></a>–remote-name-all</h3><p>所有结果均输出保存到服务器上的原始文件名</p>\n<h3 id=\"–remote-time\"><a href=\"#–remote-time\" class=\"headerlink\" title=\"–remote-time\"></a>–remote-time</h3><p>使得下载到本地的文件的时间戳和远程服务器文件的时间戳一样，常和-z -o选项搭配<br><code>curl -z file.html -o file.html --remote-time https://example.com/file.html</code></p>\n<h3 id=\"–resolve-host-name-port-ip-address\"><a href=\"#–resolve-host-name-port-ip-address\" class=\"headerlink\" title=\"–resolve [host name:port:ip address]\"></a>–resolve [host name:port:ip address]</h3><p>dns重定向，这会保存到curl的cache中<br><code>curl --resolve example.com:80:127.0.0.1 http://example.com/</code></p>\n<h3 id=\"s-–silent\"><a href=\"#s-–silent\" class=\"headerlink\" title=\"-s&#x2F;–silent\"></a>-s&#x2F;–silent</h3><p>此选项关闭进度条，并不显示错误，但是-S&#x2F;–show-error不受此选项影响</p>\n<h3 id=\"S-–show-error\"><a href=\"#S-–show-error\" class=\"headerlink\" title=\"-S&#x2F;–show-error\"></a>-S&#x2F;–show-error</h3><p>默认情况下curl会输出错误，该选项主要是抵消-s的作用</p>\n<h3 id=\"–speed-time-num\"><a href=\"#–speed-time-num\" class=\"headerlink\" title=\"–speed-time [num]\"></a>–speed-time [num]</h3><p>经常和–speed-limit一起用,下面的意思是速度小于1000并且持续15s就退出<br><code>curl --speed-time 15 --speed-limit 1000 https://example.com/</code></p>\n<h3 id=\"–speed-limit-num\"><a href=\"#–speed-limit-num\" class=\"headerlink\" title=\"–speed-limit [num]\"></a>–speed-limit [num]</h3><p>见–speed-time</p>\n<h3 id=\"–ssl\"><a href=\"#–ssl\" class=\"headerlink\" title=\"–ssl\"></a>–ssl</h3><p>尝试ssl加密(FTP,IMAP,POP3,SMTP)</p>\n<h3 id=\"–sslv2\"><a href=\"#–sslv2\" class=\"headerlink\" title=\"–sslv2\"></a>–sslv2</h3><p>使用SSL2版本</p>\n<h3 id=\"–sslv3\"><a href=\"#–sslv3\" class=\"headerlink\" title=\"–sslv3\"></a>–sslv3</h3><p>使用SSL3版本</p>\n<h3 id=\"–ssl-reqd\"><a href=\"#–ssl-reqd\" class=\"headerlink\" title=\"–ssl-reqd\"></a>–ssl-reqd</h3><p>强制ssl加密(FTP,IMAP,POP3,SMTP)</p>\n<h3 id=\"–raw\"><a href=\"#–raw\" class=\"headerlink\" title=\"–raw\"></a>–raw</h3><p>禁用内容或传输编码的所有内部http解码，而是使用未经修改的原始数据,这经常用在curl为一个代理的情况</p>\n<h3 id=\"–retry-num\"><a href=\"#–retry-num\" class=\"headerlink\" title=\"–retry [num]\"></a>–retry [num]</h3><p>curl会在发生transient error时，会重新尝试num次，默认失败一次就不会尝试，transient error包括以下：超时，FTP 4XX返回码，http5xx返回码</p>\n<h3 id=\"–request-target\"><a href=\"#–request-target\" class=\"headerlink\" title=\"–request-target\"></a>–request-target</h3><p>获取的资源路径，这个一般直接写在url中，但这配合OPTIONS方法，有个特殊用法：<br><code>curl -X OPTIONS --request-target &quot;*&quot; http://example.com/</code><br>会形成下面的头：<br><code>OPTIONS * HTTP/1.1</code></p>\n<h3 id=\"–retry-all-errors\"><a href=\"#–retry-all-errors\" class=\"headerlink\" title=\"–retry-all-errors\"></a>–retry-all-errors</h3><p>有时你确定一个服务器是好的，出现任何错误都想重试，该选项就可以帮你</p>\n<h3 id=\"–retry-connrefused\"><a href=\"#–retry-connrefused\" class=\"headerlink\" title=\"–retry-connrefused\"></a>–retry-connrefused</h3><p>重试只会发生在transient error时，但拒绝访问不属于，有时你确认服务器只是重启或其他原因，该选项可以使得出现拒绝访问时，也可以重试。</p>\n<h3 id=\"–retry-max-time-num\"><a href=\"#–retry-max-time-num\" class=\"headerlink\" title=\"–retry-max-time [num]\"></a>–retry-max-time [num]</h3><p>第一次重试之前,curl会等1s,然后第二次重试会等2s,如此指数增长下去，直到达到10min，该选项会指明等待时间不少于num秒，–max-time选项仍会起作用</p>\n<h3 id=\"T\"><a href=\"#T\" class=\"headerlink\" title=\"-T\"></a>-T</h3><ul>\n<li>HTTP PUT就是上传某个完整资源上传或替换远程的现有资源，很少被服务器启用</li>\n<li>FTP或TFTP 上传文件，如下<br><code>curl -T uploadthis ftp://example.com/this/directory/</code><br><code>curl -T uploadthis ftp://example.com/this/directory/remotename</code></li>\n<li>SMTP上传body内容，通常需要其他选项(有关header的选项)配合（–mail-from,等）<br><code>curl -T mail smtp://mail.example.com/ --mail-from user@example.com</code></li>\n</ul>\n<h3 id=\"t-–telnet-option-keyword-value\"><a href=\"#t-–telnet-option-keyword-value\" class=\"headerlink\" title=\"-t&#x2F;–telnet-option [keyword&#x3D;value]\"></a>-t&#x2F;–telnet-option [keyword&#x3D;value]</h3><p>telnet选项特有，传递以下三个参数：</p>\n<ul>\n<li>TTYPE&#x3D;[term]:设置终端类型</li>\n<li>XDISPLOC&#x3D;[X display]:设置X展示位置</li>\n<li>NEW_ENV&#x3D;[var,val]:设置环境变量值</li>\n</ul>\n<h3 id=\"–tftp-blksize-num\"><a href=\"#–tftp-blksize-num\" class=\"headerlink\" title=\"–tftp-blksize [num]\"></a>–tftp-blksize [num]</h3><p>tftp通信传输块默认大小为512,此选项可以修改，支持8-65464</p>\n<h3 id=\"–tftp-no-options\"><a href=\"#–tftp-no-options\" class=\"headerlink\" title=\"–tftp-no-options\"></a>–tftp-no-options</h3><p>有些tftp服务器不接受任何选项，此时该选项可以应用</p>\n<h3 id=\"–tlspassword-passwd\"><a href=\"#–tlspassword-passwd\" class=\"headerlink\" title=\"–tlspassword [passwd]\"></a>–tlspassword [passwd]</h3><p>TLS的特性，可以在命令行中直接使用用户名和密码<br><code>curl --tlsuser daniel --tlspassword secret https://example.com</code></p>\n<h3 id=\"–tlsuser-name\"><a href=\"#–tlsuser-name\" class=\"headerlink\" title=\"–tlsuser [name]\"></a>–tlsuser [name]</h3><p>见–tlspassword</p>\n<h3 id=\"–tlsv1-–tlsv1-0\"><a href=\"#–tlsv1-–tlsv1-0\" class=\"headerlink\" title=\"–tlsv1&#x2F;–tlsv1.0\"></a>–tlsv1&#x2F;–tlsv1.0</h3><p>使用TLS&gt;&#x3D;1.0的版本</p>\n<h3 id=\"–tlsv1-1\"><a href=\"#–tlsv1-1\" class=\"headerlink\" title=\"–tlsv1.1\"></a>–tlsv1.1</h3><p>使用TLS&gt;&#x3D;1.0的版本</p>\n<h3 id=\"–tlsv1-2\"><a href=\"#–tlsv1-2\" class=\"headerlink\" title=\"–tlsv1.2\"></a>–tlsv1.2</h3><p>使用TLS&gt;&#x3D;1.2的版本</p>\n<h3 id=\"–tlsv1-3\"><a href=\"#–tlsv1-3\" class=\"headerlink\" title=\"–tlsv1.3\"></a>–tlsv1.3</h3><p>使用TLS&gt;&#x3D;1.3的版本,curl默认</p>\n<h3 id=\"–tr-encoding\"><a href=\"#–tr-encoding\" class=\"headerlink\" title=\"–tr-encoding\"></a>–tr-encoding</h3><p>采用Transfer-Encoded压缩传输内容，curl会自动解压,不能和–compressed混用,且该选项不常用</p>\n<h3 id=\"–trace-filename\"><a href=\"#–trace-filename\" class=\"headerlink\" title=\"–trace [filename]\"></a>–trace [filename]</h3><p>会跟踪每拍接受的内容，以16进制显示,每行开头的十六进制加冒号代表该内容的byte offset</p>\n<h3 id=\"–trace-ascii-filename\"><a href=\"#–trace-ascii-filename\" class=\"headerlink\" title=\"–trace-ascii [filename]\"></a>–trace-ascii [filename]</h3><p>会跟踪每拍接受的内容，以ascii码可读形式显示</p>\n<h3 id=\"–trace-time\"><a href=\"#–trace-time\" class=\"headerlink\" title=\"–trace-time\"></a>–trace-time</h3><p>化学选项：-v&#x2F;–verbose,–trace和–trace-ascii<br>这个选项会帮助化学选项所输出内容之前加高精度的时间。</p>\n<h3 id=\"u-–user\"><a href=\"#u-–user\" class=\"headerlink\" title=\"-u&#x2F;–user\"></a>-u&#x2F;–user</h3><p>指定用户名和密码，冒号分隔<code>user:passwd</code>,这种明文，最好不用，协议层方面使用https和ftps等，如果非要使用明文,可以选择选项<code>--digest</code>,<code>--negotiate</code>,<code>--ntlm</code>,或者直接通过配置文件###1禁用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl --digest --user daniel:secret http://example.com/<br>curl --negotiate --user daniel:secret http://example.com/<br>curl --ntlm --user daniel:secret http://example.com/<br></code></pre></td></tr></table></figure>\n<h3 id=\"U-–proxy-user-user-passwd\"><a href=\"#U-–proxy-user-user-passwd\" class=\"headerlink\" title=\"-U&#x2F;–proxy-user [user:passwd]\"></a>-U&#x2F;–proxy-user [user:passwd]</h3><p>指定代理的用户名和密码<br><code>curl -U daniel:secr3t -x myproxy:80 http://example.com</code></p>\n<h3 id=\"–upload-file\"><a href=\"#–upload-file\" class=\"headerlink\" title=\"–upload-file\"></a>–upload-file</h3><p>指定上传内容文件，用于smtp</p>\n<h3 id=\"–use-ascii\"><a href=\"#–use-ascii\" class=\"headerlink\" title=\"–use-ascii\"></a>–use-ascii</h3><p>使用ascii传输，而不是二进制</p>\n<h3 id=\"v-–verbose\"><a href=\"#v-–verbose\" class=\"headerlink\" title=\"-v&#x2F;–verbose\"></a>-v&#x2F;–verbose</h3><p>该选项会使curl显示更多的内容，具体格式如下：</p>\n<ul>\n<li><code>*</code>后面跟解释性内容</li>\n<li><code>&gt;</code>后面跟客户端发送的头协议，（FTP,SMTP,POP3等没有头协议的，命令和返回当成头）</li>\n<li><code>&lt;</code>后面跟从服务端接受的返回头协议<br>HTTP&#x2F;2和HTTP&#x2F;3协议头是压缩的，但在此选项下会展开和HTTP&#x2F;1.1一样的格式</li>\n</ul>\n<h3 id=\"V-–version\"><a href=\"#V-–version\" class=\"headerlink\" title=\"-V&#x2F;–version\"></a>-V&#x2F;–version</h3><p>会输出版本相关的信息，各行含义如下:<br>**第一行:**版本号+平台+第三方依赖信息<br>**第二行:**版本发布日期<br>**第三行:**支持的协议<br>**第四行:**支持的特性</p>\n<h3 id=\"w-–write-out\"><a href=\"#w-–write-out\" class=\"headerlink\" title=\"-w&#x2F;–write-out\"></a>-w&#x2F;–write-out</h3><p>参数:<code>&lt;formatted string&gt;</code>或<code>@[filename或-]</code><br>该选项会在每个传输完毕后，在末尾加上formatted string或文件中的内容,%可以使用<code>\\n,\\r,\\t</code>转义字符，特殊的变量跟在<code>%</code>后,<code>%%</code>输出真正的%<br>有以下formatted string:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">格式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>%&#123;content_type&#125;</code></td>\n<td align=\"center\">字面义，有的内容没有类型</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;errormsg&#125;</code></td>\n<td align=\"center\">字面义，无错误为空</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;exitcode&#125;</code></td>\n<td align=\"center\">传输的退出码，无错返回0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;filename_effective&#125;</code></td>\n<td align=\"center\">最终传输内容所保存的文件名，只当指定-o或–remote-name选项有意义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;ftp_entry_path&#125;</code></td>\n<td align=\"center\">登陆ftp的初始路径</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;http_code&#125;</code></td>\n<td align=\"center\">也就是response_code</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;http_connect&#125;</code></td>\n<td align=\"center\">待探索</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;http_version&#125;</code></td>\n<td align=\"center\">字面义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;json&#125;</code></td>\n<td align=\"center\">所有write-out的变量生成json格式</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;local_ip&#125;</code></td>\n<td align=\"center\">最近一次连接的ipv4或ipv6的本地地址</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;local_port&#125;</code></td>\n<td align=\"center\">最近一次连接的本地端口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;method&#125;</code></td>\n<td align=\"center\">最近请求的方法</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;num_connects&#125;</code></td>\n<td align=\"center\">最近传输的新连接数量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;num_headers&#125;</code></td>\n<td align=\"center\">上一次传输的反应头的数量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;num_redirects&#125;</code></td>\n<td align=\"center\">请求的重定向次数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;onerror&#125;</code></td>\n<td align=\"center\">如果传输发生错误，输出之后的string,内容，否则不输出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;proxy_ssl_verify_result&#125;</code></td>\n<td align=\"center\">与代理通信时请求的SSL对等证书验证的结果,0表示成功</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;redirect_url&#125;</code></td>\n<td align=\"center\">当发出HTTP请求而没有-L重定向时，重定向会将您带到的实际URL</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;remote_ip&#125;</code></td>\n<td align=\"center\">远程的ipv4或6地址</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;remote_port&#125;</code></td>\n<td align=\"center\">远程的端口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;response_code&#125;</code></td>\n<td align=\"center\">字面义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;scheme&#125;</code></td>\n<td align=\"center\">url的scheme</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_download&#125;</code></td>\n<td align=\"center\">字面义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_header&#125;</code></td>\n<td align=\"center\">头部的大小</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_request&#125;</code></td>\n<td align=\"center\">请求的大小</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;size_upload&#125;</code></td>\n<td align=\"center\">上传大小</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;speed_download&#125;</code></td>\n<td align=\"center\">平均下载速度</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;speed_upload&#125;</code></td>\n<td align=\"center\">平均上传速度</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;ssl_verify_result&#125;</code></td>\n<td align=\"center\">请求SSL对等证书验证的结果，0表示成功</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;stderr&#125;</code></td>\n<td align=\"center\">接下来的内容输出到标准错误</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;stdout&#125;</code></td>\n<td align=\"center\">接下来的内容输出到标准输出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_appconnect&#125;</code></td>\n<td align=\"center\">从开始到完成SSL&#x2F;SSH&#x2F;etc到远程主机的连接&#x2F;握手花费的时间，单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_connect&#125;</code></td>\n<td align=\"center\">从一开始直到TCP连接到远程主机（或代理）完成花费的时间，单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_namelookup&#125;</code></td>\n<td align=\"center\">从一开始直到名字解析完成所花费的时间,单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_pretransfer&#125;</code></td>\n<td align=\"center\">从一开始直到文件传输即将开始所花费的时间，单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_redirect&#125;</code></td>\n<td align=\"center\">所有重定向步骤，包括名称查找，连接，预传输和最终事务开始之前的传输所花费的时间,单位秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_starttransfer&#125;</code></td>\n<td align=\"center\">从一凯斯直到第一个字节即将被传输，这包括time_pretransfer和服务器计算结果所需的时间</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;time_total&#125;</code></td>\n<td align=\"center\">完整操作持续的总时间，时间为秒，精度达到毫秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;url&#125;</code></td>\n<td align=\"center\">命令行中指定url</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;url_effective&#125;</code></td>\n<td align=\"center\">真实有效的url</td>\n</tr>\n<tr>\n<td align=\"center\"><code>%&#123;urlnum&#125;</code></td>\n<td align=\"center\">url的编号，从0开始计数</td>\n</tr>\n</tbody></table>\n<h3 id=\"X-–request\"><a href=\"#X-–request\" class=\"headerlink\" title=\"-X&#x2F;–request\"></a>-X&#x2F;–request</h3><p>指定http的方法，一般curl会根据选项自动判断，无需特地指定该选项，错误的方法可能使得curl行为怪异</p>\n<h3 id=\"x-–proxy-ip-addr\"><a href=\"#x-–proxy-ip-addr\" class=\"headerlink\" title=\"-x&#x2F;–proxy [ip addr]\"></a>-x&#x2F;–proxy [ip addr]</h3><ul>\n<li>指定代理，默认scheme为http,默认端口为1080<br><code>curl -x 192.168.0.1:8080 http://example.com/</code></li>\n<li>指定SOCKS协议代理，这可以直接使用各个版本，而不用-x，说明如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#SOCKS4版本</span><br>curl -x socks4://proxy.example.com http://www.example.com/<br>curl --socks4 proxy.example.com http://www.example.com/<br><span class=\"hljs-comment\">#SOCKS4a版本</span><br>curl -x socks4a://proxy.example.com http://www.example.com/<br>curl --socks4a proxy.example.com http://www.example.com/<br><span class=\"hljs-comment\">#SOCKS5版本</span><br>curl -x socks5://proxy.example.com http://www.example.com/<br>curl --socks5 proxy.example.com http://www.example.com/<br><span class=\"hljs-comment\">#SOCKS5h版本</span><br>curl -x socks5h://proxy.example.com http://www.example.com/<br>curl --socks5-ostname proxy.example.com http://www.example.com/<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"–xattr\"><a href=\"#–xattr\" class=\"headerlink\" title=\"–xattr\"></a>–xattr</h3><h3 id=\"Z-–parallel\"><a href=\"#Z-–parallel\" class=\"headerlink\" title=\"-Z&#x2F;–parallel\"></a>-Z&#x2F;–parallel</h3><h3 id=\"z-–time-cond-time-stamp-file\"><a href=\"#z-–time-cond-time-stamp-file\" class=\"headerlink\" title=\"-z&#x2F;–time-cond [time stamp&#x2F;file]\"></a>-z&#x2F;–time-cond [time stamp&#x2F;file]</h3><p>对下载的内容做时间限制(可早，可晚)，时间格式可以是常见的格式，或者指定比某个本地文件新</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl -z <span class=\"hljs-string\">&quot;Jan 10, 2017&quot;</span> https://example.com/file -O<span class=\"hljs-comment\">#只下载比该时间戳新的</span><br>curl --time-cond <span class=\"hljs-string\">&quot;Sun, 12 Sep 2004 15:05:58 -0700&quot;</span> https://www.example.org/file.html<span class=\"hljs-comment\">#只下载比该时间早的</span><br>curl -z file.html https://example.com/file.html -O<span class=\"hljs-comment\">#比file.html新的</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"-:\"></a>-:</h3><h3 id=\"–progress-bar\"><a href=\"#–progress-bar\" class=\"headerlink\" title=\"-#&#x2F;–progress-bar\"></a>-#&#x2F;–progress-bar</h3><p>当内容重定向时，进度条是默认打开的,该选项会展示一种简单的进度条，有时进度条无法估计时间</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"@作用\"></a>@作用</h3><p>传参数可以把参数放到文件里，如下:<br><code>curl -d @json http://example.com</code></p>\n<h2 id=\"curl退出码\"><a href=\"#curl退出码\" class=\"headerlink\" title=\"curl退出码\"></a>curl退出码</h2><ul>\n<li>1：不支持的协议</li>\n<li>2：初始化失败，libcurl可能出了问题</li>\n<li>3：url格式不对</li>\n<li>4：某个请求需要某个特性或选项未能满足</li>\n<li>5：无法解析代理</li>\n<li>6：无法解析主机</li>\n<li>7：无法连接主机。可能端口，主机名或防火墙的问题</li>\n<li>8：未知的ftp服务返回。可能未支持，也可能未启用选项</li>\n<li>9：ftp拒绝访问。没该文件或用户名或没权限</li>\n<li>10：ftp接受失败。</li>\n<li>11：ftp奇怪的PASS回复</li>\n<li>12：在等待服务器连接的活动FTP会话期间，超过限期</li>\n<li>13：FTP PASV命令未知的反应。通过–ftp-port选项可能解决该问题</li>\n<li>14：未知FTP227格式。这肯定是个坏服务器，或者可以通过–ftp-port解决该问题</li>\n<li>15：FTP无法获得主机</li>\n<li>16：HTTP&#x2F;2 error</li>\n<li>17：FTP无法设置binary传输。坏的服务器</li>\n<li>18：只传输了部分文件</li>\n<li>19：FTP无法获得下载该文件。RETR命令失败</li>\n<li>20：（保留）</li>\n<li>21：引用错误。IMAP、POP3、SMTP、FTP发送自定义命令时出错，建议查看报头</li>\n<li>22：HTTP页面未抓取。对应400反应码以上的错误，出现该错误只能在-f选项启用的时候</li>\n<li>23：写错误。写到本地时发生的错误</li>\n<li>24：（保留）</li>\n<li>25：上传失败。服务器空间已满或拒绝上传</li>\n<li>26：读错误。从本地读取时发生错误</li>\n<li>27：内存不够。系统分配给curl内存不足</li>\n<li>28：操作超时。由各种选项设置的各种超时</li>\n<li>29：（保留）</li>\n<li>30：FTP PORT命令错误。PORT命令有点非主流，可以试试PASV</li>\n<li>31：FTP无法使用REST。可以在没有范围或恢复的情况下重试</li>\n<li>32：（保留）</li>\n<li>33：HTTP范围错误</li>\n<li>34：HTTP post错误,需要反馈BUG</li>\n<li>35：TLS&#x2F;SSL连接错误</li>\n<li>36：无法恢复下载。FILE,FTP,SFTP会发生此错误</li>\n<li>37：无法读取该文件。FILE协议，可能不存在或没权限</li>\n<li>38：绑定LDAP失败。可能用户密码错误</li>\n<li>39：LDAP搜索失败。</li>\n<li>40：（保留）</li>\n<li>41：（保留）</li>\n<li>42：回调错误。开发者编程的错误</li>\n<li>43：错误函数参数。libcurl的调用问题</li>\n<li>44：（保留）</li>\n<li>45：网络接口错误</li>\n<li>46：（保留）</li>\n<li>47：太多重定向。默认最多50个，可以通过–max-redirs改变</li>\n<li>48：libcurl未知选项。可能curl和libcurl版本不一</li>\n<li>49：telnet错误的选项</li>\n<li>50：（保留）</li>\n<li>51：SSL&#x2F;TLS、SSH认证失败</li>\n<li>52：服务器未返回任何内容。可能是服务器有意为之</li>\n<li>53：未发现SSL引擎</li>\n<li>54：无法设置SSL加密引擎为默认</li>\n<li>55：无法发送网络数据。网络底层的错误，需要Wireshark等工具查看</li>\n<li>56：无法接受网络数据。网络底层错误。</li>\n<li>57：（保留）</li>\n<li>58：本地认证有问题。</li>\n<li>59：无法使用ssl密码。密码有格式标准</li>\n<li>60：对等证书无法使用已知ca认证</li>\n<li>61：无法识别传输编码</li>\n<li>62：无效LDAP URL</li>\n<li>63：超过最大文件大小限制</li>\n<li>64：FTP SSL失败</li>\n<li>65：发送之前帧失败</li>\n<li>66：初始化SSL引擎失败</li>\n<li>67：用户名密码CURL无法登陆</li>\n<li>68：TFTP服务没有该文件</li>\n<li>69：TFTP服务权限问题</li>\n<li>70：TFTP服务没有空间</li>\n<li>71：非法TFTP操作</li>\n<li>72：未知TFTP传输id</li>\n<li>73：TFTP文件已存在</li>\n<li>74：TFTP没有该用户</li>\n<li>75：字符转换失败</li>\n<li>76：需要字符转换函数</li>\n<li>77：读SSL CA认证时发生问题</li>\n<li>78：URL中的资源不存在</li>\n<li>79：在SSH会话中发生错误</li>\n<li>80：关闭SSL连接失败</li>\n<li>81：（保留）</li>\n<li>82：无法下载CRL文件，错误格式</li>\n<li>83：TLS认证检查失败</li>\n<li>84：FTP PRET命令失败</li>\n<li>85：RTSP:CSeq数字不匹配</li>\n<li>86：RTSP:会话标识符不匹配</li>\n<li>87：无法解析ftp文件列表</li>\n<li>88：FTP 块回掉错误</li>\n<li>89：没有可用的连接，会话将排队</li>\n<li>90：SSL公钥不匹配固定公钥</li>\n<li>91：无效SSL认证状态</li>\n<li>92：HTTP&#x2F;2流错误</li>\n<li>93：API回调错误</li>\n<li>94：认证错误</li>\n<li>95：HTTP&#x2F;3错误</li>\n<li>96：QUIC连接错误</li>\n</ul>\n<h2 id=\"curl与浏览器的区别\"><a href=\"#curl与浏览器的区别\" class=\"headerlink\" title=\"curl与浏览器的区别\"></a>curl与浏览器的区别</h2><ul>\n<li>浏览器会对接受的数据进行二次解码,更易懂些，curl就直接解码</li>\n<li>有的服务器会根据不同客户端(甚至不同的浏览器)提供更适配的内容</li>\n<li>你可以使用f12然后选中network,右键点击你想要的资源，选中<code>copy cURL</code>就可以复制相应的命令</li>\n</ul>\n<h2 id=\"POP3-curl读邮件使用的协议\"><a href=\"#POP3-curl读邮件使用的协议\" class=\"headerlink\" title=\"POP3(curl读邮件使用的协议)\"></a>POP3(curl读邮件使用的协议)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#To list message numbers and sizes:</span><br>curl pop3://mail.example.com/<br><span class=\"hljs-comment\">#To download message 1:</span><br>curl pop3://mail.example.com/1<br><span class=\"hljs-comment\">#To delete message 1:</span><br>curl --request DELE pop3://mail.example.com/1<br></code></pre></td></tr></table></figure>\n<p><strong>TLS加密</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl pop3://mail.example.com/ --ssl-reqd<br>curl pop3s://mail.example.com/<br></code></pre></td></tr></table></figure>\n<h2 id=\"IMAP-curl读邮件使用的协议，更常用现代\"><a href=\"#IMAP-curl读邮件使用的协议，更常用现代\" class=\"headerlink\" title=\"IMAP(curl读邮件使用的协议，更常用现代)\"></a>IMAP(curl读邮件使用的协议，更常用现代)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#Get the mail using the UID 57 from mailbox &#x27;stuff&#x27;:</span><br>curl imap://server.example.com/stuff;UID=57<br><span class=\"hljs-comment\">#get the mail with index 57 from the mailbox &#x27;fun&#x27;</span><br>curl imap://server.example.com/fun;MAILINDEX=57<br><span class=\"hljs-comment\">#List the mails in the mailbox &#x27;boring&#x27;:</span><br>curl imap://server.example.com/boring<br><span class=\"hljs-comment\">#List the mails in the mailbox &#x27;boring&#x27; and provide user and password:</span><br>curl imap://server.example.com/boring -u user:password<br></code></pre></td></tr></table></figure>\n<p><strong>TLS加密</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl --ssl imap://mail.example.com/inbox<br>curl imaps://mail.example.com/inbox<br></code></pre></td></tr></table></figure>\n<h2 id=\"SMTP-cURL写邮件使用的协议\"><a href=\"#SMTP-cURL写邮件使用的协议\" class=\"headerlink\" title=\"SMTP(cURL写邮件使用的协议)\"></a>SMTP(cURL写邮件使用的协议)</h2><p>必须指定收发邮箱，以及内容,默认端口587</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl smtp://mail.example.com --mail-from myself@example.com --mail-rcpt \\<br>receiver@example.com --upload-file email.txt<br></code></pre></td></tr></table></figure>\n<p>email.txt:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">From: John Smith &lt;john@example.com&gt;<br>To: Joe Smith &lt;smith@example.com&gt;<br>Subject: an example.com example email<br>Date: Mon, 7 Nov 2016 08:45:16<br><br>Dear Joe,<br>Welcome to this example email. What a lovely day.<br></code></pre></td></tr></table></figure>\n<p>和POP3、IMAP一样，可以使用SSL&#x2F;TLS加密，schema改成smtps即可，或者使用–ssl或–ssl-reqd,此时默认端口为465</p>\n<h2 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h2><p>订阅推送的协议，不太懂</p>\n<h2 id=\"TFTP\"><a href=\"#TFTP\" class=\"headerlink\" title=\"TFTP\"></a>TFTP</h2><p>小文件传输协议，使用的是UDP</p>\n<ul>\n<li>下载<code>curl -O tftp://localserver/file.boot</code></li>\n<li>上传<code>curl -T file.boot tftp://localserver/</code></li>\n</ul>\n<h2 id=\"TELNET\"><a href=\"#TELNET\" class=\"headerlink\" title=\"TELNET\"></a>TELNET</h2><p>即时通信协议，默认端口23</p>\n<h2 id=\"DICT\"><a href=\"#DICT\" class=\"headerlink\" title=\"DICT\"></a>DICT</h2><p>字典查询的协议<br>alias:</p>\n<ul>\n<li>m:match和find</li>\n<li>d:define和lookup<br>例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl dict://dict.org/m:curl<br>curl dict://dict.org/d:heisenbug:jargon<br>curl dict://dict.org/d:daniel:gcide<br>curl dict://dict.org/find:curl<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"TLS-SSL\"><a href=\"#TLS-SSL\" class=\"headerlink\" title=\"TLS&#x2F;SSL\"></a>TLS&#x2F;SSL</h2><p>TLS是建立于TCP上一层的安全加密层，SSL是旧称(且所有ssl版本都在淘汰中)，两个是一个概念。<br>各个版本协议都有TLS版本：</p>\n<ul>\n<li>HTTP-HTTPS</li>\n<li>LDAP-LDAPS</li>\n<li>FTP-FTPS</li>\n<li>POP3-POP3S</li>\n<li>IMAP-IMAPS</li>\n<li>SMTP-SMTPS<br>TLS属于third-party,你可以通过–version查看，如果你feature中有MultiSSL的特性，证明curl是支持多版本的，你可以通过<code>CURL_SSL_BACKEND</code>来设置使用那个版二</li>\n</ul>\n<h3 id=\"版本历史\"><a href=\"#版本历史\" class=\"headerlink\" title=\"版本历史\"></a>版本历史</h3><p>SSL2(1995)-&gt;SSL3-&gt;TLS1.0(1999)-&gt;TLS1.1(2006)-&gt;TLS1.2(2008)-&gt;TLS1.3(2018)</p>\n<h3 id=\"CA的存储\"><a href=\"#CA的存储\" class=\"headerlink\" title=\"CA的存储\"></a>CA的存储</h3><p>一般都是内建的，但你也可以用–cacert指定路径（一定要是PEM格式），或者设置CURL-CA_BUNDLE环境变量</p>\n<h2 id=\"wget\"><a href=\"#wget\" class=\"headerlink\" title=\"wget\"></a>wget</h2><ul>\n<li><img src=\"https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/wget.html\"></li>\n</ul>\n"},{"title":"docker","date":"2022-04-03T19:51:08.000Z","subtitle":null,"index_img":"/images/docker.png","banner_img":"/images/docker.png","_content":"## 各个文件位置\n- 本地资源的默认总目录：`/var/lib/docker/`,**迁移**docker就是复制该文件夹，**重置**就是删除该文件夹\n- 容器信息：`containers`\n- 镜像信息：`image`\n- 镜像层文件：`overlay2`\n### 修改文件位置\n- 方式1：为默认位置建立软链接\n- 方式2：daemon启动时指定-g选项\n- 方式3：修改/etc/docker/daemon.json的\"data-root\"项\n## 镜像加速\n- 查看是否在docker.service文件中配置过镜像地址：`$ systemctl cat docker | grep '\\-\\-registry\\-mirror'`\n- 上一步如果出现输出内容，修改文件去掉内容`--registry-mirror`，按接下来步骤配置\n- 在/etc/docker/daemon.json中写入下面内容：\n```bash\n{\n  \"registry-mirrors\": [\n    \"https://hub-mirror.c.163.com\",\n    \"https://mirror.baidubce.com\"\n  ]\n}\n```\n- 重启服务：`sudo systemctl daemon-reload;sudo systemctl restart docker`\n- 检查是否生效：`docker info`\n## 镜像\n### 拉取镜像\n- 格式:`docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]`\n- 默认地址是`docker.io`,仓库名默认为`library`,即官方镜像，标签默认是`latest`\n- 简化版：`docker pull ubuntu`\n### 列出镜像\n- 一般命令：`docker image ls`\n\n|选项|含义|举例|\n|:-:|:-:|:-:|\n|-a|显示包括中间层镜像在内的所有镜像||\n|-f/--fliter|过滤参数,见下||\n|--format|自定义格式，见|`docker image ls --format \"{{.ID}}: {{.Repository}}\"`|\n\n#### -f选项\n- since/before: `docker image ls -f since=mongo:3.2`,列出mongo:3.2之后建立的镜像\n- label: `docker image ls -f label=com.example.version=0.1`\n#### `<none>`虚悬镜像\n- 原因：docker pull或docker build导致镜像名被转移到最新版\n- 只列出虚悬镜像：`docker image ls -f dangling=true`\n- 删除虚悬镜像：`docker image prune`\n### 删除镜像\n- 格式：`docker image rm [选项] <镜像1> [<镜像2> ...]`,镜像可以是长/短id,镜像名或镜像摘要\n#### untagged和deleted\n镜像对应多个tag,，只有所有tag都为untagged时，才真正删除，如果一个容器依赖一个镜像，要先删除容器，才能再删除镜像\n### docker commit-添加一层形成新的镜像（慎用）\n- 说明：该命令会使一个容器形成一个新的镜像,最好不要这样，而是使用Dockerfile\n- 格式：`docker commit [选项] <容器ID或容器名> [仓库名:标签]`\n\n|选项|含义|\n|:-:|:-:|\n|--author|说明作者|\n|--message|添加说明信息|\n#### docker history\n- 说明：该命令用来查看某个镜像的提交历史\n- 示例：`docker history [仓库名:标签]`\n\n\n## 容器\n### 容器运行流程\n1) 检查本地是否存在指定的镜像，不存在就从registry下载\n2) 利用镜像创建并启动一个容器\n3) 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层\n4) 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去\n5) 从地址池配置一个ip地址给容器\n6) 执行用户指定的应用程序\n7) 执行完毕后容器被终止\n### 运行容器`docker run`\n- **格式：**`docker run [OPTIONS] image`\n\n|选项|含义|\n|:-:|:-:|\n|-c/--cpu-shares|调整容器使用cpu的权重|\n|-d|后台运行，此时容器不会把输出的结果打印到宿主机上面，`docker container logs <container id or name>`可以查看结果|\n|--dns=[ip_address]|设置dns服务器|\n|--dns-search=[DOMAIN]|设定容器搜索域|\n|--env [VAR=value]|传递环境变量|\n|--env-file [file]|从file中引入环境变量|\n|-h/--hostname=[HOSTNAME]|设定容器主机名，比较鸡肋，只能在容器内部显示|\n|-i|交互式操作,让容器的标准输入保持打开|\n|-m|--memory[=MEMORY]|调整使用内存大小|\n|--mount|挂载数据卷或主机目录|\n|--name [name]|指定容器的名字|\n|--network [my-net]|见连接容器|\n|-p|见端口映射|\n|-P|随机映射镜像的端口|\n|--rm|容器退出后随之将其删除|\n|-t|代表终端，让Docker分配一个伪终端并邦到标准输入|\n|-u=[username]|设置进程用户名|\n|-v [宿主机路径]:[容器路径]|映射路径|\n|--volumes-from|从别的容器中挂载卷|\n\n### 查看容器的信息--docker container ls\n- **格式：**`docker container ls`\n- -a:列出终止状态的容器\n### 终止容器--docker container stop\n- **格式：**`docker container stop [container id or names]`\n### 启动已终止容器--docker container start\n- **格式：**`docker container start [container id or names]`\n### 重启容器--docker container restart\n- **格式：**`docker container restart [container id or names]`\n### 查看容器的日志--docker container logs\n- **格式：**`docker container logs [container ID or NAMES]`\n### 进入后台运行的容器--docker attach/exec\n- 建议使用exec,使用attach,从stdin退出，会导致容器的停止，exec就没这个问题\n- attach格式：`docker attach [id or names]`\n#### docker exec\n- **格式：**`docker exec -it [id or names]`\n- -it选项和docker run一样\n### 导出、导入容器--docker export/import\n- 导出容器：`docker export [id] > xx.tar`\n- 导入容器快照成镜像：`cat xx.tar | docker import - test/ubuntu:v1.0`,支持url:`$ docker import http://example.com/exampleimage.tgz example/imagerepo`\n- docker load和docker import:docker import会丢弃所有历史记录和元数据信息，docker load则会保留完整记录\n### 删除容器--docker container rm\n- **格式：**`docker container rm [container id or names]`\n- -f:删除一个运行中的容器\n## 仓库\n### Docker Hub\n- 注册：在官网https://hub.docker.com免费注册一个Docker帐号\n- 登录：`docker login`命令交互式输入用户名和密码\n- 搜索：`docker search [关键字]`支持`--filter=stars=N`仅显示收藏数量N以上的镜像\n- 拉取：见镜像拉取\n- 推送：推送前先标记下`dockeer tag [image:tag] [username/xx:xx]`，`docker push username/xx:xx`\n### 私有仓库-->docker-registry\n- 使用官方registry镜像：`$ docker run -d -p 5000:5000 --restart=always --name registry registry`\n- 默认情况下仓库会在容器中的`/var/lib/registry`目录下,可以用-v选项映射\n- 标记镜像`git tag`:`docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]`\n- 推送：`docker push 127.0.0.1:5000/ubuntu:latest`\n- 拉取：`docker pull 127.0.0.1:5000/ubuntu:latest`\n- 取消非https限制：默认情况下docker不允许非https方式推送，对于使用systemd的系统，可以在/etc/docker/daemon.json中写入如下内容：\n```bash\n{\n  \"registry-mirror\": [\n    \"https://hub-mirror.c.163.com\",\n    \"https://mirror.baidubce.com\"\n  ],\n  \"insecure-registries\": [\n    \"192.168.199.100:5000\"\n  ]\n}\n```\n- 私有仓库删除镜像可能不会回收空间，可以使用Nexus3.x软件搭配\n## 数据管理\n### 数据卷\n- 特性\n  - 数据卷可以在容器之间共享和重用\n  - 对数据卷的修改会立马生效\n  - 对数据卷的更新，不会影响镜像\n  - 数据卷会默认一直存在，即使容器被删除\n- 创建一个数据卷：`docker volume create my-vol`\n- 查看数据卷：`docker volume ls`\n- 查看指定数据卷信息：`docker volume inspect my-vol`\n- 挂载数据卷\n```bash\ndocker run -d -P \\\n    --name web \\\n    # -v my-vol:/usr/share/nginx/html \\\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n```\n- 删除数据卷：`docker volume rm my-vol`\n### 挂载主机目录为数据卷\n```bash\n# 可以不加readonly,那样权限就是读写\ndocker run -d -P \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html:ro \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\\n    nginx:alpine\n```\n可以挂载指定文件，把上面source和target换成文件即可\n## 网络\n### 端口映射\n使用-p选项\n- 映射所有接口地址：`-p hostPort:containerPort`\n- 映射到指定地址的指定端口：`-p ip:hostPort:containerPort`\n- 映射到指定地址的任意端口：`-p ip::containerPort`\n- 标记udp: `-p xxport:xxport/udp`\n- 查看容器的端口映射：`docker port [id or name] [containerPort]`\n### 容器互联(两个容器)\n如果大于两个容器的互联建议使用Docker Compose\n- 新建网络：`docker network create -d bridge my-net`,-d选项有bridge和overlay(见swarm mode)\n- 连接容器：`$ docker run -it --rm --name busybox1 --network my-net busybox sh`,`$ docker run -it --rm --name busybox1 --network my-net busybox2 sh`\n- 在各个容器中ping：`ping busybox2`\n### DNS配置\n容器的DNS设置跟随宿主主机，默认使用主机上的/etc/resolv.conf(--dns-search --dns会改变默认设置),如果配置全部容器的DNS可以在`/etc/docker/daemon.json`增加以下内容设置：\n```bash\n{\n  \"dns\" : [\n    \"114.114.114.114\",\n    \"8.8.8.8\"\n  ]\n}\n```\n## docker命令汇总\n### 客户端选项\n- --config=\"\"：指定客户端配置文件，默认为 ~/.docker；\n- -D=true|false：是否使用 debug 模式。默认不开启；\n- -H, --host=[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 unix:///path/to/socket，文件句柄 fd://socketfd 或 tcp 套接字 tcp://[host[:port]]，默认为 unix:///var/run/docker.sock；\n- -l, --log-level=\"debug|info|warn|error|fatal\"：指定日志输出级别；\n- --tls=true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；\n- --tlscacert=/.docker/ca.pem：TLS CA 签名的可信证书文件路径；\n- --tlscert=/.docker/cert.pem：TLS 可信证书文件路径；\n- --tlscert=/.docker/key.pem：TLS 密钥文件路径；\n- --tlsverify=true|false：启用 TLS 校验，默认为否。\n### 客户端命令\n- attach：依附到一个正在运行的容器中；\n- build：从一个 Dockerfile 创建一个镜像；\n- commit：从一个容器的修改中创建一个新的镜像；\n- cp：在容器和本地宿主系统之间复制文件中；\n- create：创建一个新容器，但并不运行它；\n- diff：检查一个容器内文件系统的修改，包括修改和增加；\n- events：从服务端获取实时的事件；\n- exec：在运行的容器内执行命令；\n- export：导出容器内容为一个 tar 包；\n- history：显示一个镜像的历史信息；\n- images：列出存在的镜像；\n- import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；\n- info：显示一些相关的系统信息；\n- inspect：显示一个容器的具体配置信息；\n- kill：关闭一个运行中的容器 (包括进程和所有相关资源)；\n- load：从一个 tar 包中加载一个镜像；\n- login：注册或登录到一个 Docker 的仓库服务器；\n- logout：从 Docker 的仓库服务器登出；\n- logs：获取容器的 log 信息；\n- network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；\n- node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；\n- pause：暂停一个容器中的所有进程；\n- port：查找一个 nat 到一个私有网口的公共口；\n- ps：列出主机上的容器；\n- pull：从一个Docker的仓库服务器下拉一个镜像或仓库；\n- push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；\n- rename：重命名一个容器；\n- restart：重启一个运行中的容器；\n- rm：删除给定的若干个容器；\n- rmi：删除给定的若干个镜像；\n- run：创建一个新容器，并在其中运行给定命令；\n- save：保存一个镜像为 tar 包文件；\n- search：在 Docker index 中搜索一个镜像；\n- service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；\n- start：启动一个容器；\n- stats：输出（一个或多个）容器的资源使用统计信息；\n- stop：终止一个运行中的容器；\n- swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；\n- tag：为一个镜像打标签；\n- top：查看一个容器中的正在运行的进程信息；\n- unpause：将一个容器内所有的进程从暂停状态中恢复；\n- update：更新指定的若干容器的配置信息；\n- version：输出 Docker 的版本信息；\n- volume：管理 Docker volume，包括查看、创建、删除等；\n- wait：阻塞直到一个容器终止，然后输出它的退出符。\n### 服务端命令选项\n- --api-cors-header=\"\"：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 `*`；\n- --authorization-plugin=\"\"：载入认证的插件；\n- -b=\"\"：将容器挂载到一个已存在的网桥上。指定为 none 时则禁用容器的网络，与 --bip 选项互斥；\n- --bip=\"\"：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；\n- --cgroup-parent=\"\"：指定 cgroup 的父组，默认 fs cgroup 驱动为 /docker，systemd cgroup 驱动为 system.slice；\n- --cluster-store=\"\"：构成集群（如 Swarm）时，集群键值数据库服务地址；\n- --cluster-advertise=\"\"：构成集群时，自身的被访问地址，可以为 host:port 或 interface:port；\n- --cluster-store-opt=\"\"：构成集群时，键值数据库的配置选项；\n- --config-file=\"/etc/docker/daemon.json\"：daemon 配置文件路径；\n- --containerd=\"\"：containerd 文件的路径；\n- -D, --debug=true|false：是否使用 Debug 模式。缺省为 false；\n- --default-gateway=\"\"：容器的 IPv4 网关地址，必须在网桥的子网段内；\n- --default-gateway-v6=\"\"：容器的 IPv6 网关地址；\n- --default-ulimit=[]：默认的 ulimit 值；\n- --disable-legacy-registry=true|false：是否允许访问旧版本的镜像仓库服务器；\n- --dns=\"\"：指定容器使用的 DNS 服务器地址；\n- --dns-opt=\"\"：DNS 选项；\n- --dns-search=[]：DNS 搜索域；\n- --exec-opt=[]：运行时的执行选项；\n- --exec-root=\"\"：容器执行状态文件的根路径，默认为 /var/run/docker；\n- --fixed-cidr=\"\"：限定分配 IPv4 地址范围；\n- --fixed-cidr-v6=\"\"：限定分配 IPv6 地址范围；\n- -G, --group=\"\"：分配给 unix 套接字的组，默认为 docker；\n- -g, --graph=\"\"：Docker 运行时的根路径，默认为 /var/lib/docker；\n- -H, --host=[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 unix:///path/to/socket，文件句柄 fd://socketfd 或 tcp 套接字 tcp://[host[:port]]，默认为 unix:///var/run/docker.sock；\n- --icc=true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。\n- --insecure-registry=[]：允许访问给定的非安全仓库服务；\n- --ip=\"\"：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；\n- --ip-forward=true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；\n- --ip-masq=true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；\n- --iptables=true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；\n- --ipv6=true|false：是否启用 IPv6 支持，默认关闭；\n- -l, --log-level=\"debug|info|warn|error|fatal\"：指定日志输出级别；\n- --label=\"[]\"：添加指定的键值对标注；\n- --log-driver=\"json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none\"：指定日志后端驱动，默认为 json-file；\n- --log-opt=[]：日志后端的选项；\n- --mtu=VALUE：指定容器网络的 mtu；\n- -p=\"\"：指定 daemon 的 PID 文件路径。缺省为 /var/run/docker.pid；\n- --raw-logs：输出原始，未加色彩的日志信息；\n- --registry-mirror=<scheme>://<host>：指定 docker pull 时使用的注册服务器镜像地址；\n- -s, --storage-driver=\"\"：指定使用给定的存储后端；\n- --selinux-enabled=true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；\n- --storage-opt=[]：驱动后端选项；\n- --tls=true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；\n- --tlscacert=/.docker/ca.pem：TLS CA 签名的可信证书文件路径；\n- --tlscert=/.docker/cert.pem：TLS 可信证书文件路径；\n- --tlscert=/.docker/key.pem：TLS 密钥文件路径；\n- --tlsverify=true|false：启用 TLS 校验，默认为否；\n- --userland-proxy=true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；\n- --userns-remap=default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。\n## 调试docker\n- 开启debug模式：在/etc/docker/daemon.json中添加：\n```bash\n{\n\t\"debug\":true\t\n}\n```\n- 重启守护进程`sudo kill -SIGHUP $(pidof dockerd)`\n- 检查内核日志`sudo dmesg | grep dockerd`,`sudo dmesg|grep runc`\n- 不响应时，杀死进程查看堆栈：`sudo kill -SIGUSR1 $(pidof dockerd)`\n## 高级网络\n## 集群--Swarm mod\n## Docker Buildx-->未来docker build\n## 常用命令及问题\n- `docker system df`查看镜像、容器、数据卷所占用空间\n- `docker image prune`批量清理临时镜像\n- `docker container prune`删除所有终止状态的容器\n- `docker volume prune`删除无主的数据卷\n- `docker run [image] env`查看镜像支持的环境变量\n- `docker stop $(docker container ls -q)`停止所有正在运行的容器\n- `docker inspect --format '{{ .State.Pid }}' <CONTAINER ID or NAME>`获取某个容器的PID信息\n- `docker inspect --format '{{ .NetworkSettings.IPAddress }}' <CONTAINER ID or NAME>`获取某个容器的ip地址\n- 给容器指定一个固定ip地址\n```bash\ndocker network create -d bridge --subnet 172.25.0.0/16 my-net\ndocker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox\n```\n- 退出一个交互的终端而不终止，按`ctrl-p ctrl-q`\n- Error:No public port 80 published for xxx\n  - 创建镜像时 Dockerfile 要通过 EXPOSE 指定正确的开放端口；\n  - 容器启动时指定 PublishAllPort = true。\n- WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.\n  这是因为系统默认没有开启对内存和swap使用的统计功能，该功能会降低性能，可以通过以下方式开启：\n  - 编辑`/etc/default/grub`配置`GRUB_CMDLINE_LINUX=\"cgroup_enable=memory swapaccount=1\"`\n  - 更新grub:`sudo update-grub`\n  - 重启\n","source":"_posts/docker.md","raw":"---\ntitle: docker\ndate: 2022-04-04 03:51:08\nsubtitle:\ncategories:\ntags:\nindex_img: /images/docker.png\nbanner_img: /images/docker.png\n---\n## 各个文件位置\n- 本地资源的默认总目录：`/var/lib/docker/`,**迁移**docker就是复制该文件夹，**重置**就是删除该文件夹\n- 容器信息：`containers`\n- 镜像信息：`image`\n- 镜像层文件：`overlay2`\n### 修改文件位置\n- 方式1：为默认位置建立软链接\n- 方式2：daemon启动时指定-g选项\n- 方式3：修改/etc/docker/daemon.json的\"data-root\"项\n## 镜像加速\n- 查看是否在docker.service文件中配置过镜像地址：`$ systemctl cat docker | grep '\\-\\-registry\\-mirror'`\n- 上一步如果出现输出内容，修改文件去掉内容`--registry-mirror`，按接下来步骤配置\n- 在/etc/docker/daemon.json中写入下面内容：\n```bash\n{\n  \"registry-mirrors\": [\n    \"https://hub-mirror.c.163.com\",\n    \"https://mirror.baidubce.com\"\n  ]\n}\n```\n- 重启服务：`sudo systemctl daemon-reload;sudo systemctl restart docker`\n- 检查是否生效：`docker info`\n## 镜像\n### 拉取镜像\n- 格式:`docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]`\n- 默认地址是`docker.io`,仓库名默认为`library`,即官方镜像，标签默认是`latest`\n- 简化版：`docker pull ubuntu`\n### 列出镜像\n- 一般命令：`docker image ls`\n\n|选项|含义|举例|\n|:-:|:-:|:-:|\n|-a|显示包括中间层镜像在内的所有镜像||\n|-f/--fliter|过滤参数,见下||\n|--format|自定义格式，见|`docker image ls --format \"{{.ID}}: {{.Repository}}\"`|\n\n#### -f选项\n- since/before: `docker image ls -f since=mongo:3.2`,列出mongo:3.2之后建立的镜像\n- label: `docker image ls -f label=com.example.version=0.1`\n#### `<none>`虚悬镜像\n- 原因：docker pull或docker build导致镜像名被转移到最新版\n- 只列出虚悬镜像：`docker image ls -f dangling=true`\n- 删除虚悬镜像：`docker image prune`\n### 删除镜像\n- 格式：`docker image rm [选项] <镜像1> [<镜像2> ...]`,镜像可以是长/短id,镜像名或镜像摘要\n#### untagged和deleted\n镜像对应多个tag,，只有所有tag都为untagged时，才真正删除，如果一个容器依赖一个镜像，要先删除容器，才能再删除镜像\n### docker commit-添加一层形成新的镜像（慎用）\n- 说明：该命令会使一个容器形成一个新的镜像,最好不要这样，而是使用Dockerfile\n- 格式：`docker commit [选项] <容器ID或容器名> [仓库名:标签]`\n\n|选项|含义|\n|:-:|:-:|\n|--author|说明作者|\n|--message|添加说明信息|\n#### docker history\n- 说明：该命令用来查看某个镜像的提交历史\n- 示例：`docker history [仓库名:标签]`\n\n\n## 容器\n### 容器运行流程\n1) 检查本地是否存在指定的镜像，不存在就从registry下载\n2) 利用镜像创建并启动一个容器\n3) 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层\n4) 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去\n5) 从地址池配置一个ip地址给容器\n6) 执行用户指定的应用程序\n7) 执行完毕后容器被终止\n### 运行容器`docker run`\n- **格式：**`docker run [OPTIONS] image`\n\n|选项|含义|\n|:-:|:-:|\n|-c/--cpu-shares|调整容器使用cpu的权重|\n|-d|后台运行，此时容器不会把输出的结果打印到宿主机上面，`docker container logs <container id or name>`可以查看结果|\n|--dns=[ip_address]|设置dns服务器|\n|--dns-search=[DOMAIN]|设定容器搜索域|\n|--env [VAR=value]|传递环境变量|\n|--env-file [file]|从file中引入环境变量|\n|-h/--hostname=[HOSTNAME]|设定容器主机名，比较鸡肋，只能在容器内部显示|\n|-i|交互式操作,让容器的标准输入保持打开|\n|-m|--memory[=MEMORY]|调整使用内存大小|\n|--mount|挂载数据卷或主机目录|\n|--name [name]|指定容器的名字|\n|--network [my-net]|见连接容器|\n|-p|见端口映射|\n|-P|随机映射镜像的端口|\n|--rm|容器退出后随之将其删除|\n|-t|代表终端，让Docker分配一个伪终端并邦到标准输入|\n|-u=[username]|设置进程用户名|\n|-v [宿主机路径]:[容器路径]|映射路径|\n|--volumes-from|从别的容器中挂载卷|\n\n### 查看容器的信息--docker container ls\n- **格式：**`docker container ls`\n- -a:列出终止状态的容器\n### 终止容器--docker container stop\n- **格式：**`docker container stop [container id or names]`\n### 启动已终止容器--docker container start\n- **格式：**`docker container start [container id or names]`\n### 重启容器--docker container restart\n- **格式：**`docker container restart [container id or names]`\n### 查看容器的日志--docker container logs\n- **格式：**`docker container logs [container ID or NAMES]`\n### 进入后台运行的容器--docker attach/exec\n- 建议使用exec,使用attach,从stdin退出，会导致容器的停止，exec就没这个问题\n- attach格式：`docker attach [id or names]`\n#### docker exec\n- **格式：**`docker exec -it [id or names]`\n- -it选项和docker run一样\n### 导出、导入容器--docker export/import\n- 导出容器：`docker export [id] > xx.tar`\n- 导入容器快照成镜像：`cat xx.tar | docker import - test/ubuntu:v1.0`,支持url:`$ docker import http://example.com/exampleimage.tgz example/imagerepo`\n- docker load和docker import:docker import会丢弃所有历史记录和元数据信息，docker load则会保留完整记录\n### 删除容器--docker container rm\n- **格式：**`docker container rm [container id or names]`\n- -f:删除一个运行中的容器\n## 仓库\n### Docker Hub\n- 注册：在官网https://hub.docker.com免费注册一个Docker帐号\n- 登录：`docker login`命令交互式输入用户名和密码\n- 搜索：`docker search [关键字]`支持`--filter=stars=N`仅显示收藏数量N以上的镜像\n- 拉取：见镜像拉取\n- 推送：推送前先标记下`dockeer tag [image:tag] [username/xx:xx]`，`docker push username/xx:xx`\n### 私有仓库-->docker-registry\n- 使用官方registry镜像：`$ docker run -d -p 5000:5000 --restart=always --name registry registry`\n- 默认情况下仓库会在容器中的`/var/lib/registry`目录下,可以用-v选项映射\n- 标记镜像`git tag`:`docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]`\n- 推送：`docker push 127.0.0.1:5000/ubuntu:latest`\n- 拉取：`docker pull 127.0.0.1:5000/ubuntu:latest`\n- 取消非https限制：默认情况下docker不允许非https方式推送，对于使用systemd的系统，可以在/etc/docker/daemon.json中写入如下内容：\n```bash\n{\n  \"registry-mirror\": [\n    \"https://hub-mirror.c.163.com\",\n    \"https://mirror.baidubce.com\"\n  ],\n  \"insecure-registries\": [\n    \"192.168.199.100:5000\"\n  ]\n}\n```\n- 私有仓库删除镜像可能不会回收空间，可以使用Nexus3.x软件搭配\n## 数据管理\n### 数据卷\n- 特性\n  - 数据卷可以在容器之间共享和重用\n  - 对数据卷的修改会立马生效\n  - 对数据卷的更新，不会影响镜像\n  - 数据卷会默认一直存在，即使容器被删除\n- 创建一个数据卷：`docker volume create my-vol`\n- 查看数据卷：`docker volume ls`\n- 查看指定数据卷信息：`docker volume inspect my-vol`\n- 挂载数据卷\n```bash\ndocker run -d -P \\\n    --name web \\\n    # -v my-vol:/usr/share/nginx/html \\\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n```\n- 删除数据卷：`docker volume rm my-vol`\n### 挂载主机目录为数据卷\n```bash\n# 可以不加readonly,那样权限就是读写\ndocker run -d -P \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html:ro \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\\n    nginx:alpine\n```\n可以挂载指定文件，把上面source和target换成文件即可\n## 网络\n### 端口映射\n使用-p选项\n- 映射所有接口地址：`-p hostPort:containerPort`\n- 映射到指定地址的指定端口：`-p ip:hostPort:containerPort`\n- 映射到指定地址的任意端口：`-p ip::containerPort`\n- 标记udp: `-p xxport:xxport/udp`\n- 查看容器的端口映射：`docker port [id or name] [containerPort]`\n### 容器互联(两个容器)\n如果大于两个容器的互联建议使用Docker Compose\n- 新建网络：`docker network create -d bridge my-net`,-d选项有bridge和overlay(见swarm mode)\n- 连接容器：`$ docker run -it --rm --name busybox1 --network my-net busybox sh`,`$ docker run -it --rm --name busybox1 --network my-net busybox2 sh`\n- 在各个容器中ping：`ping busybox2`\n### DNS配置\n容器的DNS设置跟随宿主主机，默认使用主机上的/etc/resolv.conf(--dns-search --dns会改变默认设置),如果配置全部容器的DNS可以在`/etc/docker/daemon.json`增加以下内容设置：\n```bash\n{\n  \"dns\" : [\n    \"114.114.114.114\",\n    \"8.8.8.8\"\n  ]\n}\n```\n## docker命令汇总\n### 客户端选项\n- --config=\"\"：指定客户端配置文件，默认为 ~/.docker；\n- -D=true|false：是否使用 debug 模式。默认不开启；\n- -H, --host=[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 unix:///path/to/socket，文件句柄 fd://socketfd 或 tcp 套接字 tcp://[host[:port]]，默认为 unix:///var/run/docker.sock；\n- -l, --log-level=\"debug|info|warn|error|fatal\"：指定日志输出级别；\n- --tls=true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；\n- --tlscacert=/.docker/ca.pem：TLS CA 签名的可信证书文件路径；\n- --tlscert=/.docker/cert.pem：TLS 可信证书文件路径；\n- --tlscert=/.docker/key.pem：TLS 密钥文件路径；\n- --tlsverify=true|false：启用 TLS 校验，默认为否。\n### 客户端命令\n- attach：依附到一个正在运行的容器中；\n- build：从一个 Dockerfile 创建一个镜像；\n- commit：从一个容器的修改中创建一个新的镜像；\n- cp：在容器和本地宿主系统之间复制文件中；\n- create：创建一个新容器，但并不运行它；\n- diff：检查一个容器内文件系统的修改，包括修改和增加；\n- events：从服务端获取实时的事件；\n- exec：在运行的容器内执行命令；\n- export：导出容器内容为一个 tar 包；\n- history：显示一个镜像的历史信息；\n- images：列出存在的镜像；\n- import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；\n- info：显示一些相关的系统信息；\n- inspect：显示一个容器的具体配置信息；\n- kill：关闭一个运行中的容器 (包括进程和所有相关资源)；\n- load：从一个 tar 包中加载一个镜像；\n- login：注册或登录到一个 Docker 的仓库服务器；\n- logout：从 Docker 的仓库服务器登出；\n- logs：获取容器的 log 信息；\n- network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；\n- node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；\n- pause：暂停一个容器中的所有进程；\n- port：查找一个 nat 到一个私有网口的公共口；\n- ps：列出主机上的容器；\n- pull：从一个Docker的仓库服务器下拉一个镜像或仓库；\n- push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；\n- rename：重命名一个容器；\n- restart：重启一个运行中的容器；\n- rm：删除给定的若干个容器；\n- rmi：删除给定的若干个镜像；\n- run：创建一个新容器，并在其中运行给定命令；\n- save：保存一个镜像为 tar 包文件；\n- search：在 Docker index 中搜索一个镜像；\n- service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；\n- start：启动一个容器；\n- stats：输出（一个或多个）容器的资源使用统计信息；\n- stop：终止一个运行中的容器；\n- swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；\n- tag：为一个镜像打标签；\n- top：查看一个容器中的正在运行的进程信息；\n- unpause：将一个容器内所有的进程从暂停状态中恢复；\n- update：更新指定的若干容器的配置信息；\n- version：输出 Docker 的版本信息；\n- volume：管理 Docker volume，包括查看、创建、删除等；\n- wait：阻塞直到一个容器终止，然后输出它的退出符。\n### 服务端命令选项\n- --api-cors-header=\"\"：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 `*`；\n- --authorization-plugin=\"\"：载入认证的插件；\n- -b=\"\"：将容器挂载到一个已存在的网桥上。指定为 none 时则禁用容器的网络，与 --bip 选项互斥；\n- --bip=\"\"：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；\n- --cgroup-parent=\"\"：指定 cgroup 的父组，默认 fs cgroup 驱动为 /docker，systemd cgroup 驱动为 system.slice；\n- --cluster-store=\"\"：构成集群（如 Swarm）时，集群键值数据库服务地址；\n- --cluster-advertise=\"\"：构成集群时，自身的被访问地址，可以为 host:port 或 interface:port；\n- --cluster-store-opt=\"\"：构成集群时，键值数据库的配置选项；\n- --config-file=\"/etc/docker/daemon.json\"：daemon 配置文件路径；\n- --containerd=\"\"：containerd 文件的路径；\n- -D, --debug=true|false：是否使用 Debug 模式。缺省为 false；\n- --default-gateway=\"\"：容器的 IPv4 网关地址，必须在网桥的子网段内；\n- --default-gateway-v6=\"\"：容器的 IPv6 网关地址；\n- --default-ulimit=[]：默认的 ulimit 值；\n- --disable-legacy-registry=true|false：是否允许访问旧版本的镜像仓库服务器；\n- --dns=\"\"：指定容器使用的 DNS 服务器地址；\n- --dns-opt=\"\"：DNS 选项；\n- --dns-search=[]：DNS 搜索域；\n- --exec-opt=[]：运行时的执行选项；\n- --exec-root=\"\"：容器执行状态文件的根路径，默认为 /var/run/docker；\n- --fixed-cidr=\"\"：限定分配 IPv4 地址范围；\n- --fixed-cidr-v6=\"\"：限定分配 IPv6 地址范围；\n- -G, --group=\"\"：分配给 unix 套接字的组，默认为 docker；\n- -g, --graph=\"\"：Docker 运行时的根路径，默认为 /var/lib/docker；\n- -H, --host=[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 unix:///path/to/socket，文件句柄 fd://socketfd 或 tcp 套接字 tcp://[host[:port]]，默认为 unix:///var/run/docker.sock；\n- --icc=true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。\n- --insecure-registry=[]：允许访问给定的非安全仓库服务；\n- --ip=\"\"：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；\n- --ip-forward=true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；\n- --ip-masq=true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；\n- --iptables=true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；\n- --ipv6=true|false：是否启用 IPv6 支持，默认关闭；\n- -l, --log-level=\"debug|info|warn|error|fatal\"：指定日志输出级别；\n- --label=\"[]\"：添加指定的键值对标注；\n- --log-driver=\"json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none\"：指定日志后端驱动，默认为 json-file；\n- --log-opt=[]：日志后端的选项；\n- --mtu=VALUE：指定容器网络的 mtu；\n- -p=\"\"：指定 daemon 的 PID 文件路径。缺省为 /var/run/docker.pid；\n- --raw-logs：输出原始，未加色彩的日志信息；\n- --registry-mirror=<scheme>://<host>：指定 docker pull 时使用的注册服务器镜像地址；\n- -s, --storage-driver=\"\"：指定使用给定的存储后端；\n- --selinux-enabled=true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；\n- --storage-opt=[]：驱动后端选项；\n- --tls=true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；\n- --tlscacert=/.docker/ca.pem：TLS CA 签名的可信证书文件路径；\n- --tlscert=/.docker/cert.pem：TLS 可信证书文件路径；\n- --tlscert=/.docker/key.pem：TLS 密钥文件路径；\n- --tlsverify=true|false：启用 TLS 校验，默认为否；\n- --userland-proxy=true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；\n- --userns-remap=default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。\n## 调试docker\n- 开启debug模式：在/etc/docker/daemon.json中添加：\n```bash\n{\n\t\"debug\":true\t\n}\n```\n- 重启守护进程`sudo kill -SIGHUP $(pidof dockerd)`\n- 检查内核日志`sudo dmesg | grep dockerd`,`sudo dmesg|grep runc`\n- 不响应时，杀死进程查看堆栈：`sudo kill -SIGUSR1 $(pidof dockerd)`\n## 高级网络\n## 集群--Swarm mod\n## Docker Buildx-->未来docker build\n## 常用命令及问题\n- `docker system df`查看镜像、容器、数据卷所占用空间\n- `docker image prune`批量清理临时镜像\n- `docker container prune`删除所有终止状态的容器\n- `docker volume prune`删除无主的数据卷\n- `docker run [image] env`查看镜像支持的环境变量\n- `docker stop $(docker container ls -q)`停止所有正在运行的容器\n- `docker inspect --format '{{ .State.Pid }}' <CONTAINER ID or NAME>`获取某个容器的PID信息\n- `docker inspect --format '{{ .NetworkSettings.IPAddress }}' <CONTAINER ID or NAME>`获取某个容器的ip地址\n- 给容器指定一个固定ip地址\n```bash\ndocker network create -d bridge --subnet 172.25.0.0/16 my-net\ndocker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox\n```\n- 退出一个交互的终端而不终止，按`ctrl-p ctrl-q`\n- Error:No public port 80 published for xxx\n  - 创建镜像时 Dockerfile 要通过 EXPOSE 指定正确的开放端口；\n  - 容器启动时指定 PublishAllPort = true。\n- WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.\n  这是因为系统默认没有开启对内存和swap使用的统计功能，该功能会降低性能，可以通过以下方式开启：\n  - 编辑`/etc/default/grub`配置`GRUB_CMDLINE_LINUX=\"cgroup_enable=memory swapaccount=1\"`\n  - 更新grub:`sudo update-grub`\n  - 重启\n","slug":"docker","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi71000ugwq2g65c4jos","content":"<h2 id=\"各个文件位置\"><a href=\"#各个文件位置\" class=\"headerlink\" title=\"各个文件位置\"></a>各个文件位置</h2><ul>\n<li>本地资源的默认总目录：<code>/var/lib/docker/</code>,<strong>迁移</strong>docker就是复制该文件夹，<strong>重置</strong>就是删除该文件夹</li>\n<li>容器信息：<code>containers</code></li>\n<li>镜像信息：<code>image</code></li>\n<li>镜像层文件：<code>overlay2</code></li>\n</ul>\n<h3 id=\"修改文件位置\"><a href=\"#修改文件位置\" class=\"headerlink\" title=\"修改文件位置\"></a>修改文件位置</h3><ul>\n<li>方式1：为默认位置建立软链接</li>\n<li>方式2：daemon启动时指定-g选项</li>\n<li>方式3：修改&#x2F;etc&#x2F;docker&#x2F;daemon.json的”data-root”项</li>\n</ul>\n<h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><ul>\n<li>查看是否在docker.service文件中配置过镜像地址：<code>$ systemctl cat docker | grep &#39;\\-\\-registry\\-mirror&#39;</code></li>\n<li>上一步如果出现输出内容，修改文件去掉内容<code>--registry-mirror</code>，按接下来步骤配置</li>\n<li>在&#x2F;etc&#x2F;docker&#x2F;daemon.json中写入下面内容：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;registry-mirrors&quot;</span>: [<br>    <span class=\"hljs-string\">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class=\"hljs-string\">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>重启服务：<code>sudo systemctl daemon-reload;sudo systemctl restart docker</code></li>\n<li>检查是否生效：<code>docker info</code></li>\n</ul>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><h3 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h3><ul>\n<li>格式:<code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></li>\n<li>默认地址是<code>docker.io</code>,仓库名默认为<code>library</code>,即官方镜像，标签默认是<code>latest</code></li>\n<li>简化版：<code>docker pull ubuntu</code></li>\n</ul>\n<h3 id=\"列出镜像\"><a href=\"#列出镜像\" class=\"headerlink\" title=\"列出镜像\"></a>列出镜像</h3><ul>\n<li>一般命令：<code>docker image ls</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">显示包括中间层镜像在内的所有镜像</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-f&#x2F;–fliter</td>\n<td align=\"center\">过滤参数,见下</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">–format</td>\n<td align=\"center\">自定义格式，见</td>\n<td align=\"center\"><code>docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"f选项\"><a href=\"#f选项\" class=\"headerlink\" title=\"-f选项\"></a>-f选项</h4><ul>\n<li>since&#x2F;before: <code>docker image ls -f since=mongo:3.2</code>,列出mongo:3.2之后建立的镜像</li>\n<li>label: <code>docker image ls -f label=com.example.version=0.1</code></li>\n</ul>\n<h4 id=\"虚悬镜像\"><a href=\"#虚悬镜像\" class=\"headerlink\" title=\"&lt;none&gt;虚悬镜像\"></a><code>&lt;none&gt;</code>虚悬镜像</h4><ul>\n<li>原因：docker pull或docker build导致镜像名被转移到最新版</li>\n<li>只列出虚悬镜像：<code>docker image ls -f dangling=true</code></li>\n<li>删除虚悬镜像：<code>docker image prune</code></li>\n</ul>\n<h3 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h3><ul>\n<li>格式：<code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code>,镜像可以是长&#x2F;短id,镜像名或镜像摘要</li>\n</ul>\n<h4 id=\"untagged和deleted\"><a href=\"#untagged和deleted\" class=\"headerlink\" title=\"untagged和deleted\"></a>untagged和deleted</h4><p>镜像对应多个tag,，只有所有tag都为untagged时，才真正删除，如果一个容器依赖一个镜像，要先删除容器，才能再删除镜像</p>\n<h3 id=\"docker-commit-添加一层形成新的镜像（慎用）\"><a href=\"#docker-commit-添加一层形成新的镜像（慎用）\" class=\"headerlink\" title=\"docker commit-添加一层形成新的镜像（慎用）\"></a>docker commit-添加一层形成新的镜像（慎用）</h3><ul>\n<li>说明：该命令会使一个容器形成一个新的镜像,最好不要这样，而是使用Dockerfile</li>\n<li>格式：<code>docker commit [选项] &lt;容器ID或容器名&gt; [仓库名:标签]</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–author</td>\n<td align=\"center\">说明作者</td>\n</tr>\n<tr>\n<td align=\"center\">–message</td>\n<td align=\"center\">添加说明信息</td>\n</tr>\n</tbody></table>\n<h4 id=\"docker-history\"><a href=\"#docker-history\" class=\"headerlink\" title=\"docker history\"></a>docker history</h4><ul>\n<li>说明：该命令用来查看某个镜像的提交历史</li>\n<li>示例：<code>docker history [仓库名:标签]</code></li>\n</ul>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h3 id=\"容器运行流程\"><a href=\"#容器运行流程\" class=\"headerlink\" title=\"容器运行流程\"></a>容器运行流程</h3><ol>\n<li>检查本地是否存在指定的镜像，不存在就从registry下载</li>\n<li>利用镜像创建并启动一个容器</li>\n<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>\n<li>从地址池配置一个ip地址给容器</li>\n<li>执行用户指定的应用程序</li>\n<li>执行完毕后容器被终止</li>\n</ol>\n<h3 id=\"运行容器docker-run\"><a href=\"#运行容器docker-run\" class=\"headerlink\" title=\"运行容器docker run\"></a>运行容器<code>docker run</code></h3><ul>\n<li><strong>格式：</strong><code>docker run [OPTIONS] image</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c&#x2F;–cpu-shares</td>\n<td align=\"center\">调整容器使用cpu的权重</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">后台运行，此时容器不会把输出的结果打印到宿主机上面，<code>docker container logs &lt;container id or name&gt;</code>可以查看结果</td>\n</tr>\n<tr>\n<td align=\"center\">–dns&#x3D;[ip_address]</td>\n<td align=\"center\">设置dns服务器</td>\n</tr>\n<tr>\n<td align=\"center\">–dns-search&#x3D;[DOMAIN]</td>\n<td align=\"center\">设定容器搜索域</td>\n</tr>\n<tr>\n<td align=\"center\">–env [VAR&#x3D;value]</td>\n<td align=\"center\">传递环境变量</td>\n</tr>\n<tr>\n<td align=\"center\">–env-file [file]</td>\n<td align=\"center\">从file中引入环境变量</td>\n</tr>\n<tr>\n<td align=\"center\">-h&#x2F;–hostname&#x3D;[HOSTNAME]</td>\n<td align=\"center\">设定容器主机名，比较鸡肋，只能在容器内部显示</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">交互式操作,让容器的标准输入保持打开</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">–memory[&#x3D;MEMORY]</td>\n</tr>\n<tr>\n<td align=\"center\">–mount</td>\n<td align=\"center\">挂载数据卷或主机目录</td>\n</tr>\n<tr>\n<td align=\"center\">–name [name]</td>\n<td align=\"center\">指定容器的名字</td>\n</tr>\n<tr>\n<td align=\"center\">–network [my-net]</td>\n<td align=\"center\">见连接容器</td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">见端口映射</td>\n</tr>\n<tr>\n<td align=\"center\">-P</td>\n<td align=\"center\">随机映射镜像的端口</td>\n</tr>\n<tr>\n<td align=\"center\">–rm</td>\n<td align=\"center\">容器退出后随之将其删除</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">代表终端，让Docker分配一个伪终端并邦到标准输入</td>\n</tr>\n<tr>\n<td align=\"center\">-u&#x3D;[username]</td>\n<td align=\"center\">设置进程用户名</td>\n</tr>\n<tr>\n<td align=\"center\">-v [宿主机路径]:[容器路径]</td>\n<td align=\"center\">映射路径</td>\n</tr>\n<tr>\n<td align=\"center\">–volumes-from</td>\n<td align=\"center\">从别的容器中挂载卷</td>\n</tr>\n</tbody></table>\n<h3 id=\"查看容器的信息–docker-container-ls\"><a href=\"#查看容器的信息–docker-container-ls\" class=\"headerlink\" title=\"查看容器的信息–docker container ls\"></a>查看容器的信息–docker container ls</h3><ul>\n<li><strong>格式：</strong><code>docker container ls</code></li>\n<li>-a:列出终止状态的容器</li>\n</ul>\n<h3 id=\"终止容器–docker-container-stop\"><a href=\"#终止容器–docker-container-stop\" class=\"headerlink\" title=\"终止容器–docker container stop\"></a>终止容器–docker container stop</h3><ul>\n<li><strong>格式：</strong><code>docker container stop [container id or names]</code></li>\n</ul>\n<h3 id=\"启动已终止容器–docker-container-start\"><a href=\"#启动已终止容器–docker-container-start\" class=\"headerlink\" title=\"启动已终止容器–docker container start\"></a>启动已终止容器–docker container start</h3><ul>\n<li><strong>格式：</strong><code>docker container start [container id or names]</code></li>\n</ul>\n<h3 id=\"重启容器–docker-container-restart\"><a href=\"#重启容器–docker-container-restart\" class=\"headerlink\" title=\"重启容器–docker container restart\"></a>重启容器–docker container restart</h3><ul>\n<li><strong>格式：</strong><code>docker container restart [container id or names]</code></li>\n</ul>\n<h3 id=\"查看容器的日志–docker-container-logs\"><a href=\"#查看容器的日志–docker-container-logs\" class=\"headerlink\" title=\"查看容器的日志–docker container logs\"></a>查看容器的日志–docker container logs</h3><ul>\n<li><strong>格式：</strong><code>docker container logs [container ID or NAMES]</code></li>\n</ul>\n<h3 id=\"进入后台运行的容器–docker-attach-exec\"><a href=\"#进入后台运行的容器–docker-attach-exec\" class=\"headerlink\" title=\"进入后台运行的容器–docker attach&#x2F;exec\"></a>进入后台运行的容器–docker attach&#x2F;exec</h3><ul>\n<li>建议使用exec,使用attach,从stdin退出，会导致容器的停止，exec就没这个问题</li>\n<li>attach格式：<code>docker attach [id or names]</code></li>\n</ul>\n<h4 id=\"docker-exec\"><a href=\"#docker-exec\" class=\"headerlink\" title=\"docker exec\"></a>docker exec</h4><ul>\n<li><strong>格式：</strong><code>docker exec -it [id or names]</code></li>\n<li>-it选项和docker run一样</li>\n</ul>\n<h3 id=\"导出、导入容器–docker-export-import\"><a href=\"#导出、导入容器–docker-export-import\" class=\"headerlink\" title=\"导出、导入容器–docker export&#x2F;import\"></a>导出、导入容器–docker export&#x2F;import</h3><ul>\n<li>导出容器：<code>docker export [id] &gt; xx.tar</code></li>\n<li>导入容器快照成镜像：<code>cat xx.tar | docker import - test/ubuntu:v1.0</code>,支持url:<code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></li>\n<li>docker load和docker import:docker import会丢弃所有历史记录和元数据信息，docker load则会保留完整记录</li>\n</ul>\n<h3 id=\"删除容器–docker-container-rm\"><a href=\"#删除容器–docker-container-rm\" class=\"headerlink\" title=\"删除容器–docker container rm\"></a>删除容器–docker container rm</h3><ul>\n<li><strong>格式：</strong><code>docker container rm [container id or names]</code></li>\n<li>-f:删除一个运行中的容器</li>\n</ul>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><h3 id=\"Docker-Hub\"><a href=\"#Docker-Hub\" class=\"headerlink\" title=\"Docker Hub\"></a>Docker Hub</h3><ul>\n<li>注册：在官网<a href=\"https://hub.docker.com免费注册一个docker帐号/\">https://hub.docker.com免费注册一个Docker帐号</a></li>\n<li>登录：<code>docker login</code>命令交互式输入用户名和密码</li>\n<li>搜索：<code>docker search [关键字]</code>支持<code>--filter=stars=N</code>仅显示收藏数量N以上的镜像</li>\n<li>拉取：见镜像拉取</li>\n<li>推送：推送前先标记下<code>dockeer tag [image:tag] [username/xx:xx]</code>，<code>docker push username/xx:xx</code></li>\n</ul>\n<h3 id=\"私有仓库–-docker-registry\"><a href=\"#私有仓库–-docker-registry\" class=\"headerlink\" title=\"私有仓库–&gt;docker-registry\"></a>私有仓库–&gt;docker-registry</h3><ul>\n<li>使用官方registry镜像：<code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></li>\n<li>默认情况下仓库会在容器中的<code>/var/lib/registry</code>目录下,可以用-v选项映射</li>\n<li>标记镜像<code>git tag</code>:<code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></li>\n<li>推送：<code>docker push 127.0.0.1:5000/ubuntu:latest</code></li>\n<li>拉取：<code>docker pull 127.0.0.1:5000/ubuntu:latest</code></li>\n<li>取消非https限制：默认情况下docker不允许非https方式推送，对于使用systemd的系统，可以在&#x2F;etc&#x2F;docker&#x2F;daemon.json中写入如下内容：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;registry-mirror&quot;</span>: [<br>    <span class=\"hljs-string\">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class=\"hljs-string\">&quot;https://mirror.baidubce.com&quot;</span><br>  ],<br>  <span class=\"hljs-string\">&quot;insecure-registries&quot;</span>: [<br>    <span class=\"hljs-string\">&quot;192.168.199.100:5000&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>私有仓库删除镜像可能不会回收空间，可以使用Nexus3.x软件搭配</li>\n</ul>\n<h2 id=\"数据管理\"><a href=\"#数据管理\" class=\"headerlink\" title=\"数据管理\"></a>数据管理</h2><h3 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h3><ul>\n<li>特性<ul>\n<li>数据卷可以在容器之间共享和重用</li>\n<li>对数据卷的修改会立马生效</li>\n<li>对数据卷的更新，不会影响镜像</li>\n<li>数据卷会默认一直存在，即使容器被删除</li>\n</ul>\n</li>\n<li>创建一个数据卷：<code>docker volume create my-vol</code></li>\n<li>查看数据卷：<code>docker volume ls</code></li>\n<li>查看指定数据卷信息：<code>docker volume inspect my-vol</code></li>\n<li>挂载数据卷<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">docker run -d -P \\<br>    --name web \\<br>    <span class=\"hljs-comment\"># -v my-vol:/usr/share/nginx/html \\</span><br>    --mount <span class=\"hljs-built_in\">source</span>=my-vol,target=/usr/share/nginx/html \\<br>    nginx:alpine<br></code></pre></td></tr></table></figure></li>\n<li>删除数据卷：<code>docker volume rm my-vol</code></li>\n</ul>\n<h3 id=\"挂载主机目录为数据卷\"><a href=\"#挂载主机目录为数据卷\" class=\"headerlink\" title=\"挂载主机目录为数据卷\"></a>挂载主机目录为数据卷</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 可以不加readonly,那样权限就是读写</span><br>docker run -d -P \\<br>    --name web \\<br>    <span class=\"hljs-comment\"># -v /src/webapp:/usr/share/nginx/html:ro \\</span><br>    --mount <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">bind</span>,<span class=\"hljs-built_in\">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class=\"hljs-built_in\">readonly</span> \\<br>    nginx:alpine<br></code></pre></td></tr></table></figure>\n<p>可以挂载指定文件，把上面source和target换成文件即可</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h3><p>使用-p选项</p>\n<ul>\n<li>映射所有接口地址：<code>-p hostPort:containerPort</code></li>\n<li>映射到指定地址的指定端口：<code>-p ip:hostPort:containerPort</code></li>\n<li>映射到指定地址的任意端口：<code>-p ip::containerPort</code></li>\n<li>标记udp: <code>-p xxport:xxport/udp</code></li>\n<li>查看容器的端口映射：<code>docker port [id or name] [containerPort]</code></li>\n</ul>\n<h3 id=\"容器互联-两个容器\"><a href=\"#容器互联-两个容器\" class=\"headerlink\" title=\"容器互联(两个容器)\"></a>容器互联(两个容器)</h3><p>如果大于两个容器的互联建议使用Docker Compose</p>\n<ul>\n<li>新建网络：<code>docker network create -d bridge my-net</code>,-d选项有bridge和overlay(见swarm mode)</li>\n<li>连接容器：<code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code>,<code>$ docker run -it --rm --name busybox1 --network my-net busybox2 sh</code></li>\n<li>在各个容器中ping：<code>ping busybox2</code></li>\n</ul>\n<h3 id=\"DNS配置\"><a href=\"#DNS配置\" class=\"headerlink\" title=\"DNS配置\"></a>DNS配置</h3><p>容器的DNS设置跟随宿主主机，默认使用主机上的&#x2F;etc&#x2F;resolv.conf(–dns-search –dns会改变默认设置),如果配置全部容器的DNS可以在<code>/etc/docker/daemon.json</code>增加以下内容设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;dns&quot;</span> : [<br>    <span class=\"hljs-string\">&quot;114.114.114.114&quot;</span>,<br>    <span class=\"hljs-string\">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"docker命令汇总\"><a href=\"#docker命令汇总\" class=\"headerlink\" title=\"docker命令汇总\"></a>docker命令汇总</h2><h3 id=\"客户端选项\"><a href=\"#客户端选项\" class=\"headerlink\" title=\"客户端选项\"></a>客户端选项</h3><ul>\n<li>–config&#x3D;””：指定客户端配置文件，默认为 ~&#x2F;.docker；</li>\n<li>-D&#x3D;true|false：是否使用 debug 模式。默认不开启；</li>\n<li>-H, –host&#x3D;[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket，文件句柄 fd:&#x2F;&#x2F;socketfd 或 tcp 套接字 tcp:&#x2F;&#x2F;[host[:port]]，默认为 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock；</li>\n<li>-l, –log-level&#x3D;”debug|info|warn|error|fatal”：指定日志输出级别；</li>\n<li>–tls&#x3D;true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>\n<li>–tlscacert&#x3D;&#x2F;.docker&#x2F;ca.pem：TLS CA 签名的可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;cert.pem：TLS 可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;key.pem：TLS 密钥文件路径；</li>\n<li>–tlsverify&#x3D;true|false：启用 TLS 校验，默认为否。</li>\n</ul>\n<h3 id=\"客户端命令\"><a href=\"#客户端命令\" class=\"headerlink\" title=\"客户端命令\"></a>客户端命令</h3><ul>\n<li>attach：依附到一个正在运行的容器中；</li>\n<li>build：从一个 Dockerfile 创建一个镜像；</li>\n<li>commit：从一个容器的修改中创建一个新的镜像；</li>\n<li>cp：在容器和本地宿主系统之间复制文件中；</li>\n<li>create：创建一个新容器，但并不运行它；</li>\n<li>diff：检查一个容器内文件系统的修改，包括修改和增加；</li>\n<li>events：从服务端获取实时的事件；</li>\n<li>exec：在运行的容器内执行命令；</li>\n<li>export：导出容器内容为一个 tar 包；</li>\n<li>history：显示一个镜像的历史信息；</li>\n<li>images：列出存在的镜像；</li>\n<li>import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；</li>\n<li>info：显示一些相关的系统信息；</li>\n<li>inspect：显示一个容器的具体配置信息；</li>\n<li>kill：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>\n<li>load：从一个 tar 包中加载一个镜像；</li>\n<li>login：注册或登录到一个 Docker 的仓库服务器；</li>\n<li>logout：从 Docker 的仓库服务器登出；</li>\n<li>logs：获取容器的 log 信息；</li>\n<li>network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>\n<li>node：管理 swarm 集群中的节点，包括查看、更新、删除、提升&#x2F;取消管理节点等；</li>\n<li>pause：暂停一个容器中的所有进程；</li>\n<li>port：查找一个 nat 到一个私有网口的公共口；</li>\n<li>ps：列出主机上的容器；</li>\n<li>pull：从一个Docker的仓库服务器下拉一个镜像或仓库；</li>\n<li>push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>\n<li>rename：重命名一个容器；</li>\n<li>restart：重启一个运行中的容器；</li>\n<li>rm：删除给定的若干个容器；</li>\n<li>rmi：删除给定的若干个镜像；</li>\n<li>run：创建一个新容器，并在其中运行给定命令；</li>\n<li>save：保存一个镜像为 tar 包文件；</li>\n<li>search：在 Docker index 中搜索一个镜像；</li>\n<li>service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>\n<li>start：启动一个容器；</li>\n<li>stats：输出（一个或多个）容器的资源使用统计信息；</li>\n<li>stop：终止一个运行中的容器；</li>\n<li>swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>\n<li>tag：为一个镜像打标签；</li>\n<li>top：查看一个容器中的正在运行的进程信息；</li>\n<li>unpause：将一个容器内所有的进程从暂停状态中恢复；</li>\n<li>update：更新指定的若干容器的配置信息；</li>\n<li>version：输出 Docker 的版本信息；</li>\n<li>volume：管理 Docker volume，包括查看、创建、删除等；</li>\n<li>wait：阻塞直到一个容器终止，然后输出它的退出符。</li>\n</ul>\n<h3 id=\"服务端命令选项\"><a href=\"#服务端命令选项\" class=\"headerlink\" title=\"服务端命令选项\"></a>服务端命令选项</h3><ul>\n<li>–api-cors-header&#x3D;””：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 <code>*</code>；</li>\n<li>–authorization-plugin&#x3D;””：载入认证的插件；</li>\n<li>-b&#x3D;””：将容器挂载到一个已存在的网桥上。指定为 none 时则禁用容器的网络，与 –bip 选项互斥；</li>\n<li>–bip&#x3D;””：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；</li>\n<li>–cgroup-parent&#x3D;””：指定 cgroup 的父组，默认 fs cgroup 驱动为 &#x2F;docker，systemd cgroup 驱动为 system.slice；</li>\n<li>–cluster-store&#x3D;””：构成集群（如 Swarm）时，集群键值数据库服务地址；</li>\n<li>–cluster-advertise&#x3D;””：构成集群时，自身的被访问地址，可以为 host:port 或 interface:port；</li>\n<li>–cluster-store-opt&#x3D;””：构成集群时，键值数据库的配置选项；</li>\n<li>–config-file&#x3D;”&#x2F;etc&#x2F;docker&#x2F;daemon.json”：daemon 配置文件路径；</li>\n<li>–containerd&#x3D;””：containerd 文件的路径；</li>\n<li>-D, –debug&#x3D;true|false：是否使用 Debug 模式。缺省为 false；</li>\n<li>–default-gateway&#x3D;””：容器的 IPv4 网关地址，必须在网桥的子网段内；</li>\n<li>–default-gateway-v6&#x3D;””：容器的 IPv6 网关地址；</li>\n<li>–default-ulimit&#x3D;[]：默认的 ulimit 值；</li>\n<li>–disable-legacy-registry&#x3D;true|false：是否允许访问旧版本的镜像仓库服务器；</li>\n<li>–dns&#x3D;””：指定容器使用的 DNS 服务器地址；</li>\n<li>–dns-opt&#x3D;””：DNS 选项；</li>\n<li>–dns-search&#x3D;[]：DNS 搜索域；</li>\n<li>–exec-opt&#x3D;[]：运行时的执行选项；</li>\n<li>–exec-root&#x3D;””：容器执行状态文件的根路径，默认为 &#x2F;var&#x2F;run&#x2F;docker；</li>\n<li>–fixed-cidr&#x3D;””：限定分配 IPv4 地址范围；</li>\n<li>–fixed-cidr-v6&#x3D;””：限定分配 IPv6 地址范围；</li>\n<li>-G, –group&#x3D;””：分配给 unix 套接字的组，默认为 docker；</li>\n<li>-g, –graph&#x3D;””：Docker 运行时的根路径，默认为 &#x2F;var&#x2F;lib&#x2F;docker；</li>\n<li>-H, –host&#x3D;[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket，文件句柄 fd:&#x2F;&#x2F;socketfd 或 tcp 套接字 tcp:&#x2F;&#x2F;[host[:port]]，默认为 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock；</li>\n<li>–icc&#x3D;true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>\n<li>–insecure-registry&#x3D;[]：允许访问给定的非安全仓库服务；</li>\n<li>–ip&#x3D;””：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；</li>\n<li>–ip-forward&#x3D;true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>\n<li>–ip-masq&#x3D;true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；</li>\n<li>–iptables&#x3D;true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；</li>\n<li>–ipv6&#x3D;true|false：是否启用 IPv6 支持，默认关闭；</li>\n<li>-l, –log-level&#x3D;”debug|info|warn|error|fatal”：指定日志输出级别；</li>\n<li>–label&#x3D;”[]”：添加指定的键值对标注；</li>\n<li>–log-driver&#x3D;”json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none”：指定日志后端驱动，默认为 json-file；</li>\n<li>–log-opt&#x3D;[]：日志后端的选项；</li>\n<li>–mtu&#x3D;VALUE：指定容器网络的 mtu；</li>\n<li>-p&#x3D;””：指定 daemon 的 PID 文件路径。缺省为 &#x2F;var&#x2F;run&#x2F;docker.pid；</li>\n<li>–raw-logs：输出原始，未加色彩的日志信息；</li>\n<li>–registry-mirror&#x3D;<scheme>:&#x2F;&#x2F;<host>：指定 docker pull 时使用的注册服务器镜像地址；</li>\n<li>-s, –storage-driver&#x3D;””：指定使用给定的存储后端；</li>\n<li>–selinux-enabled&#x3D;true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>\n<li>–storage-opt&#x3D;[]：驱动后端选项；</li>\n<li>–tls&#x3D;true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>\n<li>–tlscacert&#x3D;&#x2F;.docker&#x2F;ca.pem：TLS CA 签名的可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;cert.pem：TLS 可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;key.pem：TLS 密钥文件路径；</li>\n<li>–tlsverify&#x3D;true|false：启用 TLS 校验，默认为否；</li>\n<li>–userland-proxy&#x3D;true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>\n<li>–userns-remap&#x3D;default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>\n</ul>\n<h2 id=\"调试docker\"><a href=\"#调试docker\" class=\"headerlink\" title=\"调试docker\"></a>调试docker</h2><ul>\n<li>开启debug模式：在&#x2F;etc&#x2F;docker&#x2F;daemon.json中添加：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t<span class=\"hljs-string\">&quot;debug&quot;</span>:<span class=\"hljs-literal\">true</span>\t<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>重启守护进程<code>sudo kill -SIGHUP $(pidof dockerd)</code></li>\n<li>检查内核日志<code>sudo dmesg | grep dockerd</code>,<code>sudo dmesg|grep runc</code></li>\n<li>不响应时，杀死进程查看堆栈：<code>sudo kill -SIGUSR1 $(pidof dockerd)</code></li>\n</ul>\n<h2 id=\"高级网络\"><a href=\"#高级网络\" class=\"headerlink\" title=\"高级网络\"></a>高级网络</h2><h2 id=\"集群–Swarm-mod\"><a href=\"#集群–Swarm-mod\" class=\"headerlink\" title=\"集群–Swarm mod\"></a>集群–Swarm mod</h2><h2 id=\"Docker-Buildx–-未来docker-build\"><a href=\"#Docker-Buildx–-未来docker-build\" class=\"headerlink\" title=\"Docker Buildx–&gt;未来docker build\"></a>Docker Buildx–&gt;未来docker build</h2><h2 id=\"常用命令及问题\"><a href=\"#常用命令及问题\" class=\"headerlink\" title=\"常用命令及问题\"></a>常用命令及问题</h2><ul>\n<li><code>docker system df</code>查看镜像、容器、数据卷所占用空间</li>\n<li><code>docker image prune</code>批量清理临时镜像</li>\n<li><code>docker container prune</code>删除所有终止状态的容器</li>\n<li><code>docker volume prune</code>删除无主的数据卷</li>\n<li><code>docker run [image] env</code>查看镜像支持的环境变量</li>\n<li><code>docker stop $(docker container ls -q)</code>停止所有正在运行的容器</li>\n<li><code>docker inspect --format &#39;&#123;&#123; .State.Pid &#125;&#125;&#39; &lt;CONTAINER ID or NAME&gt;</code>获取某个容器的PID信息</li>\n<li><code>docker inspect --format &#39;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#39; &lt;CONTAINER ID or NAME&gt;</code>获取某个容器的ip地址</li>\n<li>给容器指定一个固定ip地址<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">docker network create -d bridge --subnet 172.25.0.0/16 my-net<br>docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox<br></code></pre></td></tr></table></figure></li>\n<li>退出一个交互的终端而不终止，按<code>ctrl-p ctrl-q</code></li>\n<li>Error:No public port 80 published for xxx<ul>\n<li>创建镜像时 Dockerfile 要通过 EXPOSE 指定正确的开放端口；</li>\n<li>容器启动时指定 PublishAllPort &#x3D; true。</li>\n</ul>\n</li>\n<li>WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.<br>这是因为系统默认没有开启对内存和swap使用的统计功能，该功能会降低性能，可以通过以下方式开启：<ul>\n<li>编辑<code>/etc/default/grub</code>配置<code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</code></li>\n<li>更新grub:<code>sudo update-grub</code></li>\n<li>重启</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"各个文件位置\"><a href=\"#各个文件位置\" class=\"headerlink\" title=\"各个文件位置\"></a>各个文件位置</h2><ul>\n<li>本地资源的默认总目录：<code>/var/lib/docker/</code>,<strong>迁移</strong>docker就是复制该文件夹，<strong>重置</strong>就是删除该文件夹</li>\n<li>容器信息：<code>containers</code></li>\n<li>镜像信息：<code>image</code></li>\n<li>镜像层文件：<code>overlay2</code></li>\n</ul>\n<h3 id=\"修改文件位置\"><a href=\"#修改文件位置\" class=\"headerlink\" title=\"修改文件位置\"></a>修改文件位置</h3><ul>\n<li>方式1：为默认位置建立软链接</li>\n<li>方式2：daemon启动时指定-g选项</li>\n<li>方式3：修改&#x2F;etc&#x2F;docker&#x2F;daemon.json的”data-root”项</li>\n</ul>\n<h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><ul>\n<li>查看是否在docker.service文件中配置过镜像地址：<code>$ systemctl cat docker | grep &#39;\\-\\-registry\\-mirror&#39;</code></li>\n<li>上一步如果出现输出内容，修改文件去掉内容<code>--registry-mirror</code>，按接下来步骤配置</li>\n<li>在&#x2F;etc&#x2F;docker&#x2F;daemon.json中写入下面内容：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;registry-mirrors&quot;</span>: [<br>    <span class=\"hljs-string\">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class=\"hljs-string\">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>重启服务：<code>sudo systemctl daemon-reload;sudo systemctl restart docker</code></li>\n<li>检查是否生效：<code>docker info</code></li>\n</ul>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><h3 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h3><ul>\n<li>格式:<code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></li>\n<li>默认地址是<code>docker.io</code>,仓库名默认为<code>library</code>,即官方镜像，标签默认是<code>latest</code></li>\n<li>简化版：<code>docker pull ubuntu</code></li>\n</ul>\n<h3 id=\"列出镜像\"><a href=\"#列出镜像\" class=\"headerlink\" title=\"列出镜像\"></a>列出镜像</h3><ul>\n<li>一般命令：<code>docker image ls</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">显示包括中间层镜像在内的所有镜像</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-f&#x2F;–fliter</td>\n<td align=\"center\">过滤参数,见下</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">–format</td>\n<td align=\"center\">自定义格式，见</td>\n<td align=\"center\"><code>docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"f选项\"><a href=\"#f选项\" class=\"headerlink\" title=\"-f选项\"></a>-f选项</h4><ul>\n<li>since&#x2F;before: <code>docker image ls -f since=mongo:3.2</code>,列出mongo:3.2之后建立的镜像</li>\n<li>label: <code>docker image ls -f label=com.example.version=0.1</code></li>\n</ul>\n<h4 id=\"虚悬镜像\"><a href=\"#虚悬镜像\" class=\"headerlink\" title=\"&lt;none&gt;虚悬镜像\"></a><code>&lt;none&gt;</code>虚悬镜像</h4><ul>\n<li>原因：docker pull或docker build导致镜像名被转移到最新版</li>\n<li>只列出虚悬镜像：<code>docker image ls -f dangling=true</code></li>\n<li>删除虚悬镜像：<code>docker image prune</code></li>\n</ul>\n<h3 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h3><ul>\n<li>格式：<code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code>,镜像可以是长&#x2F;短id,镜像名或镜像摘要</li>\n</ul>\n<h4 id=\"untagged和deleted\"><a href=\"#untagged和deleted\" class=\"headerlink\" title=\"untagged和deleted\"></a>untagged和deleted</h4><p>镜像对应多个tag,，只有所有tag都为untagged时，才真正删除，如果一个容器依赖一个镜像，要先删除容器，才能再删除镜像</p>\n<h3 id=\"docker-commit-添加一层形成新的镜像（慎用）\"><a href=\"#docker-commit-添加一层形成新的镜像（慎用）\" class=\"headerlink\" title=\"docker commit-添加一层形成新的镜像（慎用）\"></a>docker commit-添加一层形成新的镜像（慎用）</h3><ul>\n<li>说明：该命令会使一个容器形成一个新的镜像,最好不要这样，而是使用Dockerfile</li>\n<li>格式：<code>docker commit [选项] &lt;容器ID或容器名&gt; [仓库名:标签]</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–author</td>\n<td align=\"center\">说明作者</td>\n</tr>\n<tr>\n<td align=\"center\">–message</td>\n<td align=\"center\">添加说明信息</td>\n</tr>\n</tbody></table>\n<h4 id=\"docker-history\"><a href=\"#docker-history\" class=\"headerlink\" title=\"docker history\"></a>docker history</h4><ul>\n<li>说明：该命令用来查看某个镜像的提交历史</li>\n<li>示例：<code>docker history [仓库名:标签]</code></li>\n</ul>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h3 id=\"容器运行流程\"><a href=\"#容器运行流程\" class=\"headerlink\" title=\"容器运行流程\"></a>容器运行流程</h3><ol>\n<li>检查本地是否存在指定的镜像，不存在就从registry下载</li>\n<li>利用镜像创建并启动一个容器</li>\n<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>\n<li>从地址池配置一个ip地址给容器</li>\n<li>执行用户指定的应用程序</li>\n<li>执行完毕后容器被终止</li>\n</ol>\n<h3 id=\"运行容器docker-run\"><a href=\"#运行容器docker-run\" class=\"headerlink\" title=\"运行容器docker run\"></a>运行容器<code>docker run</code></h3><ul>\n<li><strong>格式：</strong><code>docker run [OPTIONS] image</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c&#x2F;–cpu-shares</td>\n<td align=\"center\">调整容器使用cpu的权重</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">后台运行，此时容器不会把输出的结果打印到宿主机上面，<code>docker container logs &lt;container id or name&gt;</code>可以查看结果</td>\n</tr>\n<tr>\n<td align=\"center\">–dns&#x3D;[ip_address]</td>\n<td align=\"center\">设置dns服务器</td>\n</tr>\n<tr>\n<td align=\"center\">–dns-search&#x3D;[DOMAIN]</td>\n<td align=\"center\">设定容器搜索域</td>\n</tr>\n<tr>\n<td align=\"center\">–env [VAR&#x3D;value]</td>\n<td align=\"center\">传递环境变量</td>\n</tr>\n<tr>\n<td align=\"center\">–env-file [file]</td>\n<td align=\"center\">从file中引入环境变量</td>\n</tr>\n<tr>\n<td align=\"center\">-h&#x2F;–hostname&#x3D;[HOSTNAME]</td>\n<td align=\"center\">设定容器主机名，比较鸡肋，只能在容器内部显示</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">交互式操作,让容器的标准输入保持打开</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">–memory[&#x3D;MEMORY]</td>\n</tr>\n<tr>\n<td align=\"center\">–mount</td>\n<td align=\"center\">挂载数据卷或主机目录</td>\n</tr>\n<tr>\n<td align=\"center\">–name [name]</td>\n<td align=\"center\">指定容器的名字</td>\n</tr>\n<tr>\n<td align=\"center\">–network [my-net]</td>\n<td align=\"center\">见连接容器</td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">见端口映射</td>\n</tr>\n<tr>\n<td align=\"center\">-P</td>\n<td align=\"center\">随机映射镜像的端口</td>\n</tr>\n<tr>\n<td align=\"center\">–rm</td>\n<td align=\"center\">容器退出后随之将其删除</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">代表终端，让Docker分配一个伪终端并邦到标准输入</td>\n</tr>\n<tr>\n<td align=\"center\">-u&#x3D;[username]</td>\n<td align=\"center\">设置进程用户名</td>\n</tr>\n<tr>\n<td align=\"center\">-v [宿主机路径]:[容器路径]</td>\n<td align=\"center\">映射路径</td>\n</tr>\n<tr>\n<td align=\"center\">–volumes-from</td>\n<td align=\"center\">从别的容器中挂载卷</td>\n</tr>\n</tbody></table>\n<h3 id=\"查看容器的信息–docker-container-ls\"><a href=\"#查看容器的信息–docker-container-ls\" class=\"headerlink\" title=\"查看容器的信息–docker container ls\"></a>查看容器的信息–docker container ls</h3><ul>\n<li><strong>格式：</strong><code>docker container ls</code></li>\n<li>-a:列出终止状态的容器</li>\n</ul>\n<h3 id=\"终止容器–docker-container-stop\"><a href=\"#终止容器–docker-container-stop\" class=\"headerlink\" title=\"终止容器–docker container stop\"></a>终止容器–docker container stop</h3><ul>\n<li><strong>格式：</strong><code>docker container stop [container id or names]</code></li>\n</ul>\n<h3 id=\"启动已终止容器–docker-container-start\"><a href=\"#启动已终止容器–docker-container-start\" class=\"headerlink\" title=\"启动已终止容器–docker container start\"></a>启动已终止容器–docker container start</h3><ul>\n<li><strong>格式：</strong><code>docker container start [container id or names]</code></li>\n</ul>\n<h3 id=\"重启容器–docker-container-restart\"><a href=\"#重启容器–docker-container-restart\" class=\"headerlink\" title=\"重启容器–docker container restart\"></a>重启容器–docker container restart</h3><ul>\n<li><strong>格式：</strong><code>docker container restart [container id or names]</code></li>\n</ul>\n<h3 id=\"查看容器的日志–docker-container-logs\"><a href=\"#查看容器的日志–docker-container-logs\" class=\"headerlink\" title=\"查看容器的日志–docker container logs\"></a>查看容器的日志–docker container logs</h3><ul>\n<li><strong>格式：</strong><code>docker container logs [container ID or NAMES]</code></li>\n</ul>\n<h3 id=\"进入后台运行的容器–docker-attach-exec\"><a href=\"#进入后台运行的容器–docker-attach-exec\" class=\"headerlink\" title=\"进入后台运行的容器–docker attach&#x2F;exec\"></a>进入后台运行的容器–docker attach&#x2F;exec</h3><ul>\n<li>建议使用exec,使用attach,从stdin退出，会导致容器的停止，exec就没这个问题</li>\n<li>attach格式：<code>docker attach [id or names]</code></li>\n</ul>\n<h4 id=\"docker-exec\"><a href=\"#docker-exec\" class=\"headerlink\" title=\"docker exec\"></a>docker exec</h4><ul>\n<li><strong>格式：</strong><code>docker exec -it [id or names]</code></li>\n<li>-it选项和docker run一样</li>\n</ul>\n<h3 id=\"导出、导入容器–docker-export-import\"><a href=\"#导出、导入容器–docker-export-import\" class=\"headerlink\" title=\"导出、导入容器–docker export&#x2F;import\"></a>导出、导入容器–docker export&#x2F;import</h3><ul>\n<li>导出容器：<code>docker export [id] &gt; xx.tar</code></li>\n<li>导入容器快照成镜像：<code>cat xx.tar | docker import - test/ubuntu:v1.0</code>,支持url:<code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></li>\n<li>docker load和docker import:docker import会丢弃所有历史记录和元数据信息，docker load则会保留完整记录</li>\n</ul>\n<h3 id=\"删除容器–docker-container-rm\"><a href=\"#删除容器–docker-container-rm\" class=\"headerlink\" title=\"删除容器–docker container rm\"></a>删除容器–docker container rm</h3><ul>\n<li><strong>格式：</strong><code>docker container rm [container id or names]</code></li>\n<li>-f:删除一个运行中的容器</li>\n</ul>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><h3 id=\"Docker-Hub\"><a href=\"#Docker-Hub\" class=\"headerlink\" title=\"Docker Hub\"></a>Docker Hub</h3><ul>\n<li>注册：在官网<a href=\"https://hub.docker.com免费注册一个docker帐号/\">https://hub.docker.com免费注册一个Docker帐号</a></li>\n<li>登录：<code>docker login</code>命令交互式输入用户名和密码</li>\n<li>搜索：<code>docker search [关键字]</code>支持<code>--filter=stars=N</code>仅显示收藏数量N以上的镜像</li>\n<li>拉取：见镜像拉取</li>\n<li>推送：推送前先标记下<code>dockeer tag [image:tag] [username/xx:xx]</code>，<code>docker push username/xx:xx</code></li>\n</ul>\n<h3 id=\"私有仓库–-docker-registry\"><a href=\"#私有仓库–-docker-registry\" class=\"headerlink\" title=\"私有仓库–&gt;docker-registry\"></a>私有仓库–&gt;docker-registry</h3><ul>\n<li>使用官方registry镜像：<code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></li>\n<li>默认情况下仓库会在容器中的<code>/var/lib/registry</code>目录下,可以用-v选项映射</li>\n<li>标记镜像<code>git tag</code>:<code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></li>\n<li>推送：<code>docker push 127.0.0.1:5000/ubuntu:latest</code></li>\n<li>拉取：<code>docker pull 127.0.0.1:5000/ubuntu:latest</code></li>\n<li>取消非https限制：默认情况下docker不允许非https方式推送，对于使用systemd的系统，可以在&#x2F;etc&#x2F;docker&#x2F;daemon.json中写入如下内容：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;registry-mirror&quot;</span>: [<br>    <span class=\"hljs-string\">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class=\"hljs-string\">&quot;https://mirror.baidubce.com&quot;</span><br>  ],<br>  <span class=\"hljs-string\">&quot;insecure-registries&quot;</span>: [<br>    <span class=\"hljs-string\">&quot;192.168.199.100:5000&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>私有仓库删除镜像可能不会回收空间，可以使用Nexus3.x软件搭配</li>\n</ul>\n<h2 id=\"数据管理\"><a href=\"#数据管理\" class=\"headerlink\" title=\"数据管理\"></a>数据管理</h2><h3 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h3><ul>\n<li>特性<ul>\n<li>数据卷可以在容器之间共享和重用</li>\n<li>对数据卷的修改会立马生效</li>\n<li>对数据卷的更新，不会影响镜像</li>\n<li>数据卷会默认一直存在，即使容器被删除</li>\n</ul>\n</li>\n<li>创建一个数据卷：<code>docker volume create my-vol</code></li>\n<li>查看数据卷：<code>docker volume ls</code></li>\n<li>查看指定数据卷信息：<code>docker volume inspect my-vol</code></li>\n<li>挂载数据卷<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">docker run -d -P \\<br>    --name web \\<br>    <span class=\"hljs-comment\"># -v my-vol:/usr/share/nginx/html \\</span><br>    --mount <span class=\"hljs-built_in\">source</span>=my-vol,target=/usr/share/nginx/html \\<br>    nginx:alpine<br></code></pre></td></tr></table></figure></li>\n<li>删除数据卷：<code>docker volume rm my-vol</code></li>\n</ul>\n<h3 id=\"挂载主机目录为数据卷\"><a href=\"#挂载主机目录为数据卷\" class=\"headerlink\" title=\"挂载主机目录为数据卷\"></a>挂载主机目录为数据卷</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 可以不加readonly,那样权限就是读写</span><br>docker run -d -P \\<br>    --name web \\<br>    <span class=\"hljs-comment\"># -v /src/webapp:/usr/share/nginx/html:ro \\</span><br>    --mount <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">bind</span>,<span class=\"hljs-built_in\">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class=\"hljs-built_in\">readonly</span> \\<br>    nginx:alpine<br></code></pre></td></tr></table></figure>\n<p>可以挂载指定文件，把上面source和target换成文件即可</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h3><p>使用-p选项</p>\n<ul>\n<li>映射所有接口地址：<code>-p hostPort:containerPort</code></li>\n<li>映射到指定地址的指定端口：<code>-p ip:hostPort:containerPort</code></li>\n<li>映射到指定地址的任意端口：<code>-p ip::containerPort</code></li>\n<li>标记udp: <code>-p xxport:xxport/udp</code></li>\n<li>查看容器的端口映射：<code>docker port [id or name] [containerPort]</code></li>\n</ul>\n<h3 id=\"容器互联-两个容器\"><a href=\"#容器互联-两个容器\" class=\"headerlink\" title=\"容器互联(两个容器)\"></a>容器互联(两个容器)</h3><p>如果大于两个容器的互联建议使用Docker Compose</p>\n<ul>\n<li>新建网络：<code>docker network create -d bridge my-net</code>,-d选项有bridge和overlay(见swarm mode)</li>\n<li>连接容器：<code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code>,<code>$ docker run -it --rm --name busybox1 --network my-net busybox2 sh</code></li>\n<li>在各个容器中ping：<code>ping busybox2</code></li>\n</ul>\n<h3 id=\"DNS配置\"><a href=\"#DNS配置\" class=\"headerlink\" title=\"DNS配置\"></a>DNS配置</h3><p>容器的DNS设置跟随宿主主机，默认使用主机上的&#x2F;etc&#x2F;resolv.conf(–dns-search –dns会改变默认设置),如果配置全部容器的DNS可以在<code>/etc/docker/daemon.json</code>增加以下内容设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;dns&quot;</span> : [<br>    <span class=\"hljs-string\">&quot;114.114.114.114&quot;</span>,<br>    <span class=\"hljs-string\">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"docker命令汇总\"><a href=\"#docker命令汇总\" class=\"headerlink\" title=\"docker命令汇总\"></a>docker命令汇总</h2><h3 id=\"客户端选项\"><a href=\"#客户端选项\" class=\"headerlink\" title=\"客户端选项\"></a>客户端选项</h3><ul>\n<li>–config&#x3D;””：指定客户端配置文件，默认为 ~&#x2F;.docker；</li>\n<li>-D&#x3D;true|false：是否使用 debug 模式。默认不开启；</li>\n<li>-H, –host&#x3D;[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket，文件句柄 fd:&#x2F;&#x2F;socketfd 或 tcp 套接字 tcp:&#x2F;&#x2F;[host[:port]]，默认为 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock；</li>\n<li>-l, –log-level&#x3D;”debug|info|warn|error|fatal”：指定日志输出级别；</li>\n<li>–tls&#x3D;true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>\n<li>–tlscacert&#x3D;&#x2F;.docker&#x2F;ca.pem：TLS CA 签名的可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;cert.pem：TLS 可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;key.pem：TLS 密钥文件路径；</li>\n<li>–tlsverify&#x3D;true|false：启用 TLS 校验，默认为否。</li>\n</ul>\n<h3 id=\"客户端命令\"><a href=\"#客户端命令\" class=\"headerlink\" title=\"客户端命令\"></a>客户端命令</h3><ul>\n<li>attach：依附到一个正在运行的容器中；</li>\n<li>build：从一个 Dockerfile 创建一个镜像；</li>\n<li>commit：从一个容器的修改中创建一个新的镜像；</li>\n<li>cp：在容器和本地宿主系统之间复制文件中；</li>\n<li>create：创建一个新容器，但并不运行它；</li>\n<li>diff：检查一个容器内文件系统的修改，包括修改和增加；</li>\n<li>events：从服务端获取实时的事件；</li>\n<li>exec：在运行的容器内执行命令；</li>\n<li>export：导出容器内容为一个 tar 包；</li>\n<li>history：显示一个镜像的历史信息；</li>\n<li>images：列出存在的镜像；</li>\n<li>import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；</li>\n<li>info：显示一些相关的系统信息；</li>\n<li>inspect：显示一个容器的具体配置信息；</li>\n<li>kill：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>\n<li>load：从一个 tar 包中加载一个镜像；</li>\n<li>login：注册或登录到一个 Docker 的仓库服务器；</li>\n<li>logout：从 Docker 的仓库服务器登出；</li>\n<li>logs：获取容器的 log 信息；</li>\n<li>network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>\n<li>node：管理 swarm 集群中的节点，包括查看、更新、删除、提升&#x2F;取消管理节点等；</li>\n<li>pause：暂停一个容器中的所有进程；</li>\n<li>port：查找一个 nat 到一个私有网口的公共口；</li>\n<li>ps：列出主机上的容器；</li>\n<li>pull：从一个Docker的仓库服务器下拉一个镜像或仓库；</li>\n<li>push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>\n<li>rename：重命名一个容器；</li>\n<li>restart：重启一个运行中的容器；</li>\n<li>rm：删除给定的若干个容器；</li>\n<li>rmi：删除给定的若干个镜像；</li>\n<li>run：创建一个新容器，并在其中运行给定命令；</li>\n<li>save：保存一个镜像为 tar 包文件；</li>\n<li>search：在 Docker index 中搜索一个镜像；</li>\n<li>service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>\n<li>start：启动一个容器；</li>\n<li>stats：输出（一个或多个）容器的资源使用统计信息；</li>\n<li>stop：终止一个运行中的容器；</li>\n<li>swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>\n<li>tag：为一个镜像打标签；</li>\n<li>top：查看一个容器中的正在运行的进程信息；</li>\n<li>unpause：将一个容器内所有的进程从暂停状态中恢复；</li>\n<li>update：更新指定的若干容器的配置信息；</li>\n<li>version：输出 Docker 的版本信息；</li>\n<li>volume：管理 Docker volume，包括查看、创建、删除等；</li>\n<li>wait：阻塞直到一个容器终止，然后输出它的退出符。</li>\n</ul>\n<h3 id=\"服务端命令选项\"><a href=\"#服务端命令选项\" class=\"headerlink\" title=\"服务端命令选项\"></a>服务端命令选项</h3><ul>\n<li>–api-cors-header&#x3D;””：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 <code>*</code>；</li>\n<li>–authorization-plugin&#x3D;””：载入认证的插件；</li>\n<li>-b&#x3D;””：将容器挂载到一个已存在的网桥上。指定为 none 时则禁用容器的网络，与 –bip 选项互斥；</li>\n<li>–bip&#x3D;””：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；</li>\n<li>–cgroup-parent&#x3D;””：指定 cgroup 的父组，默认 fs cgroup 驱动为 &#x2F;docker，systemd cgroup 驱动为 system.slice；</li>\n<li>–cluster-store&#x3D;””：构成集群（如 Swarm）时，集群键值数据库服务地址；</li>\n<li>–cluster-advertise&#x3D;””：构成集群时，自身的被访问地址，可以为 host:port 或 interface:port；</li>\n<li>–cluster-store-opt&#x3D;””：构成集群时，键值数据库的配置选项；</li>\n<li>–config-file&#x3D;”&#x2F;etc&#x2F;docker&#x2F;daemon.json”：daemon 配置文件路径；</li>\n<li>–containerd&#x3D;””：containerd 文件的路径；</li>\n<li>-D, –debug&#x3D;true|false：是否使用 Debug 模式。缺省为 false；</li>\n<li>–default-gateway&#x3D;””：容器的 IPv4 网关地址，必须在网桥的子网段内；</li>\n<li>–default-gateway-v6&#x3D;””：容器的 IPv6 网关地址；</li>\n<li>–default-ulimit&#x3D;[]：默认的 ulimit 值；</li>\n<li>–disable-legacy-registry&#x3D;true|false：是否允许访问旧版本的镜像仓库服务器；</li>\n<li>–dns&#x3D;””：指定容器使用的 DNS 服务器地址；</li>\n<li>–dns-opt&#x3D;””：DNS 选项；</li>\n<li>–dns-search&#x3D;[]：DNS 搜索域；</li>\n<li>–exec-opt&#x3D;[]：运行时的执行选项；</li>\n<li>–exec-root&#x3D;””：容器执行状态文件的根路径，默认为 &#x2F;var&#x2F;run&#x2F;docker；</li>\n<li>–fixed-cidr&#x3D;””：限定分配 IPv4 地址范围；</li>\n<li>–fixed-cidr-v6&#x3D;””：限定分配 IPv6 地址范围；</li>\n<li>-G, –group&#x3D;””：分配给 unix 套接字的组，默认为 docker；</li>\n<li>-g, –graph&#x3D;””：Docker 运行时的根路径，默认为 &#x2F;var&#x2F;lib&#x2F;docker；</li>\n<li>-H, –host&#x3D;[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket，文件句柄 fd:&#x2F;&#x2F;socketfd 或 tcp 套接字 tcp:&#x2F;&#x2F;[host[:port]]，默认为 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock；</li>\n<li>–icc&#x3D;true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>\n<li>–insecure-registry&#x3D;[]：允许访问给定的非安全仓库服务；</li>\n<li>–ip&#x3D;””：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；</li>\n<li>–ip-forward&#x3D;true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>\n<li>–ip-masq&#x3D;true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；</li>\n<li>–iptables&#x3D;true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；</li>\n<li>–ipv6&#x3D;true|false：是否启用 IPv6 支持，默认关闭；</li>\n<li>-l, –log-level&#x3D;”debug|info|warn|error|fatal”：指定日志输出级别；</li>\n<li>–label&#x3D;”[]”：添加指定的键值对标注；</li>\n<li>–log-driver&#x3D;”json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none”：指定日志后端驱动，默认为 json-file；</li>\n<li>–log-opt&#x3D;[]：日志后端的选项；</li>\n<li>–mtu&#x3D;VALUE：指定容器网络的 mtu；</li>\n<li>-p&#x3D;””：指定 daemon 的 PID 文件路径。缺省为 &#x2F;var&#x2F;run&#x2F;docker.pid；</li>\n<li>–raw-logs：输出原始，未加色彩的日志信息；</li>\n<li>–registry-mirror&#x3D;<scheme>:&#x2F;&#x2F;<host>：指定 docker pull 时使用的注册服务器镜像地址；</li>\n<li>-s, –storage-driver&#x3D;””：指定使用给定的存储后端；</li>\n<li>–selinux-enabled&#x3D;true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>\n<li>–storage-opt&#x3D;[]：驱动后端选项；</li>\n<li>–tls&#x3D;true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>\n<li>–tlscacert&#x3D;&#x2F;.docker&#x2F;ca.pem：TLS CA 签名的可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;cert.pem：TLS 可信证书文件路径；</li>\n<li>–tlscert&#x3D;&#x2F;.docker&#x2F;key.pem：TLS 密钥文件路径；</li>\n<li>–tlsverify&#x3D;true|false：启用 TLS 校验，默认为否；</li>\n<li>–userland-proxy&#x3D;true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>\n<li>–userns-remap&#x3D;default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>\n</ul>\n<h2 id=\"调试docker\"><a href=\"#调试docker\" class=\"headerlink\" title=\"调试docker\"></a>调试docker</h2><ul>\n<li>开启debug模式：在&#x2F;etc&#x2F;docker&#x2F;daemon.json中添加：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t<span class=\"hljs-string\">&quot;debug&quot;</span>:<span class=\"hljs-literal\">true</span>\t<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>重启守护进程<code>sudo kill -SIGHUP $(pidof dockerd)</code></li>\n<li>检查内核日志<code>sudo dmesg | grep dockerd</code>,<code>sudo dmesg|grep runc</code></li>\n<li>不响应时，杀死进程查看堆栈：<code>sudo kill -SIGUSR1 $(pidof dockerd)</code></li>\n</ul>\n<h2 id=\"高级网络\"><a href=\"#高级网络\" class=\"headerlink\" title=\"高级网络\"></a>高级网络</h2><h2 id=\"集群–Swarm-mod\"><a href=\"#集群–Swarm-mod\" class=\"headerlink\" title=\"集群–Swarm mod\"></a>集群–Swarm mod</h2><h2 id=\"Docker-Buildx–-未来docker-build\"><a href=\"#Docker-Buildx–-未来docker-build\" class=\"headerlink\" title=\"Docker Buildx–&gt;未来docker build\"></a>Docker Buildx–&gt;未来docker build</h2><h2 id=\"常用命令及问题\"><a href=\"#常用命令及问题\" class=\"headerlink\" title=\"常用命令及问题\"></a>常用命令及问题</h2><ul>\n<li><code>docker system df</code>查看镜像、容器、数据卷所占用空间</li>\n<li><code>docker image prune</code>批量清理临时镜像</li>\n<li><code>docker container prune</code>删除所有终止状态的容器</li>\n<li><code>docker volume prune</code>删除无主的数据卷</li>\n<li><code>docker run [image] env</code>查看镜像支持的环境变量</li>\n<li><code>docker stop $(docker container ls -q)</code>停止所有正在运行的容器</li>\n<li><code>docker inspect --format &#39;&#123;&#123; .State.Pid &#125;&#125;&#39; &lt;CONTAINER ID or NAME&gt;</code>获取某个容器的PID信息</li>\n<li><code>docker inspect --format &#39;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#39; &lt;CONTAINER ID or NAME&gt;</code>获取某个容器的ip地址</li>\n<li>给容器指定一个固定ip地址<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">docker network create -d bridge --subnet 172.25.0.0/16 my-net<br>docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox<br></code></pre></td></tr></table></figure></li>\n<li>退出一个交互的终端而不终止，按<code>ctrl-p ctrl-q</code></li>\n<li>Error:No public port 80 published for xxx<ul>\n<li>创建镜像时 Dockerfile 要通过 EXPOSE 指定正确的开放端口；</li>\n<li>容器启动时指定 PublishAllPort &#x3D; true。</li>\n</ul>\n</li>\n<li>WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.<br>这是因为系统默认没有开启对内存和swap使用的统计功能，该功能会降低性能，可以通过以下方式开启：<ul>\n<li>编辑<code>/etc/default/grub</code>配置<code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</code></li>\n<li>更新grub:<code>sudo update-grub</code></li>\n<li>重启</li>\n</ul>\n</li>\n</ul>\n"},{"title":"gcc编译器及编译原理","date":"2020-12-19T09:25:41.000Z","subtitle":null,"index_img":"/images/gcc.jpg","banner_img":"/images/gcc.jpg","_content":"# 基本概念\n**预处理:**`g++ -E main.cpp -o main.ii`,-E表示只进行预处理。预处理主要是处理各种宏的展开;添加行号和文件标识符,为编译器产生调试信息提供便利;删除注释;保留编译器用到的编译器指令等\n**编译:**`g++ -S main.ii -o main.s`,-S表示只编译。编译是在预处理的基础上经过一系列词法分析、语法分析及优化后生成汇编代码。\n**汇编:**`g++ -c main.s -o main.o`,汇编将汇编代码转换为机器可执行的指令\n**链接:**`g++ main.o`,链接生成可执行程序,之所以需要链接是因为我们的代码不可能像main.cpp这么简单,现代软件动则成百上千万行,如果写在一个main.cpp既不利于分工合作,也无法维护,因此通常是由一堆cpp文件组成,编译器分别编译每个cpp,这些cpp里会引用别的模块中的函数或全局变量,在编译单个cpp的时候是没法知道它们的准确地址,因此在编译结束后,需要连接器将各种还没有准确地址的符号(函数、变量等)设置为正确的值,这样组装在一起就可以形成一个完整的可执行程序\n# 选项\n- `-l<library>` 链接动态库\n- `-L<dir>` 动态库搜索目录\n- `-D<expression>` 宏定义命令中定义\n- `-I <dir>`头文件搜索目录\n- `-isystem`specify the include path for system headers path\n# 静态库编译和使用\n- `gcc -c increase.c -o increase.o`把.c编译成.o\n- `ar -r libincrease.a increase.o`归档成静态库.a\n- `gcc main.c -L -static -o main`链接成可执行文件\n- 环境变量：`LIBRARY_PATH`Specify the directories where search for static libraries .a at compile-time\n# 调试\n`g++ -O0 -g [-g3] <program.cpp> -o program\ngdb [--args] ./program <args...>`\n- -O0 Disable any code optimization for helping the debugger. It is implicit for most compilers\n- -g Enable debugging\n    - stores the symbol table information in the executable (mapping between assembly and source code lines)\n    - for some compilers, it may disable certain optimizations\n    - slow down the compilation phase and the execution\n- -g3 Produces enhanced debugging information, e.g. macro definitions. Available for most compilers. Suggested instead of -g \n# 动态库编译和使用\n- `gcc -shared -fPIC -o libinc.so increase.c`-fPIC生成位置独立的代码,此类代码可以在不同进程间共享\n- `gcc -lincrease -o main main.c`链接动态库\n```bash\ng++ source1.c -c source1.o -fPIC\ng++ source2.c -c source2.o -fPIC\ng++ source1.o source2.o -shared -o libmydynamiclib.so\n```\n- 环境变量：`LD_LIBRARY_PATH`Specify the directories where search for dynamic/shared libraries .dll at run-time\n# 内存检查\n## -fsanitize\n基本比Valgrind工具更好\n### address\nmemory error detector,Similar to valgrind but faster (50X slowdown)\n• heap/stack/global out-of-bounds\n• memory leaks\n• use-after-free, use-after-return, use-after-scope\n• double-free, invalid free\n• initialization order bugs\n`clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer <program>`\n### leak\na run-time memory leak detector\n`clang++ -O1 -g -fsanitize=leak -fno-omit-frame-pointer <program>`\n### memory\nis detector of uninitialized reads\n`clang++ -O1 -g -fsanitize=memory -fno-omit-frame-pointer <program>`\n### undefined\na undefined behavior detector\n- signed integer overflow, floating-point types overflow, enumerated not in range\n- out-of-bounds array indexing, misaligned address\n- divide by zero\n- etc.\n`clang++ -O1 -g -fsanitize=undefined -fno-omit-frame-pointer <program>`\n### integer\nChecks for undefined or suspicious integer behavior (e.g. unsigned integer overflow)\n### nullability\nChecks passing null as a function parameter, assigning null to an lvalue, and returning null from a function\n# Warn\n- `Wall`:Enables many standard warnings (∼50 warnings)\n- `Wextra`:Enables some extra warning flags that are not enabled by -Wall (∼15 warnings)\n- `Wpedantic`:Issue all the warnings demanded by strict ISO C/C++\n\n# 栈有关选项\n- `-Wstack-usage=<byte-size>` Warn if the stack usage of a function might exceed byte-size. The computation done to determine the stack usage is conservative (no VLA)\n- `fstack-usage` Makes the compiler output stack usage information for the\nprogram, on a per-function basis\n- `-Wvla` Warn if a variable-length array is used in the code\n- `-Wvla-larger-than=<byte-size>` Warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed byte-size bytes\n## _FORTIFY_SOURCE\nAdding FORTIFY SOURCE define, the compiler provides buffer overflow checks for the\nfollowing functions:\nmemcpy , mempcpy , memmove , memset , strcpy , stpcpy , strncpy , strcat ,\nstrncat , sprintf , vsprintf , snprintf , vsnprintf , gets .\n```C++\n# include <cstring> // std::memset\n# include <string> // std::stoi\nint main(int argc, char** argv) {\nint size = std::stoi(argv[1]);\nchar buffer[24];\nstd::memset(buffer, 0xFF, size);\n}\n```\n```bash\n$ gcc -O1 -D FORTIFY SOURCE program.cpp -o program\n$ ./program 12 # OK\n$ ./program 32 # Wrong\n$ *** buffer overflow detected ***: ./program terminated\n```\n","source":"_posts/gcc编译器及编译原理.md","raw":"---\ntitle: gcc编译器及编译原理\ndate: 2020-12-19 17:25:41\nsubtitle:\ncategories:\ntags:\nindex_img: /images/gcc.jpg\nbanner_img: /images/gcc.jpg\n---\n# 基本概念\n**预处理:**`g++ -E main.cpp -o main.ii`,-E表示只进行预处理。预处理主要是处理各种宏的展开;添加行号和文件标识符,为编译器产生调试信息提供便利;删除注释;保留编译器用到的编译器指令等\n**编译:**`g++ -S main.ii -o main.s`,-S表示只编译。编译是在预处理的基础上经过一系列词法分析、语法分析及优化后生成汇编代码。\n**汇编:**`g++ -c main.s -o main.o`,汇编将汇编代码转换为机器可执行的指令\n**链接:**`g++ main.o`,链接生成可执行程序,之所以需要链接是因为我们的代码不可能像main.cpp这么简单,现代软件动则成百上千万行,如果写在一个main.cpp既不利于分工合作,也无法维护,因此通常是由一堆cpp文件组成,编译器分别编译每个cpp,这些cpp里会引用别的模块中的函数或全局变量,在编译单个cpp的时候是没法知道它们的准确地址,因此在编译结束后,需要连接器将各种还没有准确地址的符号(函数、变量等)设置为正确的值,这样组装在一起就可以形成一个完整的可执行程序\n# 选项\n- `-l<library>` 链接动态库\n- `-L<dir>` 动态库搜索目录\n- `-D<expression>` 宏定义命令中定义\n- `-I <dir>`头文件搜索目录\n- `-isystem`specify the include path for system headers path\n# 静态库编译和使用\n- `gcc -c increase.c -o increase.o`把.c编译成.o\n- `ar -r libincrease.a increase.o`归档成静态库.a\n- `gcc main.c -L -static -o main`链接成可执行文件\n- 环境变量：`LIBRARY_PATH`Specify the directories where search for static libraries .a at compile-time\n# 调试\n`g++ -O0 -g [-g3] <program.cpp> -o program\ngdb [--args] ./program <args...>`\n- -O0 Disable any code optimization for helping the debugger. It is implicit for most compilers\n- -g Enable debugging\n    - stores the symbol table information in the executable (mapping between assembly and source code lines)\n    - for some compilers, it may disable certain optimizations\n    - slow down the compilation phase and the execution\n- -g3 Produces enhanced debugging information, e.g. macro definitions. Available for most compilers. Suggested instead of -g \n# 动态库编译和使用\n- `gcc -shared -fPIC -o libinc.so increase.c`-fPIC生成位置独立的代码,此类代码可以在不同进程间共享\n- `gcc -lincrease -o main main.c`链接动态库\n```bash\ng++ source1.c -c source1.o -fPIC\ng++ source2.c -c source2.o -fPIC\ng++ source1.o source2.o -shared -o libmydynamiclib.so\n```\n- 环境变量：`LD_LIBRARY_PATH`Specify the directories where search for dynamic/shared libraries .dll at run-time\n# 内存检查\n## -fsanitize\n基本比Valgrind工具更好\n### address\nmemory error detector,Similar to valgrind but faster (50X slowdown)\n• heap/stack/global out-of-bounds\n• memory leaks\n• use-after-free, use-after-return, use-after-scope\n• double-free, invalid free\n• initialization order bugs\n`clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer <program>`\n### leak\na run-time memory leak detector\n`clang++ -O1 -g -fsanitize=leak -fno-omit-frame-pointer <program>`\n### memory\nis detector of uninitialized reads\n`clang++ -O1 -g -fsanitize=memory -fno-omit-frame-pointer <program>`\n### undefined\na undefined behavior detector\n- signed integer overflow, floating-point types overflow, enumerated not in range\n- out-of-bounds array indexing, misaligned address\n- divide by zero\n- etc.\n`clang++ -O1 -g -fsanitize=undefined -fno-omit-frame-pointer <program>`\n### integer\nChecks for undefined or suspicious integer behavior (e.g. unsigned integer overflow)\n### nullability\nChecks passing null as a function parameter, assigning null to an lvalue, and returning null from a function\n# Warn\n- `Wall`:Enables many standard warnings (∼50 warnings)\n- `Wextra`:Enables some extra warning flags that are not enabled by -Wall (∼15 warnings)\n- `Wpedantic`:Issue all the warnings demanded by strict ISO C/C++\n\n# 栈有关选项\n- `-Wstack-usage=<byte-size>` Warn if the stack usage of a function might exceed byte-size. The computation done to determine the stack usage is conservative (no VLA)\n- `fstack-usage` Makes the compiler output stack usage information for the\nprogram, on a per-function basis\n- `-Wvla` Warn if a variable-length array is used in the code\n- `-Wvla-larger-than=<byte-size>` Warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed byte-size bytes\n## _FORTIFY_SOURCE\nAdding FORTIFY SOURCE define, the compiler provides buffer overflow checks for the\nfollowing functions:\nmemcpy , mempcpy , memmove , memset , strcpy , stpcpy , strncpy , strcat ,\nstrncat , sprintf , vsprintf , snprintf , vsnprintf , gets .\n```C++\n# include <cstring> // std::memset\n# include <string> // std::stoi\nint main(int argc, char** argv) {\nint size = std::stoi(argv[1]);\nchar buffer[24];\nstd::memset(buffer, 0xFF, size);\n}\n```\n```bash\n$ gcc -O1 -D FORTIFY SOURCE program.cpp -o program\n$ ./program 12 # OK\n$ ./program 32 # Wrong\n$ *** buffer overflow detected ***: ./program terminated\n```\n","slug":"gcc编译器及编译原理","published":1,"updated":"2024-04-04T21:12:07.838Z","_id":"clq1yvi71000vgwq20iz06mj2","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p><strong>预处理:</strong><code>g++ -E main.cpp -o main.ii</code>,-E表示只进行预处理。预处理主要是处理各种宏的展开;添加行号和文件标识符,为编译器产生调试信息提供便利;删除注释;保留编译器用到的编译器指令等<br><strong>编译:</strong><code>g++ -S main.ii -o main.s</code>,-S表示只编译。编译是在预处理的基础上经过一系列词法分析、语法分析及优化后生成汇编代码。<br><strong>汇编:</strong><code>g++ -c main.s -o main.o</code>,汇编将汇编代码转换为机器可执行的指令<br><strong>链接:</strong><code>g++ main.o</code>,链接生成可执行程序,之所以需要链接是因为我们的代码不可能像main.cpp这么简单,现代软件动则成百上千万行,如果写在一个main.cpp既不利于分工合作,也无法维护,因此通常是由一堆cpp文件组成,编译器分别编译每个cpp,这些cpp里会引用别的模块中的函数或全局变量,在编译单个cpp的时候是没法知道它们的准确地址,因此在编译结束后,需要连接器将各种还没有准确地址的符号(函数、变量等)设置为正确的值,这样组装在一起就可以形成一个完整的可执行程序</p>\n<h1 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h1><ul>\n<li><code>-l&lt;library&gt;</code> 链接动态库</li>\n<li><code>-L&lt;dir&gt;</code> 动态库搜索目录</li>\n<li><code>-D&lt;expression&gt;</code> 宏定义命令中定义</li>\n<li><code>-I &lt;dir&gt;</code>头文件搜索目录</li>\n<li><code>-isystem</code>specify the include path for system headers path</li>\n</ul>\n<h1 id=\"静态库编译和使用\"><a href=\"#静态库编译和使用\" class=\"headerlink\" title=\"静态库编译和使用\"></a>静态库编译和使用</h1><ul>\n<li><code>gcc -c increase.c -o increase.o</code>把.c编译成.o</li>\n<li><code>ar -r libincrease.a increase.o</code>归档成静态库.a</li>\n<li><code>gcc main.c -L -static -o main</code>链接成可执行文件</li>\n<li>环境变量：<code>LIBRARY_PATH</code>Specify the directories where search for static libraries .a at compile-time</li>\n</ul>\n<h1 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h1><p><code>g++ -O0 -g [-g3] &lt;program.cpp&gt; -o program gdb [--args] ./program &lt;args...&gt;</code></p>\n<ul>\n<li>-O0 Disable any code optimization for helping the debugger. It is implicit for most compilers</li>\n<li>-g Enable debugging<ul>\n<li>stores the symbol table information in the executable (mapping between assembly and source code lines)</li>\n<li>for some compilers, it may disable certain optimizations</li>\n<li>slow down the compilation phase and the execution</li>\n</ul>\n</li>\n<li>-g3 Produces enhanced debugging information, e.g. macro definitions. Available for most compilers. Suggested instead of -g</li>\n</ul>\n<h1 id=\"动态库编译和使用\"><a href=\"#动态库编译和使用\" class=\"headerlink\" title=\"动态库编译和使用\"></a>动态库编译和使用</h1><ul>\n<li><code>gcc -shared -fPIC -o libinc.so increase.c</code>-fPIC生成位置独立的代码,此类代码可以在不同进程间共享</li>\n<li><code>gcc -lincrease -o main main.c</code>链接动态库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">g++ source1.c -c source1.o -fPIC<br>g++ source2.c -c source2.o -fPIC<br>g++ source1.o source2.o -shared -o libmydynamiclib.so<br></code></pre></td></tr></table></figure></li>\n<li>环境变量：<code>LD_LIBRARY_PATH</code>Specify the directories where search for dynamic&#x2F;shared libraries .dll at run-time</li>\n</ul>\n<h1 id=\"内存检查\"><a href=\"#内存检查\" class=\"headerlink\" title=\"内存检查\"></a>内存检查</h1><h2 id=\"fsanitize\"><a href=\"#fsanitize\" class=\"headerlink\" title=\"-fsanitize\"></a>-fsanitize</h2><p>基本比Valgrind工具更好</p>\n<h3 id=\"address\"><a href=\"#address\" class=\"headerlink\" title=\"address\"></a>address</h3><p>memory error detector,Similar to valgrind but faster (50X slowdown)<br>• heap&#x2F;stack&#x2F;global out-of-bounds<br>• memory leaks<br>• use-after-free, use-after-return, use-after-scope<br>• double-free, invalid free<br>• initialization order bugs<br><code>clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer &lt;program&gt;</code></p>\n<h3 id=\"leak\"><a href=\"#leak\" class=\"headerlink\" title=\"leak\"></a>leak</h3><p>a run-time memory leak detector<br><code>clang++ -O1 -g -fsanitize=leak -fno-omit-frame-pointer &lt;program&gt;</code></p>\n<h3 id=\"memory\"><a href=\"#memory\" class=\"headerlink\" title=\"memory\"></a>memory</h3><p>is detector of uninitialized reads<br><code>clang++ -O1 -g -fsanitize=memory -fno-omit-frame-pointer &lt;program&gt;</code></p>\n<h3 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h3><p>a undefined behavior detector</p>\n<ul>\n<li>signed integer overflow, floating-point types overflow, enumerated not in range</li>\n<li>out-of-bounds array indexing, misaligned address</li>\n<li>divide by zero</li>\n<li>etc.<br><code>clang++ -O1 -g -fsanitize=undefined -fno-omit-frame-pointer &lt;program&gt;</code></li>\n</ul>\n<h3 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h3><p>Checks for undefined or suspicious integer behavior (e.g. unsigned integer overflow)</p>\n<h3 id=\"nullability\"><a href=\"#nullability\" class=\"headerlink\" title=\"nullability\"></a>nullability</h3><p>Checks passing null as a function parameter, assigning null to an lvalue, and returning null from a function</p>\n<h1 id=\"Warn\"><a href=\"#Warn\" class=\"headerlink\" title=\"Warn\"></a>Warn</h1><ul>\n<li><code>Wall</code>:Enables many standard warnings (∼50 warnings)</li>\n<li><code>Wextra</code>:Enables some extra warning flags that are not enabled by -Wall (∼15 warnings)</li>\n<li><code>Wpedantic</code>:Issue all the warnings demanded by strict ISO C&#x2F;C++</li>\n</ul>\n<h1 id=\"栈有关选项\"><a href=\"#栈有关选项\" class=\"headerlink\" title=\"栈有关选项\"></a>栈有关选项</h1><ul>\n<li><code>-Wstack-usage=&lt;byte-size&gt;</code> Warn if the stack usage of a function might exceed byte-size. The computation done to determine the stack usage is conservative (no VLA)</li>\n<li><code>fstack-usage</code> Makes the compiler output stack usage information for the<br>program, on a per-function basis</li>\n<li><code>-Wvla</code> Warn if a variable-length array is used in the code</li>\n<li><code>-Wvla-larger-than=&lt;byte-size&gt;</code> Warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed byte-size bytes</li>\n</ul>\n<h2 id=\"FORTIFY-SOURCE\"><a href=\"#FORTIFY-SOURCE\" class=\"headerlink\" title=\"_FORTIFY_SOURCE\"></a>_FORTIFY_SOURCE</h2><p>Adding FORTIFY SOURCE define, the compiler provides buffer overflow checks for the<br>following functions:<br>memcpy , mempcpy , memmove , memset , strcpy , stpcpy , strncpy , strcat ,<br>strncat , sprintf , vsprintf , snprintf , vsnprintf , gets .</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span> <span class=\"hljs-comment\">// std::memset</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span> <span class=\"hljs-comment\">// std::stoi</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>** argv)</span> </span>&#123;<br><span class=\"hljs-type\">int</span> size = std::<span class=\"hljs-built_in\">stoi</span>(argv[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">24</span>];<br>std::<span class=\"hljs-built_in\">memset</span>(buffer, <span class=\"hljs-number\">0xFF</span>, size);<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ gcc -O1 -D FORTIFY SOURCE program.cpp -o program<br>$ ./program 12 <span class=\"hljs-comment\"># OK</span><br>$ ./program 32 <span class=\"hljs-comment\"># Wrong</span><br>$ *** buffer overflow detected ***: ./program terminated<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p><strong>预处理:</strong><code>g++ -E main.cpp -o main.ii</code>,-E表示只进行预处理。预处理主要是处理各种宏的展开;添加行号和文件标识符,为编译器产生调试信息提供便利;删除注释;保留编译器用到的编译器指令等<br><strong>编译:</strong><code>g++ -S main.ii -o main.s</code>,-S表示只编译。编译是在预处理的基础上经过一系列词法分析、语法分析及优化后生成汇编代码。<br><strong>汇编:</strong><code>g++ -c main.s -o main.o</code>,汇编将汇编代码转换为机器可执行的指令<br><strong>链接:</strong><code>g++ main.o</code>,链接生成可执行程序,之所以需要链接是因为我们的代码不可能像main.cpp这么简单,现代软件动则成百上千万行,如果写在一个main.cpp既不利于分工合作,也无法维护,因此通常是由一堆cpp文件组成,编译器分别编译每个cpp,这些cpp里会引用别的模块中的函数或全局变量,在编译单个cpp的时候是没法知道它们的准确地址,因此在编译结束后,需要连接器将各种还没有准确地址的符号(函数、变量等)设置为正确的值,这样组装在一起就可以形成一个完整的可执行程序</p>\n<h1 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h1><ul>\n<li><code>-l&lt;library&gt;</code> 链接动态库</li>\n<li><code>-L&lt;dir&gt;</code> 动态库搜索目录</li>\n<li><code>-D&lt;expression&gt;</code> 宏定义命令中定义</li>\n<li><code>-I &lt;dir&gt;</code>头文件搜索目录</li>\n<li><code>-isystem</code>specify the include path for system headers path</li>\n</ul>\n<h1 id=\"静态库编译和使用\"><a href=\"#静态库编译和使用\" class=\"headerlink\" title=\"静态库编译和使用\"></a>静态库编译和使用</h1><ul>\n<li><code>gcc -c increase.c -o increase.o</code>把.c编译成.o</li>\n<li><code>ar -r libincrease.a increase.o</code>归档成静态库.a</li>\n<li><code>gcc main.c -L -static -o main</code>链接成可执行文件</li>\n<li>环境变量：<code>LIBRARY_PATH</code>Specify the directories where search for static libraries .a at compile-time</li>\n</ul>\n<h1 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h1><p><code>g++ -O0 -g [-g3] &lt;program.cpp&gt; -o program gdb [--args] ./program &lt;args...&gt;</code></p>\n<ul>\n<li>-O0 Disable any code optimization for helping the debugger. It is implicit for most compilers</li>\n<li>-g Enable debugging<ul>\n<li>stores the symbol table information in the executable (mapping between assembly and source code lines)</li>\n<li>for some compilers, it may disable certain optimizations</li>\n<li>slow down the compilation phase and the execution</li>\n</ul>\n</li>\n<li>-g3 Produces enhanced debugging information, e.g. macro definitions. Available for most compilers. Suggested instead of -g</li>\n</ul>\n<h1 id=\"动态库编译和使用\"><a href=\"#动态库编译和使用\" class=\"headerlink\" title=\"动态库编译和使用\"></a>动态库编译和使用</h1><ul>\n<li><code>gcc -shared -fPIC -o libinc.so increase.c</code>-fPIC生成位置独立的代码,此类代码可以在不同进程间共享</li>\n<li><code>gcc -lincrease -o main main.c</code>链接动态库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">g++ source1.c -c source1.o -fPIC<br>g++ source2.c -c source2.o -fPIC<br>g++ source1.o source2.o -shared -o libmydynamiclib.so<br></code></pre></td></tr></table></figure></li>\n<li>环境变量：<code>LD_LIBRARY_PATH</code>Specify the directories where search for dynamic&#x2F;shared libraries .dll at run-time</li>\n</ul>\n<h1 id=\"内存检查\"><a href=\"#内存检查\" class=\"headerlink\" title=\"内存检查\"></a>内存检查</h1><h2 id=\"fsanitize\"><a href=\"#fsanitize\" class=\"headerlink\" title=\"-fsanitize\"></a>-fsanitize</h2><p>基本比Valgrind工具更好</p>\n<h3 id=\"address\"><a href=\"#address\" class=\"headerlink\" title=\"address\"></a>address</h3><p>memory error detector,Similar to valgrind but faster (50X slowdown)<br>• heap&#x2F;stack&#x2F;global out-of-bounds<br>• memory leaks<br>• use-after-free, use-after-return, use-after-scope<br>• double-free, invalid free<br>• initialization order bugs<br><code>clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer &lt;program&gt;</code></p>\n<h3 id=\"leak\"><a href=\"#leak\" class=\"headerlink\" title=\"leak\"></a>leak</h3><p>a run-time memory leak detector<br><code>clang++ -O1 -g -fsanitize=leak -fno-omit-frame-pointer &lt;program&gt;</code></p>\n<h3 id=\"memory\"><a href=\"#memory\" class=\"headerlink\" title=\"memory\"></a>memory</h3><p>is detector of uninitialized reads<br><code>clang++ -O1 -g -fsanitize=memory -fno-omit-frame-pointer &lt;program&gt;</code></p>\n<h3 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h3><p>a undefined behavior detector</p>\n<ul>\n<li>signed integer overflow, floating-point types overflow, enumerated not in range</li>\n<li>out-of-bounds array indexing, misaligned address</li>\n<li>divide by zero</li>\n<li>etc.<br><code>clang++ -O1 -g -fsanitize=undefined -fno-omit-frame-pointer &lt;program&gt;</code></li>\n</ul>\n<h3 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h3><p>Checks for undefined or suspicious integer behavior (e.g. unsigned integer overflow)</p>\n<h3 id=\"nullability\"><a href=\"#nullability\" class=\"headerlink\" title=\"nullability\"></a>nullability</h3><p>Checks passing null as a function parameter, assigning null to an lvalue, and returning null from a function</p>\n<h1 id=\"Warn\"><a href=\"#Warn\" class=\"headerlink\" title=\"Warn\"></a>Warn</h1><ul>\n<li><code>Wall</code>:Enables many standard warnings (∼50 warnings)</li>\n<li><code>Wextra</code>:Enables some extra warning flags that are not enabled by -Wall (∼15 warnings)</li>\n<li><code>Wpedantic</code>:Issue all the warnings demanded by strict ISO C&#x2F;C++</li>\n</ul>\n<h1 id=\"栈有关选项\"><a href=\"#栈有关选项\" class=\"headerlink\" title=\"栈有关选项\"></a>栈有关选项</h1><ul>\n<li><code>-Wstack-usage=&lt;byte-size&gt;</code> Warn if the stack usage of a function might exceed byte-size. The computation done to determine the stack usage is conservative (no VLA)</li>\n<li><code>fstack-usage</code> Makes the compiler output stack usage information for the<br>program, on a per-function basis</li>\n<li><code>-Wvla</code> Warn if a variable-length array is used in the code</li>\n<li><code>-Wvla-larger-than=&lt;byte-size&gt;</code> Warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed byte-size bytes</li>\n</ul>\n<h2 id=\"FORTIFY-SOURCE\"><a href=\"#FORTIFY-SOURCE\" class=\"headerlink\" title=\"_FORTIFY_SOURCE\"></a>_FORTIFY_SOURCE</h2><p>Adding FORTIFY SOURCE define, the compiler provides buffer overflow checks for the<br>following functions:<br>memcpy , mempcpy , memmove , memset , strcpy , stpcpy , strncpy , strcat ,<br>strncat , sprintf , vsprintf , snprintf , vsnprintf , gets .</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span> <span class=\"hljs-comment\">// std::memset</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span> <span class=\"hljs-comment\">// std::stoi</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>** argv)</span> </span>&#123;<br><span class=\"hljs-type\">int</span> size = std::<span class=\"hljs-built_in\">stoi</span>(argv[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">24</span>];<br>std::<span class=\"hljs-built_in\">memset</span>(buffer, <span class=\"hljs-number\">0xFF</span>, size);<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ gcc -O1 -D FORTIFY SOURCE program.cpp -o program<br>$ ./program 12 <span class=\"hljs-comment\"># OK</span><br>$ ./program 32 <span class=\"hljs-comment\"># Wrong</span><br>$ *** buffer overflow detected ***: ./program terminated<br></code></pre></td></tr></table></figure>\n"},{"title":"git","date":"2021-03-31T14:50:40.000Z","subtitle":null,"index_img":"/images/git.jpg","banner_img":"/images/git.jpg","_content":"# git预设置(~/.gitconfig)\n- `git config --global user.name \"xxx\"`\n- `git config --global user.email \"xx.com\"`\n- `git config --list`检查已有配置信息\n- `git config --global core.editor vim`配置默认编辑器\n- `git config --global alias.comi commit`命令的别名\n- `git config --global credential.helper cache`设置无密码推送\n- `git config --global alias.st \"status\"`设置status的别名为st\n- `git config --global alias.st \"status\"`设置status的别名为st\n- `git config --global --replace-all alias.lg  \"log --pretty=format:'%C(auto) %h | %ai | %Cred %an %Cgreen %s'\"`推荐设置log的别名\n# git 初始化\n`git init`初始化仓库，并建立.git子目录\n# `git status`\n`-s`:简单展现，A表示新添加到缓存区,左边M表示文件被修改并放入缓存区,右边M表示文件被修改并没有放入缓存区,??问号表示未被跟踪的文件\n# `git add <files>`\n跟踪文件并加入暂存区,可以通过`git ls-files --stage`来查看暂存区的文件\n# `git diff`显示更为详细的变化\n- 默认比较工作目录与缓存区间的差异\n- `--cached`比较缓存区与已提交的差异\n- HEAD查看所有改动\n- --stat:显示摘要\n# `git commit`\n注释行里会有最后一次运行git status的输出\n- -v:会将diff输出加入到注释行\n- -m:将提交信息与命令放在同一行\n- -a:可以将所有跟踪文件跳过add步骤直接commit\n- --amend:上次提交后发现忘了几个文件,可以add之后再加上此选项提交将会覆盖上次提交。\n# `git rm <files>`\n- 移除缓存区文件并且工作目录也一并移除\n- --cached:只删除缓存区,保留工作目录\n# `git mv`移动文件\n- 等价于'mv file1 file2;git rm file1;git add README'\n# `git log`显示提交记录(git shortlog 显示简短的记录)\n- -p:显示每次提交的差异\n- -(n):显示最近n次提交\n- --since,--after:仅显示指定时间之后的提交\n- --until,--before:仅显示指定时间之前的提交\n- --author:仅显示指定作者相关的提交\n- --committer:仅显示指定提交者相关的提交\n- --grep:仅显示含指定关键字的提交\n- -S:仅显示添加或移除了某个关键字的提交\n- --stat:简略信息\n- --graph:显示ASCLL图形表示分支的合并历史\n- --relative-date:使用较短的相对时间显示\n- --abbrev-commit:仅显示SHA-1的前几个字符,而非所有的40个字符\n- --name-status:显示增删改的文件清单\n- --name-only:仅在提交信息后显示以修改的文件清单\n- --pretty=format:\"<格式>\":指定格式输出\n  <格式>有如下：\n\n  |选项|说明|\n  | :-: | :-: |\n  |%H|提交对象(commit)的完整哈希字串|\n  |%h|提交对象的简短哈希字串|\n  |%T|树对象的完整哈希字串|\n  |%t|树对象的简短哈希字串|\n  |%P|父对象的完整哈希字串|\n  |%p|父对象的简短哈希字串|\n  |%an|作者的名字|\n  |%ae|作者的邮件|\n  |%ad|作者修订日期|\n  |%ar|作者修订日期,按多久以前的方式显示|\n  |%cn|提交者的名字|\n  |%ce|提交者的电子邮件|\n  |%cd|提交日期|\n  |%cr|提交日期,按多久以前的方式显示|\n  |%s|提交说明|\n\n# 回退\n- `git reset HEAD <file>`(适用已提交add):撤销某个暂存文件,即将add退回\n- `git reset HEAD\\~1`:回退到上一个版本\n- `git reset --hard <commit_id>`注意此步骤会将commit_id后的commit删除,最好不用\n- `git push origin HEAD --force`让服务器也回退到某版本(本地仓库已回退)\n- `git revert HEAD`回退到HEAD上一个版本,但是树结构往下走，只不过与父节点相同\n- `git checkout [file]`(未git add的情况下):撤销某个工作目录下文件的修改,恢复为版本库中一模一样的版本,危险的命令,你的修改将不会保存\n# `git remote`远程仓库的使用\n- -v:显示简写对应的url\n- `show origin`:展示origin的具体信息\n- `rename o1 o2`:重命名某个远程\n- `rm xx`:移除某个远程\n- `add xx`:增加某个远程\n- `prune origin`:删除本地在远程服务器上不存在的分支\n# `git push <remote-name> <branch-name>`\n- `--tags`:推送所有标签\n- 使用git push <远程主机名(origin)> <本地分支名>:<远程分支名>\n- `git push --set-upstream <remote_name> <branch_name>`将远程分支作为当前分支的上游分支,--unset-upstream,则是删除这种关联\n# 远程拉取\n- git fetch:会抓取数据到本地数据库，但不会自动合并并修改当前工作\n- git clone:会自动将其添加为远程仓库并默认以'origin'缩写,并自动跟踪远程master\n- git pull:主区数据并自动尝试合并到当前所在分支\n# git tag\n- -a:增加个标签,可以在后面加个校验和,为指定的补打标签\n- -m:在命令行增加说明\n- -d:删除某个标签\n- -l:列举标签\n- <tag_name> <commit_id>:为某个哈希打标签,必须显示地推送标签至远程库'git push origin v1.5',当某个标签被删除或信息改变'git push origin  :refs/tags/<tag_name>'\n- `git branch <new-branch-name> <tag-name>`从指定的标签拉取一个分支出来\n- `git show <tag_name>`查看tag信息\n# 分支管理\n- `git clone -b <分支名> <仓库地址>`克隆指定分支\n- `git fetch origin <branch_name>`抓取某个远程分支\n- `git branch xxx`创建分支,不加任何xxx会显示所有分支\n- `git log --oneline --decorate`查看各个分支当前所指对象\n- `git checkout xxx`切换分支,切换分支会改变工作目录里的文件\n- `git log --oneline --decorate --graph --all`查看分叉历史\n- `git merge xxbranch`合并指定分支到当前分支,如果当前分支可以沿着一条线走下去则会有'fast-forward提示'\n- `git merge --abort`取消当前合并,重建合并前状态\n- `git merge --no-commit xxbranch`合并到本地文件,之后需要手动commit,xxbranch仍是新节点的父节点\n- `git merge --squash xxbranch`生成本地diff,patch,手动提交后,与xxbranch不构成父子节点\n- `git checkout -b serverfix origin/serverfix`跟踪远程库其他分支等价于`git checkout --track orighin/serverfix`\n- `git push origin --delete xxx` 删除远程分支\n## git branch 选项\n- -d xxx: 删除分支\n- -D xxx:强制删除某个未合并的分支\n- -v:显示每个分支最后的提交\n- --merged:查看所有已与当前分支合并的分支\n- --no-merged:查看所有未与当前分支合并的分支\n- -f some hash:强制some分支移动到某hash版本\n- `-u origin:master`:设置当前分支跟踪远程分支\n- `-r`:显示所有远程分支\n- `-a`:显示所有本地和远程分支\n## `git rebase` \n- `git rebase xxx`把当前分支衍合到xxx分支\n- `git rebase --onto master server client`把server与client共同祖先之后的变化加到master中去\n- `git rebase -i xx`以他为xx基础或其共同祖先节点进行交互界面的rebase\n## `git cherry-pick a b c`把a,b,c等应用到当前分支\n## `git describe <branch>`会输出以下信息\n`<最近的tag>_<tag距离分支几个节点>_<当前分支hash值>`\n## `^`第一个父提交`^2`第二个父提交`~2`爷爷提交\n## 格式:`[source:destination]`\n# 高级\n## `git stash`\n备份当前的工作区内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到git栈中\n- `git stash list`显示所有栈内的备份\n- `git stash apply <stash_name>`从栈中读取最新一次保存的内容，恢复工作区的相关内容\n- `git stash pop`删除最新的暂存\n- `git stash drop<stash_name>`删除指定暂存\n# 建议规范\n## 推荐的分支管理\n- `master`:主分支,禁止直接在master上进行代码的提交和修改,此分支的代码可以随时被发布到线上\n- `develop`:测试分支,所有开发完成需要提交测试的功能合并到该分支,该分支包含最新的更改\n- `feature`:开发分支,大家根据不同需求创建独立的功能分支,开发后合并到develop分支\n- `fix`:分支为bug修复分支,需要根据实际情况对已发布的版本进行漏洞修复\n## 标签tag管理\nTag采用三段式:v版本.里程碑.序号(v2.3.1)\n- 第一位:架构升级或架构重大调整\n- 第二位:新功能上线或模块大的调整\n- 第三位:bug修复\n## 提交信息格式\n### 中文:\n- -<新功能>添加解析url功能\n- -<修改>修改某功能的某个实现为另一个实先\n- -<Bug修复>修复url的特殊情况下解析失败的问题\n- -<重构>重构获取数据的方法\n- -<测试>添加(修改、删除)获取数据的单元测试代码\n- -<文档>修改(添加、删除)文档\n### 英文:\n- -feat:新功能\n- -fix:修补bug\n- -refactor:重构\n- -test:测试相关\n- -docs:文档\n# .gitignore\n该文件里的文件夹和文件(可以使用通配符`*`,`!`,`?`,`[a-zA-Z]`等，具体看)不被加入版本控制中，也就不会出现在git status中(文件.gitignore本身还是会untrack状态),git add的时候不会被加入，这里仅局限于untracked file，那些Staged file，不受.gitignore影响\n- 每一行定义一个或一组文件夹或文件，以`/`结尾的只匹配文件夹，否则，可以匹配文件或文件夹\n- 以`!`开头的，如果有冲突，会把之前模式匹配的覆盖掉\n- 如果一个文件夹已经被匹配，那么其子文件夹和文件就不受其他模式影响\n- `**/foo`匹配任何位置的foo，类似的`a/**/b`匹配`a/x/b`,`a/b`等\n\n# 常见问题技巧:\n- 推送要密码,改成ssh认证,在.git/config里修改remote地址,从仓库复制过去ssh地址,不用httpServer,因为它就是默认用密码登录,也可以从命令行修改\n- 仓库中所有文件的sha1值在.git目录中的objects文件夹下，想要根据sha1值查看文件内容，可以用`git cat-file -p [sha1值]`注意，objects中只有两个数字的文件夹是该文件夹下所有文件内容的sha1值的前两位，所以要拼接一下，当然你如果用命令知道它的完整sha1值就不用拼接了\n- `gitjk`有用的命令，可以查看如何撤销上个命令,可以从网上下载该工具，需要npm\n- `git log --tags --simplify-by-decoration --pretty=\"format:%ci %d\"`通过log来看tag,并且加上了日期\n- 加了ssh-key死活连不上\n    1. 在.ssh文件夹下加个config文件,内容如下：\n ```c++\nHost github.com\nUser 2726905171@qq.com\nHostname ssh.github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_ed25519\nPort 443\n ```\n    2. 之后执行命令`ssh-add 私钥位置`\n","source":"_posts/git.md","raw":"---\ntitle: git\ndate: 2021-03-31 22:50:40\nsubtitle:\ncategories:\ntags:\nindex_img: /images/git.jpg\nbanner_img: /images/git.jpg\n---\n# git预设置(~/.gitconfig)\n- `git config --global user.name \"xxx\"`\n- `git config --global user.email \"xx.com\"`\n- `git config --list`检查已有配置信息\n- `git config --global core.editor vim`配置默认编辑器\n- `git config --global alias.comi commit`命令的别名\n- `git config --global credential.helper cache`设置无密码推送\n- `git config --global alias.st \"status\"`设置status的别名为st\n- `git config --global alias.st \"status\"`设置status的别名为st\n- `git config --global --replace-all alias.lg  \"log --pretty=format:'%C(auto) %h | %ai | %Cred %an %Cgreen %s'\"`推荐设置log的别名\n# git 初始化\n`git init`初始化仓库，并建立.git子目录\n# `git status`\n`-s`:简单展现，A表示新添加到缓存区,左边M表示文件被修改并放入缓存区,右边M表示文件被修改并没有放入缓存区,??问号表示未被跟踪的文件\n# `git add <files>`\n跟踪文件并加入暂存区,可以通过`git ls-files --stage`来查看暂存区的文件\n# `git diff`显示更为详细的变化\n- 默认比较工作目录与缓存区间的差异\n- `--cached`比较缓存区与已提交的差异\n- HEAD查看所有改动\n- --stat:显示摘要\n# `git commit`\n注释行里会有最后一次运行git status的输出\n- -v:会将diff输出加入到注释行\n- -m:将提交信息与命令放在同一行\n- -a:可以将所有跟踪文件跳过add步骤直接commit\n- --amend:上次提交后发现忘了几个文件,可以add之后再加上此选项提交将会覆盖上次提交。\n# `git rm <files>`\n- 移除缓存区文件并且工作目录也一并移除\n- --cached:只删除缓存区,保留工作目录\n# `git mv`移动文件\n- 等价于'mv file1 file2;git rm file1;git add README'\n# `git log`显示提交记录(git shortlog 显示简短的记录)\n- -p:显示每次提交的差异\n- -(n):显示最近n次提交\n- --since,--after:仅显示指定时间之后的提交\n- --until,--before:仅显示指定时间之前的提交\n- --author:仅显示指定作者相关的提交\n- --committer:仅显示指定提交者相关的提交\n- --grep:仅显示含指定关键字的提交\n- -S:仅显示添加或移除了某个关键字的提交\n- --stat:简略信息\n- --graph:显示ASCLL图形表示分支的合并历史\n- --relative-date:使用较短的相对时间显示\n- --abbrev-commit:仅显示SHA-1的前几个字符,而非所有的40个字符\n- --name-status:显示增删改的文件清单\n- --name-only:仅在提交信息后显示以修改的文件清单\n- --pretty=format:\"<格式>\":指定格式输出\n  <格式>有如下：\n\n  |选项|说明|\n  | :-: | :-: |\n  |%H|提交对象(commit)的完整哈希字串|\n  |%h|提交对象的简短哈希字串|\n  |%T|树对象的完整哈希字串|\n  |%t|树对象的简短哈希字串|\n  |%P|父对象的完整哈希字串|\n  |%p|父对象的简短哈希字串|\n  |%an|作者的名字|\n  |%ae|作者的邮件|\n  |%ad|作者修订日期|\n  |%ar|作者修订日期,按多久以前的方式显示|\n  |%cn|提交者的名字|\n  |%ce|提交者的电子邮件|\n  |%cd|提交日期|\n  |%cr|提交日期,按多久以前的方式显示|\n  |%s|提交说明|\n\n# 回退\n- `git reset HEAD <file>`(适用已提交add):撤销某个暂存文件,即将add退回\n- `git reset HEAD\\~1`:回退到上一个版本\n- `git reset --hard <commit_id>`注意此步骤会将commit_id后的commit删除,最好不用\n- `git push origin HEAD --force`让服务器也回退到某版本(本地仓库已回退)\n- `git revert HEAD`回退到HEAD上一个版本,但是树结构往下走，只不过与父节点相同\n- `git checkout [file]`(未git add的情况下):撤销某个工作目录下文件的修改,恢复为版本库中一模一样的版本,危险的命令,你的修改将不会保存\n# `git remote`远程仓库的使用\n- -v:显示简写对应的url\n- `show origin`:展示origin的具体信息\n- `rename o1 o2`:重命名某个远程\n- `rm xx`:移除某个远程\n- `add xx`:增加某个远程\n- `prune origin`:删除本地在远程服务器上不存在的分支\n# `git push <remote-name> <branch-name>`\n- `--tags`:推送所有标签\n- 使用git push <远程主机名(origin)> <本地分支名>:<远程分支名>\n- `git push --set-upstream <remote_name> <branch_name>`将远程分支作为当前分支的上游分支,--unset-upstream,则是删除这种关联\n# 远程拉取\n- git fetch:会抓取数据到本地数据库，但不会自动合并并修改当前工作\n- git clone:会自动将其添加为远程仓库并默认以'origin'缩写,并自动跟踪远程master\n- git pull:主区数据并自动尝试合并到当前所在分支\n# git tag\n- -a:增加个标签,可以在后面加个校验和,为指定的补打标签\n- -m:在命令行增加说明\n- -d:删除某个标签\n- -l:列举标签\n- <tag_name> <commit_id>:为某个哈希打标签,必须显示地推送标签至远程库'git push origin v1.5',当某个标签被删除或信息改变'git push origin  :refs/tags/<tag_name>'\n- `git branch <new-branch-name> <tag-name>`从指定的标签拉取一个分支出来\n- `git show <tag_name>`查看tag信息\n# 分支管理\n- `git clone -b <分支名> <仓库地址>`克隆指定分支\n- `git fetch origin <branch_name>`抓取某个远程分支\n- `git branch xxx`创建分支,不加任何xxx会显示所有分支\n- `git log --oneline --decorate`查看各个分支当前所指对象\n- `git checkout xxx`切换分支,切换分支会改变工作目录里的文件\n- `git log --oneline --decorate --graph --all`查看分叉历史\n- `git merge xxbranch`合并指定分支到当前分支,如果当前分支可以沿着一条线走下去则会有'fast-forward提示'\n- `git merge --abort`取消当前合并,重建合并前状态\n- `git merge --no-commit xxbranch`合并到本地文件,之后需要手动commit,xxbranch仍是新节点的父节点\n- `git merge --squash xxbranch`生成本地diff,patch,手动提交后,与xxbranch不构成父子节点\n- `git checkout -b serverfix origin/serverfix`跟踪远程库其他分支等价于`git checkout --track orighin/serverfix`\n- `git push origin --delete xxx` 删除远程分支\n## git branch 选项\n- -d xxx: 删除分支\n- -D xxx:强制删除某个未合并的分支\n- -v:显示每个分支最后的提交\n- --merged:查看所有已与当前分支合并的分支\n- --no-merged:查看所有未与当前分支合并的分支\n- -f some hash:强制some分支移动到某hash版本\n- `-u origin:master`:设置当前分支跟踪远程分支\n- `-r`:显示所有远程分支\n- `-a`:显示所有本地和远程分支\n## `git rebase` \n- `git rebase xxx`把当前分支衍合到xxx分支\n- `git rebase --onto master server client`把server与client共同祖先之后的变化加到master中去\n- `git rebase -i xx`以他为xx基础或其共同祖先节点进行交互界面的rebase\n## `git cherry-pick a b c`把a,b,c等应用到当前分支\n## `git describe <branch>`会输出以下信息\n`<最近的tag>_<tag距离分支几个节点>_<当前分支hash值>`\n## `^`第一个父提交`^2`第二个父提交`~2`爷爷提交\n## 格式:`[source:destination]`\n# 高级\n## `git stash`\n备份当前的工作区内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到git栈中\n- `git stash list`显示所有栈内的备份\n- `git stash apply <stash_name>`从栈中读取最新一次保存的内容，恢复工作区的相关内容\n- `git stash pop`删除最新的暂存\n- `git stash drop<stash_name>`删除指定暂存\n# 建议规范\n## 推荐的分支管理\n- `master`:主分支,禁止直接在master上进行代码的提交和修改,此分支的代码可以随时被发布到线上\n- `develop`:测试分支,所有开发完成需要提交测试的功能合并到该分支,该分支包含最新的更改\n- `feature`:开发分支,大家根据不同需求创建独立的功能分支,开发后合并到develop分支\n- `fix`:分支为bug修复分支,需要根据实际情况对已发布的版本进行漏洞修复\n## 标签tag管理\nTag采用三段式:v版本.里程碑.序号(v2.3.1)\n- 第一位:架构升级或架构重大调整\n- 第二位:新功能上线或模块大的调整\n- 第三位:bug修复\n## 提交信息格式\n### 中文:\n- -<新功能>添加解析url功能\n- -<修改>修改某功能的某个实现为另一个实先\n- -<Bug修复>修复url的特殊情况下解析失败的问题\n- -<重构>重构获取数据的方法\n- -<测试>添加(修改、删除)获取数据的单元测试代码\n- -<文档>修改(添加、删除)文档\n### 英文:\n- -feat:新功能\n- -fix:修补bug\n- -refactor:重构\n- -test:测试相关\n- -docs:文档\n# .gitignore\n该文件里的文件夹和文件(可以使用通配符`*`,`!`,`?`,`[a-zA-Z]`等，具体看)不被加入版本控制中，也就不会出现在git status中(文件.gitignore本身还是会untrack状态),git add的时候不会被加入，这里仅局限于untracked file，那些Staged file，不受.gitignore影响\n- 每一行定义一个或一组文件夹或文件，以`/`结尾的只匹配文件夹，否则，可以匹配文件或文件夹\n- 以`!`开头的，如果有冲突，会把之前模式匹配的覆盖掉\n- 如果一个文件夹已经被匹配，那么其子文件夹和文件就不受其他模式影响\n- `**/foo`匹配任何位置的foo，类似的`a/**/b`匹配`a/x/b`,`a/b`等\n\n# 常见问题技巧:\n- 推送要密码,改成ssh认证,在.git/config里修改remote地址,从仓库复制过去ssh地址,不用httpServer,因为它就是默认用密码登录,也可以从命令行修改\n- 仓库中所有文件的sha1值在.git目录中的objects文件夹下，想要根据sha1值查看文件内容，可以用`git cat-file -p [sha1值]`注意，objects中只有两个数字的文件夹是该文件夹下所有文件内容的sha1值的前两位，所以要拼接一下，当然你如果用命令知道它的完整sha1值就不用拼接了\n- `gitjk`有用的命令，可以查看如何撤销上个命令,可以从网上下载该工具，需要npm\n- `git log --tags --simplify-by-decoration --pretty=\"format:%ci %d\"`通过log来看tag,并且加上了日期\n- 加了ssh-key死活连不上\n    1. 在.ssh文件夹下加个config文件,内容如下：\n ```c++\nHost github.com\nUser 2726905171@qq.com\nHostname ssh.github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_ed25519\nPort 443\n ```\n    2. 之后执行命令`ssh-add 私钥位置`\n","slug":"git","published":1,"updated":"2024-01-18T20:36:43.573Z","_id":"clq1yvi71000wgwq29rc1auxb","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"git预设置-gitconfig\"><a href=\"#git预设置-gitconfig\" class=\"headerlink\" title=\"git预设置(~&#x2F;.gitconfig)\"></a>git预设置(~&#x2F;.gitconfig)</h1><ul>\n<li><code>git config --global user.name &quot;xxx&quot;</code></li>\n<li><code>git config --global user.email &quot;xx.com&quot;</code></li>\n<li><code>git config --list</code>检查已有配置信息</li>\n<li><code>git config --global core.editor vim</code>配置默认编辑器</li>\n<li><code>git config --global alias.comi commit</code>命令的别名</li>\n<li><code>git config --global credential.helper cache</code>设置无密码推送</li>\n<li><code>git config --global alias.st &quot;status&quot;</code>设置status的别名为st</li>\n<li><code>git config --global alias.st &quot;status&quot;</code>设置status的别名为st</li>\n<li><code>git config --global --replace-all alias.lg  &quot;log --pretty=format:&#39;%C(auto) %h | %ai | %Cred %an %Cgreen %s&#39;&quot;</code>推荐设置log的别名</li>\n</ul>\n<h1 id=\"git-初始化\"><a href=\"#git-初始化\" class=\"headerlink\" title=\"git 初始化\"></a>git 初始化</h1><p><code>git init</code>初始化仓库，并建立.git子目录</p>\n<h1 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a><code>git status</code></h1><p><code>-s</code>:简单展现，A表示新添加到缓存区,左边M表示文件被修改并放入缓存区,右边M表示文件被修改并没有放入缓存区,??问号表示未被跟踪的文件</p>\n<h1 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add &lt;files&gt;\"></a><code>git add &lt;files&gt;</code></h1><p>跟踪文件并加入暂存区,可以通过<code>git ls-files --stage</code>来查看暂存区的文件</p>\n<h1 id=\"git-diff显示更为详细的变化\"><a href=\"#git-diff显示更为详细的变化\" class=\"headerlink\" title=\"git diff显示更为详细的变化\"></a><code>git diff</code>显示更为详细的变化</h1><ul>\n<li>默认比较工作目录与缓存区间的差异</li>\n<li><code>--cached</code>比较缓存区与已提交的差异</li>\n<li>HEAD查看所有改动</li>\n<li>–stat:显示摘要</li>\n</ul>\n<h1 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a><code>git commit</code></h1><p>注释行里会有最后一次运行git status的输出</p>\n<ul>\n<li>-v:会将diff输出加入到注释行</li>\n<li>-m:将提交信息与命令放在同一行</li>\n<li>-a:可以将所有跟踪文件跳过add步骤直接commit</li>\n<li>–amend:上次提交后发现忘了几个文件,可以add之后再加上此选项提交将会覆盖上次提交。</li>\n</ul>\n<h1 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm &lt;files&gt;\"></a><code>git rm &lt;files&gt;</code></h1><ul>\n<li>移除缓存区文件并且工作目录也一并移除</li>\n<li>–cached:只删除缓存区,保留工作目录</li>\n</ul>\n<h1 id=\"git-mv移动文件\"><a href=\"#git-mv移动文件\" class=\"headerlink\" title=\"git mv移动文件\"></a><code>git mv</code>移动文件</h1><ul>\n<li>等价于’mv file1 file2;git rm file1;git add README’</li>\n</ul>\n<h1 id=\"git-log显示提交记录-git-shortlog-显示简短的记录\"><a href=\"#git-log显示提交记录-git-shortlog-显示简短的记录\" class=\"headerlink\" title=\"git log显示提交记录(git shortlog 显示简短的记录)\"></a><code>git log</code>显示提交记录(git shortlog 显示简短的记录)</h1><ul>\n<li><p>-p:显示每次提交的差异</p>\n</li>\n<li><p>-(n):显示最近n次提交</p>\n</li>\n<li><p>–since,–after:仅显示指定时间之后的提交</p>\n</li>\n<li><p>–until,–before:仅显示指定时间之前的提交</p>\n</li>\n<li><p>–author:仅显示指定作者相关的提交</p>\n</li>\n<li><p>–committer:仅显示指定提交者相关的提交</p>\n</li>\n<li><p>–grep:仅显示含指定关键字的提交</p>\n</li>\n<li><p>-S:仅显示添加或移除了某个关键字的提交</p>\n</li>\n<li><p>–stat:简略信息</p>\n</li>\n<li><p>–graph:显示ASCLL图形表示分支的合并历史</p>\n</li>\n<li><p>–relative-date:使用较短的相对时间显示</p>\n</li>\n<li><p>–abbrev-commit:仅显示SHA-1的前几个字符,而非所有的40个字符</p>\n</li>\n<li><p>–name-status:显示增删改的文件清单</p>\n</li>\n<li><p>–name-only:仅在提交信息后显示以修改的文件清单</p>\n</li>\n<li><p>–pretty&#x3D;format:”&lt;格式&gt;”:指定格式输出<br>&lt;格式&gt;有如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">%H</td>\n<td align=\"center\">提交对象(commit)的完整哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%h</td>\n<td align=\"center\">提交对象的简短哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%T</td>\n<td align=\"center\">树对象的完整哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%t</td>\n<td align=\"center\">树对象的简短哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%P</td>\n<td align=\"center\">父对象的完整哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%p</td>\n<td align=\"center\">父对象的简短哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%an</td>\n<td align=\"center\">作者的名字</td>\n</tr>\n<tr>\n<td align=\"center\">%ae</td>\n<td align=\"center\">作者的邮件</td>\n</tr>\n<tr>\n<td align=\"center\">%ad</td>\n<td align=\"center\">作者修订日期</td>\n</tr>\n<tr>\n<td align=\"center\">%ar</td>\n<td align=\"center\">作者修订日期,按多久以前的方式显示</td>\n</tr>\n<tr>\n<td align=\"center\">%cn</td>\n<td align=\"center\">提交者的名字</td>\n</tr>\n<tr>\n<td align=\"center\">%ce</td>\n<td align=\"center\">提交者的电子邮件</td>\n</tr>\n<tr>\n<td align=\"center\">%cd</td>\n<td align=\"center\">提交日期</td>\n</tr>\n<tr>\n<td align=\"center\">%cr</td>\n<td align=\"center\">提交日期,按多久以前的方式显示</td>\n</tr>\n<tr>\n<td align=\"center\">%s</td>\n<td align=\"center\">提交说明</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h1 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h1><ul>\n<li><code>git reset HEAD &lt;file&gt;</code>(适用已提交add):撤销某个暂存文件,即将add退回</li>\n<li><code>git reset HEAD\\~1</code>:回退到上一个版本</li>\n<li><code>git reset --hard &lt;commit_id&gt;</code>注意此步骤会将commit_id后的commit删除,最好不用</li>\n<li><code>git push origin HEAD --force</code>让服务器也回退到某版本(本地仓库已回退)</li>\n<li><code>git revert HEAD</code>回退到HEAD上一个版本,但是树结构往下走，只不过与父节点相同</li>\n<li><code>git checkout [file]</code>(未git add的情况下):撤销某个工作目录下文件的修改,恢复为版本库中一模一样的版本,危险的命令,你的修改将不会保存</li>\n</ul>\n<h1 id=\"git-remote远程仓库的使用\"><a href=\"#git-remote远程仓库的使用\" class=\"headerlink\" title=\"git remote远程仓库的使用\"></a><code>git remote</code>远程仓库的使用</h1><ul>\n<li>-v:显示简写对应的url</li>\n<li><code>show origin</code>:展示origin的具体信息</li>\n<li><code>rename o1 o2</code>:重命名某个远程</li>\n<li><code>rm xx</code>:移除某个远程</li>\n<li><code>add xx</code>:增加某个远程</li>\n<li><code>prune origin</code>:删除本地在远程服务器上不存在的分支</li>\n</ul>\n<h1 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push &lt;remote-name&gt; &lt;branch-name&gt;\"></a><code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code></h1><ul>\n<li><code>--tags</code>:推送所有标签</li>\n<li>使用git push &lt;远程主机名(origin)&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</li>\n<li><code>git push --set-upstream &lt;remote_name&gt; &lt;branch_name&gt;</code>将远程分支作为当前分支的上游分支,–unset-upstream,则是删除这种关联</li>\n</ul>\n<h1 id=\"远程拉取\"><a href=\"#远程拉取\" class=\"headerlink\" title=\"远程拉取\"></a>远程拉取</h1><ul>\n<li>git fetch:会抓取数据到本地数据库，但不会自动合并并修改当前工作</li>\n<li>git clone:会自动将其添加为远程仓库并默认以’origin’缩写,并自动跟踪远程master</li>\n<li>git pull:主区数据并自动尝试合并到当前所在分支</li>\n</ul>\n<h1 id=\"git-tag\"><a href=\"#git-tag\" class=\"headerlink\" title=\"git tag\"></a>git tag</h1><ul>\n<li>-a:增加个标签,可以在后面加个校验和,为指定的补打标签</li>\n<li>-m:在命令行增加说明</li>\n<li>-d:删除某个标签</li>\n<li>-l:列举标签</li>\n<li><tag_name> <commit_id>:为某个哈希打标签,必须显示地推送标签至远程库’git push origin v1.5’,当某个标签被删除或信息改变’git push origin  :refs&#x2F;tags&#x2F;<tag_name>‘</li>\n<li><code>git branch &lt;new-branch-name&gt; &lt;tag-name&gt;</code>从指定的标签拉取一个分支出来</li>\n<li><code>git show &lt;tag_name&gt;</code>查看tag信息</li>\n</ul>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><ul>\n<li><code>git clone -b &lt;分支名&gt; &lt;仓库地址&gt;</code>克隆指定分支</li>\n<li><code>git fetch origin &lt;branch_name&gt;</code>抓取某个远程分支</li>\n<li><code>git branch xxx</code>创建分支,不加任何xxx会显示所有分支</li>\n<li><code>git log --oneline --decorate</code>查看各个分支当前所指对象</li>\n<li><code>git checkout xxx</code>切换分支,切换分支会改变工作目录里的文件</li>\n<li><code>git log --oneline --decorate --graph --all</code>查看分叉历史</li>\n<li><code>git merge xxbranch</code>合并指定分支到当前分支,如果当前分支可以沿着一条线走下去则会有’fast-forward提示’</li>\n<li><code>git merge --abort</code>取消当前合并,重建合并前状态</li>\n<li><code>git merge --no-commit xxbranch</code>合并到本地文件,之后需要手动commit,xxbranch仍是新节点的父节点</li>\n<li><code>git merge --squash xxbranch</code>生成本地diff,patch,手动提交后,与xxbranch不构成父子节点</li>\n<li><code>git checkout -b serverfix origin/serverfix</code>跟踪远程库其他分支等价于<code>git checkout --track orighin/serverfix</code></li>\n<li><code>git push origin --delete xxx</code> 删除远程分支</li>\n</ul>\n<h2 id=\"git-branch-选项\"><a href=\"#git-branch-选项\" class=\"headerlink\" title=\"git branch 选项\"></a>git branch 选项</h2><ul>\n<li>-d xxx: 删除分支</li>\n<li>-D xxx:强制删除某个未合并的分支</li>\n<li>-v:显示每个分支最后的提交</li>\n<li>–merged:查看所有已与当前分支合并的分支</li>\n<li>–no-merged:查看所有未与当前分支合并的分支</li>\n<li>-f some hash:强制some分支移动到某hash版本</li>\n<li><code>-u origin:master</code>:设置当前分支跟踪远程分支</li>\n<li><code>-r</code>:显示所有远程分支</li>\n<li><code>-a</code>:显示所有本地和远程分支</li>\n</ul>\n<h2 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a><code>git rebase</code></h2><ul>\n<li><code>git rebase xxx</code>把当前分支衍合到xxx分支</li>\n<li><code>git rebase --onto master server client</code>把server与client共同祖先之后的变化加到master中去</li>\n<li><code>git rebase -i xx</code>以他为xx基础或其共同祖先节点进行交互界面的rebase</li>\n</ul>\n<h2 id=\"git-cherry-pick-a-b-c把a-b-c等应用到当前分支\"><a href=\"#git-cherry-pick-a-b-c把a-b-c等应用到当前分支\" class=\"headerlink\" title=\"git cherry-pick a b c把a,b,c等应用到当前分支\"></a><code>git cherry-pick a b c</code>把a,b,c等应用到当前分支</h2><h2 id=\"git-describe-会输出以下信息\"><a href=\"#git-describe-会输出以下信息\" class=\"headerlink\" title=\"git describe &lt;branch&gt;会输出以下信息\"></a><code>git describe &lt;branch&gt;</code>会输出以下信息</h2><p><code>&lt;最近的tag&gt;_&lt;tag距离分支几个节点&gt;_&lt;当前分支hash值&gt;</code></p>\n<h2 id=\"第一个父提交-2第二个父提交-2爷爷提交\"><a href=\"#第一个父提交-2第二个父提交-2爷爷提交\" class=\"headerlink\" title=\"^第一个父提交^2第二个父提交~2爷爷提交\"></a><code>^</code>第一个父提交<code>^2</code>第二个父提交<code>~2</code>爷爷提交</h2><h2 id=\"格式-source-destination\"><a href=\"#格式-source-destination\" class=\"headerlink\" title=\"格式:[source:destination]\"></a>格式:<code>[source:destination]</code></h2><h1 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h1><h2 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a><code>git stash</code></h2><p>备份当前的工作区内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到git栈中</p>\n<ul>\n<li><code>git stash list</code>显示所有栈内的备份</li>\n<li><code>git stash apply &lt;stash_name&gt;</code>从栈中读取最新一次保存的内容，恢复工作区的相关内容</li>\n<li><code>git stash pop</code>删除最新的暂存</li>\n<li><code>git stash drop&lt;stash_name&gt;</code>删除指定暂存</li>\n</ul>\n<h1 id=\"建议规范\"><a href=\"#建议规范\" class=\"headerlink\" title=\"建议规范\"></a>建议规范</h1><h2 id=\"推荐的分支管理\"><a href=\"#推荐的分支管理\" class=\"headerlink\" title=\"推荐的分支管理\"></a>推荐的分支管理</h2><ul>\n<li><code>master</code>:主分支,禁止直接在master上进行代码的提交和修改,此分支的代码可以随时被发布到线上</li>\n<li><code>develop</code>:测试分支,所有开发完成需要提交测试的功能合并到该分支,该分支包含最新的更改</li>\n<li><code>feature</code>:开发分支,大家根据不同需求创建独立的功能分支,开发后合并到develop分支</li>\n<li><code>fix</code>:分支为bug修复分支,需要根据实际情况对已发布的版本进行漏洞修复</li>\n</ul>\n<h2 id=\"标签tag管理\"><a href=\"#标签tag管理\" class=\"headerlink\" title=\"标签tag管理\"></a>标签tag管理</h2><p>Tag采用三段式:v版本.里程碑.序号(v2.3.1)</p>\n<ul>\n<li>第一位:架构升级或架构重大调整</li>\n<li>第二位:新功能上线或模块大的调整</li>\n<li>第三位:bug修复</li>\n</ul>\n<h2 id=\"提交信息格式\"><a href=\"#提交信息格式\" class=\"headerlink\" title=\"提交信息格式\"></a>提交信息格式</h2><h3 id=\"中文\"><a href=\"#中文\" class=\"headerlink\" title=\"中文:\"></a>中文:</h3><ul>\n<li>-&lt;新功能&gt;添加解析url功能</li>\n<li>-&lt;修改&gt;修改某功能的某个实现为另一个实先</li>\n<li>-&lt;Bug修复&gt;修复url的特殊情况下解析失败的问题</li>\n<li>-&lt;重构&gt;重构获取数据的方法</li>\n<li>-&lt;测试&gt;添加(修改、删除)获取数据的单元测试代码</li>\n<li>-&lt;文档&gt;修改(添加、删除)文档</li>\n</ul>\n<h3 id=\"英文\"><a href=\"#英文\" class=\"headerlink\" title=\"英文:\"></a>英文:</h3><ul>\n<li>-feat:新功能</li>\n<li>-fix:修补bug</li>\n<li>-refactor:重构</li>\n<li>-test:测试相关</li>\n<li>-docs:文档</li>\n</ul>\n<h1 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h1><p>该文件里的文件夹和文件(可以使用通配符<code>*</code>,<code>!</code>,<code>?</code>,<code>[a-zA-Z]</code>等，具体看)不被加入版本控制中，也就不会出现在git status中(文件.gitignore本身还是会untrack状态),git add的时候不会被加入，这里仅局限于untracked file，那些Staged file，不受.gitignore影响</p>\n<ul>\n<li>每一行定义一个或一组文件夹或文件，以<code>/</code>结尾的只匹配文件夹，否则，可以匹配文件或文件夹</li>\n<li>以<code>!</code>开头的，如果有冲突，会把之前模式匹配的覆盖掉</li>\n<li>如果一个文件夹已经被匹配，那么其子文件夹和文件就不受其他模式影响</li>\n<li><code>**/foo</code>匹配任何位置的foo，类似的<code>a/**/b</code>匹配<code>a/x/b</code>,<code>a/b</code>等</li>\n</ul>\n<h1 id=\"常见问题技巧\"><a href=\"#常见问题技巧\" class=\"headerlink\" title=\"常见问题技巧:\"></a>常见问题技巧:</h1><ul>\n<li>推送要密码,改成ssh认证,在.git&#x2F;config里修改remote地址,从仓库复制过去ssh地址,不用httpServer,因为它就是默认用密码登录,也可以从命令行修改</li>\n<li>仓库中所有文件的sha1值在.git目录中的objects文件夹下，想要根据sha1值查看文件内容，可以用<code>git cat-file -p [sha1值]</code>注意，objects中只有两个数字的文件夹是该文件夹下所有文件内容的sha1值的前两位，所以要拼接一下，当然你如果用命令知道它的完整sha1值就不用拼接了</li>\n<li><code>gitjk</code>有用的命令，可以查看如何撤销上个命令,可以从网上下载该工具，需要npm</li>\n<li><code>git log --tags --simplify-by-decoration --pretty=&quot;format:%ci %d&quot;</code>通过log来看tag,并且加上了日期</li>\n<li>加了ssh-key死活连不上<ol>\n<li>在.ssh文件夹下加个config文件,内容如下： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Host github.com<br>User <span class=\"hljs-number\">2726905171</span>@qq.com<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_ed25519<br>Port <span class=\"hljs-number\">443</span><br></code></pre></td></tr></table></figure></li>\n<li>之后执行命令<code>ssh-add 私钥位置</code></li>\n</ol>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"git预设置-gitconfig\"><a href=\"#git预设置-gitconfig\" class=\"headerlink\" title=\"git预设置(~&#x2F;.gitconfig)\"></a>git预设置(~&#x2F;.gitconfig)</h1><ul>\n<li><code>git config --global user.name &quot;xxx&quot;</code></li>\n<li><code>git config --global user.email &quot;xx.com&quot;</code></li>\n<li><code>git config --list</code>检查已有配置信息</li>\n<li><code>git config --global core.editor vim</code>配置默认编辑器</li>\n<li><code>git config --global alias.comi commit</code>命令的别名</li>\n<li><code>git config --global credential.helper cache</code>设置无密码推送</li>\n<li><code>git config --global alias.st &quot;status&quot;</code>设置status的别名为st</li>\n<li><code>git config --global alias.st &quot;status&quot;</code>设置status的别名为st</li>\n<li><code>git config --global --replace-all alias.lg  &quot;log --pretty=format:&#39;%C(auto) %h | %ai | %Cred %an %Cgreen %s&#39;&quot;</code>推荐设置log的别名</li>\n</ul>\n<h1 id=\"git-初始化\"><a href=\"#git-初始化\" class=\"headerlink\" title=\"git 初始化\"></a>git 初始化</h1><p><code>git init</code>初始化仓库，并建立.git子目录</p>\n<h1 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a><code>git status</code></h1><p><code>-s</code>:简单展现，A表示新添加到缓存区,左边M表示文件被修改并放入缓存区,右边M表示文件被修改并没有放入缓存区,??问号表示未被跟踪的文件</p>\n<h1 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add &lt;files&gt;\"></a><code>git add &lt;files&gt;</code></h1><p>跟踪文件并加入暂存区,可以通过<code>git ls-files --stage</code>来查看暂存区的文件</p>\n<h1 id=\"git-diff显示更为详细的变化\"><a href=\"#git-diff显示更为详细的变化\" class=\"headerlink\" title=\"git diff显示更为详细的变化\"></a><code>git diff</code>显示更为详细的变化</h1><ul>\n<li>默认比较工作目录与缓存区间的差异</li>\n<li><code>--cached</code>比较缓存区与已提交的差异</li>\n<li>HEAD查看所有改动</li>\n<li>–stat:显示摘要</li>\n</ul>\n<h1 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a><code>git commit</code></h1><p>注释行里会有最后一次运行git status的输出</p>\n<ul>\n<li>-v:会将diff输出加入到注释行</li>\n<li>-m:将提交信息与命令放在同一行</li>\n<li>-a:可以将所有跟踪文件跳过add步骤直接commit</li>\n<li>–amend:上次提交后发现忘了几个文件,可以add之后再加上此选项提交将会覆盖上次提交。</li>\n</ul>\n<h1 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm &lt;files&gt;\"></a><code>git rm &lt;files&gt;</code></h1><ul>\n<li>移除缓存区文件并且工作目录也一并移除</li>\n<li>–cached:只删除缓存区,保留工作目录</li>\n</ul>\n<h1 id=\"git-mv移动文件\"><a href=\"#git-mv移动文件\" class=\"headerlink\" title=\"git mv移动文件\"></a><code>git mv</code>移动文件</h1><ul>\n<li>等价于’mv file1 file2;git rm file1;git add README’</li>\n</ul>\n<h1 id=\"git-log显示提交记录-git-shortlog-显示简短的记录\"><a href=\"#git-log显示提交记录-git-shortlog-显示简短的记录\" class=\"headerlink\" title=\"git log显示提交记录(git shortlog 显示简短的记录)\"></a><code>git log</code>显示提交记录(git shortlog 显示简短的记录)</h1><ul>\n<li><p>-p:显示每次提交的差异</p>\n</li>\n<li><p>-(n):显示最近n次提交</p>\n</li>\n<li><p>–since,–after:仅显示指定时间之后的提交</p>\n</li>\n<li><p>–until,–before:仅显示指定时间之前的提交</p>\n</li>\n<li><p>–author:仅显示指定作者相关的提交</p>\n</li>\n<li><p>–committer:仅显示指定提交者相关的提交</p>\n</li>\n<li><p>–grep:仅显示含指定关键字的提交</p>\n</li>\n<li><p>-S:仅显示添加或移除了某个关键字的提交</p>\n</li>\n<li><p>–stat:简略信息</p>\n</li>\n<li><p>–graph:显示ASCLL图形表示分支的合并历史</p>\n</li>\n<li><p>–relative-date:使用较短的相对时间显示</p>\n</li>\n<li><p>–abbrev-commit:仅显示SHA-1的前几个字符,而非所有的40个字符</p>\n</li>\n<li><p>–name-status:显示增删改的文件清单</p>\n</li>\n<li><p>–name-only:仅在提交信息后显示以修改的文件清单</p>\n</li>\n<li><p>–pretty&#x3D;format:”&lt;格式&gt;”:指定格式输出<br>&lt;格式&gt;有如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">%H</td>\n<td align=\"center\">提交对象(commit)的完整哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%h</td>\n<td align=\"center\">提交对象的简短哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%T</td>\n<td align=\"center\">树对象的完整哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%t</td>\n<td align=\"center\">树对象的简短哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%P</td>\n<td align=\"center\">父对象的完整哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%p</td>\n<td align=\"center\">父对象的简短哈希字串</td>\n</tr>\n<tr>\n<td align=\"center\">%an</td>\n<td align=\"center\">作者的名字</td>\n</tr>\n<tr>\n<td align=\"center\">%ae</td>\n<td align=\"center\">作者的邮件</td>\n</tr>\n<tr>\n<td align=\"center\">%ad</td>\n<td align=\"center\">作者修订日期</td>\n</tr>\n<tr>\n<td align=\"center\">%ar</td>\n<td align=\"center\">作者修订日期,按多久以前的方式显示</td>\n</tr>\n<tr>\n<td align=\"center\">%cn</td>\n<td align=\"center\">提交者的名字</td>\n</tr>\n<tr>\n<td align=\"center\">%ce</td>\n<td align=\"center\">提交者的电子邮件</td>\n</tr>\n<tr>\n<td align=\"center\">%cd</td>\n<td align=\"center\">提交日期</td>\n</tr>\n<tr>\n<td align=\"center\">%cr</td>\n<td align=\"center\">提交日期,按多久以前的方式显示</td>\n</tr>\n<tr>\n<td align=\"center\">%s</td>\n<td align=\"center\">提交说明</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h1 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h1><ul>\n<li><code>git reset HEAD &lt;file&gt;</code>(适用已提交add):撤销某个暂存文件,即将add退回</li>\n<li><code>git reset HEAD\\~1</code>:回退到上一个版本</li>\n<li><code>git reset --hard &lt;commit_id&gt;</code>注意此步骤会将commit_id后的commit删除,最好不用</li>\n<li><code>git push origin HEAD --force</code>让服务器也回退到某版本(本地仓库已回退)</li>\n<li><code>git revert HEAD</code>回退到HEAD上一个版本,但是树结构往下走，只不过与父节点相同</li>\n<li><code>git checkout [file]</code>(未git add的情况下):撤销某个工作目录下文件的修改,恢复为版本库中一模一样的版本,危险的命令,你的修改将不会保存</li>\n</ul>\n<h1 id=\"git-remote远程仓库的使用\"><a href=\"#git-remote远程仓库的使用\" class=\"headerlink\" title=\"git remote远程仓库的使用\"></a><code>git remote</code>远程仓库的使用</h1><ul>\n<li>-v:显示简写对应的url</li>\n<li><code>show origin</code>:展示origin的具体信息</li>\n<li><code>rename o1 o2</code>:重命名某个远程</li>\n<li><code>rm xx</code>:移除某个远程</li>\n<li><code>add xx</code>:增加某个远程</li>\n<li><code>prune origin</code>:删除本地在远程服务器上不存在的分支</li>\n</ul>\n<h1 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push &lt;remote-name&gt; &lt;branch-name&gt;\"></a><code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code></h1><ul>\n<li><code>--tags</code>:推送所有标签</li>\n<li>使用git push &lt;远程主机名(origin)&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</li>\n<li><code>git push --set-upstream &lt;remote_name&gt; &lt;branch_name&gt;</code>将远程分支作为当前分支的上游分支,–unset-upstream,则是删除这种关联</li>\n</ul>\n<h1 id=\"远程拉取\"><a href=\"#远程拉取\" class=\"headerlink\" title=\"远程拉取\"></a>远程拉取</h1><ul>\n<li>git fetch:会抓取数据到本地数据库，但不会自动合并并修改当前工作</li>\n<li>git clone:会自动将其添加为远程仓库并默认以’origin’缩写,并自动跟踪远程master</li>\n<li>git pull:主区数据并自动尝试合并到当前所在分支</li>\n</ul>\n<h1 id=\"git-tag\"><a href=\"#git-tag\" class=\"headerlink\" title=\"git tag\"></a>git tag</h1><ul>\n<li>-a:增加个标签,可以在后面加个校验和,为指定的补打标签</li>\n<li>-m:在命令行增加说明</li>\n<li>-d:删除某个标签</li>\n<li>-l:列举标签</li>\n<li><tag_name> <commit_id>:为某个哈希打标签,必须显示地推送标签至远程库’git push origin v1.5’,当某个标签被删除或信息改变’git push origin  :refs&#x2F;tags&#x2F;<tag_name>‘</li>\n<li><code>git branch &lt;new-branch-name&gt; &lt;tag-name&gt;</code>从指定的标签拉取一个分支出来</li>\n<li><code>git show &lt;tag_name&gt;</code>查看tag信息</li>\n</ul>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><ul>\n<li><code>git clone -b &lt;分支名&gt; &lt;仓库地址&gt;</code>克隆指定分支</li>\n<li><code>git fetch origin &lt;branch_name&gt;</code>抓取某个远程分支</li>\n<li><code>git branch xxx</code>创建分支,不加任何xxx会显示所有分支</li>\n<li><code>git log --oneline --decorate</code>查看各个分支当前所指对象</li>\n<li><code>git checkout xxx</code>切换分支,切换分支会改变工作目录里的文件</li>\n<li><code>git log --oneline --decorate --graph --all</code>查看分叉历史</li>\n<li><code>git merge xxbranch</code>合并指定分支到当前分支,如果当前分支可以沿着一条线走下去则会有’fast-forward提示’</li>\n<li><code>git merge --abort</code>取消当前合并,重建合并前状态</li>\n<li><code>git merge --no-commit xxbranch</code>合并到本地文件,之后需要手动commit,xxbranch仍是新节点的父节点</li>\n<li><code>git merge --squash xxbranch</code>生成本地diff,patch,手动提交后,与xxbranch不构成父子节点</li>\n<li><code>git checkout -b serverfix origin/serverfix</code>跟踪远程库其他分支等价于<code>git checkout --track orighin/serverfix</code></li>\n<li><code>git push origin --delete xxx</code> 删除远程分支</li>\n</ul>\n<h2 id=\"git-branch-选项\"><a href=\"#git-branch-选项\" class=\"headerlink\" title=\"git branch 选项\"></a>git branch 选项</h2><ul>\n<li>-d xxx: 删除分支</li>\n<li>-D xxx:强制删除某个未合并的分支</li>\n<li>-v:显示每个分支最后的提交</li>\n<li>–merged:查看所有已与当前分支合并的分支</li>\n<li>–no-merged:查看所有未与当前分支合并的分支</li>\n<li>-f some hash:强制some分支移动到某hash版本</li>\n<li><code>-u origin:master</code>:设置当前分支跟踪远程分支</li>\n<li><code>-r</code>:显示所有远程分支</li>\n<li><code>-a</code>:显示所有本地和远程分支</li>\n</ul>\n<h2 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a><code>git rebase</code></h2><ul>\n<li><code>git rebase xxx</code>把当前分支衍合到xxx分支</li>\n<li><code>git rebase --onto master server client</code>把server与client共同祖先之后的变化加到master中去</li>\n<li><code>git rebase -i xx</code>以他为xx基础或其共同祖先节点进行交互界面的rebase</li>\n</ul>\n<h2 id=\"git-cherry-pick-a-b-c把a-b-c等应用到当前分支\"><a href=\"#git-cherry-pick-a-b-c把a-b-c等应用到当前分支\" class=\"headerlink\" title=\"git cherry-pick a b c把a,b,c等应用到当前分支\"></a><code>git cherry-pick a b c</code>把a,b,c等应用到当前分支</h2><h2 id=\"git-describe-会输出以下信息\"><a href=\"#git-describe-会输出以下信息\" class=\"headerlink\" title=\"git describe &lt;branch&gt;会输出以下信息\"></a><code>git describe &lt;branch&gt;</code>会输出以下信息</h2><p><code>&lt;最近的tag&gt;_&lt;tag距离分支几个节点&gt;_&lt;当前分支hash值&gt;</code></p>\n<h2 id=\"第一个父提交-2第二个父提交-2爷爷提交\"><a href=\"#第一个父提交-2第二个父提交-2爷爷提交\" class=\"headerlink\" title=\"^第一个父提交^2第二个父提交~2爷爷提交\"></a><code>^</code>第一个父提交<code>^2</code>第二个父提交<code>~2</code>爷爷提交</h2><h2 id=\"格式-source-destination\"><a href=\"#格式-source-destination\" class=\"headerlink\" title=\"格式:[source:destination]\"></a>格式:<code>[source:destination]</code></h2><h1 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h1><h2 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a><code>git stash</code></h2><p>备份当前的工作区内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到git栈中</p>\n<ul>\n<li><code>git stash list</code>显示所有栈内的备份</li>\n<li><code>git stash apply &lt;stash_name&gt;</code>从栈中读取最新一次保存的内容，恢复工作区的相关内容</li>\n<li><code>git stash pop</code>删除最新的暂存</li>\n<li><code>git stash drop&lt;stash_name&gt;</code>删除指定暂存</li>\n</ul>\n<h1 id=\"建议规范\"><a href=\"#建议规范\" class=\"headerlink\" title=\"建议规范\"></a>建议规范</h1><h2 id=\"推荐的分支管理\"><a href=\"#推荐的分支管理\" class=\"headerlink\" title=\"推荐的分支管理\"></a>推荐的分支管理</h2><ul>\n<li><code>master</code>:主分支,禁止直接在master上进行代码的提交和修改,此分支的代码可以随时被发布到线上</li>\n<li><code>develop</code>:测试分支,所有开发完成需要提交测试的功能合并到该分支,该分支包含最新的更改</li>\n<li><code>feature</code>:开发分支,大家根据不同需求创建独立的功能分支,开发后合并到develop分支</li>\n<li><code>fix</code>:分支为bug修复分支,需要根据实际情况对已发布的版本进行漏洞修复</li>\n</ul>\n<h2 id=\"标签tag管理\"><a href=\"#标签tag管理\" class=\"headerlink\" title=\"标签tag管理\"></a>标签tag管理</h2><p>Tag采用三段式:v版本.里程碑.序号(v2.3.1)</p>\n<ul>\n<li>第一位:架构升级或架构重大调整</li>\n<li>第二位:新功能上线或模块大的调整</li>\n<li>第三位:bug修复</li>\n</ul>\n<h2 id=\"提交信息格式\"><a href=\"#提交信息格式\" class=\"headerlink\" title=\"提交信息格式\"></a>提交信息格式</h2><h3 id=\"中文\"><a href=\"#中文\" class=\"headerlink\" title=\"中文:\"></a>中文:</h3><ul>\n<li>-&lt;新功能&gt;添加解析url功能</li>\n<li>-&lt;修改&gt;修改某功能的某个实现为另一个实先</li>\n<li>-&lt;Bug修复&gt;修复url的特殊情况下解析失败的问题</li>\n<li>-&lt;重构&gt;重构获取数据的方法</li>\n<li>-&lt;测试&gt;添加(修改、删除)获取数据的单元测试代码</li>\n<li>-&lt;文档&gt;修改(添加、删除)文档</li>\n</ul>\n<h3 id=\"英文\"><a href=\"#英文\" class=\"headerlink\" title=\"英文:\"></a>英文:</h3><ul>\n<li>-feat:新功能</li>\n<li>-fix:修补bug</li>\n<li>-refactor:重构</li>\n<li>-test:测试相关</li>\n<li>-docs:文档</li>\n</ul>\n<h1 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h1><p>该文件里的文件夹和文件(可以使用通配符<code>*</code>,<code>!</code>,<code>?</code>,<code>[a-zA-Z]</code>等，具体看)不被加入版本控制中，也就不会出现在git status中(文件.gitignore本身还是会untrack状态),git add的时候不会被加入，这里仅局限于untracked file，那些Staged file，不受.gitignore影响</p>\n<ul>\n<li>每一行定义一个或一组文件夹或文件，以<code>/</code>结尾的只匹配文件夹，否则，可以匹配文件或文件夹</li>\n<li>以<code>!</code>开头的，如果有冲突，会把之前模式匹配的覆盖掉</li>\n<li>如果一个文件夹已经被匹配，那么其子文件夹和文件就不受其他模式影响</li>\n<li><code>**/foo</code>匹配任何位置的foo，类似的<code>a/**/b</code>匹配<code>a/x/b</code>,<code>a/b</code>等</li>\n</ul>\n<h1 id=\"常见问题技巧\"><a href=\"#常见问题技巧\" class=\"headerlink\" title=\"常见问题技巧:\"></a>常见问题技巧:</h1><ul>\n<li>推送要密码,改成ssh认证,在.git&#x2F;config里修改remote地址,从仓库复制过去ssh地址,不用httpServer,因为它就是默认用密码登录,也可以从命令行修改</li>\n<li>仓库中所有文件的sha1值在.git目录中的objects文件夹下，想要根据sha1值查看文件内容，可以用<code>git cat-file -p [sha1值]</code>注意，objects中只有两个数字的文件夹是该文件夹下所有文件内容的sha1值的前两位，所以要拼接一下，当然你如果用命令知道它的完整sha1值就不用拼接了</li>\n<li><code>gitjk</code>有用的命令，可以查看如何撤销上个命令,可以从网上下载该工具，需要npm</li>\n<li><code>git log --tags --simplify-by-decoration --pretty=&quot;format:%ci %d&quot;</code>通过log来看tag,并且加上了日期</li>\n<li>加了ssh-key死活连不上<ol>\n<li>在.ssh文件夹下加个config文件,内容如下： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Host github.com<br>User <span class=\"hljs-number\">2726905171</span>@qq.com<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_ed25519<br>Port <span class=\"hljs-number\">443</span><br></code></pre></td></tr></table></figure></li>\n<li>之后执行命令<code>ssh-add 私钥位置</code></li>\n</ol>\n</li>\n</ul>\n"},{"title":"grep与正则表达式","date":"2020-11-20T11:46:54.000Z","subtitle":null,"index_img":"/images/regex.jpg","banner_img":"/images/regex.jpg","_content":"# grep\n格式:`grep [options] [regex] [file...]`\n\n|选项|描述|\n|:-:|:-:|\n|-i|忽略大小写|\n|-v|打印不匹配的文本行|\n|-c|只打印匹配或不匹配(-v选项)的行数|\n|-l|打印包含匹配项的文件名,而不是文本行本身|\n|-L|相似于-l项,但是只是打印不包含匹配项的文件名|\n|-n|在每个匹配行之前打印出相应的行号|\n|-w|只识别整个单词(即模式前后有空格)|\n|-E|识别扩展正则表达式|\n|-F|忽略字符中的元字符|\n|-r|递归对某个目录的所有文件|\n|-I|等价于-binary-files=without-match,不匹配二进制|\n|-exclude-dir=[目录路径]|跳过某个目录|\n|--binary-files=without-match|二进制文件不匹配|\n\n# 正则表达式\n## 正则表达式的元字\n\n|特殊字符|用途|\n|:-:|:-:|\n|`.`|匹配除换行符外的任一单字符。在awk中,句点也能匹配换行符|\n|`*`|匹配任一个(包括零个)在它面前的字符(包括由正则表达式指定的字符)|\n|`[...]`|匹配方括号中的字符类中的任意一个。如果方括号中第一个字符为脱字符号(^),则表示否定匹配,即匹配除了换行符和类中列出的那些字符以外的所有字符。在awk中,也匹配换行符。连字符(-)用于表示字符的范围(可以连续用如[A-Za-z0-9])。如果类中的第一个字符为右方括号(])则表示它是类的成员＝所有其他的元字符在被指定为类中的成员时都会失去它们原来的含义|\n|`^`|如果作为正则表达式的第一个字符,则表示匹配行的开始。在awk中匹配字符串的开始,即使字符串包含嵌入的换行符|\n|`$`|如果作为正则表达式的最后一个字符,则表示匹配行的结尾。在awk中匹配字符串的结尾,即使字符串包含嵌入的换行符。|\n|`\\{n,m\\}`|匹配它前面某个范围内单个字符出现的次数(包括由正则表达式指定的字符)。`\\{n\\}`将匹配n次出现,`\\{n,\\}`至少匹配n次出现,而且`\\{n,m\\}`匹配n和m之间任意次的出现|\n|`\\`|转义随后的特殊字符|\n\n## POSIX字符类\nPOSIX是标准,通用于其它shell命令,不仅仅是正则,并且只能出现在中括号中,就是说应该这么写`[[:alnum:]]`\n\n|类|打印字符|\n|:-:|:-:|\n|[:alnum:]|字母数字字符,等价于[A-Za-z0-9]|\n|[:word:]|与[:alnum:]相同,但增加了下划线字符|\n|[:alpha:]|字母字符|\n|[:blank:]|空格和制表符|\n|[:cntrl:]|控制字符,0~31和127的ASCII字符|\n|[:digit:]|数字字符0~9|\n|[:graph:]|可打印和可见的(非空格)字符,33-126的ASCII|\n|[:lower:]|小写字符|\n|[:upper:]|大写字符|\n|[:print:]|可打印的字符(包括空白字符)|\n|[:punct:]|标点符号字符,在 ASCII 中, 等 价 于:`-!”#$%&’()*+,./:;<=>?@[\\\\\\]_‘| ̃`|\n|[:space:]|空白字符,包括空格,tab,回车,换行,vertical tab和form feed,在ASCII中,等价于:[\\t\\r\\n\\v\\f]|\n|[:xdigit:]|十六进制数字|\n\n## 扩展的元字符\n\n|特殊字符|用途|\n|:-:|:-:|\n|`+`|匹配前面的正则表达式的一次或多次出现|\n|`?`|匹配前面的正则表达式的零次或一次出现|\n|`\\|`|逻辑表达或,指定可以匹配前面的或后面的正则表达式|\n|`()`|对正则表达式分组,如`^(bz|gz|zip) 和 ^bz|gz|zip`的区分,前者表示以三者之一开头的,后者表示以bz开头,或包含gz或zip|\n|`{n,m}`|匹配它前面某个范围内单个字符出现的次数,与基本元字符的一样|\n|`\\w`|和任何可以做单词组成成分的字符匹配(字母下划线数字)|\n|`\\W`|和任何不能做单词组成成分的字符匹配|\n|`\\<`|和一个单词开头的空字符串匹配|\n|`\\>`|和一个单词末尾的空字符串匹配|\n|`\\y`|和一个单词开头的空字符串或末尾的空字符串匹配（单词边界）,这适用于awk|\n|`\\b`|同上，除了awk的其他软件|\n|`\\B`|匹配非单词边界。er\\B 能匹配 verb 中的 er，但不能匹配 never 中的 er。|\n|`\\d`|匹配数字：[0-9]|\n|`\\D`|匹配非数字|\n|`\\s`|匹配所有空格字符，等价于`[\\t\\n\\f\\r\\p{Z}]`|\n|`\\S`|匹配所有非空格字符|\n|`p`|匹配 CR/LF（等同于 \\r\\n），用来匹配DOS行终止符|\n|`\\'`|和在缓冲区开始处的空字符串匹配|\n## 零宽度断言\n\n|符号|描述|\n|:-:|:-:|\n|?=|正先行断言-存在|\n|?!|负先行断言-排除|\n|?<=|正后发断言-存在|\n|`?<!`|负后发断言-排除|\n## 模式修正符\n\n|标志|描述|\n|:-:|:-:|\n|i|忽略大小写。|\n|g|全局搜索。|\n|m|多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。|\n\n## grep应用举例\n- 打印匹配前后5行:`grep -5 'pattern' inputfile` \n- 打印匹配后5行:`grep -A 5 'pattern' inputfile`\n- 打印匹配前5行:`grep -B 5 'pattern' inputfile`\n- 打印匹配前5行:`grep -i 'pattern' inputfile`\n- 提取w1和w2两个中间的文字:`grep -o -P '(?<=w1).*(?=w2)'`\n- 查找一个单词出现的次数:`grep -o bbo filename |wc -l`\n- 查找括号之间的字符:`grep -oP '\\(\\K[^\\)]+'`\n## 正则表达式举例\n- 引号中的任意字符串: `\".*\"`\n- 邮箱：`^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$`\n- 中国大陆手机号：`^1[3-9][[:digit:]]\\{9\\}$`\n- 匹配任意域名：`^((http:\\/\\/)|(https:\\/\\/))?([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}(\\/)`\n- 匹配IP地址：`((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))`\n- 汉字：`^[\\u4e00-\\u9fa5]{0,}$`\n- 整数：`^-?[1-9]\\d*$`\n- 浮点数：`^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$`\n- 身份证号：`^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$`\n- 军官证：`^[\\u4E00-\\u9FA5](字第)([0-9a-zA-Z]{4,8})(号?)$`\n- 护照：`^([a-zA-z]|[0-9]){5,17}$`\n- 港澳通行证：`^([A-Z]\\d{6,10}(\\(\\w{1}\\))?)$`\n- 台湾通行证：`^\\d{8}|^[a-zA-Z0-9]{10}|^\\d{18}$`\n- 强密码：`^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$`\n- 火车车次：`^[GCDZTSPKXLY1-9]\\d{1,4}$`\n- url：`^[a-zA-Z]+:\\/\\/`\n- Mac地址：`^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$`\n- 传真号码：`^(([0\\+]\\d{2,3}-)?(0\\d{2,3})-)(\\d{7,8})(-(\\d{3,}))?$`\n- 手机号码：`^1[34578]\\d{9}$`\n- md5格式32位：`^[a-f0-9]{32}$`\n- ipv4：`(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}`\n- ipv6：`(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))`\n- email：`^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$`\n- 十六进制颜色：`^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$`\n- 版本号：`^\\d+(?:\\.\\d+){2}$`\n- 车牌号：`^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z](?:((\\d{5}[A-HJK])|([A-HJK][A-HJ-NP-Z0-9][0-9]{4}))|[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳])$`\n- 中国邮政编码：`[1-9]\\d{5}(?!\\d)`\n- 迅雷连接：`^thunderx?:\\/\\/[a-zA-Z\\d]+=$`\n- ed2k连接：`^ed2k:\\/\\/\\|file\\|.+\\|\\/$`\n- 磁力连接：`^magnet:\\?xt=urn:btih:[0-9a-fA-F]{40,}.*$`\n- html标记：`<(\\S*?)[^>]*>.*?</\\1>|<.*?/>`\n- html注释：`<!--(.*?)-->`\n\n# 超强的grep替代品\n- ripgrep\n- hypergrep\n","source":"_posts/grep与正则表达式.md","raw":"---\ntitle: grep与正则表达式\ndate: 2020-11-20 19:46:54\nsubtitle:\ncategories:\ntags:\nindex_img: /images/regex.jpg\nbanner_img: /images/regex.jpg\n---\n# grep\n格式:`grep [options] [regex] [file...]`\n\n|选项|描述|\n|:-:|:-:|\n|-i|忽略大小写|\n|-v|打印不匹配的文本行|\n|-c|只打印匹配或不匹配(-v选项)的行数|\n|-l|打印包含匹配项的文件名,而不是文本行本身|\n|-L|相似于-l项,但是只是打印不包含匹配项的文件名|\n|-n|在每个匹配行之前打印出相应的行号|\n|-w|只识别整个单词(即模式前后有空格)|\n|-E|识别扩展正则表达式|\n|-F|忽略字符中的元字符|\n|-r|递归对某个目录的所有文件|\n|-I|等价于-binary-files=without-match,不匹配二进制|\n|-exclude-dir=[目录路径]|跳过某个目录|\n|--binary-files=without-match|二进制文件不匹配|\n\n# 正则表达式\n## 正则表达式的元字\n\n|特殊字符|用途|\n|:-:|:-:|\n|`.`|匹配除换行符外的任一单字符。在awk中,句点也能匹配换行符|\n|`*`|匹配任一个(包括零个)在它面前的字符(包括由正则表达式指定的字符)|\n|`[...]`|匹配方括号中的字符类中的任意一个。如果方括号中第一个字符为脱字符号(^),则表示否定匹配,即匹配除了换行符和类中列出的那些字符以外的所有字符。在awk中,也匹配换行符。连字符(-)用于表示字符的范围(可以连续用如[A-Za-z0-9])。如果类中的第一个字符为右方括号(])则表示它是类的成员＝所有其他的元字符在被指定为类中的成员时都会失去它们原来的含义|\n|`^`|如果作为正则表达式的第一个字符,则表示匹配行的开始。在awk中匹配字符串的开始,即使字符串包含嵌入的换行符|\n|`$`|如果作为正则表达式的最后一个字符,则表示匹配行的结尾。在awk中匹配字符串的结尾,即使字符串包含嵌入的换行符。|\n|`\\{n,m\\}`|匹配它前面某个范围内单个字符出现的次数(包括由正则表达式指定的字符)。`\\{n\\}`将匹配n次出现,`\\{n,\\}`至少匹配n次出现,而且`\\{n,m\\}`匹配n和m之间任意次的出现|\n|`\\`|转义随后的特殊字符|\n\n## POSIX字符类\nPOSIX是标准,通用于其它shell命令,不仅仅是正则,并且只能出现在中括号中,就是说应该这么写`[[:alnum:]]`\n\n|类|打印字符|\n|:-:|:-:|\n|[:alnum:]|字母数字字符,等价于[A-Za-z0-9]|\n|[:word:]|与[:alnum:]相同,但增加了下划线字符|\n|[:alpha:]|字母字符|\n|[:blank:]|空格和制表符|\n|[:cntrl:]|控制字符,0~31和127的ASCII字符|\n|[:digit:]|数字字符0~9|\n|[:graph:]|可打印和可见的(非空格)字符,33-126的ASCII|\n|[:lower:]|小写字符|\n|[:upper:]|大写字符|\n|[:print:]|可打印的字符(包括空白字符)|\n|[:punct:]|标点符号字符,在 ASCII 中, 等 价 于:`-!”#$%&’()*+,./:;<=>?@[\\\\\\]_‘| ̃`|\n|[:space:]|空白字符,包括空格,tab,回车,换行,vertical tab和form feed,在ASCII中,等价于:[\\t\\r\\n\\v\\f]|\n|[:xdigit:]|十六进制数字|\n\n## 扩展的元字符\n\n|特殊字符|用途|\n|:-:|:-:|\n|`+`|匹配前面的正则表达式的一次或多次出现|\n|`?`|匹配前面的正则表达式的零次或一次出现|\n|`\\|`|逻辑表达或,指定可以匹配前面的或后面的正则表达式|\n|`()`|对正则表达式分组,如`^(bz|gz|zip) 和 ^bz|gz|zip`的区分,前者表示以三者之一开头的,后者表示以bz开头,或包含gz或zip|\n|`{n,m}`|匹配它前面某个范围内单个字符出现的次数,与基本元字符的一样|\n|`\\w`|和任何可以做单词组成成分的字符匹配(字母下划线数字)|\n|`\\W`|和任何不能做单词组成成分的字符匹配|\n|`\\<`|和一个单词开头的空字符串匹配|\n|`\\>`|和一个单词末尾的空字符串匹配|\n|`\\y`|和一个单词开头的空字符串或末尾的空字符串匹配（单词边界）,这适用于awk|\n|`\\b`|同上，除了awk的其他软件|\n|`\\B`|匹配非单词边界。er\\B 能匹配 verb 中的 er，但不能匹配 never 中的 er。|\n|`\\d`|匹配数字：[0-9]|\n|`\\D`|匹配非数字|\n|`\\s`|匹配所有空格字符，等价于`[\\t\\n\\f\\r\\p{Z}]`|\n|`\\S`|匹配所有非空格字符|\n|`p`|匹配 CR/LF（等同于 \\r\\n），用来匹配DOS行终止符|\n|`\\'`|和在缓冲区开始处的空字符串匹配|\n## 零宽度断言\n\n|符号|描述|\n|:-:|:-:|\n|?=|正先行断言-存在|\n|?!|负先行断言-排除|\n|?<=|正后发断言-存在|\n|`?<!`|负后发断言-排除|\n## 模式修正符\n\n|标志|描述|\n|:-:|:-:|\n|i|忽略大小写。|\n|g|全局搜索。|\n|m|多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。|\n\n## grep应用举例\n- 打印匹配前后5行:`grep -5 'pattern' inputfile` \n- 打印匹配后5行:`grep -A 5 'pattern' inputfile`\n- 打印匹配前5行:`grep -B 5 'pattern' inputfile`\n- 打印匹配前5行:`grep -i 'pattern' inputfile`\n- 提取w1和w2两个中间的文字:`grep -o -P '(?<=w1).*(?=w2)'`\n- 查找一个单词出现的次数:`grep -o bbo filename |wc -l`\n- 查找括号之间的字符:`grep -oP '\\(\\K[^\\)]+'`\n## 正则表达式举例\n- 引号中的任意字符串: `\".*\"`\n- 邮箱：`^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$`\n- 中国大陆手机号：`^1[3-9][[:digit:]]\\{9\\}$`\n- 匹配任意域名：`^((http:\\/\\/)|(https:\\/\\/))?([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}(\\/)`\n- 匹配IP地址：`((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))`\n- 汉字：`^[\\u4e00-\\u9fa5]{0,}$`\n- 整数：`^-?[1-9]\\d*$`\n- 浮点数：`^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$`\n- 身份证号：`^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$`\n- 军官证：`^[\\u4E00-\\u9FA5](字第)([0-9a-zA-Z]{4,8})(号?)$`\n- 护照：`^([a-zA-z]|[0-9]){5,17}$`\n- 港澳通行证：`^([A-Z]\\d{6,10}(\\(\\w{1}\\))?)$`\n- 台湾通行证：`^\\d{8}|^[a-zA-Z0-9]{10}|^\\d{18}$`\n- 强密码：`^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$`\n- 火车车次：`^[GCDZTSPKXLY1-9]\\d{1,4}$`\n- url：`^[a-zA-Z]+:\\/\\/`\n- Mac地址：`^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$`\n- 传真号码：`^(([0\\+]\\d{2,3}-)?(0\\d{2,3})-)(\\d{7,8})(-(\\d{3,}))?$`\n- 手机号码：`^1[34578]\\d{9}$`\n- md5格式32位：`^[a-f0-9]{32}$`\n- ipv4：`(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}`\n- ipv6：`(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))`\n- email：`^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$`\n- 十六进制颜色：`^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$`\n- 版本号：`^\\d+(?:\\.\\d+){2}$`\n- 车牌号：`^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z](?:((\\d{5}[A-HJK])|([A-HJK][A-HJ-NP-Z0-9][0-9]{4}))|[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳])$`\n- 中国邮政编码：`[1-9]\\d{5}(?!\\d)`\n- 迅雷连接：`^thunderx?:\\/\\/[a-zA-Z\\d]+=$`\n- ed2k连接：`^ed2k:\\/\\/\\|file\\|.+\\|\\/$`\n- 磁力连接：`^magnet:\\?xt=urn:btih:[0-9a-fA-F]{40,}.*$`\n- html标记：`<(\\S*?)[^>]*>.*?</\\1>|<.*?/>`\n- html注释：`<!--(.*?)-->`\n\n# 超强的grep替代品\n- ripgrep\n- hypergrep\n","slug":"grep与正则表达式","published":1,"updated":"2024-10-07T00:49:00.958Z","_id":"clq1yvi72000zgwq2e2fy6j71","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h1><p>格式:<code>grep [options] [regex] [file...]</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">忽略大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">打印不匹配的文本行</td>\n</tr>\n<tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">只打印匹配或不匹配(-v选项)的行数</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">打印包含匹配项的文件名,而不是文本行本身</td>\n</tr>\n<tr>\n<td align=\"center\">-L</td>\n<td align=\"center\">相似于-l项,但是只是打印不包含匹配项的文件名</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">在每个匹配行之前打印出相应的行号</td>\n</tr>\n<tr>\n<td align=\"center\">-w</td>\n<td align=\"center\">只识别整个单词(即模式前后有空格)</td>\n</tr>\n<tr>\n<td align=\"center\">-E</td>\n<td align=\"center\">识别扩展正则表达式</td>\n</tr>\n<tr>\n<td align=\"center\">-F</td>\n<td align=\"center\">忽略字符中的元字符</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">递归对某个目录的所有文件</td>\n</tr>\n<tr>\n<td align=\"center\">-I</td>\n<td align=\"center\">等价于-binary-files&#x3D;without-match,不匹配二进制</td>\n</tr>\n<tr>\n<td align=\"center\">-exclude-dir&#x3D;[目录路径]</td>\n<td align=\"center\">跳过某个目录</td>\n</tr>\n<tr>\n<td align=\"center\">–binary-files&#x3D;without-match</td>\n<td align=\"center\">二进制文件不匹配</td>\n</tr>\n</tbody></table>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"正则表达式的元字\"><a href=\"#正则表达式的元字\" class=\"headerlink\" title=\"正则表达式的元字\"></a>正则表达式的元字</h2><table>\n<thead>\n<tr>\n<th align=\"center\">特殊字符</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>.</code></td>\n<td align=\"center\">匹配除换行符外的任一单字符。在awk中,句点也能匹配换行符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>*</code></td>\n<td align=\"center\">匹配任一个(包括零个)在它面前的字符(包括由正则表达式指定的字符)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[...]</code></td>\n<td align=\"center\">匹配方括号中的字符类中的任意一个。如果方括号中第一个字符为脱字符号(^),则表示否定匹配,即匹配除了换行符和类中列出的那些字符以外的所有字符。在awk中,也匹配换行符。连字符(-)用于表示字符的范围(可以连续用如[A-Za-z0-9])。如果类中的第一个字符为右方括号(])则表示它是类的成员＝所有其他的元字符在被指定为类中的成员时都会失去它们原来的含义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>^</code></td>\n<td align=\"center\">如果作为正则表达式的第一个字符,则表示匹配行的开始。在awk中匹配字符串的开始,即使字符串包含嵌入的换行符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$</code></td>\n<td align=\"center\">如果作为正则表达式的最后一个字符,则表示匹配行的结尾。在awk中匹配字符串的结尾,即使字符串包含嵌入的换行符。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&#123;n,m\\&#125;</code></td>\n<td align=\"center\">匹配它前面某个范围内单个字符出现的次数(包括由正则表达式指定的字符)。<code>\\&#123;n\\&#125;</code>将匹配n次出现,<code>\\&#123;n,\\&#125;</code>至少匹配n次出现,而且<code>\\&#123;n,m\\&#125;</code>匹配n和m之间任意次的出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\</code></td>\n<td align=\"center\">转义随后的特殊字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"POSIX字符类\"><a href=\"#POSIX字符类\" class=\"headerlink\" title=\"POSIX字符类\"></a>POSIX字符类</h2><p>POSIX是标准,通用于其它shell命令,不仅仅是正则,并且只能出现在中括号中,就是说应该这么写<code>[[:alnum:]]</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类</th>\n<th align=\"center\">打印字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">[:alnum:]</td>\n<td align=\"center\">字母数字字符,等价于[A-Za-z0-9]</td>\n</tr>\n<tr>\n<td align=\"center\">[:word:]</td>\n<td align=\"center\">与[:alnum:]相同,但增加了下划线字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:alpha:]</td>\n<td align=\"center\">字母字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:blank:]</td>\n<td align=\"center\">空格和制表符</td>\n</tr>\n<tr>\n<td align=\"center\">[:cntrl:]</td>\n<td align=\"center\">控制字符,0~31和127的ASCII字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:digit:]</td>\n<td align=\"center\">数字字符0~9</td>\n</tr>\n<tr>\n<td align=\"center\">[:graph:]</td>\n<td align=\"center\">可打印和可见的(非空格)字符,33-126的ASCII</td>\n</tr>\n<tr>\n<td align=\"center\">[:lower:]</td>\n<td align=\"center\">小写字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:upper:]</td>\n<td align=\"center\">大写字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:print:]</td>\n<td align=\"center\">可打印的字符(包括空白字符)</td>\n</tr>\n<tr>\n<td align=\"center\">[:punct:]</td>\n<td align=\"center\">标点符号字符,在 ASCII 中, 等 价 于:&#96;-!”#$%&amp;’()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[\\]_‘</td>\n</tr>\n<tr>\n<td align=\"center\">[:space:]</td>\n<td align=\"center\">空白字符,包括空格,tab,回车,换行,vertical tab和form feed,在ASCII中,等价于:[\\t\\r\\n\\v\\f]</td>\n</tr>\n<tr>\n<td align=\"center\">[:xdigit:]</td>\n<td align=\"center\">十六进制数字</td>\n</tr>\n</tbody></table>\n<h2 id=\"扩展的元字符\"><a href=\"#扩展的元字符\" class=\"headerlink\" title=\"扩展的元字符\"></a>扩展的元字符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">特殊字符</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>+</code></td>\n<td align=\"center\">匹配前面的正则表达式的一次或多次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>?</code></td>\n<td align=\"center\">匹配前面的正则表达式的零次或一次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>|</code></td>\n<td align=\"center\">逻辑表达或,指定可以匹配前面的或后面的正则表达式</td>\n</tr>\n<tr>\n<td align=\"center\"><code>()</code></td>\n<td align=\"center\">对正则表达式分组,如&#96;^(bz</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&#123;n,m&#125;</code></td>\n<td align=\"center\">匹配它前面某个范围内单个字符出现的次数,与基本元字符的一样</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\w</code></td>\n<td align=\"center\">和任何可以做单词组成成分的字符匹配(字母下划线数字)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\W</code></td>\n<td align=\"center\">和任何不能做单词组成成分的字符匹配</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&lt;</code></td>\n<td align=\"center\">和一个单词开头的空字符串匹配</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&gt;</code></td>\n<td align=\"center\">和一个单词末尾的空字符串匹配</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\y</code></td>\n<td align=\"center\">和一个单词开头的空字符串或末尾的空字符串匹配（单词边界）,这适用于awk</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\b</code></td>\n<td align=\"center\">同上，除了awk的其他软件</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\B</code></td>\n<td align=\"center\">匹配非单词边界。er\\B 能匹配 verb 中的 er，但不能匹配 never 中的 er。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\d</code></td>\n<td align=\"center\">匹配数字：[0-9]</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\D</code></td>\n<td align=\"center\">匹配非数字</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\s</code></td>\n<td align=\"center\">匹配所有空格字符，等价于<code>[\\t\\n\\f\\r\\p&#123;Z&#125;]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\S</code></td>\n<td align=\"center\">匹配所有非空格字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>p</code></td>\n<td align=\"center\">匹配 CR&#x2F;LF（等同于 \\r\\n），用来匹配DOS行终止符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&#39;</code></td>\n<td align=\"center\">和在缓冲区开始处的空字符串匹配</td>\n</tr>\n</tbody></table>\n<h2 id=\"零宽度断言\"><a href=\"#零宽度断言\" class=\"headerlink\" title=\"零宽度断言\"></a>零宽度断言</h2><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">?&#x3D;</td>\n<td align=\"center\">正先行断言-存在</td>\n</tr>\n<tr>\n<td align=\"center\">?!</td>\n<td align=\"center\">负先行断言-排除</td>\n</tr>\n<tr>\n<td align=\"center\">?&lt;&#x3D;</td>\n<td align=\"center\">正后发断言-存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>?&lt;!</code></td>\n<td align=\"center\">负后发断言-排除</td>\n</tr>\n</tbody></table>\n<h2 id=\"模式修正符\"><a href=\"#模式修正符\" class=\"headerlink\" title=\"模式修正符\"></a>模式修正符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">标志</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">i</td>\n<td align=\"center\">忽略大小写。</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td align=\"center\">全局搜索。</td>\n</tr>\n<tr>\n<td align=\"center\">m</td>\n<td align=\"center\">多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</td>\n</tr>\n</tbody></table>\n<h2 id=\"grep应用举例\"><a href=\"#grep应用举例\" class=\"headerlink\" title=\"grep应用举例\"></a>grep应用举例</h2><ul>\n<li>打印匹配前后5行:<code>grep -5 &#39;pattern&#39; inputfile</code> </li>\n<li>打印匹配后5行:<code>grep -A 5 &#39;pattern&#39; inputfile</code></li>\n<li>打印匹配前5行:<code>grep -B 5 &#39;pattern&#39; inputfile</code></li>\n<li>打印匹配前5行:<code>grep -i &#39;pattern&#39; inputfile</code></li>\n<li>提取w1和w2两个中间的文字:<code>grep -o -P &#39;(?&lt;=w1).*(?=w2)&#39;</code></li>\n<li>查找一个单词出现的次数:<code>grep -o bbo filename |wc -l</code></li>\n<li>查找括号之间的字符:<code>grep -oP &#39;\\(\\K[^\\)]+&#39;</code></li>\n</ul>\n<h2 id=\"正则表达式举例\"><a href=\"#正则表达式举例\" class=\"headerlink\" title=\"正则表达式举例\"></a>正则表达式举例</h2><ul>\n<li>引号中的任意字符串: <code>&quot;.*&quot;</code></li>\n<li>邮箱：<code>^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$</code></li>\n<li>中国大陆手机号：<code>^1[3-9][[:digit:]]\\&#123;9\\&#125;$</code></li>\n<li>匹配任意域名：<code>^((http:\\/\\/)|(https:\\/\\/))?([a-zA-Z0-9]([a-zA-Z0-9\\-]&#123;0,61&#125;[a-zA-Z0-9])?\\.)+[a-zA-Z]&#123;2,6&#125;(\\/)</code></li>\n<li>匹配IP地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>\n<li>汉字：<code>^[\\u4e00-\\u9fa5]&#123;0,&#125;$</code></li>\n<li>整数：<code>^-?[1-9]\\d*$</code></li>\n<li>浮点数：<code>^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$</code></li>\n<li>身份证号：<code>^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$</code></li>\n<li>军官证：<code>^[\\u4E00-\\u9FA5](字第)([0-9a-zA-Z]&#123;4,8&#125;)(号?)$</code></li>\n<li>护照：<code>^([a-zA-z]|[0-9])&#123;5,17&#125;$</code></li>\n<li>港澳通行证：<code>^([A-Z]\\d&#123;6,10&#125;(\\(\\w&#123;1&#125;\\))?)$</code></li>\n<li>台湾通行证：<code>^\\d&#123;8&#125;|^[a-zA-Z0-9]&#123;10&#125;|^\\d&#123;18&#125;$</code></li>\n<li>强密码：<code>^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$</code></li>\n<li>火车车次：<code>^[GCDZTSPKXLY1-9]\\d&#123;1,4&#125;$</code></li>\n<li>url：<code>^[a-zA-Z]+:\\/\\/</code></li>\n<li>Mac地址：<code>^([0-9a-fA-F][0-9a-fA-F]:)&#123;5&#125;([0-9a-fA-F][0-9a-fA-F])$</code></li>\n<li>传真号码：<code>^(([0\\+]\\d&#123;2,3&#125;-)?(0\\d&#123;2,3&#125;)-)(\\d&#123;7,8&#125;)(-(\\d&#123;3,&#125;))?$</code></li>\n<li>手机号码：<code>^1[34578]\\d&#123;9&#125;$</code></li>\n<li>md5格式32位：<code>^[a-f0-9]&#123;32&#125;$</code></li>\n<li>ipv4：<code>(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))&#123;3&#125;</code></li>\n<li>ipv6：<code>(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</code></li>\n<li>email：<code>^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$</code></li>\n<li>十六进制颜色：<code>^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$</code></li>\n<li>版本号：<code>^\\d+(?:\\.\\d+)&#123;2&#125;$</code></li>\n<li>车牌号：<code>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z](?:((\\d&#123;5&#125;[A-HJK])|([A-HJK][A-HJ-NP-Z0-9][0-9]&#123;4&#125;))|[A-HJ-NP-Z0-9]&#123;4&#125;[A-HJ-NP-Z0-9挂学警港澳])$</code></li>\n<li>中国邮政编码：<code>[1-9]\\d&#123;5&#125;(?!\\d)</code></li>\n<li>迅雷连接：<code>^thunderx?:\\/\\/[a-zA-Z\\d]+=$</code></li>\n<li>ed2k连接：<code>^ed2k:\\/\\/\\|file\\|.+\\|\\/$</code></li>\n<li>磁力连接：<code>^magnet:\\?xt=urn:btih:[0-9a-fA-F]&#123;40,&#125;.*$</code></li>\n<li>html标记：<code>&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*?/&gt;</code></li>\n<li>html注释：<code>&lt;!--(.*?)--&gt;</code></li>\n</ul>\n<h1 id=\"超强的grep替代品\"><a href=\"#超强的grep替代品\" class=\"headerlink\" title=\"超强的grep替代品\"></a>超强的grep替代品</h1><ul>\n<li>ripgrep</li>\n<li>hypergrep</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h1><p>格式:<code>grep [options] [regex] [file...]</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">忽略大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">打印不匹配的文本行</td>\n</tr>\n<tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">只打印匹配或不匹配(-v选项)的行数</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">打印包含匹配项的文件名,而不是文本行本身</td>\n</tr>\n<tr>\n<td align=\"center\">-L</td>\n<td align=\"center\">相似于-l项,但是只是打印不包含匹配项的文件名</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">在每个匹配行之前打印出相应的行号</td>\n</tr>\n<tr>\n<td align=\"center\">-w</td>\n<td align=\"center\">只识别整个单词(即模式前后有空格)</td>\n</tr>\n<tr>\n<td align=\"center\">-E</td>\n<td align=\"center\">识别扩展正则表达式</td>\n</tr>\n<tr>\n<td align=\"center\">-F</td>\n<td align=\"center\">忽略字符中的元字符</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">递归对某个目录的所有文件</td>\n</tr>\n<tr>\n<td align=\"center\">-I</td>\n<td align=\"center\">等价于-binary-files&#x3D;without-match,不匹配二进制</td>\n</tr>\n<tr>\n<td align=\"center\">-exclude-dir&#x3D;[目录路径]</td>\n<td align=\"center\">跳过某个目录</td>\n</tr>\n<tr>\n<td align=\"center\">–binary-files&#x3D;without-match</td>\n<td align=\"center\">二进制文件不匹配</td>\n</tr>\n</tbody></table>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"正则表达式的元字\"><a href=\"#正则表达式的元字\" class=\"headerlink\" title=\"正则表达式的元字\"></a>正则表达式的元字</h2><table>\n<thead>\n<tr>\n<th align=\"center\">特殊字符</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>.</code></td>\n<td align=\"center\">匹配除换行符外的任一单字符。在awk中,句点也能匹配换行符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>*</code></td>\n<td align=\"center\">匹配任一个(包括零个)在它面前的字符(包括由正则表达式指定的字符)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[...]</code></td>\n<td align=\"center\">匹配方括号中的字符类中的任意一个。如果方括号中第一个字符为脱字符号(^),则表示否定匹配,即匹配除了换行符和类中列出的那些字符以外的所有字符。在awk中,也匹配换行符。连字符(-)用于表示字符的范围(可以连续用如[A-Za-z0-9])。如果类中的第一个字符为右方括号(])则表示它是类的成员＝所有其他的元字符在被指定为类中的成员时都会失去它们原来的含义</td>\n</tr>\n<tr>\n<td align=\"center\"><code>^</code></td>\n<td align=\"center\">如果作为正则表达式的第一个字符,则表示匹配行的开始。在awk中匹配字符串的开始,即使字符串包含嵌入的换行符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$</code></td>\n<td align=\"center\">如果作为正则表达式的最后一个字符,则表示匹配行的结尾。在awk中匹配字符串的结尾,即使字符串包含嵌入的换行符。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&#123;n,m\\&#125;</code></td>\n<td align=\"center\">匹配它前面某个范围内单个字符出现的次数(包括由正则表达式指定的字符)。<code>\\&#123;n\\&#125;</code>将匹配n次出现,<code>\\&#123;n,\\&#125;</code>至少匹配n次出现,而且<code>\\&#123;n,m\\&#125;</code>匹配n和m之间任意次的出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\</code></td>\n<td align=\"center\">转义随后的特殊字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"POSIX字符类\"><a href=\"#POSIX字符类\" class=\"headerlink\" title=\"POSIX字符类\"></a>POSIX字符类</h2><p>POSIX是标准,通用于其它shell命令,不仅仅是正则,并且只能出现在中括号中,就是说应该这么写<code>[[:alnum:]]</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类</th>\n<th align=\"center\">打印字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">[:alnum:]</td>\n<td align=\"center\">字母数字字符,等价于[A-Za-z0-9]</td>\n</tr>\n<tr>\n<td align=\"center\">[:word:]</td>\n<td align=\"center\">与[:alnum:]相同,但增加了下划线字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:alpha:]</td>\n<td align=\"center\">字母字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:blank:]</td>\n<td align=\"center\">空格和制表符</td>\n</tr>\n<tr>\n<td align=\"center\">[:cntrl:]</td>\n<td align=\"center\">控制字符,0~31和127的ASCII字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:digit:]</td>\n<td align=\"center\">数字字符0~9</td>\n</tr>\n<tr>\n<td align=\"center\">[:graph:]</td>\n<td align=\"center\">可打印和可见的(非空格)字符,33-126的ASCII</td>\n</tr>\n<tr>\n<td align=\"center\">[:lower:]</td>\n<td align=\"center\">小写字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:upper:]</td>\n<td align=\"center\">大写字符</td>\n</tr>\n<tr>\n<td align=\"center\">[:print:]</td>\n<td align=\"center\">可打印的字符(包括空白字符)</td>\n</tr>\n<tr>\n<td align=\"center\">[:punct:]</td>\n<td align=\"center\">标点符号字符,在 ASCII 中, 等 价 于:&#96;-!”#$%&amp;’()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[\\]_‘</td>\n</tr>\n<tr>\n<td align=\"center\">[:space:]</td>\n<td align=\"center\">空白字符,包括空格,tab,回车,换行,vertical tab和form feed,在ASCII中,等价于:[\\t\\r\\n\\v\\f]</td>\n</tr>\n<tr>\n<td align=\"center\">[:xdigit:]</td>\n<td align=\"center\">十六进制数字</td>\n</tr>\n</tbody></table>\n<h2 id=\"扩展的元字符\"><a href=\"#扩展的元字符\" class=\"headerlink\" title=\"扩展的元字符\"></a>扩展的元字符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">特殊字符</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>+</code></td>\n<td align=\"center\">匹配前面的正则表达式的一次或多次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>?</code></td>\n<td align=\"center\">匹配前面的正则表达式的零次或一次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>|</code></td>\n<td align=\"center\">逻辑表达或,指定可以匹配前面的或后面的正则表达式</td>\n</tr>\n<tr>\n<td align=\"center\"><code>()</code></td>\n<td align=\"center\">对正则表达式分组,如&#96;^(bz</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&#123;n,m&#125;</code></td>\n<td align=\"center\">匹配它前面某个范围内单个字符出现的次数,与基本元字符的一样</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\w</code></td>\n<td align=\"center\">和任何可以做单词组成成分的字符匹配(字母下划线数字)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\W</code></td>\n<td align=\"center\">和任何不能做单词组成成分的字符匹配</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&lt;</code></td>\n<td align=\"center\">和一个单词开头的空字符串匹配</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&gt;</code></td>\n<td align=\"center\">和一个单词末尾的空字符串匹配</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\y</code></td>\n<td align=\"center\">和一个单词开头的空字符串或末尾的空字符串匹配（单词边界）,这适用于awk</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\b</code></td>\n<td align=\"center\">同上，除了awk的其他软件</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\B</code></td>\n<td align=\"center\">匹配非单词边界。er\\B 能匹配 verb 中的 er，但不能匹配 never 中的 er。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\d</code></td>\n<td align=\"center\">匹配数字：[0-9]</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\D</code></td>\n<td align=\"center\">匹配非数字</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\s</code></td>\n<td align=\"center\">匹配所有空格字符，等价于<code>[\\t\\n\\f\\r\\p&#123;Z&#125;]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\S</code></td>\n<td align=\"center\">匹配所有非空格字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>p</code></td>\n<td align=\"center\">匹配 CR&#x2F;LF（等同于 \\r\\n），用来匹配DOS行终止符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\&#39;</code></td>\n<td align=\"center\">和在缓冲区开始处的空字符串匹配</td>\n</tr>\n</tbody></table>\n<h2 id=\"零宽度断言\"><a href=\"#零宽度断言\" class=\"headerlink\" title=\"零宽度断言\"></a>零宽度断言</h2><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">?&#x3D;</td>\n<td align=\"center\">正先行断言-存在</td>\n</tr>\n<tr>\n<td align=\"center\">?!</td>\n<td align=\"center\">负先行断言-排除</td>\n</tr>\n<tr>\n<td align=\"center\">?&lt;&#x3D;</td>\n<td align=\"center\">正后发断言-存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>?&lt;!</code></td>\n<td align=\"center\">负后发断言-排除</td>\n</tr>\n</tbody></table>\n<h2 id=\"模式修正符\"><a href=\"#模式修正符\" class=\"headerlink\" title=\"模式修正符\"></a>模式修正符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">标志</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">i</td>\n<td align=\"center\">忽略大小写。</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td align=\"center\">全局搜索。</td>\n</tr>\n<tr>\n<td align=\"center\">m</td>\n<td align=\"center\">多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</td>\n</tr>\n</tbody></table>\n<h2 id=\"grep应用举例\"><a href=\"#grep应用举例\" class=\"headerlink\" title=\"grep应用举例\"></a>grep应用举例</h2><ul>\n<li>打印匹配前后5行:<code>grep -5 &#39;pattern&#39; inputfile</code> </li>\n<li>打印匹配后5行:<code>grep -A 5 &#39;pattern&#39; inputfile</code></li>\n<li>打印匹配前5行:<code>grep -B 5 &#39;pattern&#39; inputfile</code></li>\n<li>打印匹配前5行:<code>grep -i &#39;pattern&#39; inputfile</code></li>\n<li>提取w1和w2两个中间的文字:<code>grep -o -P &#39;(?&lt;=w1).*(?=w2)&#39;</code></li>\n<li>查找一个单词出现的次数:<code>grep -o bbo filename |wc -l</code></li>\n<li>查找括号之间的字符:<code>grep -oP &#39;\\(\\K[^\\)]+&#39;</code></li>\n</ul>\n<h2 id=\"正则表达式举例\"><a href=\"#正则表达式举例\" class=\"headerlink\" title=\"正则表达式举例\"></a>正则表达式举例</h2><ul>\n<li>引号中的任意字符串: <code>&quot;.*&quot;</code></li>\n<li>邮箱：<code>^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$</code></li>\n<li>中国大陆手机号：<code>^1[3-9][[:digit:]]\\&#123;9\\&#125;$</code></li>\n<li>匹配任意域名：<code>^((http:\\/\\/)|(https:\\/\\/))?([a-zA-Z0-9]([a-zA-Z0-9\\-]&#123;0,61&#125;[a-zA-Z0-9])?\\.)+[a-zA-Z]&#123;2,6&#125;(\\/)</code></li>\n<li>匹配IP地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>\n<li>汉字：<code>^[\\u4e00-\\u9fa5]&#123;0,&#125;$</code></li>\n<li>整数：<code>^-?[1-9]\\d*$</code></li>\n<li>浮点数：<code>^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$</code></li>\n<li>身份证号：<code>^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$</code></li>\n<li>军官证：<code>^[\\u4E00-\\u9FA5](字第)([0-9a-zA-Z]&#123;4,8&#125;)(号?)$</code></li>\n<li>护照：<code>^([a-zA-z]|[0-9])&#123;5,17&#125;$</code></li>\n<li>港澳通行证：<code>^([A-Z]\\d&#123;6,10&#125;(\\(\\w&#123;1&#125;\\))?)$</code></li>\n<li>台湾通行证：<code>^\\d&#123;8&#125;|^[a-zA-Z0-9]&#123;10&#125;|^\\d&#123;18&#125;$</code></li>\n<li>强密码：<code>^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$</code></li>\n<li>火车车次：<code>^[GCDZTSPKXLY1-9]\\d&#123;1,4&#125;$</code></li>\n<li>url：<code>^[a-zA-Z]+:\\/\\/</code></li>\n<li>Mac地址：<code>^([0-9a-fA-F][0-9a-fA-F]:)&#123;5&#125;([0-9a-fA-F][0-9a-fA-F])$</code></li>\n<li>传真号码：<code>^(([0\\+]\\d&#123;2,3&#125;-)?(0\\d&#123;2,3&#125;)-)(\\d&#123;7,8&#125;)(-(\\d&#123;3,&#125;))?$</code></li>\n<li>手机号码：<code>^1[34578]\\d&#123;9&#125;$</code></li>\n<li>md5格式32位：<code>^[a-f0-9]&#123;32&#125;$</code></li>\n<li>ipv4：<code>(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))&#123;3&#125;</code></li>\n<li>ipv6：<code>(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</code></li>\n<li>email：<code>^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$</code></li>\n<li>十六进制颜色：<code>^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$</code></li>\n<li>版本号：<code>^\\d+(?:\\.\\d+)&#123;2&#125;$</code></li>\n<li>车牌号：<code>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z](?:((\\d&#123;5&#125;[A-HJK])|([A-HJK][A-HJ-NP-Z0-9][0-9]&#123;4&#125;))|[A-HJ-NP-Z0-9]&#123;4&#125;[A-HJ-NP-Z0-9挂学警港澳])$</code></li>\n<li>中国邮政编码：<code>[1-9]\\d&#123;5&#125;(?!\\d)</code></li>\n<li>迅雷连接：<code>^thunderx?:\\/\\/[a-zA-Z\\d]+=$</code></li>\n<li>ed2k连接：<code>^ed2k:\\/\\/\\|file\\|.+\\|\\/$</code></li>\n<li>磁力连接：<code>^magnet:\\?xt=urn:btih:[0-9a-fA-F]&#123;40,&#125;.*$</code></li>\n<li>html标记：<code>&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*?/&gt;</code></li>\n<li>html注释：<code>&lt;!--(.*?)--&gt;</code></li>\n</ul>\n<h1 id=\"超强的grep替代品\"><a href=\"#超强的grep替代品\" class=\"headerlink\" title=\"超强的grep替代品\"></a>超强的grep替代品</h1><ul>\n<li>ripgrep</li>\n<li>hypergrep</li>\n</ul>\n"},{"title":"Hello World","index_img":"/images/hello_world.jpg","banner_img":"/images/hello_world.jpg","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nindex_img: /images/hello_world.jpg\nbanner_img: /images/hello_world.jpg\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n","slug":"hello-world","published":1,"date":"2023-12-12T04:17:37.424Z","updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi720010gwq2a1wpbyx1","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"openSSH","date":"2020-12-21T12:30:23.000Z","subtitle":null,"index_img":"/images/openssh.png","banner_img":"/images/openssh.png","_content":"1.登录服务器\n`ssh <user>@<hostname>`hostname是主机名,可以是域名,也可能是IP地址,不指定<user>@时,默认为客户端的当前用户名\n`ssh -p 8821 foo.com`默认端口为21,可以用-p选项指定服务器的端口\n2.文件信息\n服务器公钥的指纹既是SSH服务器公钥的哈希值,每台SSH服务器都有唯一一对密钥\n`ssh-keygen -l -f [*.pub]`查看某个公钥的指纹\nssh会将本机链接过的所有服务器公钥的指纹存储在\"~/.ssh/known_hosts\"文件中。每次链接服务器都会通过该文件判断是否为陌生服务器,如果是陌生的则会产生警告,如果输入yes忽略警告,将会自动添加该服务器的公钥指纹到该文件\n`ssh-keygen -R <hostname>`用于删除某服务器的公钥(用于失效的情况),也可以手动删除known_hosts文件中的相关内容\n3.执行远程命令\n一般在登陆后,输入命令,\n也可以一步到位`ssh [username@hostname] <command>`登陆成功后立即执行命令,如果命令是交互式的,则需要加上-t选项,如:`ssh -t foo.com vi foo.txt`\n4.命令行配置项\n\n|参数|意义|例子|\n|:-:|:-:|:-:|\n|-c|指定加密算法|`ssh -c blowfish,3des server.example.com`,`ssh -c blowfish -c 3des server.example.com`|\n|-C|压缩数据传输|`ssh -C server.example.com`|\n|-d|设置打印的debug信息级别,数值越高越详细|`ssh -d 1 foo.com`|\n|-D|指定本机的Socks监听端口,该端口收到的请求,都将转发到远程SSH主机,又称动态端口转发|`ssh -D 1080 server`|\n|-f|表示SSH链接在后台运行||\n|-F|指定配置文件|`ssh -F /usr/local/ssh/other_config`|\n|-i|用于指定私钥,默认值是\\~/.ssh/id_dsa|`ssh -i my-key server.example.com`|\n|-l|参数指定远程登录的账户名|`ssh -l nanbert server.example.com`|\n|-L|设置本地端口转发|`ssh -L 9999:targetServer:80 user@remoteServer`所有发向本地9999端口的请求,都会经过remoteServer发往targetServer的80端口,相当于直接连上了80的端口|\n|-m|指定校验数据完整性的算法(MAC)|`ssh -m hmac-sha1,hmac-md5 server.example.com`|\n|-o|参数用来指定一个配置命令,来覆盖配置文件设置|`ssh -o \"User sally\" server.example.com`|\n|-p|指定链接的服务器的端口|`ssh -p 2305 server.example.com`|\n|-q|安静模式,不输出任何警告|`ssh -q foo.com`|\n|-R|指定远程端口转发|`ssh -R 9999:targetServer:902 local`该命令需要在跳板服务器执行,指定本机计算机local监听自己的9999端口,所有发向这个端口的请求,都会转向targetServer的902端口|\n|-t|在ssh直接运行远端命令时,提供一个交互shell|`ssh -t server.example.com emacs`|\n|-v|显示详细信息,可重复多次,表示详细程度|`ssh -vvv server.example.com`|\n|-V|显示客户端版本信息||\n|-X|表示打开X窗口转发|`ssh -X server.example.com`|\n|-1,-2,-4,-6|1表示SSH1协议,2表示SSH2协议,4表示IPv4协议(默认值),6表示Ipv6协议||\n\n5.配置文件\n\n|路径|作用|\n|:-:|:-:|\n|/etc/ssh/ssh_config|全局配置文件|\n|~/.ssh/config|用户个人的配置文件|\n|~/.ssh/id_ecdsa|用户的ECDSA私钥|\n|~/.ssh/id_ecdsa.pub|用户的ECDSA公钥|\n|~/.ssh/rsa|用于SSH2的rsa私钥|\n|~/.ssh/rsa.pub|用于SSH2的rsa公钥|\n|~/.ssh/identity|用于SSH1的rsa私钥|\n|~/.ssh/identity.pub|用于SSH1的rsa公钥|\n|~/.ssh/known_hosts|包含SSH服务器的公钥指纹|\n\n配置文件示例:\n```bash\nHost *\n\tPort 2222\nHost remoteserver\n\tHostName remote.example.com\n\tUser nanbert\n\tPort 2112\n```\n常见配置命令:\n`AddressFamily <option>`option可以是inet,表示IPV4协议,也可以是inet6,表示IPV6协议\n`BindAddress 192.168.10.235`指定本机的IP地址(如果本机有多个Ip地址)\n`CheckHostIP <yesOrNo>`是否检查SSH的服务器IP地址是否跟公钥数据库吻合\n`Ciphers <option>`:指定加密算法\n`Compression <yesOrNo>`是否压缩传输信号\n`ConnectionAttempts <num>`客户端进行连接时,最大尝试次数\n`ConnectTimeout <num>`客户端进行连接时,服务器在指定秒数内没有回复,则中断连接尝试\n`DynamicForward <portNum>`指定动态转发端口\n`GlobalKnownHostsFile <filePath>`指定全局的公钥数据库文件的位置\n`Host <serverName>`指定连接的域名或IP地址,也可以是别名,支持通配符,后面所有配置都是针对该主机,直到遇到下一个Host\n`HostKeyAlgorithm <options>`指定密钥算法,优先级从高到低排列,以逗号分隔\n`HostName <serverAddress>`在Host命令使用别名的情况下用\n`IdentityFile <fileName>`指定私钥文件\n`LocalForward 2001 localhost:143`指定本地端口转发\n`LogLevel <options>`指定日志详细程度。如果设为`QUIET`,将不输出大部分的警告和提示\n`MACs <options>`指定数据校验算法,以逗号分隔\n`NumberOfPasswordPrompts <num>`输错密码最大尝试数\n`PasswordAuthentication <yesOrNo>`是否支持密码登录,这里只是客户端,需要服务器也有相同的设置\n`Port <portNum>`指定客户端链接的SSH服务器端口\n`PreferredAutentications publickey,hostbased,password`指定各种登录方法优先级\n`Protocol <1,2>`支持的SSH协议版本,可以用逗号分隔同时支持两个版本\n`PubKeyAuthentication <yesOrNo>`是否支持密钥登录,这里只是客户端设置,需要服务器相同的设置\n`RemoteForward 2001 server:143`指定远程端口转发\n`SendEnv <variable>`客户端向服务器发送环境变量名,多个环境变量之间用空格分隔,变量的值从当前环境拷贝\n`ServerAliveCountMax <num>`如果没有收到服务器的回应,客户端发送多少次keepalive信号,才断开连接,默认为3\n`ServerAliveInterval <num>`客户端建立连接后,如果在给定的数秒内,没有收到服务器发来的消息,客户端向服务器发送keepalive消息,如果不希望客户端发送,这一项设为0\n`StrictHostKeyChecking <yesOrNo>`yes表示严格检查,服务器公钥为未知或发生变化,则拒绝连接。no表示如果服务器公钥未知,则加入客户端公钥数据库,如果公钥发生变化,不改变客户端公钥数据库,输出一条警告,依然允许连接继续进行。ask(默认值)表示向用户询问是否继续\n`TCPKeepAlive <yesOrNo>`客户端是否定期向服务器发送keepalive信息\n`User <userName>`指定登录账户名\n`UserKnownHostsFile <filePath>`指定当前用户的服务器公钥指纹列表(known_hosts)的文件位置\n`VerifyHostKeyDNS <yesOrNo>`是否检查SSH服务器的DNS记录,确认公钥指纹是否与known_hosts文件保持一致\n6.密钥\n*概念*:\n密钥是一个非常大的数字,通过加密算法得到。对称加密只需要一个密钥,非对称加密需要成对使用,分为公钥和私钥。\nSSH密钥登录采用非对称加密,每个永不通过自己的密钥登录。其中,私钥必须私密保存,不能泄露;公钥则公开,对外发送。它们的关系是,公钥和私钥是一一对应\n*过程*:\n预备步骤,客户端通过`ssh-keygen`生产自己的公钥和私钥\n第一步,手动将客户端的公钥放入远程服务器的指定位置\n第二步,客户端向服务器发起SSH登录请求\n第三步,服务器收到用户SSH登录的请求,发送一些随机数据给用户,要求用户证明自己的身份\n第四步,客户端收到服务器发来的数据,私用私钥对数据进行签名,然后再发给服务器\n第五步,服务器收到客户端发来的加密签名后,使用对应的公钥解密,然后跟原始数据比较。如果一致,就允许用户登录\n*ssh-key--生成密钥*\n该命令会生成一对密钥,私钥默认存在~/.ssh/id_rsa,公钥默认存在~/.ssh/id_rsa.pub\n\n|选项|含义|\n|:-:|:-:|\n|-b [num]|指定密钥的二进制位数。这个参数越大,密钥越不容易破解,但是加密解密的开销也会越大,一般至少应该是1024|\n|-C \"[string]\"|可以为密钥文件指定新的注释,格式一般为`username@host`|\n|-f [filename]|参数指定生成的私钥文件。不指定的话,会在~/.ssh文件夹下生成一对密钥|\n|-F [hostname]|检查某个主机名是否在known_hosts文件里面|\n|-N [secretword]|指定私钥的密码|\n|-p[secretword]|重新指定私钥的密码|\n|-R [hostname]|将指定的主机公钥移除出known_hosts文件|\n|-t [algorithm]|指定加密算法,一般为dsa或rsa|\n\n*手动上传公钥*\n把客户端生成的公钥复制粘贴到文件\\~/.ssh/authorized_keys中去,一个公钥占据一行\n*ssh-copy-id--自动上传公钥*\n`ssh-copy-id -i key_file user@host` 自动上传公钥到服务器\n公钥文件可以不指定路劲和.pub后缀,会自动在\\~/.ssh目录下寻找\n确保authorized_keys文件末尾为换行符,否则两个公钥连在一起,两个都会失效\n\n*ssh-agent命令*\n私钥设置了密码后,每次使用都必须输入密码,连续使用scp命令时,这就很麻烦,ssh-agent命令就是为了解决这个问题而设计的,它让用户在整个bash对话中,只在第一次使用SSH命令是输入密码,然后将私钥保存在内存中\n第一步,新建一次命令对话\n`ssh-agent bash(zhs、fish)`\n第二步,添加私钥\n`ssh-add [filename]`可以不指定私钥名称,使用默认文件~/.ssh/id_rsa\n第三步登录远程服务器\n`ssh remoteHost`\n最后,如果要退出ssh-agent,可以按Ctrl+d,也可以用如下命令\n`ssh-agent -k`\n*ssh-add命令*\nssh-add命令用来将私钥加入ssh-agent\n\n|选项|含义|\n|:-:|:-:|\n|-d|从内存中删除指定的私钥|\n|-D|从内存中删除所有已经添加的私钥|\n|-l|列出所有已经添加的私钥|\n\n<font size=6>**服务器端sshd**</font>\n**1.sshd配置文件**\n`/etc/ssh/sshd_config`配置文件\n`/etc/ssh/ssh_host_ecdsa_key`ECDSA私钥\n`/etc/ssh/ssh_host_ecdsa_key.pub`ECDSA公钥\n`/etc/ssh/ssh_host_key`用于SSH1协议版本的RSA私钥\n`/etc/ssh/ssh_host_key.pub`用于SSH1协议版本的RSA公钥\n`/etc/ssh/ssh_host_rsa_key`用于SSH2协议版本的RSA私钥\n`/etc/ssh/ssh_host_rsa_key.pub`用于SSH2协议版本的RSA公钥\n`/etc/pam.d/sshd`PAM配置文件\n<font color=#FF0000>重装会使这些文件失效,可以先备份</font>\n**sshd配置项**\n\n|配置项|含义|\n|:-:|:-:|\n|AcceptEnv [variables...]|允许接受客户端通过SendEnv命令发来的哪些环境变量,变量名用空格分隔|\n|AllowGroups [groupNames...]|指定允许登录的用户组,多个组之间用空格隔开,若不用该项,则所有组都可以用|\n|AllowUsers [userNames...]|指定允许登录的用户,用户名之间用空格隔开,支持通配符|\n|AllowTcpForwarding [options]|默认值为yes,允许端口转发,local只允许本地端口转发,remote表示只允许远程端口转发|\n|AuthorizedKeysFile [directory]|指定存储用户公钥的目录,默认是`~/.ssh/authorized_keys`|\n|Banner [file]|指定用户登录后,sshd向其展示的信息文件,默认不展示任何内容|\n|ChallengeResponseAuthentication [yesOrNo]|指定是否用\"键盘交互\"身份验证方案,默认值为yes,如果完全禁用基于密码的验证,PasswordAuthentication也设为no|\n|Ciphers [algorithms]|指定sshd可以接受的加密算法,多个算法之间使用逗号分割|\n|ClientAliveCountMax [num]|指定建立连接后,客户端失去响应时,服务器尝试连接的次数|\n|ClientAliveInterval [num]|允许客户端发呆的时间,单位为秒,如果超过这时间,连接将会关闭|\n|Compression [yesOrNo]|Compression指定客户端与服务器之间的数据传输是否为压缩,默认为yes|\n|DenyGroups [groupNames...]|指定不允许登录的用户组,组间空格分开|\n|DenyUsers [userNames...]|指定不允许登录的用户,空格分开不同用户|\n|FascistLogging [yesOrNo]|SSH1版本专用,指定日志是否输出全部Debug信息|\n|HostKey [filePath]|指定服务器密钥的文件路径|\n|KeyRegenerationInterval [num]|指定SSH1版本的密钥重新生成的时间间隔,单位为秒,默认为3600|\n|ListenAddress [ipAddress]|指定sshd监听本机的IP地址,即sshd启用的IP地址,默认是0.0.0.0,表示在本机所有网络接口启用。可以改成只在某个网络接口启用,可以多次使用该配置项,来监听多个ip地址|\n|LoginGraceTime [num]|指定允许客户端登录时发呆的最长时间,超过该时间就断开,0表示没有限制|\n|LogLevel [options]|指定日志的详细程度,可能的值有:QUIET,FATAL,ERROR,INFO,VERNBOSE,DEBUG,DEBUG1,DEBUG2,DEBUG3,默认为INFO|\n|MACs [algorithms]|指定sshd可以接受的数据校验算法(MACs hmac-sha1),多个算法之间使用逗号分隔|\n|MaxAuthTries [num]|指定SSH登录允许的最大密码尝试数|\n|MaxStartups [num]|指定允许同时并发的SSH链接数量,0表示没有限制,也可以是A:B:C形式,如10:50:20,表示如果达到10个并发链接,后面的连接有50%的概率被拒绝,如果达到20个并发连接,则后面的100%拒绝|\n|PasswordAuthentication [yesOrNo]|是否允许密码登录,默认值为yes|\n|PermitEmptyPasswords [yesOrNo]|指定是否允许空密码登录,默认为yes|\n|PermitRootLogin [yesOrNo]|是否允许根用户登录,默认为yes,也可以设为prohibit-password,表示允许密钥登录root,但禁止密码登录|\n|PermitUserEnvironment [yesOrNo]|是否允许sshd加载客户端的~/.ssh/environment文件和~/.ssh/authorized_keys文件里面的environment=options 环境变量设置.默认值为no|\n|Port [num]|指定sshd监听的端口,默认22,可以多次设置,监听多个端口|\n|PrintMoth [yesOrNo]|指定用户登录后,是否向其展示系统的motd的信息文件/etc/motd,默认为yes|\n|Protocol [options]|1表示使用SSH1协议,'1,2'表示支持两个版本的协议|\n|PubKeyAuthentication [yesOrNo]|指定是否允许公钥登录,默认为yes|\n|QuietMode [yesOrNo]|SSH1专用,yes表示日志只输出致命的错误信息|\n|RSAAuthentication [yesOrNo]||指定是否允许RSA认证,默认值为yes|\n|ServerKeyBits [num]|指定SSH1版本的密钥重新生成时的位数,默认为767|\n|StrictModes [yesOrNo]|指定sshd是否检查用户的一些重要文件和目录权限,即对于用户的SSH配置文件,密钥文件和所在目录,SSH要求拥有者必须是根用户或用户本人,其他人的写权限必须关闭|\n|SyslogFacility [options]|指定Syslog如何处理sshd日志,默认是AUTH|\n|TCPKeepAlive [unknown]|指定打开sshd跟客户端tcp链接的keepalive参数|\n|UseDNS [yesOrNo]|指定用户SSH登录一个域名时,服务器是否使用DNS,确认该域名对应的IP地址包含本机,建议关闭|\n|UserLogin [yesOrNo]|指定用户认证内部是否使用/user/bin/login代替SSH工具,默认为no|\n|UserPrivilegeSeparation|指定用户认证通过后,使用另一个子线程处理用户权限相关的操作,这样利于提高安全性|\n|VerboseMode|SSH2版本专用,指定日志输出详细的Debug信息|\n|X11Forwarding|指定是否打开X window的转发,默认值为no|\n**sshd命令行配置项**\n\n|参数|含义|\n|:-:|:-:|\n|-d|用于显示debug信息|\n|-D|指定sshd不作为后台守护进程运行|\n|-e|将sshd写入系统日志syslog的内容导向标准错误|\n|-f [filePath]|指定配置文件位置|\n|-h [filePath]|指定密钥|\n|-o [Key Value]|指定配置文件的一个配置项和对应的值,如:sshd -o \"Port 2034\"|\n|-p [num]|指定sshd的服务端口|\n|-t|检查配置文件语法是否正确|\n\n## scp命令\n- `scp [参数][原路径][目标路径]`\n- 它的底层是SSH协议,默认端口22,相当于先用ssh命令登陆远程主机,然后在执行拷贝,可以用于两个远程系统之间的复制\n### 参数\n-1 强制scp命令使用协议ssh1\n-2 强制scp命令使用协议ssh2\n-4 强制scp命令只使用IPv4寻址\n-6 强制scp命令只使用IPv6寻址\n-B 使用批处理模式（传输过程中不询问传输口令或短语）\n-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）\n-p 留原文件的修改时间，访问时间和访问权限。\n-q 不显示传输进度条。\n-r 递归复制整个目录。\n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。\n-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。\n-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。\n-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。\n-l limit 限定用户所能使用的带宽，以Kbit/s为单位。\n-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，\n-P port 注意是大写的P, port是指定数据传输用到的端口号\n-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n\n\n<font size=6>**sftp命令**</font>\n**简介**\nsftp是ssh提供的一个客户端应用程序,主要用来安全地访问FTP。因为FTP是不加密协议,很不安全,sftp相当于将FTP放入SSH:\n`sftp username@hostname`\n进入sftp后,使用那些命令,如get获取远程文件,put上传文件等\n<font size=6>**端口转发**</font>\n(待建)可见<https://wangdoc.com/ssh/port-forwarding.html>\n<font size=6>**证书登录**</font>\n(待建)可见<https://wangdoc.com/ssh/ca.html>\n","source":"_posts/openSSH.md","raw":"---\ntitle: openSSH\ndate: 2020-12-21 20:30:23\nsubtitle:\ncategories:\ntags:\nindex_img: /images/openssh.png\nbanner_img: /images/openssh.png\n---\n1.登录服务器\n`ssh <user>@<hostname>`hostname是主机名,可以是域名,也可能是IP地址,不指定<user>@时,默认为客户端的当前用户名\n`ssh -p 8821 foo.com`默认端口为21,可以用-p选项指定服务器的端口\n2.文件信息\n服务器公钥的指纹既是SSH服务器公钥的哈希值,每台SSH服务器都有唯一一对密钥\n`ssh-keygen -l -f [*.pub]`查看某个公钥的指纹\nssh会将本机链接过的所有服务器公钥的指纹存储在\"~/.ssh/known_hosts\"文件中。每次链接服务器都会通过该文件判断是否为陌生服务器,如果是陌生的则会产生警告,如果输入yes忽略警告,将会自动添加该服务器的公钥指纹到该文件\n`ssh-keygen -R <hostname>`用于删除某服务器的公钥(用于失效的情况),也可以手动删除known_hosts文件中的相关内容\n3.执行远程命令\n一般在登陆后,输入命令,\n也可以一步到位`ssh [username@hostname] <command>`登陆成功后立即执行命令,如果命令是交互式的,则需要加上-t选项,如:`ssh -t foo.com vi foo.txt`\n4.命令行配置项\n\n|参数|意义|例子|\n|:-:|:-:|:-:|\n|-c|指定加密算法|`ssh -c blowfish,3des server.example.com`,`ssh -c blowfish -c 3des server.example.com`|\n|-C|压缩数据传输|`ssh -C server.example.com`|\n|-d|设置打印的debug信息级别,数值越高越详细|`ssh -d 1 foo.com`|\n|-D|指定本机的Socks监听端口,该端口收到的请求,都将转发到远程SSH主机,又称动态端口转发|`ssh -D 1080 server`|\n|-f|表示SSH链接在后台运行||\n|-F|指定配置文件|`ssh -F /usr/local/ssh/other_config`|\n|-i|用于指定私钥,默认值是\\~/.ssh/id_dsa|`ssh -i my-key server.example.com`|\n|-l|参数指定远程登录的账户名|`ssh -l nanbert server.example.com`|\n|-L|设置本地端口转发|`ssh -L 9999:targetServer:80 user@remoteServer`所有发向本地9999端口的请求,都会经过remoteServer发往targetServer的80端口,相当于直接连上了80的端口|\n|-m|指定校验数据完整性的算法(MAC)|`ssh -m hmac-sha1,hmac-md5 server.example.com`|\n|-o|参数用来指定一个配置命令,来覆盖配置文件设置|`ssh -o \"User sally\" server.example.com`|\n|-p|指定链接的服务器的端口|`ssh -p 2305 server.example.com`|\n|-q|安静模式,不输出任何警告|`ssh -q foo.com`|\n|-R|指定远程端口转发|`ssh -R 9999:targetServer:902 local`该命令需要在跳板服务器执行,指定本机计算机local监听自己的9999端口,所有发向这个端口的请求,都会转向targetServer的902端口|\n|-t|在ssh直接运行远端命令时,提供一个交互shell|`ssh -t server.example.com emacs`|\n|-v|显示详细信息,可重复多次,表示详细程度|`ssh -vvv server.example.com`|\n|-V|显示客户端版本信息||\n|-X|表示打开X窗口转发|`ssh -X server.example.com`|\n|-1,-2,-4,-6|1表示SSH1协议,2表示SSH2协议,4表示IPv4协议(默认值),6表示Ipv6协议||\n\n5.配置文件\n\n|路径|作用|\n|:-:|:-:|\n|/etc/ssh/ssh_config|全局配置文件|\n|~/.ssh/config|用户个人的配置文件|\n|~/.ssh/id_ecdsa|用户的ECDSA私钥|\n|~/.ssh/id_ecdsa.pub|用户的ECDSA公钥|\n|~/.ssh/rsa|用于SSH2的rsa私钥|\n|~/.ssh/rsa.pub|用于SSH2的rsa公钥|\n|~/.ssh/identity|用于SSH1的rsa私钥|\n|~/.ssh/identity.pub|用于SSH1的rsa公钥|\n|~/.ssh/known_hosts|包含SSH服务器的公钥指纹|\n\n配置文件示例:\n```bash\nHost *\n\tPort 2222\nHost remoteserver\n\tHostName remote.example.com\n\tUser nanbert\n\tPort 2112\n```\n常见配置命令:\n`AddressFamily <option>`option可以是inet,表示IPV4协议,也可以是inet6,表示IPV6协议\n`BindAddress 192.168.10.235`指定本机的IP地址(如果本机有多个Ip地址)\n`CheckHostIP <yesOrNo>`是否检查SSH的服务器IP地址是否跟公钥数据库吻合\n`Ciphers <option>`:指定加密算法\n`Compression <yesOrNo>`是否压缩传输信号\n`ConnectionAttempts <num>`客户端进行连接时,最大尝试次数\n`ConnectTimeout <num>`客户端进行连接时,服务器在指定秒数内没有回复,则中断连接尝试\n`DynamicForward <portNum>`指定动态转发端口\n`GlobalKnownHostsFile <filePath>`指定全局的公钥数据库文件的位置\n`Host <serverName>`指定连接的域名或IP地址,也可以是别名,支持通配符,后面所有配置都是针对该主机,直到遇到下一个Host\n`HostKeyAlgorithm <options>`指定密钥算法,优先级从高到低排列,以逗号分隔\n`HostName <serverAddress>`在Host命令使用别名的情况下用\n`IdentityFile <fileName>`指定私钥文件\n`LocalForward 2001 localhost:143`指定本地端口转发\n`LogLevel <options>`指定日志详细程度。如果设为`QUIET`,将不输出大部分的警告和提示\n`MACs <options>`指定数据校验算法,以逗号分隔\n`NumberOfPasswordPrompts <num>`输错密码最大尝试数\n`PasswordAuthentication <yesOrNo>`是否支持密码登录,这里只是客户端,需要服务器也有相同的设置\n`Port <portNum>`指定客户端链接的SSH服务器端口\n`PreferredAutentications publickey,hostbased,password`指定各种登录方法优先级\n`Protocol <1,2>`支持的SSH协议版本,可以用逗号分隔同时支持两个版本\n`PubKeyAuthentication <yesOrNo>`是否支持密钥登录,这里只是客户端设置,需要服务器相同的设置\n`RemoteForward 2001 server:143`指定远程端口转发\n`SendEnv <variable>`客户端向服务器发送环境变量名,多个环境变量之间用空格分隔,变量的值从当前环境拷贝\n`ServerAliveCountMax <num>`如果没有收到服务器的回应,客户端发送多少次keepalive信号,才断开连接,默认为3\n`ServerAliveInterval <num>`客户端建立连接后,如果在给定的数秒内,没有收到服务器发来的消息,客户端向服务器发送keepalive消息,如果不希望客户端发送,这一项设为0\n`StrictHostKeyChecking <yesOrNo>`yes表示严格检查,服务器公钥为未知或发生变化,则拒绝连接。no表示如果服务器公钥未知,则加入客户端公钥数据库,如果公钥发生变化,不改变客户端公钥数据库,输出一条警告,依然允许连接继续进行。ask(默认值)表示向用户询问是否继续\n`TCPKeepAlive <yesOrNo>`客户端是否定期向服务器发送keepalive信息\n`User <userName>`指定登录账户名\n`UserKnownHostsFile <filePath>`指定当前用户的服务器公钥指纹列表(known_hosts)的文件位置\n`VerifyHostKeyDNS <yesOrNo>`是否检查SSH服务器的DNS记录,确认公钥指纹是否与known_hosts文件保持一致\n6.密钥\n*概念*:\n密钥是一个非常大的数字,通过加密算法得到。对称加密只需要一个密钥,非对称加密需要成对使用,分为公钥和私钥。\nSSH密钥登录采用非对称加密,每个永不通过自己的密钥登录。其中,私钥必须私密保存,不能泄露;公钥则公开,对外发送。它们的关系是,公钥和私钥是一一对应\n*过程*:\n预备步骤,客户端通过`ssh-keygen`生产自己的公钥和私钥\n第一步,手动将客户端的公钥放入远程服务器的指定位置\n第二步,客户端向服务器发起SSH登录请求\n第三步,服务器收到用户SSH登录的请求,发送一些随机数据给用户,要求用户证明自己的身份\n第四步,客户端收到服务器发来的数据,私用私钥对数据进行签名,然后再发给服务器\n第五步,服务器收到客户端发来的加密签名后,使用对应的公钥解密,然后跟原始数据比较。如果一致,就允许用户登录\n*ssh-key--生成密钥*\n该命令会生成一对密钥,私钥默认存在~/.ssh/id_rsa,公钥默认存在~/.ssh/id_rsa.pub\n\n|选项|含义|\n|:-:|:-:|\n|-b [num]|指定密钥的二进制位数。这个参数越大,密钥越不容易破解,但是加密解密的开销也会越大,一般至少应该是1024|\n|-C \"[string]\"|可以为密钥文件指定新的注释,格式一般为`username@host`|\n|-f [filename]|参数指定生成的私钥文件。不指定的话,会在~/.ssh文件夹下生成一对密钥|\n|-F [hostname]|检查某个主机名是否在known_hosts文件里面|\n|-N [secretword]|指定私钥的密码|\n|-p[secretword]|重新指定私钥的密码|\n|-R [hostname]|将指定的主机公钥移除出known_hosts文件|\n|-t [algorithm]|指定加密算法,一般为dsa或rsa|\n\n*手动上传公钥*\n把客户端生成的公钥复制粘贴到文件\\~/.ssh/authorized_keys中去,一个公钥占据一行\n*ssh-copy-id--自动上传公钥*\n`ssh-copy-id -i key_file user@host` 自动上传公钥到服务器\n公钥文件可以不指定路劲和.pub后缀,会自动在\\~/.ssh目录下寻找\n确保authorized_keys文件末尾为换行符,否则两个公钥连在一起,两个都会失效\n\n*ssh-agent命令*\n私钥设置了密码后,每次使用都必须输入密码,连续使用scp命令时,这就很麻烦,ssh-agent命令就是为了解决这个问题而设计的,它让用户在整个bash对话中,只在第一次使用SSH命令是输入密码,然后将私钥保存在内存中\n第一步,新建一次命令对话\n`ssh-agent bash(zhs、fish)`\n第二步,添加私钥\n`ssh-add [filename]`可以不指定私钥名称,使用默认文件~/.ssh/id_rsa\n第三步登录远程服务器\n`ssh remoteHost`\n最后,如果要退出ssh-agent,可以按Ctrl+d,也可以用如下命令\n`ssh-agent -k`\n*ssh-add命令*\nssh-add命令用来将私钥加入ssh-agent\n\n|选项|含义|\n|:-:|:-:|\n|-d|从内存中删除指定的私钥|\n|-D|从内存中删除所有已经添加的私钥|\n|-l|列出所有已经添加的私钥|\n\n<font size=6>**服务器端sshd**</font>\n**1.sshd配置文件**\n`/etc/ssh/sshd_config`配置文件\n`/etc/ssh/ssh_host_ecdsa_key`ECDSA私钥\n`/etc/ssh/ssh_host_ecdsa_key.pub`ECDSA公钥\n`/etc/ssh/ssh_host_key`用于SSH1协议版本的RSA私钥\n`/etc/ssh/ssh_host_key.pub`用于SSH1协议版本的RSA公钥\n`/etc/ssh/ssh_host_rsa_key`用于SSH2协议版本的RSA私钥\n`/etc/ssh/ssh_host_rsa_key.pub`用于SSH2协议版本的RSA公钥\n`/etc/pam.d/sshd`PAM配置文件\n<font color=#FF0000>重装会使这些文件失效,可以先备份</font>\n**sshd配置项**\n\n|配置项|含义|\n|:-:|:-:|\n|AcceptEnv [variables...]|允许接受客户端通过SendEnv命令发来的哪些环境变量,变量名用空格分隔|\n|AllowGroups [groupNames...]|指定允许登录的用户组,多个组之间用空格隔开,若不用该项,则所有组都可以用|\n|AllowUsers [userNames...]|指定允许登录的用户,用户名之间用空格隔开,支持通配符|\n|AllowTcpForwarding [options]|默认值为yes,允许端口转发,local只允许本地端口转发,remote表示只允许远程端口转发|\n|AuthorizedKeysFile [directory]|指定存储用户公钥的目录,默认是`~/.ssh/authorized_keys`|\n|Banner [file]|指定用户登录后,sshd向其展示的信息文件,默认不展示任何内容|\n|ChallengeResponseAuthentication [yesOrNo]|指定是否用\"键盘交互\"身份验证方案,默认值为yes,如果完全禁用基于密码的验证,PasswordAuthentication也设为no|\n|Ciphers [algorithms]|指定sshd可以接受的加密算法,多个算法之间使用逗号分割|\n|ClientAliveCountMax [num]|指定建立连接后,客户端失去响应时,服务器尝试连接的次数|\n|ClientAliveInterval [num]|允许客户端发呆的时间,单位为秒,如果超过这时间,连接将会关闭|\n|Compression [yesOrNo]|Compression指定客户端与服务器之间的数据传输是否为压缩,默认为yes|\n|DenyGroups [groupNames...]|指定不允许登录的用户组,组间空格分开|\n|DenyUsers [userNames...]|指定不允许登录的用户,空格分开不同用户|\n|FascistLogging [yesOrNo]|SSH1版本专用,指定日志是否输出全部Debug信息|\n|HostKey [filePath]|指定服务器密钥的文件路径|\n|KeyRegenerationInterval [num]|指定SSH1版本的密钥重新生成的时间间隔,单位为秒,默认为3600|\n|ListenAddress [ipAddress]|指定sshd监听本机的IP地址,即sshd启用的IP地址,默认是0.0.0.0,表示在本机所有网络接口启用。可以改成只在某个网络接口启用,可以多次使用该配置项,来监听多个ip地址|\n|LoginGraceTime [num]|指定允许客户端登录时发呆的最长时间,超过该时间就断开,0表示没有限制|\n|LogLevel [options]|指定日志的详细程度,可能的值有:QUIET,FATAL,ERROR,INFO,VERNBOSE,DEBUG,DEBUG1,DEBUG2,DEBUG3,默认为INFO|\n|MACs [algorithms]|指定sshd可以接受的数据校验算法(MACs hmac-sha1),多个算法之间使用逗号分隔|\n|MaxAuthTries [num]|指定SSH登录允许的最大密码尝试数|\n|MaxStartups [num]|指定允许同时并发的SSH链接数量,0表示没有限制,也可以是A:B:C形式,如10:50:20,表示如果达到10个并发链接,后面的连接有50%的概率被拒绝,如果达到20个并发连接,则后面的100%拒绝|\n|PasswordAuthentication [yesOrNo]|是否允许密码登录,默认值为yes|\n|PermitEmptyPasswords [yesOrNo]|指定是否允许空密码登录,默认为yes|\n|PermitRootLogin [yesOrNo]|是否允许根用户登录,默认为yes,也可以设为prohibit-password,表示允许密钥登录root,但禁止密码登录|\n|PermitUserEnvironment [yesOrNo]|是否允许sshd加载客户端的~/.ssh/environment文件和~/.ssh/authorized_keys文件里面的environment=options 环境变量设置.默认值为no|\n|Port [num]|指定sshd监听的端口,默认22,可以多次设置,监听多个端口|\n|PrintMoth [yesOrNo]|指定用户登录后,是否向其展示系统的motd的信息文件/etc/motd,默认为yes|\n|Protocol [options]|1表示使用SSH1协议,'1,2'表示支持两个版本的协议|\n|PubKeyAuthentication [yesOrNo]|指定是否允许公钥登录,默认为yes|\n|QuietMode [yesOrNo]|SSH1专用,yes表示日志只输出致命的错误信息|\n|RSAAuthentication [yesOrNo]||指定是否允许RSA认证,默认值为yes|\n|ServerKeyBits [num]|指定SSH1版本的密钥重新生成时的位数,默认为767|\n|StrictModes [yesOrNo]|指定sshd是否检查用户的一些重要文件和目录权限,即对于用户的SSH配置文件,密钥文件和所在目录,SSH要求拥有者必须是根用户或用户本人,其他人的写权限必须关闭|\n|SyslogFacility [options]|指定Syslog如何处理sshd日志,默认是AUTH|\n|TCPKeepAlive [unknown]|指定打开sshd跟客户端tcp链接的keepalive参数|\n|UseDNS [yesOrNo]|指定用户SSH登录一个域名时,服务器是否使用DNS,确认该域名对应的IP地址包含本机,建议关闭|\n|UserLogin [yesOrNo]|指定用户认证内部是否使用/user/bin/login代替SSH工具,默认为no|\n|UserPrivilegeSeparation|指定用户认证通过后,使用另一个子线程处理用户权限相关的操作,这样利于提高安全性|\n|VerboseMode|SSH2版本专用,指定日志输出详细的Debug信息|\n|X11Forwarding|指定是否打开X window的转发,默认值为no|\n**sshd命令行配置项**\n\n|参数|含义|\n|:-:|:-:|\n|-d|用于显示debug信息|\n|-D|指定sshd不作为后台守护进程运行|\n|-e|将sshd写入系统日志syslog的内容导向标准错误|\n|-f [filePath]|指定配置文件位置|\n|-h [filePath]|指定密钥|\n|-o [Key Value]|指定配置文件的一个配置项和对应的值,如:sshd -o \"Port 2034\"|\n|-p [num]|指定sshd的服务端口|\n|-t|检查配置文件语法是否正确|\n\n## scp命令\n- `scp [参数][原路径][目标路径]`\n- 它的底层是SSH协议,默认端口22,相当于先用ssh命令登陆远程主机,然后在执行拷贝,可以用于两个远程系统之间的复制\n### 参数\n-1 强制scp命令使用协议ssh1\n-2 强制scp命令使用协议ssh2\n-4 强制scp命令只使用IPv4寻址\n-6 强制scp命令只使用IPv6寻址\n-B 使用批处理模式（传输过程中不询问传输口令或短语）\n-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）\n-p 留原文件的修改时间，访问时间和访问权限。\n-q 不显示传输进度条。\n-r 递归复制整个目录。\n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。\n-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。\n-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。\n-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。\n-l limit 限定用户所能使用的带宽，以Kbit/s为单位。\n-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，\n-P port 注意是大写的P, port是指定数据传输用到的端口号\n-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n\n\n<font size=6>**sftp命令**</font>\n**简介**\nsftp是ssh提供的一个客户端应用程序,主要用来安全地访问FTP。因为FTP是不加密协议,很不安全,sftp相当于将FTP放入SSH:\n`sftp username@hostname`\n进入sftp后,使用那些命令,如get获取远程文件,put上传文件等\n<font size=6>**端口转发**</font>\n(待建)可见<https://wangdoc.com/ssh/port-forwarding.html>\n<font size=6>**证书登录**</font>\n(待建)可见<https://wangdoc.com/ssh/ca.html>\n","slug":"openSSH","published":1,"updated":"2024-04-30T21:25:21.319Z","_id":"clq1yvi720011gwq2c3lrbfmb","comments":1,"layout":"post","photos":[],"content":"<p>1.登录服务器<br><code>ssh &lt;user&gt;@&lt;hostname&gt;</code>hostname是主机名,可以是域名,也可能是IP地址,不指定<user>@时,默认为客户端的当前用户名<br><code>ssh -p 8821 foo.com</code>默认端口为21,可以用-p选项指定服务器的端口<br>2.文件信息<br>服务器公钥的指纹既是SSH服务器公钥的哈希值,每台SSH服务器都有唯一一对密钥<br><code>ssh-keygen -l -f [*.pub]</code>查看某个公钥的指纹<br>ssh会将本机链接过的所有服务器公钥的指纹存储在”~&#x2F;.ssh&#x2F;known_hosts”文件中。每次链接服务器都会通过该文件判断是否为陌生服务器,如果是陌生的则会产生警告,如果输入yes忽略警告,将会自动添加该服务器的公钥指纹到该文件<br><code>ssh-keygen -R &lt;hostname&gt;</code>用于删除某服务器的公钥(用于失效的情况),也可以手动删除known_hosts文件中的相关内容<br>3.执行远程命令<br>一般在登陆后,输入命令,<br>也可以一步到位<code>ssh [username@hostname] &lt;command&gt;</code>登陆成功后立即执行命令,如果命令是交互式的,则需要加上-t选项,如:<code>ssh -t foo.com vi foo.txt</code><br>4.命令行配置项</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">指定加密算法</td>\n<td align=\"center\"><code>ssh -c blowfish,3des server.example.com</code>,<code>ssh -c blowfish -c 3des server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-C</td>\n<td align=\"center\">压缩数据传输</td>\n<td align=\"center\"><code>ssh -C server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">设置打印的debug信息级别,数值越高越详细</td>\n<td align=\"center\"><code>ssh -d 1 foo.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">指定本机的Socks监听端口,该端口收到的请求,都将转发到远程SSH主机,又称动态端口转发</td>\n<td align=\"center\"><code>ssh -D 1080 server</code></td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">表示SSH链接在后台运行</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-F</td>\n<td align=\"center\">指定配置文件</td>\n<td align=\"center\"><code>ssh -F /usr/local/ssh/other_config</code></td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">用于指定私钥,默认值是~&#x2F;.ssh&#x2F;id_dsa</td>\n<td align=\"center\"><code>ssh -i my-key server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">参数指定远程登录的账户名</td>\n<td align=\"center\"><code>ssh -l nanbert server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-L</td>\n<td align=\"center\">设置本地端口转发</td>\n<td align=\"center\"><code>ssh -L 9999:targetServer:80 user@remoteServer</code>所有发向本地9999端口的请求,都会经过remoteServer发往targetServer的80端口,相当于直接连上了80的端口</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">指定校验数据完整性的算法(MAC)</td>\n<td align=\"center\"><code>ssh -m hmac-sha1,hmac-md5 server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-o</td>\n<td align=\"center\">参数用来指定一个配置命令,来覆盖配置文件设置</td>\n<td align=\"center\"><code>ssh -o &quot;User sally&quot; server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">指定链接的服务器的端口</td>\n<td align=\"center\"><code>ssh -p 2305 server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-q</td>\n<td align=\"center\">安静模式,不输出任何警告</td>\n<td align=\"center\"><code>ssh -q foo.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-R</td>\n<td align=\"center\">指定远程端口转发</td>\n<td align=\"center\"><code>ssh -R 9999:targetServer:902 local</code>该命令需要在跳板服务器执行,指定本机计算机local监听自己的9999端口,所有发向这个端口的请求,都会转向targetServer的902端口</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">在ssh直接运行远端命令时,提供一个交互shell</td>\n<td align=\"center\"><code>ssh -t server.example.com emacs</code></td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">显示详细信息,可重复多次,表示详细程度</td>\n<td align=\"center\"><code>ssh -vvv server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-V</td>\n<td align=\"center\">显示客户端版本信息</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-X</td>\n<td align=\"center\">表示打开X窗口转发</td>\n<td align=\"center\"><code>ssh -X server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-1,-2,-4,-6</td>\n<td align=\"center\">1表示SSH1协议,2表示SSH2协议,4表示IPv4协议(默认值),6表示Ipv6协议</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>5.配置文件</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">路径</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;etc&#x2F;ssh&#x2F;ssh_config</td>\n<td align=\"center\">全局配置文件</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;config</td>\n<td align=\"center\">用户个人的配置文件</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;id_ecdsa</td>\n<td align=\"center\">用户的ECDSA私钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;id_ecdsa.pub</td>\n<td align=\"center\">用户的ECDSA公钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;rsa</td>\n<td align=\"center\">用于SSH2的rsa私钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;rsa.pub</td>\n<td align=\"center\">用于SSH2的rsa公钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;identity</td>\n<td align=\"center\">用于SSH1的rsa私钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;identity.pub</td>\n<td align=\"center\">用于SSH1的rsa公钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;known_hosts</td>\n<td align=\"center\">包含SSH服务器的公钥指纹</td>\n</tr>\n</tbody></table>\n<p>配置文件示例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Host *<br>\tPort 2222<br>Host remoteserver<br>\tHostName remote.example.com<br>\tUser nanbert<br>\tPort 2112<br></code></pre></td></tr></table></figure>\n<p>常见配置命令:<br><code>AddressFamily &lt;option&gt;</code>option可以是inet,表示IPV4协议,也可以是inet6,表示IPV6协议<br><code>BindAddress 192.168.10.235</code>指定本机的IP地址(如果本机有多个Ip地址)<br><code>CheckHostIP &lt;yesOrNo&gt;</code>是否检查SSH的服务器IP地址是否跟公钥数据库吻合<br><code>Ciphers &lt;option&gt;</code>:指定加密算法<br><code>Compression &lt;yesOrNo&gt;</code>是否压缩传输信号<br><code>ConnectionAttempts &lt;num&gt;</code>客户端进行连接时,最大尝试次数<br><code>ConnectTimeout &lt;num&gt;</code>客户端进行连接时,服务器在指定秒数内没有回复,则中断连接尝试<br><code>DynamicForward &lt;portNum&gt;</code>指定动态转发端口<br><code>GlobalKnownHostsFile &lt;filePath&gt;</code>指定全局的公钥数据库文件的位置<br><code>Host &lt;serverName&gt;</code>指定连接的域名或IP地址,也可以是别名,支持通配符,后面所有配置都是针对该主机,直到遇到下一个Host<br><code>HostKeyAlgorithm &lt;options&gt;</code>指定密钥算法,优先级从高到低排列,以逗号分隔<br><code>HostName &lt;serverAddress&gt;</code>在Host命令使用别名的情况下用<br><code>IdentityFile &lt;fileName&gt;</code>指定私钥文件<br><code>LocalForward 2001 localhost:143</code>指定本地端口转发<br><code>LogLevel &lt;options&gt;</code>指定日志详细程度。如果设为<code>QUIET</code>,将不输出大部分的警告和提示<br><code>MACs &lt;options&gt;</code>指定数据校验算法,以逗号分隔<br><code>NumberOfPasswordPrompts &lt;num&gt;</code>输错密码最大尝试数<br><code>PasswordAuthentication &lt;yesOrNo&gt;</code>是否支持密码登录,这里只是客户端,需要服务器也有相同的设置<br><code>Port &lt;portNum&gt;</code>指定客户端链接的SSH服务器端口<br><code>PreferredAutentications publickey,hostbased,password</code>指定各种登录方法优先级<br><code>Protocol &lt;1,2&gt;</code>支持的SSH协议版本,可以用逗号分隔同时支持两个版本<br><code>PubKeyAuthentication &lt;yesOrNo&gt;</code>是否支持密钥登录,这里只是客户端设置,需要服务器相同的设置<br><code>RemoteForward 2001 server:143</code>指定远程端口转发<br><code>SendEnv &lt;variable&gt;</code>客户端向服务器发送环境变量名,多个环境变量之间用空格分隔,变量的值从当前环境拷贝<br><code>ServerAliveCountMax &lt;num&gt;</code>如果没有收到服务器的回应,客户端发送多少次keepalive信号,才断开连接,默认为3<br><code>ServerAliveInterval &lt;num&gt;</code>客户端建立连接后,如果在给定的数秒内,没有收到服务器发来的消息,客户端向服务器发送keepalive消息,如果不希望客户端发送,这一项设为0<br><code>StrictHostKeyChecking &lt;yesOrNo&gt;</code>yes表示严格检查,服务器公钥为未知或发生变化,则拒绝连接。no表示如果服务器公钥未知,则加入客户端公钥数据库,如果公钥发生变化,不改变客户端公钥数据库,输出一条警告,依然允许连接继续进行。ask(默认值)表示向用户询问是否继续<br><code>TCPKeepAlive &lt;yesOrNo&gt;</code>客户端是否定期向服务器发送keepalive信息<br><code>User &lt;userName&gt;</code>指定登录账户名<br><code>UserKnownHostsFile &lt;filePath&gt;</code>指定当前用户的服务器公钥指纹列表(known_hosts)的文件位置<br><code>VerifyHostKeyDNS &lt;yesOrNo&gt;</code>是否检查SSH服务器的DNS记录,确认公钥指纹是否与known_hosts文件保持一致<br>6.密钥<br><em>概念</em>:<br>密钥是一个非常大的数字,通过加密算法得到。对称加密只需要一个密钥,非对称加密需要成对使用,分为公钥和私钥。<br>SSH密钥登录采用非对称加密,每个永不通过自己的密钥登录。其中,私钥必须私密保存,不能泄露;公钥则公开,对外发送。它们的关系是,公钥和私钥是一一对应<br><em>过程</em>:<br>预备步骤,客户端通过<code>ssh-keygen</code>生产自己的公钥和私钥<br>第一步,手动将客户端的公钥放入远程服务器的指定位置<br>第二步,客户端向服务器发起SSH登录请求<br>第三步,服务器收到用户SSH登录的请求,发送一些随机数据给用户,要求用户证明自己的身份<br>第四步,客户端收到服务器发来的数据,私用私钥对数据进行签名,然后再发给服务器<br>第五步,服务器收到客户端发来的加密签名后,使用对应的公钥解密,然后跟原始数据比较。如果一致,就允许用户登录<br><em>ssh-key–生成密钥</em><br>该命令会生成一对密钥,私钥默认存在<del>&#x2F;.ssh&#x2F;id_rsa,公钥默认存在</del>&#x2F;.ssh&#x2F;id_rsa.pub</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b [num]</td>\n<td align=\"center\">指定密钥的二进制位数。这个参数越大,密钥越不容易破解,但是加密解密的开销也会越大,一般至少应该是1024</td>\n</tr>\n<tr>\n<td align=\"center\">-C “[string]”</td>\n<td align=\"center\">可以为密钥文件指定新的注释,格式一般为<code>username@host</code></td>\n</tr>\n<tr>\n<td align=\"center\">-f [filename]</td>\n<td align=\"center\">参数指定生成的私钥文件。不指定的话,会在~&#x2F;.ssh文件夹下生成一对密钥</td>\n</tr>\n<tr>\n<td align=\"center\">-F [hostname]</td>\n<td align=\"center\">检查某个主机名是否在known_hosts文件里面</td>\n</tr>\n<tr>\n<td align=\"center\">-N [secretword]</td>\n<td align=\"center\">指定私钥的密码</td>\n</tr>\n<tr>\n<td align=\"center\">-p[secretword]</td>\n<td align=\"center\">重新指定私钥的密码</td>\n</tr>\n<tr>\n<td align=\"center\">-R [hostname]</td>\n<td align=\"center\">将指定的主机公钥移除出known_hosts文件</td>\n</tr>\n<tr>\n<td align=\"center\">-t [algorithm]</td>\n<td align=\"center\">指定加密算法,一般为dsa或rsa</td>\n</tr>\n</tbody></table>\n<p><em>手动上传公钥</em><br>把客户端生成的公钥复制粘贴到文件~&#x2F;.ssh&#x2F;authorized_keys中去,一个公钥占据一行<br><em>ssh-copy-id–自动上传公钥</em><br><code>ssh-copy-id -i key_file user@host</code> 自动上传公钥到服务器<br>公钥文件可以不指定路劲和.pub后缀,会自动在~&#x2F;.ssh目录下寻找<br>确保authorized_keys文件末尾为换行符,否则两个公钥连在一起,两个都会失效</p>\n<p><em>ssh-agent命令</em><br>私钥设置了密码后,每次使用都必须输入密码,连续使用scp命令时,这就很麻烦,ssh-agent命令就是为了解决这个问题而设计的,它让用户在整个bash对话中,只在第一次使用SSH命令是输入密码,然后将私钥保存在内存中<br>第一步,新建一次命令对话<br><code>ssh-agent bash(zhs、fish)</code><br>第二步,添加私钥<br><code>ssh-add [filename]</code>可以不指定私钥名称,使用默认文件~&#x2F;.ssh&#x2F;id_rsa<br>第三步登录远程服务器<br><code>ssh remoteHost</code><br>最后,如果要退出ssh-agent,可以按Ctrl+d,也可以用如下命令<br><code>ssh-agent -k</code><br><em>ssh-add命令</em><br>ssh-add命令用来将私钥加入ssh-agent</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">从内存中删除指定的私钥</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">从内存中删除所有已经添加的私钥</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">列出所有已经添加的私钥</td>\n</tr>\n</tbody></table>\n<p><font size=6><strong>服务器端sshd</strong></font><br><strong>1.sshd配置文件</strong><br><code>/etc/ssh/sshd_config</code>配置文件<br><code>/etc/ssh/ssh_host_ecdsa_key</code>ECDSA私钥<br><code>/etc/ssh/ssh_host_ecdsa_key.pub</code>ECDSA公钥<br><code>/etc/ssh/ssh_host_key</code>用于SSH1协议版本的RSA私钥<br><code>/etc/ssh/ssh_host_key.pub</code>用于SSH1协议版本的RSA公钥<br><code>/etc/ssh/ssh_host_rsa_key</code>用于SSH2协议版本的RSA私钥<br><code>/etc/ssh/ssh_host_rsa_key.pub</code>用于SSH2协议版本的RSA公钥<br><code>/etc/pam.d/sshd</code>PAM配置文件<br><font color=#FF0000>重装会使这些文件失效,可以先备份</font><br><strong>sshd配置项</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">配置项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">AcceptEnv [variables…]</td>\n<td align=\"center\">允许接受客户端通过SendEnv命令发来的哪些环境变量,变量名用空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">AllowGroups [groupNames…]</td>\n<td align=\"center\">指定允许登录的用户组,多个组之间用空格隔开,若不用该项,则所有组都可以用</td>\n</tr>\n<tr>\n<td align=\"center\">AllowUsers [userNames…]</td>\n<td align=\"center\">指定允许登录的用户,用户名之间用空格隔开,支持通配符</td>\n</tr>\n<tr>\n<td align=\"center\">AllowTcpForwarding [options]</td>\n<td align=\"center\">默认值为yes,允许端口转发,local只允许本地端口转发,remote表示只允许远程端口转发</td>\n</tr>\n<tr>\n<td align=\"center\">AuthorizedKeysFile [directory]</td>\n<td align=\"center\">指定存储用户公钥的目录,默认是<code>~/.ssh/authorized_keys</code></td>\n</tr>\n<tr>\n<td align=\"center\">Banner [file]</td>\n<td align=\"center\">指定用户登录后,sshd向其展示的信息文件,默认不展示任何内容</td>\n</tr>\n<tr>\n<td align=\"center\">ChallengeResponseAuthentication [yesOrNo]</td>\n<td align=\"center\">指定是否用”键盘交互”身份验证方案,默认值为yes,如果完全禁用基于密码的验证,PasswordAuthentication也设为no</td>\n</tr>\n<tr>\n<td align=\"center\">Ciphers [algorithms]</td>\n<td align=\"center\">指定sshd可以接受的加密算法,多个算法之间使用逗号分割</td>\n</tr>\n<tr>\n<td align=\"center\">ClientAliveCountMax [num]</td>\n<td align=\"center\">指定建立连接后,客户端失去响应时,服务器尝试连接的次数</td>\n</tr>\n<tr>\n<td align=\"center\">ClientAliveInterval [num]</td>\n<td align=\"center\">允许客户端发呆的时间,单位为秒,如果超过这时间,连接将会关闭</td>\n</tr>\n<tr>\n<td align=\"center\">Compression [yesOrNo]</td>\n<td align=\"center\">Compression指定客户端与服务器之间的数据传输是否为压缩,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">DenyGroups [groupNames…]</td>\n<td align=\"center\">指定不允许登录的用户组,组间空格分开</td>\n</tr>\n<tr>\n<td align=\"center\">DenyUsers [userNames…]</td>\n<td align=\"center\">指定不允许登录的用户,空格分开不同用户</td>\n</tr>\n<tr>\n<td align=\"center\">FascistLogging [yesOrNo]</td>\n<td align=\"center\">SSH1版本专用,指定日志是否输出全部Debug信息</td>\n</tr>\n<tr>\n<td align=\"center\">HostKey [filePath]</td>\n<td align=\"center\">指定服务器密钥的文件路径</td>\n</tr>\n<tr>\n<td align=\"center\">KeyRegenerationInterval [num]</td>\n<td align=\"center\">指定SSH1版本的密钥重新生成的时间间隔,单位为秒,默认为3600</td>\n</tr>\n<tr>\n<td align=\"center\">ListenAddress [ipAddress]</td>\n<td align=\"center\">指定sshd监听本机的IP地址,即sshd启用的IP地址,默认是0.0.0.0,表示在本机所有网络接口启用。可以改成只在某个网络接口启用,可以多次使用该配置项,来监听多个ip地址</td>\n</tr>\n<tr>\n<td align=\"center\">LoginGraceTime [num]</td>\n<td align=\"center\">指定允许客户端登录时发呆的最长时间,超过该时间就断开,0表示没有限制</td>\n</tr>\n<tr>\n<td align=\"center\">LogLevel [options]</td>\n<td align=\"center\">指定日志的详细程度,可能的值有:QUIET,FATAL,ERROR,INFO,VERNBOSE,DEBUG,DEBUG1,DEBUG2,DEBUG3,默认为INFO</td>\n</tr>\n<tr>\n<td align=\"center\">MACs [algorithms]</td>\n<td align=\"center\">指定sshd可以接受的数据校验算法(MACs hmac-sha1),多个算法之间使用逗号分隔</td>\n</tr>\n<tr>\n<td align=\"center\">MaxAuthTries [num]</td>\n<td align=\"center\">指定SSH登录允许的最大密码尝试数</td>\n</tr>\n<tr>\n<td align=\"center\">MaxStartups [num]</td>\n<td align=\"center\">指定允许同时并发的SSH链接数量,0表示没有限制,也可以是A:B:C形式,如10:50:20,表示如果达到10个并发链接,后面的连接有50%的概率被拒绝,如果达到20个并发连接,则后面的100%拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">PasswordAuthentication [yesOrNo]</td>\n<td align=\"center\">是否允许密码登录,默认值为yes</td>\n</tr>\n<tr>\n<td align=\"center\">PermitEmptyPasswords [yesOrNo]</td>\n<td align=\"center\">指定是否允许空密码登录,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">PermitRootLogin [yesOrNo]</td>\n<td align=\"center\">是否允许根用户登录,默认为yes,也可以设为prohibit-password,表示允许密钥登录root,但禁止密码登录</td>\n</tr>\n<tr>\n<td align=\"center\">PermitUserEnvironment [yesOrNo]</td>\n<td align=\"center\">是否允许sshd加载客户端的<del>&#x2F;.ssh&#x2F;environment文件和</del>&#x2F;.ssh&#x2F;authorized_keys文件里面的environment&#x3D;options 环境变量设置.默认值为no</td>\n</tr>\n<tr>\n<td align=\"center\">Port [num]</td>\n<td align=\"center\">指定sshd监听的端口,默认22,可以多次设置,监听多个端口</td>\n</tr>\n<tr>\n<td align=\"center\">PrintMoth [yesOrNo]</td>\n<td align=\"center\">指定用户登录后,是否向其展示系统的motd的信息文件&#x2F;etc&#x2F;motd,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">Protocol [options]</td>\n<td align=\"center\">1表示使用SSH1协议,’1,2’表示支持两个版本的协议</td>\n</tr>\n<tr>\n<td align=\"center\">PubKeyAuthentication [yesOrNo]</td>\n<td align=\"center\">指定是否允许公钥登录,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">QuietMode [yesOrNo]</td>\n<td align=\"center\">SSH1专用,yes表示日志只输出致命的错误信息</td>\n</tr>\n<tr>\n<td align=\"center\">RSAAuthentication [yesOrNo]</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ServerKeyBits [num]</td>\n<td align=\"center\">指定SSH1版本的密钥重新生成时的位数,默认为767</td>\n</tr>\n<tr>\n<td align=\"center\">StrictModes [yesOrNo]</td>\n<td align=\"center\">指定sshd是否检查用户的一些重要文件和目录权限,即对于用户的SSH配置文件,密钥文件和所在目录,SSH要求拥有者必须是根用户或用户本人,其他人的写权限必须关闭</td>\n</tr>\n<tr>\n<td align=\"center\">SyslogFacility [options]</td>\n<td align=\"center\">指定Syslog如何处理sshd日志,默认是AUTH</td>\n</tr>\n<tr>\n<td align=\"center\">TCPKeepAlive [unknown]</td>\n<td align=\"center\">指定打开sshd跟客户端tcp链接的keepalive参数</td>\n</tr>\n<tr>\n<td align=\"center\">UseDNS [yesOrNo]</td>\n<td align=\"center\">指定用户SSH登录一个域名时,服务器是否使用DNS,确认该域名对应的IP地址包含本机,建议关闭</td>\n</tr>\n<tr>\n<td align=\"center\">UserLogin [yesOrNo]</td>\n<td align=\"center\">指定用户认证内部是否使用&#x2F;user&#x2F;bin&#x2F;login代替SSH工具,默认为no</td>\n</tr>\n<tr>\n<td align=\"center\">UserPrivilegeSeparation</td>\n<td align=\"center\">指定用户认证通过后,使用另一个子线程处理用户权限相关的操作,这样利于提高安全性</td>\n</tr>\n<tr>\n<td align=\"center\">VerboseMode</td>\n<td align=\"center\">SSH2版本专用,指定日志输出详细的Debug信息</td>\n</tr>\n<tr>\n<td align=\"center\">X11Forwarding</td>\n<td align=\"center\">指定是否打开X window的转发,默认值为no</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>sshd命令行配置项</strong></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">用于显示debug信息</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">指定sshd不作为后台守护进程运行</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">将sshd写入系统日志syslog的内容导向标准错误</td>\n</tr>\n<tr>\n<td align=\"center\">-f [filePath]</td>\n<td align=\"center\">指定配置文件位置</td>\n</tr>\n<tr>\n<td align=\"center\">-h [filePath]</td>\n<td align=\"center\">指定密钥</td>\n</tr>\n<tr>\n<td align=\"center\">-o [Key Value]</td>\n<td align=\"center\">指定配置文件的一个配置项和对应的值,如:sshd -o “Port 2034”</td>\n</tr>\n<tr>\n<td align=\"center\">-p [num]</td>\n<td align=\"center\">指定sshd的服务端口</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">检查配置文件语法是否正确</td>\n</tr>\n</tbody></table>\n<h2 id=\"scp命令\"><a href=\"#scp命令\" class=\"headerlink\" title=\"scp命令\"></a>scp命令</h2><ul>\n<li><code>scp [参数][原路径][目标路径]</code></li>\n<li>它的底层是SSH协议,默认端口22,相当于先用ssh命令登陆远程主机,然后在执行拷贝,可以用于两个远程系统之间的复制</li>\n</ul>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>-1 强制scp命令使用协议ssh1<br>-2 强制scp命令使用协议ssh2<br>-4 强制scp命令只使用IPv4寻址<br>-6 强制scp命令只使用IPv6寻址<br>-B 使用批处理模式（传输过程中不询问传输口令或短语）<br>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）<br>-p 留原文件的修改时间，访问时间和访问权限。<br>-q 不显示传输进度条。<br>-r 递归复制整个目录。<br>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。<br>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。<br>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。<br>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。<br>-l limit 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。<br>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，<br>-P port 注意是大写的P, port是指定数据传输用到的端口号<br>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</p>\n<p><font size=6><strong>sftp命令</strong></font><br><strong>简介</strong><br>sftp是ssh提供的一个客户端应用程序,主要用来安全地访问FTP。因为FTP是不加密协议,很不安全,sftp相当于将FTP放入SSH:<br><code>sftp username@hostname</code><br>进入sftp后,使用那些命令,如get获取远程文件,put上传文件等<br><font size=6><strong>端口转发</strong></font><br>(待建)可见<a href=\"https://wangdoc.com/ssh/port-forwarding.html\">https://wangdoc.com/ssh/port-forwarding.html</a><br><font size=6><strong>证书登录</strong></font><br>(待建)可见<a href=\"https://wangdoc.com/ssh/ca.html\">https://wangdoc.com/ssh/ca.html</a></p>\n","excerpt":"","more":"<p>1.登录服务器<br><code>ssh &lt;user&gt;@&lt;hostname&gt;</code>hostname是主机名,可以是域名,也可能是IP地址,不指定<user>@时,默认为客户端的当前用户名<br><code>ssh -p 8821 foo.com</code>默认端口为21,可以用-p选项指定服务器的端口<br>2.文件信息<br>服务器公钥的指纹既是SSH服务器公钥的哈希值,每台SSH服务器都有唯一一对密钥<br><code>ssh-keygen -l -f [*.pub]</code>查看某个公钥的指纹<br>ssh会将本机链接过的所有服务器公钥的指纹存储在”~&#x2F;.ssh&#x2F;known_hosts”文件中。每次链接服务器都会通过该文件判断是否为陌生服务器,如果是陌生的则会产生警告,如果输入yes忽略警告,将会自动添加该服务器的公钥指纹到该文件<br><code>ssh-keygen -R &lt;hostname&gt;</code>用于删除某服务器的公钥(用于失效的情况),也可以手动删除known_hosts文件中的相关内容<br>3.执行远程命令<br>一般在登陆后,输入命令,<br>也可以一步到位<code>ssh [username@hostname] &lt;command&gt;</code>登陆成功后立即执行命令,如果命令是交互式的,则需要加上-t选项,如:<code>ssh -t foo.com vi foo.txt</code><br>4.命令行配置项</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">指定加密算法</td>\n<td align=\"center\"><code>ssh -c blowfish,3des server.example.com</code>,<code>ssh -c blowfish -c 3des server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-C</td>\n<td align=\"center\">压缩数据传输</td>\n<td align=\"center\"><code>ssh -C server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">设置打印的debug信息级别,数值越高越详细</td>\n<td align=\"center\"><code>ssh -d 1 foo.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">指定本机的Socks监听端口,该端口收到的请求,都将转发到远程SSH主机,又称动态端口转发</td>\n<td align=\"center\"><code>ssh -D 1080 server</code></td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">表示SSH链接在后台运行</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-F</td>\n<td align=\"center\">指定配置文件</td>\n<td align=\"center\"><code>ssh -F /usr/local/ssh/other_config</code></td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">用于指定私钥,默认值是~&#x2F;.ssh&#x2F;id_dsa</td>\n<td align=\"center\"><code>ssh -i my-key server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">参数指定远程登录的账户名</td>\n<td align=\"center\"><code>ssh -l nanbert server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-L</td>\n<td align=\"center\">设置本地端口转发</td>\n<td align=\"center\"><code>ssh -L 9999:targetServer:80 user@remoteServer</code>所有发向本地9999端口的请求,都会经过remoteServer发往targetServer的80端口,相当于直接连上了80的端口</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">指定校验数据完整性的算法(MAC)</td>\n<td align=\"center\"><code>ssh -m hmac-sha1,hmac-md5 server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-o</td>\n<td align=\"center\">参数用来指定一个配置命令,来覆盖配置文件设置</td>\n<td align=\"center\"><code>ssh -o &quot;User sally&quot; server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">指定链接的服务器的端口</td>\n<td align=\"center\"><code>ssh -p 2305 server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-q</td>\n<td align=\"center\">安静模式,不输出任何警告</td>\n<td align=\"center\"><code>ssh -q foo.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-R</td>\n<td align=\"center\">指定远程端口转发</td>\n<td align=\"center\"><code>ssh -R 9999:targetServer:902 local</code>该命令需要在跳板服务器执行,指定本机计算机local监听自己的9999端口,所有发向这个端口的请求,都会转向targetServer的902端口</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">在ssh直接运行远端命令时,提供一个交互shell</td>\n<td align=\"center\"><code>ssh -t server.example.com emacs</code></td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">显示详细信息,可重复多次,表示详细程度</td>\n<td align=\"center\"><code>ssh -vvv server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-V</td>\n<td align=\"center\">显示客户端版本信息</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-X</td>\n<td align=\"center\">表示打开X窗口转发</td>\n<td align=\"center\"><code>ssh -X server.example.com</code></td>\n</tr>\n<tr>\n<td align=\"center\">-1,-2,-4,-6</td>\n<td align=\"center\">1表示SSH1协议,2表示SSH2协议,4表示IPv4协议(默认值),6表示Ipv6协议</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>5.配置文件</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">路径</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;etc&#x2F;ssh&#x2F;ssh_config</td>\n<td align=\"center\">全局配置文件</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;config</td>\n<td align=\"center\">用户个人的配置文件</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;id_ecdsa</td>\n<td align=\"center\">用户的ECDSA私钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;id_ecdsa.pub</td>\n<td align=\"center\">用户的ECDSA公钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;rsa</td>\n<td align=\"center\">用于SSH2的rsa私钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;rsa.pub</td>\n<td align=\"center\">用于SSH2的rsa公钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;identity</td>\n<td align=\"center\">用于SSH1的rsa私钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;identity.pub</td>\n<td align=\"center\">用于SSH1的rsa公钥</td>\n</tr>\n<tr>\n<td align=\"center\">~&#x2F;.ssh&#x2F;known_hosts</td>\n<td align=\"center\">包含SSH服务器的公钥指纹</td>\n</tr>\n</tbody></table>\n<p>配置文件示例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Host *<br>\tPort 2222<br>Host remoteserver<br>\tHostName remote.example.com<br>\tUser nanbert<br>\tPort 2112<br></code></pre></td></tr></table></figure>\n<p>常见配置命令:<br><code>AddressFamily &lt;option&gt;</code>option可以是inet,表示IPV4协议,也可以是inet6,表示IPV6协议<br><code>BindAddress 192.168.10.235</code>指定本机的IP地址(如果本机有多个Ip地址)<br><code>CheckHostIP &lt;yesOrNo&gt;</code>是否检查SSH的服务器IP地址是否跟公钥数据库吻合<br><code>Ciphers &lt;option&gt;</code>:指定加密算法<br><code>Compression &lt;yesOrNo&gt;</code>是否压缩传输信号<br><code>ConnectionAttempts &lt;num&gt;</code>客户端进行连接时,最大尝试次数<br><code>ConnectTimeout &lt;num&gt;</code>客户端进行连接时,服务器在指定秒数内没有回复,则中断连接尝试<br><code>DynamicForward &lt;portNum&gt;</code>指定动态转发端口<br><code>GlobalKnownHostsFile &lt;filePath&gt;</code>指定全局的公钥数据库文件的位置<br><code>Host &lt;serverName&gt;</code>指定连接的域名或IP地址,也可以是别名,支持通配符,后面所有配置都是针对该主机,直到遇到下一个Host<br><code>HostKeyAlgorithm &lt;options&gt;</code>指定密钥算法,优先级从高到低排列,以逗号分隔<br><code>HostName &lt;serverAddress&gt;</code>在Host命令使用别名的情况下用<br><code>IdentityFile &lt;fileName&gt;</code>指定私钥文件<br><code>LocalForward 2001 localhost:143</code>指定本地端口转发<br><code>LogLevel &lt;options&gt;</code>指定日志详细程度。如果设为<code>QUIET</code>,将不输出大部分的警告和提示<br><code>MACs &lt;options&gt;</code>指定数据校验算法,以逗号分隔<br><code>NumberOfPasswordPrompts &lt;num&gt;</code>输错密码最大尝试数<br><code>PasswordAuthentication &lt;yesOrNo&gt;</code>是否支持密码登录,这里只是客户端,需要服务器也有相同的设置<br><code>Port &lt;portNum&gt;</code>指定客户端链接的SSH服务器端口<br><code>PreferredAutentications publickey,hostbased,password</code>指定各种登录方法优先级<br><code>Protocol &lt;1,2&gt;</code>支持的SSH协议版本,可以用逗号分隔同时支持两个版本<br><code>PubKeyAuthentication &lt;yesOrNo&gt;</code>是否支持密钥登录,这里只是客户端设置,需要服务器相同的设置<br><code>RemoteForward 2001 server:143</code>指定远程端口转发<br><code>SendEnv &lt;variable&gt;</code>客户端向服务器发送环境变量名,多个环境变量之间用空格分隔,变量的值从当前环境拷贝<br><code>ServerAliveCountMax &lt;num&gt;</code>如果没有收到服务器的回应,客户端发送多少次keepalive信号,才断开连接,默认为3<br><code>ServerAliveInterval &lt;num&gt;</code>客户端建立连接后,如果在给定的数秒内,没有收到服务器发来的消息,客户端向服务器发送keepalive消息,如果不希望客户端发送,这一项设为0<br><code>StrictHostKeyChecking &lt;yesOrNo&gt;</code>yes表示严格检查,服务器公钥为未知或发生变化,则拒绝连接。no表示如果服务器公钥未知,则加入客户端公钥数据库,如果公钥发生变化,不改变客户端公钥数据库,输出一条警告,依然允许连接继续进行。ask(默认值)表示向用户询问是否继续<br><code>TCPKeepAlive &lt;yesOrNo&gt;</code>客户端是否定期向服务器发送keepalive信息<br><code>User &lt;userName&gt;</code>指定登录账户名<br><code>UserKnownHostsFile &lt;filePath&gt;</code>指定当前用户的服务器公钥指纹列表(known_hosts)的文件位置<br><code>VerifyHostKeyDNS &lt;yesOrNo&gt;</code>是否检查SSH服务器的DNS记录,确认公钥指纹是否与known_hosts文件保持一致<br>6.密钥<br><em>概念</em>:<br>密钥是一个非常大的数字,通过加密算法得到。对称加密只需要一个密钥,非对称加密需要成对使用,分为公钥和私钥。<br>SSH密钥登录采用非对称加密,每个永不通过自己的密钥登录。其中,私钥必须私密保存,不能泄露;公钥则公开,对外发送。它们的关系是,公钥和私钥是一一对应<br><em>过程</em>:<br>预备步骤,客户端通过<code>ssh-keygen</code>生产自己的公钥和私钥<br>第一步,手动将客户端的公钥放入远程服务器的指定位置<br>第二步,客户端向服务器发起SSH登录请求<br>第三步,服务器收到用户SSH登录的请求,发送一些随机数据给用户,要求用户证明自己的身份<br>第四步,客户端收到服务器发来的数据,私用私钥对数据进行签名,然后再发给服务器<br>第五步,服务器收到客户端发来的加密签名后,使用对应的公钥解密,然后跟原始数据比较。如果一致,就允许用户登录<br><em>ssh-key–生成密钥</em><br>该命令会生成一对密钥,私钥默认存在<del>&#x2F;.ssh&#x2F;id_rsa,公钥默认存在</del>&#x2F;.ssh&#x2F;id_rsa.pub</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b [num]</td>\n<td align=\"center\">指定密钥的二进制位数。这个参数越大,密钥越不容易破解,但是加密解密的开销也会越大,一般至少应该是1024</td>\n</tr>\n<tr>\n<td align=\"center\">-C “[string]”</td>\n<td align=\"center\">可以为密钥文件指定新的注释,格式一般为<code>username@host</code></td>\n</tr>\n<tr>\n<td align=\"center\">-f [filename]</td>\n<td align=\"center\">参数指定生成的私钥文件。不指定的话,会在~&#x2F;.ssh文件夹下生成一对密钥</td>\n</tr>\n<tr>\n<td align=\"center\">-F [hostname]</td>\n<td align=\"center\">检查某个主机名是否在known_hosts文件里面</td>\n</tr>\n<tr>\n<td align=\"center\">-N [secretword]</td>\n<td align=\"center\">指定私钥的密码</td>\n</tr>\n<tr>\n<td align=\"center\">-p[secretword]</td>\n<td align=\"center\">重新指定私钥的密码</td>\n</tr>\n<tr>\n<td align=\"center\">-R [hostname]</td>\n<td align=\"center\">将指定的主机公钥移除出known_hosts文件</td>\n</tr>\n<tr>\n<td align=\"center\">-t [algorithm]</td>\n<td align=\"center\">指定加密算法,一般为dsa或rsa</td>\n</tr>\n</tbody></table>\n<p><em>手动上传公钥</em><br>把客户端生成的公钥复制粘贴到文件~&#x2F;.ssh&#x2F;authorized_keys中去,一个公钥占据一行<br><em>ssh-copy-id–自动上传公钥</em><br><code>ssh-copy-id -i key_file user@host</code> 自动上传公钥到服务器<br>公钥文件可以不指定路劲和.pub后缀,会自动在~&#x2F;.ssh目录下寻找<br>确保authorized_keys文件末尾为换行符,否则两个公钥连在一起,两个都会失效</p>\n<p><em>ssh-agent命令</em><br>私钥设置了密码后,每次使用都必须输入密码,连续使用scp命令时,这就很麻烦,ssh-agent命令就是为了解决这个问题而设计的,它让用户在整个bash对话中,只在第一次使用SSH命令是输入密码,然后将私钥保存在内存中<br>第一步,新建一次命令对话<br><code>ssh-agent bash(zhs、fish)</code><br>第二步,添加私钥<br><code>ssh-add [filename]</code>可以不指定私钥名称,使用默认文件~&#x2F;.ssh&#x2F;id_rsa<br>第三步登录远程服务器<br><code>ssh remoteHost</code><br>最后,如果要退出ssh-agent,可以按Ctrl+d,也可以用如下命令<br><code>ssh-agent -k</code><br><em>ssh-add命令</em><br>ssh-add命令用来将私钥加入ssh-agent</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">从内存中删除指定的私钥</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">从内存中删除所有已经添加的私钥</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">列出所有已经添加的私钥</td>\n</tr>\n</tbody></table>\n<p><font size=6><strong>服务器端sshd</strong></font><br><strong>1.sshd配置文件</strong><br><code>/etc/ssh/sshd_config</code>配置文件<br><code>/etc/ssh/ssh_host_ecdsa_key</code>ECDSA私钥<br><code>/etc/ssh/ssh_host_ecdsa_key.pub</code>ECDSA公钥<br><code>/etc/ssh/ssh_host_key</code>用于SSH1协议版本的RSA私钥<br><code>/etc/ssh/ssh_host_key.pub</code>用于SSH1协议版本的RSA公钥<br><code>/etc/ssh/ssh_host_rsa_key</code>用于SSH2协议版本的RSA私钥<br><code>/etc/ssh/ssh_host_rsa_key.pub</code>用于SSH2协议版本的RSA公钥<br><code>/etc/pam.d/sshd</code>PAM配置文件<br><font color=#FF0000>重装会使这些文件失效,可以先备份</font><br><strong>sshd配置项</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">配置项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">AcceptEnv [variables…]</td>\n<td align=\"center\">允许接受客户端通过SendEnv命令发来的哪些环境变量,变量名用空格分隔</td>\n</tr>\n<tr>\n<td align=\"center\">AllowGroups [groupNames…]</td>\n<td align=\"center\">指定允许登录的用户组,多个组之间用空格隔开,若不用该项,则所有组都可以用</td>\n</tr>\n<tr>\n<td align=\"center\">AllowUsers [userNames…]</td>\n<td align=\"center\">指定允许登录的用户,用户名之间用空格隔开,支持通配符</td>\n</tr>\n<tr>\n<td align=\"center\">AllowTcpForwarding [options]</td>\n<td align=\"center\">默认值为yes,允许端口转发,local只允许本地端口转发,remote表示只允许远程端口转发</td>\n</tr>\n<tr>\n<td align=\"center\">AuthorizedKeysFile [directory]</td>\n<td align=\"center\">指定存储用户公钥的目录,默认是<code>~/.ssh/authorized_keys</code></td>\n</tr>\n<tr>\n<td align=\"center\">Banner [file]</td>\n<td align=\"center\">指定用户登录后,sshd向其展示的信息文件,默认不展示任何内容</td>\n</tr>\n<tr>\n<td align=\"center\">ChallengeResponseAuthentication [yesOrNo]</td>\n<td align=\"center\">指定是否用”键盘交互”身份验证方案,默认值为yes,如果完全禁用基于密码的验证,PasswordAuthentication也设为no</td>\n</tr>\n<tr>\n<td align=\"center\">Ciphers [algorithms]</td>\n<td align=\"center\">指定sshd可以接受的加密算法,多个算法之间使用逗号分割</td>\n</tr>\n<tr>\n<td align=\"center\">ClientAliveCountMax [num]</td>\n<td align=\"center\">指定建立连接后,客户端失去响应时,服务器尝试连接的次数</td>\n</tr>\n<tr>\n<td align=\"center\">ClientAliveInterval [num]</td>\n<td align=\"center\">允许客户端发呆的时间,单位为秒,如果超过这时间,连接将会关闭</td>\n</tr>\n<tr>\n<td align=\"center\">Compression [yesOrNo]</td>\n<td align=\"center\">Compression指定客户端与服务器之间的数据传输是否为压缩,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">DenyGroups [groupNames…]</td>\n<td align=\"center\">指定不允许登录的用户组,组间空格分开</td>\n</tr>\n<tr>\n<td align=\"center\">DenyUsers [userNames…]</td>\n<td align=\"center\">指定不允许登录的用户,空格分开不同用户</td>\n</tr>\n<tr>\n<td align=\"center\">FascistLogging [yesOrNo]</td>\n<td align=\"center\">SSH1版本专用,指定日志是否输出全部Debug信息</td>\n</tr>\n<tr>\n<td align=\"center\">HostKey [filePath]</td>\n<td align=\"center\">指定服务器密钥的文件路径</td>\n</tr>\n<tr>\n<td align=\"center\">KeyRegenerationInterval [num]</td>\n<td align=\"center\">指定SSH1版本的密钥重新生成的时间间隔,单位为秒,默认为3600</td>\n</tr>\n<tr>\n<td align=\"center\">ListenAddress [ipAddress]</td>\n<td align=\"center\">指定sshd监听本机的IP地址,即sshd启用的IP地址,默认是0.0.0.0,表示在本机所有网络接口启用。可以改成只在某个网络接口启用,可以多次使用该配置项,来监听多个ip地址</td>\n</tr>\n<tr>\n<td align=\"center\">LoginGraceTime [num]</td>\n<td align=\"center\">指定允许客户端登录时发呆的最长时间,超过该时间就断开,0表示没有限制</td>\n</tr>\n<tr>\n<td align=\"center\">LogLevel [options]</td>\n<td align=\"center\">指定日志的详细程度,可能的值有:QUIET,FATAL,ERROR,INFO,VERNBOSE,DEBUG,DEBUG1,DEBUG2,DEBUG3,默认为INFO</td>\n</tr>\n<tr>\n<td align=\"center\">MACs [algorithms]</td>\n<td align=\"center\">指定sshd可以接受的数据校验算法(MACs hmac-sha1),多个算法之间使用逗号分隔</td>\n</tr>\n<tr>\n<td align=\"center\">MaxAuthTries [num]</td>\n<td align=\"center\">指定SSH登录允许的最大密码尝试数</td>\n</tr>\n<tr>\n<td align=\"center\">MaxStartups [num]</td>\n<td align=\"center\">指定允许同时并发的SSH链接数量,0表示没有限制,也可以是A:B:C形式,如10:50:20,表示如果达到10个并发链接,后面的连接有50%的概率被拒绝,如果达到20个并发连接,则后面的100%拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">PasswordAuthentication [yesOrNo]</td>\n<td align=\"center\">是否允许密码登录,默认值为yes</td>\n</tr>\n<tr>\n<td align=\"center\">PermitEmptyPasswords [yesOrNo]</td>\n<td align=\"center\">指定是否允许空密码登录,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">PermitRootLogin [yesOrNo]</td>\n<td align=\"center\">是否允许根用户登录,默认为yes,也可以设为prohibit-password,表示允许密钥登录root,但禁止密码登录</td>\n</tr>\n<tr>\n<td align=\"center\">PermitUserEnvironment [yesOrNo]</td>\n<td align=\"center\">是否允许sshd加载客户端的<del>&#x2F;.ssh&#x2F;environment文件和</del>&#x2F;.ssh&#x2F;authorized_keys文件里面的environment&#x3D;options 环境变量设置.默认值为no</td>\n</tr>\n<tr>\n<td align=\"center\">Port [num]</td>\n<td align=\"center\">指定sshd监听的端口,默认22,可以多次设置,监听多个端口</td>\n</tr>\n<tr>\n<td align=\"center\">PrintMoth [yesOrNo]</td>\n<td align=\"center\">指定用户登录后,是否向其展示系统的motd的信息文件&#x2F;etc&#x2F;motd,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">Protocol [options]</td>\n<td align=\"center\">1表示使用SSH1协议,’1,2’表示支持两个版本的协议</td>\n</tr>\n<tr>\n<td align=\"center\">PubKeyAuthentication [yesOrNo]</td>\n<td align=\"center\">指定是否允许公钥登录,默认为yes</td>\n</tr>\n<tr>\n<td align=\"center\">QuietMode [yesOrNo]</td>\n<td align=\"center\">SSH1专用,yes表示日志只输出致命的错误信息</td>\n</tr>\n<tr>\n<td align=\"center\">RSAAuthentication [yesOrNo]</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ServerKeyBits [num]</td>\n<td align=\"center\">指定SSH1版本的密钥重新生成时的位数,默认为767</td>\n</tr>\n<tr>\n<td align=\"center\">StrictModes [yesOrNo]</td>\n<td align=\"center\">指定sshd是否检查用户的一些重要文件和目录权限,即对于用户的SSH配置文件,密钥文件和所在目录,SSH要求拥有者必须是根用户或用户本人,其他人的写权限必须关闭</td>\n</tr>\n<tr>\n<td align=\"center\">SyslogFacility [options]</td>\n<td align=\"center\">指定Syslog如何处理sshd日志,默认是AUTH</td>\n</tr>\n<tr>\n<td align=\"center\">TCPKeepAlive [unknown]</td>\n<td align=\"center\">指定打开sshd跟客户端tcp链接的keepalive参数</td>\n</tr>\n<tr>\n<td align=\"center\">UseDNS [yesOrNo]</td>\n<td align=\"center\">指定用户SSH登录一个域名时,服务器是否使用DNS,确认该域名对应的IP地址包含本机,建议关闭</td>\n</tr>\n<tr>\n<td align=\"center\">UserLogin [yesOrNo]</td>\n<td align=\"center\">指定用户认证内部是否使用&#x2F;user&#x2F;bin&#x2F;login代替SSH工具,默认为no</td>\n</tr>\n<tr>\n<td align=\"center\">UserPrivilegeSeparation</td>\n<td align=\"center\">指定用户认证通过后,使用另一个子线程处理用户权限相关的操作,这样利于提高安全性</td>\n</tr>\n<tr>\n<td align=\"center\">VerboseMode</td>\n<td align=\"center\">SSH2版本专用,指定日志输出详细的Debug信息</td>\n</tr>\n<tr>\n<td align=\"center\">X11Forwarding</td>\n<td align=\"center\">指定是否打开X window的转发,默认值为no</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>sshd命令行配置项</strong></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">用于显示debug信息</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">指定sshd不作为后台守护进程运行</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">将sshd写入系统日志syslog的内容导向标准错误</td>\n</tr>\n<tr>\n<td align=\"center\">-f [filePath]</td>\n<td align=\"center\">指定配置文件位置</td>\n</tr>\n<tr>\n<td align=\"center\">-h [filePath]</td>\n<td align=\"center\">指定密钥</td>\n</tr>\n<tr>\n<td align=\"center\">-o [Key Value]</td>\n<td align=\"center\">指定配置文件的一个配置项和对应的值,如:sshd -o “Port 2034”</td>\n</tr>\n<tr>\n<td align=\"center\">-p [num]</td>\n<td align=\"center\">指定sshd的服务端口</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">检查配置文件语法是否正确</td>\n</tr>\n</tbody></table>\n<h2 id=\"scp命令\"><a href=\"#scp命令\" class=\"headerlink\" title=\"scp命令\"></a>scp命令</h2><ul>\n<li><code>scp [参数][原路径][目标路径]</code></li>\n<li>它的底层是SSH协议,默认端口22,相当于先用ssh命令登陆远程主机,然后在执行拷贝,可以用于两个远程系统之间的复制</li>\n</ul>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>-1 强制scp命令使用协议ssh1<br>-2 强制scp命令使用协议ssh2<br>-4 强制scp命令只使用IPv4寻址<br>-6 强制scp命令只使用IPv6寻址<br>-B 使用批处理模式（传输过程中不询问传输口令或短语）<br>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）<br>-p 留原文件的修改时间，访问时间和访问权限。<br>-q 不显示传输进度条。<br>-r 递归复制整个目录。<br>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。<br>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。<br>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。<br>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。<br>-l limit 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。<br>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，<br>-P port 注意是大写的P, port是指定数据传输用到的端口号<br>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</p>\n<p><font size=6><strong>sftp命令</strong></font><br><strong>简介</strong><br>sftp是ssh提供的一个客户端应用程序,主要用来安全地访问FTP。因为FTP是不加密协议,很不安全,sftp相当于将FTP放入SSH:<br><code>sftp username@hostname</code><br>进入sftp后,使用那些命令,如get获取远程文件,put上传文件等<br><font size=6><strong>端口转发</strong></font><br>(待建)可见<a href=\"https://wangdoc.com/ssh/port-forwarding.html\">https://wangdoc.com/ssh/port-forwarding.html</a><br><font size=6><strong>证书登录</strong></font><br>(待建)可见<a href=\"https://wangdoc.com/ssh/ca.html\">https://wangdoc.com/ssh/ca.html</a></p>\n"},{"title":"html及markdown","date":"2019-07-18T07:54:54.000Z","subtitle":null,"index_img":"/images/html.jpg","banner_img":"/images/html.jpg","_content":"1.  \n粗体&lt;b>...&lt;/b>\n斜体&lt;i>...&lt;/i>\n下标&lt;sub>...&lt;/sub>\n上标&lt;sup>...&lt;/sup>\n希腊字母&lt;greek>...&lt;/greek>\n数学符号&lt;math>...&lt;/math>\n特殊符号&lt;userdef>...&lt;/userdef>\n尖括号的转义则是在&与;之间加入对应的编码\n2.  \nmarkdown特殊符号的打出：\n空格可以全角的空格打出\n3.  \n字体的形式:\n\\*斜体\\*——>*斜体*\n\\*\\*粗体\\*\\*——>**粗体**\n\\*\\*\\*粗斜体\\*\\*\\*——>***粗斜体***\n\\~\\~删除线\\~\\~——>~~删除线~~\n\\`\\`\\`\n代码行１\n代码行２\n代码行３\n\\`\\`\\`\n```\n代码行１\n代码行２\n代码行３\n```\n","source":"_posts/html及markdown.md","raw":"---\ntitle: html及markdown\ndate: 2019-07-18 15:54:54\nsubtitle:\ncategories: html\ntags:\nindex_img: /images/html.jpg\nbanner_img: /images/html.jpg\n---\n1.  \n粗体&lt;b>...&lt;/b>\n斜体&lt;i>...&lt;/i>\n下标&lt;sub>...&lt;/sub>\n上标&lt;sup>...&lt;/sup>\n希腊字母&lt;greek>...&lt;/greek>\n数学符号&lt;math>...&lt;/math>\n特殊符号&lt;userdef>...&lt;/userdef>\n尖括号的转义则是在&与;之间加入对应的编码\n2.  \nmarkdown特殊符号的打出：\n空格可以全角的空格打出\n3.  \n字体的形式:\n\\*斜体\\*——>*斜体*\n\\*\\*粗体\\*\\*——>**粗体**\n\\*\\*\\*粗斜体\\*\\*\\*——>***粗斜体***\n\\~\\~删除线\\~\\~——>~~删除线~~\n\\`\\`\\`\n代码行１\n代码行２\n代码行３\n\\`\\`\\`\n```\n代码行１\n代码行２\n代码行３\n```\n","slug":"html及markdown","published":1,"updated":"2023-12-20T12:41:15.400Z","_id":"clq1yvi730013gwq2d9uge3px","comments":1,"layout":"post","photos":[],"content":"<ol>\n<li>粗体&lt;b&gt;…&lt;&#x2F;b&gt;<br>斜体&lt;i&gt;…&lt;&#x2F;i&gt;<br>下标&lt;sub&gt;…&lt;&#x2F;sub&gt;<br>上标&lt;sup&gt;…&lt;&#x2F;sup&gt;<br>希腊字母&lt;greek&gt;…&lt;&#x2F;greek&gt;<br>数学符号&lt;math&gt;…&lt;&#x2F;math&gt;<br>特殊符号&lt;userdef&gt;…&lt;&#x2F;userdef&gt;<br>尖括号的转义则是在&amp;与;之间加入对应的编码</li>\n<li>markdown特殊符号的打出：<br>空格可以全角的空格打出</li>\n<li>字体的形式:<br>*斜体*——&gt;<em>斜体</em><br>**粗体**——&gt;<strong>粗体</strong><br>***粗斜体***——&gt;<em><strong>粗斜体</strong></em><br>~~删除线~~——&gt;<del>删除线</del><br>```<br>代码行１<br>代码行２<br>代码行３<br>```<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">代码行１<br>代码行２<br>代码行３<br></code></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<ol>\n<li>粗体&lt;b&gt;…&lt;&#x2F;b&gt;<br>斜体&lt;i&gt;…&lt;&#x2F;i&gt;<br>下标&lt;sub&gt;…&lt;&#x2F;sub&gt;<br>上标&lt;sup&gt;…&lt;&#x2F;sup&gt;<br>希腊字母&lt;greek&gt;…&lt;&#x2F;greek&gt;<br>数学符号&lt;math&gt;…&lt;&#x2F;math&gt;<br>特殊符号&lt;userdef&gt;…&lt;&#x2F;userdef&gt;<br>尖括号的转义则是在&amp;与;之间加入对应的编码</li>\n<li>markdown特殊符号的打出：<br>空格可以全角的空格打出</li>\n<li>字体的形式:<br>*斜体*——&gt;<em>斜体</em><br>**粗体**——&gt;<strong>粗体</strong><br>***粗斜体***——&gt;<em><strong>粗斜体</strong></em><br>~~删除线~~——&gt;<del>删除线</del><br>```<br>代码行１<br>代码行２<br>代码行３<br>```<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">代码行１<br>代码行２<br>代码行３<br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"sed","date":"2019-07-18T10:16:15.000Z","subtitle":null,"index_img":"/images/sed.jpeg","banner_img":"/images/sed.jpeg","_content":"### sed作用原理\nsed首先将整个编辑脚本应用于第一个输入行(存在模式空间)，然后再读取第二个输入行。sed总是处理原始行的最新形式，所以生成的任何编辑动作都会作用于后续命令。\n### sed选项总结\n\n|options|describe|example|\n|:-:|:-:|:-:|\n|-e|编辑随后的指令|`sed -e 's/brown/green/;s/dog/cat/' data.txt`|\n|-f|跟随脚本中的文件名|\n|-n|阻止输入行的自动输出|\n|-r|支持扩展的正则表达式|\n|-i|直接修改读取的文件内容,而不是由屏幕输出|\n### 在命令行上指定多重命令\n- `sed 's/MA/ma/; s/FA/fa/' file`\n- `sed -e '/MA/ma/' -e 's/FA/fa/' file`\n- bash等通用,输入单引号后回车,会出现`>`多行输入提示符\nsed为流编辑器,一次读取一行内容,并执行相应的命令,格式如下:\n`sed [options] '[command]' (file)`\n\n### sed地址表示方法\n\n|地址|说明|\n|:-:|:-:|\n|n|行号,n是一个正整数|\n|$|最后一行|\n|/regexp/|正则表达式匹配行|\n|addr1,addr2|从addr1到addr2范围内的文本行,包含地址addr2在内,地址是上述任意的地址形式|\n|first~step|匹配由数字first代表的文本行,然后随后的每个在step间隔处的文本行。例如1~2代表奇数行|\n|addr1,+n|匹配地址addr1和随后的n个文本行|\n|addr!|匹配所有文本行,除了addr之外,addr是上述任意的地址形式|\n\n### 分组命令\nsed使用大括号`{}`将一个地址嵌套在另一个地址上，或在相同的地址上应用多个命令，左大括号必须在行末，右大括号独占一行，之后必须没空格\n**例1：**\n```bash\n1,5{\n/^$/d\n}\n```\n**例2：**\n```bash\n1,5{\n/^$/d\ns/a/b/\n}\n```\n\n### 替换s\n`[address]s/pattern/replacement/flags`\n#### 替换的标志位\n\n|flag|含义|\n|:-:|:-:|\n|n|1到512之间的一个数字,表示对文本模式中指定模式第n次出现的情况进行替换|\n|g|对模式空间的所有出现的情况进行全局更改|\n|p|打印模式空间的内容,可以加感叹号，表示不打印|\n|W <file>|将模式空间的内容写到文件file中|\n\n#### 替换部分的元字符\n- `&`:表示命中的正则表达式\n- `\\`:后面可接回车,其他元字符转义\n- `\\<n>`:表示匹配的部分,在pattern中用`\\(`和`\\)`括起来\n\n#### 界定符\n- 如果模式中含有'/'可以用感叹号作定界符,如`s!/usr/mail!/usr2/mail!`\n- 注意地址的界定符不能这么玩\n\n### 删除d\n匹配到这个地址就删除模式空间内容,并且会导致不再执行接下来的脚本，读取新的行。\n### a、i、c\n- 追加`[line-address(单行)]a\\\n\t\t\\<text\\>`\n  加入模式空间内容之后\n- 插入`[line-address(单行)]i\\\n\t\t\\<text\\>`\n  插入模式空间内容之前\n- 更改`[address(可以是范围)]c\\\n\t\t\\<text\\>`\n  替换模式空间(范围的话,替换范围内的内容)的内容\n#### 注意项\n- 每一个都要求后面跟一个反斜杠转义第一个行尾,text必须从下一行开始\n- text内容如果是多行,则行末要加反斜线,最后一行不需要\n- 如果更改存在于组命令中,且是个范围，则会存在每一行都替换,而不是范围替换一次\n- 插入与追加的文本内容不受命令影响,也不影响行计数器\n- 更改命令则与删除命令类似,接下来的脚本不会作用，会立刻读入新行\n### 读和写命令\n- `[line-address]r file`读入某个文件的内容,追加到模式空间后\n- `[address]w file`把模式空间内容写到某个文件\n#### 注意项\n- 文件不存在不会报错\n- 如果一个脚本中有多个指令写到同一个文件,那么每个写命令都将追加到这个文件\n- 读的内容不受之后命令影响\n- sed最多打开10个文件\n### 其他命令\n- 列表`[addess]l`:不仅显示内容,非打印字符显示为两个数字的ASCLL代码\n- `[line-address]=`:不打印内容,但打印行号\n- `[address]n`:输出模式空间内容(没抑制输出的话),读取输入的下一行,并且后续命令用于新行,之前的命令不会用于新行\n- `[line-address]q`:停止读入新行，退出脚本,经常用来打印前几行\n- 转换`[address]y/abc/xyz/`(类似于tr),有用的例子转换大小写y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/\n### 反斜线圆括号用法\n`s/\\([0-9]\\)-\\([0-9]\\)/\\2-\\1/g`指交换斜杠前后的两个数字\n### 多行模式N\n多行模式空间:多行Next(N)命令通过读取新的输入行,并将它添加到模式空间的现有内容来创建多行模式空间。模式空间最初的内容和新的输入行之间用换行符分隔。在模式空间中嵌入的换行符可以用转义序列\"\\n\"来匹配。在多行模式空间中,元字符\"^\"匹配空间中的第一个字条,而不匹配换行符后面的字符。同样,\"$\"只匹配模式空间中最后的换行符,而不匹配任何嵌入的换行符。在执行Next命令之后,控制将被传递给脚本中的后续命令。\n这与next不同，next不创建多行模式，它输出内容，然后，读取新的行。\n举例:例如要将\"Owner and Operator Guide\"换成\"Installation Guide\",对于处于不同行的情况可以这样做:\n```bash\n/Operator$/{\nN\ns/Owner and Operator\\nGuide/Installation Guide/\n}\n```\n上面比较不普遍,更普遍做法是:\n```bash\ns/Owner and Operator Guide/Installtion Guide/\n/Owner/{\nN\ns/ *\\n/ /\ns/Owner and Operator Guide */Installation Guide\\\n/\n}\n```\n### 多行模式D\n删除命令(d)删除模式空间的内容并导致读入新的输入行,从而在脚本的顶端重新使用编辑方法。删除命令(D)稍微有些不同:它删除模式空间中直到第一个嵌入的换行符的这部分内容。他不会导致读入新的输入行,相反,**它返回到脚本的顶端**,将这些指令应用于模式空间的剩余内容。\n例子:\n```bash\n/^ $/{\nN\n/^ \\n$/D\n}\n```\n以上可以删除连续多个空行,只保留一个空行\n### 多行模式P\n该命令输出多行模式空间的第一部分，直到第一个嵌入的换行符为止。  \nP命令经常出现在Next命令之后和Delete命令之前，建立一个输入/输出循环，用来维护两行的模式空间，这样就能之输出第一行，然后返回到脚本的顶端，用于第二行。\n### 保持空间\n保持空间:当改变模式空间中的原始内容时,用于保留当前输入行的副本。影响模式空间的命令\n|命令|缩写|功能|\n|:-:|:-:|:-:|\n|Hold|h或H|将模式空间的内容复制或追加到保持空间(大写追加)|\n|Get|g或G|将保持空间的内容复制或追加到模式空间(大写追加)|\n|Exchange|x|交换保持空间和模式空间的内容|\n\n### 高级的流控制命令  \n- 分支:在脚本中将控制转移到另一行\n```bash\n:top\ncommand1\ncommand2\n/pattern/b top\ncommand3\n```\n如果没有定义top或没有标签(可以为任意命名),则将跳转到脚本末尾,上面例子意思是如果找不到pattern,才执行commmand3\n**注意**不要在标签后加空格\n- 测试:如果当前匹配行上成功进行了替换,那么test命令就会转到标签处,用法和分支一样,把b改成t即可\n```bash\n/sth/{\ns/a/b/\nt\ns/c/b/\nt\ns/d/b/\n}\n```\n一旦一个替换被执行，控制就到脚本末尾\n### 一些例子\n- `sed '52q;d' file`打印52行，效率高\n- `cat jane.txt | tr '[A-Z]' '[a-z]' | tr ';.?\\047,():\"-' ' '|tr ' ' '\\012' | grep -v '^ *$' | sort | uniq -c | sort -n`:统计单词数,首先大写替换为小写，然后替换标点为空格,再替换空格为换行,去空行,排序，计数，再排序。\n- `sed 'G' file`在每行后添加个空行\n- `sed -n \"$!N;/^(.*)n1$/!P;D' test.txt`删除文件中连续且重复的行\n- `sed '/^$/d;G'`保证每一行后都有个空行，会删除连续空行，并添加空行\n- `sed 'n;d' test.txt`删除偶数行\n- `sed '/regex/{x;p;x}' test.txt`匹配regex之前添加空行\n- `sed '/regex/G' test.txt`匹配regex之后添加空行\n- `sed '/regex/{x;p;x;G;}' test.txt`之前之后都添加空行\n- `sed 'n;n;n;n;G'`每5行添加一个空行或`sed '0~5G' text.txt`\n- `sed '=' test.txt | sed 'N;s/s*ns*/t/'`给每一行添加行号，以制表符分隔\n- `sed '/./=' test.txt | sed '/./N; s/s*ns*/t/'`为非空行添加行号\n- `sed -n '$=' test.txt`统计行数\n- `sed 's/^[[:blank:]]*|[[:blank:]]*$//' test.txt`删除行首和行尾空白\n- `sed '1!G;h;$!d' test.txt`反转每一行的顺序(类似tac)\n- `sed '/n/!G;s/(.)(.*n)/&21/;//D;s/.//'`反转每一行的字母顺序(类似rev)\n- `sed -e ':a' -e 's/([0-9])([0-9]{3})($|,)/1,2/;ta' test.txt`给数字串加逗号或`sed -e ':a' -e 's/(.*[0-9])([0-9]{3})/1,2/;ta' test.txt`\n- `sed 'q' test.txt`打印文件第一行\n- `sed -n 'N;P' file`打印奇数行\n- `sed -n '/regex/{n;p}' test.txt` 打印匹配那一行的后一行\n- `sed -n '/regex/{=;x;1!p;g;$!N;p;D;}; h' test.txt`  打印匹配“regex”那一行的前后一行，并且打印匹配行的行号(类似grep -A1 -B1)\n- `sed -n '/^.{65}/p' test.txt`打印长于65个字符的行\n- `sed '/^$/N;/n$/D' test.txt`压缩连续空行(类似于cat -s)\n- `sed '/./,$!d'`删除文件开头的空行\n- `sed ':a;/^n*$/{$d;N;ba}' test.txt`删除文件结尾空行\n\n","source":"_posts/sed.md","raw":"---\ntitle: 'sed'\ndate: 2019-07-18 18:16:15\nsubtitle:\ncategories: 文本处理\ntags:\nindex_img: /images/sed.jpeg\nbanner_img: /images/sed.jpeg\n---\n### sed作用原理\nsed首先将整个编辑脚本应用于第一个输入行(存在模式空间)，然后再读取第二个输入行。sed总是处理原始行的最新形式，所以生成的任何编辑动作都会作用于后续命令。\n### sed选项总结\n\n|options|describe|example|\n|:-:|:-:|:-:|\n|-e|编辑随后的指令|`sed -e 's/brown/green/;s/dog/cat/' data.txt`|\n|-f|跟随脚本中的文件名|\n|-n|阻止输入行的自动输出|\n|-r|支持扩展的正则表达式|\n|-i|直接修改读取的文件内容,而不是由屏幕输出|\n### 在命令行上指定多重命令\n- `sed 's/MA/ma/; s/FA/fa/' file`\n- `sed -e '/MA/ma/' -e 's/FA/fa/' file`\n- bash等通用,输入单引号后回车,会出现`>`多行输入提示符\nsed为流编辑器,一次读取一行内容,并执行相应的命令,格式如下:\n`sed [options] '[command]' (file)`\n\n### sed地址表示方法\n\n|地址|说明|\n|:-:|:-:|\n|n|行号,n是一个正整数|\n|$|最后一行|\n|/regexp/|正则表达式匹配行|\n|addr1,addr2|从addr1到addr2范围内的文本行,包含地址addr2在内,地址是上述任意的地址形式|\n|first~step|匹配由数字first代表的文本行,然后随后的每个在step间隔处的文本行。例如1~2代表奇数行|\n|addr1,+n|匹配地址addr1和随后的n个文本行|\n|addr!|匹配所有文本行,除了addr之外,addr是上述任意的地址形式|\n\n### 分组命令\nsed使用大括号`{}`将一个地址嵌套在另一个地址上，或在相同的地址上应用多个命令，左大括号必须在行末，右大括号独占一行，之后必须没空格\n**例1：**\n```bash\n1,5{\n/^$/d\n}\n```\n**例2：**\n```bash\n1,5{\n/^$/d\ns/a/b/\n}\n```\n\n### 替换s\n`[address]s/pattern/replacement/flags`\n#### 替换的标志位\n\n|flag|含义|\n|:-:|:-:|\n|n|1到512之间的一个数字,表示对文本模式中指定模式第n次出现的情况进行替换|\n|g|对模式空间的所有出现的情况进行全局更改|\n|p|打印模式空间的内容,可以加感叹号，表示不打印|\n|W <file>|将模式空间的内容写到文件file中|\n\n#### 替换部分的元字符\n- `&`:表示命中的正则表达式\n- `\\`:后面可接回车,其他元字符转义\n- `\\<n>`:表示匹配的部分,在pattern中用`\\(`和`\\)`括起来\n\n#### 界定符\n- 如果模式中含有'/'可以用感叹号作定界符,如`s!/usr/mail!/usr2/mail!`\n- 注意地址的界定符不能这么玩\n\n### 删除d\n匹配到这个地址就删除模式空间内容,并且会导致不再执行接下来的脚本，读取新的行。\n### a、i、c\n- 追加`[line-address(单行)]a\\\n\t\t\\<text\\>`\n  加入模式空间内容之后\n- 插入`[line-address(单行)]i\\\n\t\t\\<text\\>`\n  插入模式空间内容之前\n- 更改`[address(可以是范围)]c\\\n\t\t\\<text\\>`\n  替换模式空间(范围的话,替换范围内的内容)的内容\n#### 注意项\n- 每一个都要求后面跟一个反斜杠转义第一个行尾,text必须从下一行开始\n- text内容如果是多行,则行末要加反斜线,最后一行不需要\n- 如果更改存在于组命令中,且是个范围，则会存在每一行都替换,而不是范围替换一次\n- 插入与追加的文本内容不受命令影响,也不影响行计数器\n- 更改命令则与删除命令类似,接下来的脚本不会作用，会立刻读入新行\n### 读和写命令\n- `[line-address]r file`读入某个文件的内容,追加到模式空间后\n- `[address]w file`把模式空间内容写到某个文件\n#### 注意项\n- 文件不存在不会报错\n- 如果一个脚本中有多个指令写到同一个文件,那么每个写命令都将追加到这个文件\n- 读的内容不受之后命令影响\n- sed最多打开10个文件\n### 其他命令\n- 列表`[addess]l`:不仅显示内容,非打印字符显示为两个数字的ASCLL代码\n- `[line-address]=`:不打印内容,但打印行号\n- `[address]n`:输出模式空间内容(没抑制输出的话),读取输入的下一行,并且后续命令用于新行,之前的命令不会用于新行\n- `[line-address]q`:停止读入新行，退出脚本,经常用来打印前几行\n- 转换`[address]y/abc/xyz/`(类似于tr),有用的例子转换大小写y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/\n### 反斜线圆括号用法\n`s/\\([0-9]\\)-\\([0-9]\\)/\\2-\\1/g`指交换斜杠前后的两个数字\n### 多行模式N\n多行模式空间:多行Next(N)命令通过读取新的输入行,并将它添加到模式空间的现有内容来创建多行模式空间。模式空间最初的内容和新的输入行之间用换行符分隔。在模式空间中嵌入的换行符可以用转义序列\"\\n\"来匹配。在多行模式空间中,元字符\"^\"匹配空间中的第一个字条,而不匹配换行符后面的字符。同样,\"$\"只匹配模式空间中最后的换行符,而不匹配任何嵌入的换行符。在执行Next命令之后,控制将被传递给脚本中的后续命令。\n这与next不同，next不创建多行模式，它输出内容，然后，读取新的行。\n举例:例如要将\"Owner and Operator Guide\"换成\"Installation Guide\",对于处于不同行的情况可以这样做:\n```bash\n/Operator$/{\nN\ns/Owner and Operator\\nGuide/Installation Guide/\n}\n```\n上面比较不普遍,更普遍做法是:\n```bash\ns/Owner and Operator Guide/Installtion Guide/\n/Owner/{\nN\ns/ *\\n/ /\ns/Owner and Operator Guide */Installation Guide\\\n/\n}\n```\n### 多行模式D\n删除命令(d)删除模式空间的内容并导致读入新的输入行,从而在脚本的顶端重新使用编辑方法。删除命令(D)稍微有些不同:它删除模式空间中直到第一个嵌入的换行符的这部分内容。他不会导致读入新的输入行,相反,**它返回到脚本的顶端**,将这些指令应用于模式空间的剩余内容。\n例子:\n```bash\n/^ $/{\nN\n/^ \\n$/D\n}\n```\n以上可以删除连续多个空行,只保留一个空行\n### 多行模式P\n该命令输出多行模式空间的第一部分，直到第一个嵌入的换行符为止。  \nP命令经常出现在Next命令之后和Delete命令之前，建立一个输入/输出循环，用来维护两行的模式空间，这样就能之输出第一行，然后返回到脚本的顶端，用于第二行。\n### 保持空间\n保持空间:当改变模式空间中的原始内容时,用于保留当前输入行的副本。影响模式空间的命令\n|命令|缩写|功能|\n|:-:|:-:|:-:|\n|Hold|h或H|将模式空间的内容复制或追加到保持空间(大写追加)|\n|Get|g或G|将保持空间的内容复制或追加到模式空间(大写追加)|\n|Exchange|x|交换保持空间和模式空间的内容|\n\n### 高级的流控制命令  \n- 分支:在脚本中将控制转移到另一行\n```bash\n:top\ncommand1\ncommand2\n/pattern/b top\ncommand3\n```\n如果没有定义top或没有标签(可以为任意命名),则将跳转到脚本末尾,上面例子意思是如果找不到pattern,才执行commmand3\n**注意**不要在标签后加空格\n- 测试:如果当前匹配行上成功进行了替换,那么test命令就会转到标签处,用法和分支一样,把b改成t即可\n```bash\n/sth/{\ns/a/b/\nt\ns/c/b/\nt\ns/d/b/\n}\n```\n一旦一个替换被执行，控制就到脚本末尾\n### 一些例子\n- `sed '52q;d' file`打印52行，效率高\n- `cat jane.txt | tr '[A-Z]' '[a-z]' | tr ';.?\\047,():\"-' ' '|tr ' ' '\\012' | grep -v '^ *$' | sort | uniq -c | sort -n`:统计单词数,首先大写替换为小写，然后替换标点为空格,再替换空格为换行,去空行,排序，计数，再排序。\n- `sed 'G' file`在每行后添加个空行\n- `sed -n \"$!N;/^(.*)n1$/!P;D' test.txt`删除文件中连续且重复的行\n- `sed '/^$/d;G'`保证每一行后都有个空行，会删除连续空行，并添加空行\n- `sed 'n;d' test.txt`删除偶数行\n- `sed '/regex/{x;p;x}' test.txt`匹配regex之前添加空行\n- `sed '/regex/G' test.txt`匹配regex之后添加空行\n- `sed '/regex/{x;p;x;G;}' test.txt`之前之后都添加空行\n- `sed 'n;n;n;n;G'`每5行添加一个空行或`sed '0~5G' text.txt`\n- `sed '=' test.txt | sed 'N;s/s*ns*/t/'`给每一行添加行号，以制表符分隔\n- `sed '/./=' test.txt | sed '/./N; s/s*ns*/t/'`为非空行添加行号\n- `sed -n '$=' test.txt`统计行数\n- `sed 's/^[[:blank:]]*|[[:blank:]]*$//' test.txt`删除行首和行尾空白\n- `sed '1!G;h;$!d' test.txt`反转每一行的顺序(类似tac)\n- `sed '/n/!G;s/(.)(.*n)/&21/;//D;s/.//'`反转每一行的字母顺序(类似rev)\n- `sed -e ':a' -e 's/([0-9])([0-9]{3})($|,)/1,2/;ta' test.txt`给数字串加逗号或`sed -e ':a' -e 's/(.*[0-9])([0-9]{3})/1,2/;ta' test.txt`\n- `sed 'q' test.txt`打印文件第一行\n- `sed -n 'N;P' file`打印奇数行\n- `sed -n '/regex/{n;p}' test.txt` 打印匹配那一行的后一行\n- `sed -n '/regex/{=;x;1!p;g;$!N;p;D;}; h' test.txt`  打印匹配“regex”那一行的前后一行，并且打印匹配行的行号(类似grep -A1 -B1)\n- `sed -n '/^.{65}/p' test.txt`打印长于65个字符的行\n- `sed '/^$/N;/n$/D' test.txt`压缩连续空行(类似于cat -s)\n- `sed '/./,$!d'`删除文件开头的空行\n- `sed ':a;/^n*$/{$d;N;ba}' test.txt`删除文件结尾空行\n\n","slug":"sed","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi77001ogwq2by3qewbi","content":"<h3 id=\"sed作用原理\"><a href=\"#sed作用原理\" class=\"headerlink\" title=\"sed作用原理\"></a>sed作用原理</h3><p>sed首先将整个编辑脚本应用于第一个输入行(存在模式空间)，然后再读取第二个输入行。sed总是处理原始行的最新形式，所以生成的任何编辑动作都会作用于后续命令。</p>\n<h3 id=\"sed选项总结\"><a href=\"#sed选项总结\" class=\"headerlink\" title=\"sed选项总结\"></a>sed选项总结</h3><table>\n<thead>\n<tr>\n<th align=\"center\">options</th>\n<th align=\"center\">describe</th>\n<th align=\"center\">example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">编辑随后的指令</td>\n<td align=\"center\"><code>sed -e &#39;s/brown/green/;s/dog/cat/&#39; data.txt</code></td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">跟随脚本中的文件名</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">阻止输入行的自动输出</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">支持扩展的正则表达式</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">直接修改读取的文件内容,而不是由屏幕输出</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"在命令行上指定多重命令\"><a href=\"#在命令行上指定多重命令\" class=\"headerlink\" title=\"在命令行上指定多重命令\"></a>在命令行上指定多重命令</h3><ul>\n<li><code>sed &#39;s/MA/ma/; s/FA/fa/&#39; file</code></li>\n<li><code>sed -e &#39;/MA/ma/&#39; -e &#39;s/FA/fa/&#39; file</code></li>\n<li>bash等通用,输入单引号后回车,会出现<code>&gt;</code>多行输入提示符<br>sed为流编辑器,一次读取一行内容,并执行相应的命令,格式如下:<br><code>sed [options] &#39;[command]&#39; (file)</code></li>\n</ul>\n<h3 id=\"sed地址表示方法\"><a href=\"#sed地址表示方法\" class=\"headerlink\" title=\"sed地址表示方法\"></a>sed地址表示方法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">n</td>\n<td align=\"center\">行号,n是一个正整数</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"center\">最后一行</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;regexp&#x2F;</td>\n<td align=\"center\">正则表达式匹配行</td>\n</tr>\n<tr>\n<td align=\"center\">addr1,addr2</td>\n<td align=\"center\">从addr1到addr2范围内的文本行,包含地址addr2在内,地址是上述任意的地址形式</td>\n</tr>\n<tr>\n<td align=\"center\">first~step</td>\n<td align=\"center\">匹配由数字first代表的文本行,然后随后的每个在step间隔处的文本行。例如1~2代表奇数行</td>\n</tr>\n<tr>\n<td align=\"center\">addr1,+n</td>\n<td align=\"center\">匹配地址addr1和随后的n个文本行</td>\n</tr>\n<tr>\n<td align=\"center\">addr!</td>\n<td align=\"center\">匹配所有文本行,除了addr之外,addr是上述任意的地址形式</td>\n</tr>\n</tbody></table>\n<h3 id=\"分组命令\"><a href=\"#分组命令\" class=\"headerlink\" title=\"分组命令\"></a>分组命令</h3><p>sed使用大括号<code>&#123;&#125;</code>将一个地址嵌套在另一个地址上，或在相同的地址上应用多个命令，左大括号必须在行末，右大括号独占一行，之后必须没空格<br><strong>例1：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">1,5&#123;<br>/^$/d<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>例2：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">1,5&#123;<br>/^$/d<br>s/a/b/<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"替换s\"><a href=\"#替换s\" class=\"headerlink\" title=\"替换s\"></a>替换s</h3><p><code>[address]s/pattern/replacement/flags</code></p>\n<h4 id=\"替换的标志位\"><a href=\"#替换的标志位\" class=\"headerlink\" title=\"替换的标志位\"></a>替换的标志位</h4><table>\n<thead>\n<tr>\n<th align=\"center\">flag</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">n</td>\n<td align=\"center\">1到512之间的一个数字,表示对文本模式中指定模式第n次出现的情况进行替换</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td align=\"center\">对模式空间的所有出现的情况进行全局更改</td>\n</tr>\n<tr>\n<td align=\"center\">p</td>\n<td align=\"center\">打印模式空间的内容,可以加感叹号，表示不打印</td>\n</tr>\n<tr>\n<td align=\"center\">W <file></td>\n<td align=\"center\">将模式空间的内容写到文件file中</td>\n</tr>\n</tbody></table>\n<h4 id=\"替换部分的元字符\"><a href=\"#替换部分的元字符\" class=\"headerlink\" title=\"替换部分的元字符\"></a>替换部分的元字符</h4><ul>\n<li><code>&amp;</code>:表示命中的正则表达式</li>\n<li><code>\\</code>:后面可接回车,其他元字符转义</li>\n<li><code>\\&lt;n&gt;</code>:表示匹配的部分,在pattern中用<code>\\(</code>和<code>\\)</code>括起来</li>\n</ul>\n<h4 id=\"界定符\"><a href=\"#界定符\" class=\"headerlink\" title=\"界定符\"></a>界定符</h4><ul>\n<li>如果模式中含有’&#x2F;‘可以用感叹号作定界符,如<code>s!/usr/mail!/usr2/mail!</code></li>\n<li>注意地址的界定符不能这么玩</li>\n</ul>\n<h3 id=\"删除d\"><a href=\"#删除d\" class=\"headerlink\" title=\"删除d\"></a>删除d</h3><p>匹配到这个地址就删除模式空间内容,并且会导致不再执行接下来的脚本，读取新的行。</p>\n<h3 id=\"a、i、c\"><a href=\"#a、i、c\" class=\"headerlink\" title=\"a、i、c\"></a>a、i、c</h3><ul>\n<li>追加<code>[line-address(单行)]a\\   \\&lt;text\\&gt;</code><br>加入模式空间内容之后</li>\n<li>插入<code>[line-address(单行)]i\\   \\&lt;text\\&gt;</code><br>插入模式空间内容之前</li>\n<li>更改<code>[address(可以是范围)]c\\   \\&lt;text\\&gt;</code><br>替换模式空间(范围的话,替换范围内的内容)的内容</li>\n</ul>\n<h4 id=\"注意项\"><a href=\"#注意项\" class=\"headerlink\" title=\"注意项\"></a>注意项</h4><ul>\n<li>每一个都要求后面跟一个反斜杠转义第一个行尾,text必须从下一行开始</li>\n<li>text内容如果是多行,则行末要加反斜线,最后一行不需要</li>\n<li>如果更改存在于组命令中,且是个范围，则会存在每一行都替换,而不是范围替换一次</li>\n<li>插入与追加的文本内容不受命令影响,也不影响行计数器</li>\n<li>更改命令则与删除命令类似,接下来的脚本不会作用，会立刻读入新行</li>\n</ul>\n<h3 id=\"读和写命令\"><a href=\"#读和写命令\" class=\"headerlink\" title=\"读和写命令\"></a>读和写命令</h3><ul>\n<li><code>[line-address]r file</code>读入某个文件的内容,追加到模式空间后</li>\n<li><code>[address]w file</code>把模式空间内容写到某个文件</li>\n</ul>\n<h4 id=\"注意项-1\"><a href=\"#注意项-1\" class=\"headerlink\" title=\"注意项\"></a>注意项</h4><ul>\n<li>文件不存在不会报错</li>\n<li>如果一个脚本中有多个指令写到同一个文件,那么每个写命令都将追加到这个文件</li>\n<li>读的内容不受之后命令影响</li>\n<li>sed最多打开10个文件</li>\n</ul>\n<h3 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h3><ul>\n<li>列表<code>[addess]l</code>:不仅显示内容,非打印字符显示为两个数字的ASCLL代码</li>\n<li><code>[line-address]=</code>:不打印内容,但打印行号</li>\n<li><code>[address]n</code>:输出模式空间内容(没抑制输出的话),读取输入的下一行,并且后续命令用于新行,之前的命令不会用于新行</li>\n<li><code>[line-address]q</code>:停止读入新行，退出脚本,经常用来打印前几行</li>\n<li>转换<code>[address]y/abc/xyz/</code>(类似于tr),有用的例子转换大小写y&#x2F;abcdefghijklmnopqrstuvwxyz&#x2F;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x2F;</li>\n</ul>\n<h3 id=\"反斜线圆括号用法\"><a href=\"#反斜线圆括号用法\" class=\"headerlink\" title=\"反斜线圆括号用法\"></a>反斜线圆括号用法</h3><p><code>s/\\([0-9]\\)-\\([0-9]\\)/\\2-\\1/g</code>指交换斜杠前后的两个数字</p>\n<h3 id=\"多行模式N\"><a href=\"#多行模式N\" class=\"headerlink\" title=\"多行模式N\"></a>多行模式N</h3><p>多行模式空间:多行Next(N)命令通过读取新的输入行,并将它添加到模式空间的现有内容来创建多行模式空间。模式空间最初的内容和新的输入行之间用换行符分隔。在模式空间中嵌入的换行符可以用转义序列”\\n”来匹配。在多行模式空间中,元字符”^”匹配空间中的第一个字条,而不匹配换行符后面的字符。同样,”$”只匹配模式空间中最后的换行符,而不匹配任何嵌入的换行符。在执行Next命令之后,控制将被传递给脚本中的后续命令。<br>这与next不同，next不创建多行模式，它输出内容，然后，读取新的行。<br>举例:例如要将”Owner and Operator Guide”换成”Installation Guide”,对于处于不同行的情况可以这样做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/Operator$/&#123;<br>N<br>s/Owner and Operator\\nGuide/Installation Guide/<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面比较不普遍,更普遍做法是:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">s/Owner and Operator Guide/Installtion Guide/<br>/Owner/&#123;<br>N<br>s/ *\\n/ /<br>s/Owner and Operator Guide */Installation Guide\\<br>/<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"多行模式D\"><a href=\"#多行模式D\" class=\"headerlink\" title=\"多行模式D\"></a>多行模式D</h3><p>删除命令(d)删除模式空间的内容并导致读入新的输入行,从而在脚本的顶端重新使用编辑方法。删除命令(D)稍微有些不同:它删除模式空间中直到第一个嵌入的换行符的这部分内容。他不会导致读入新的输入行,相反,<strong>它返回到脚本的顶端</strong>,将这些指令应用于模式空间的剩余内容。<br>例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/^ $/&#123;<br>N<br>/^ \\n$/D<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上可以删除连续多个空行,只保留一个空行</p>\n<h3 id=\"多行模式P\"><a href=\"#多行模式P\" class=\"headerlink\" title=\"多行模式P\"></a>多行模式P</h3><p>该命令输出多行模式空间的第一部分，直到第一个嵌入的换行符为止。<br>P命令经常出现在Next命令之后和Delete命令之前，建立一个输入&#x2F;输出循环，用来维护两行的模式空间，这样就能之输出第一行，然后返回到脚本的顶端，用于第二行。</p>\n<h3 id=\"保持空间\"><a href=\"#保持空间\" class=\"headerlink\" title=\"保持空间\"></a>保持空间</h3><p>保持空间:当改变模式空间中的原始内容时,用于保留当前输入行的副本。影响模式空间的命令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">命令</th>\n<th align=\"center\">缩写</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Hold</td>\n<td align=\"center\">h或H</td>\n<td align=\"center\">将模式空间的内容复制或追加到保持空间(大写追加)</td>\n</tr>\n<tr>\n<td align=\"center\">Get</td>\n<td align=\"center\">g或G</td>\n<td align=\"center\">将保持空间的内容复制或追加到模式空间(大写追加)</td>\n</tr>\n<tr>\n<td align=\"center\">Exchange</td>\n<td align=\"center\">x</td>\n<td align=\"center\">交换保持空间和模式空间的内容</td>\n</tr>\n</tbody></table>\n<h3 id=\"高级的流控制命令\"><a href=\"#高级的流控制命令\" class=\"headerlink\" title=\"高级的流控制命令\"></a>高级的流控制命令</h3><ul>\n<li>分支:在脚本中将控制转移到另一行<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:top<br>command1<br>command2<br>/pattern/b top<br>command3<br></code></pre></td></tr></table></figure>\n如果没有定义top或没有标签(可以为任意命名),则将跳转到脚本末尾,上面例子意思是如果找不到pattern,才执行commmand3<br><strong>注意</strong>不要在标签后加空格</li>\n<li>测试:如果当前匹配行上成功进行了替换,那么test命令就会转到标签处,用法和分支一样,把b改成t即可<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/sth/&#123;<br>s/a/b/<br>t<br>s/c/b/<br>t<br>s/d/b/<br>&#125;<br></code></pre></td></tr></table></figure>\n一旦一个替换被执行，控制就到脚本末尾</li>\n</ul>\n<h3 id=\"一些例子\"><a href=\"#一些例子\" class=\"headerlink\" title=\"一些例子\"></a>一些例子</h3><ul>\n<li><code>sed &#39;52q;d&#39; file</code>打印52行，效率高</li>\n<li><code>cat jane.txt | tr &#39;[A-Z]&#39; &#39;[a-z]&#39; | tr &#39;;.?\\047,():&quot;-&#39; &#39; &#39;|tr &#39; &#39; &#39;\\012&#39; | grep -v &#39;^ *$&#39; | sort | uniq -c | sort -n</code>:统计单词数,首先大写替换为小写，然后替换标点为空格,再替换空格为换行,去空行,排序，计数，再排序。</li>\n<li><code>sed &#39;G&#39; file</code>在每行后添加个空行</li>\n<li><code>sed -n &quot;$!N;/^(.*)n1$/!P;D&#39; test.txt</code>删除文件中连续且重复的行</li>\n<li><code>sed &#39;/^$/d;G&#39;</code>保证每一行后都有个空行，会删除连续空行，并添加空行</li>\n<li><code>sed &#39;n;d&#39; test.txt</code>删除偶数行</li>\n<li><code>sed &#39;/regex/&#123;x;p;x&#125;&#39; test.txt</code>匹配regex之前添加空行</li>\n<li><code>sed &#39;/regex/G&#39; test.txt</code>匹配regex之后添加空行</li>\n<li><code>sed &#39;/regex/&#123;x;p;x;G;&#125;&#39; test.txt</code>之前之后都添加空行</li>\n<li><code>sed &#39;n;n;n;n;G&#39;</code>每5行添加一个空行或<code>sed &#39;0~5G&#39; text.txt</code></li>\n<li><code>sed &#39;=&#39; test.txt | sed &#39;N;s/s*ns*/t/&#39;</code>给每一行添加行号，以制表符分隔</li>\n<li><code>sed &#39;/./=&#39; test.txt | sed &#39;/./N; s/s*ns*/t/&#39;</code>为非空行添加行号</li>\n<li><code>sed -n &#39;$=&#39; test.txt</code>统计行数</li>\n<li><code>sed &#39;s/^[[:blank:]]*|[[:blank:]]*$//&#39; test.txt</code>删除行首和行尾空白</li>\n<li><code>sed &#39;1!G;h;$!d&#39; test.txt</code>反转每一行的顺序(类似tac)</li>\n<li><code>sed &#39;/n/!G;s/(.)(.*n)/&amp;21/;//D;s/.//&#39;</code>反转每一行的字母顺序(类似rev)</li>\n<li><code>sed -e &#39;:a&#39; -e &#39;s/([0-9])([0-9]&#123;3&#125;)($|,)/1,2/;ta&#39; test.txt</code>给数字串加逗号或<code>sed -e &#39;:a&#39; -e &#39;s/(.*[0-9])([0-9]&#123;3&#125;)/1,2/;ta&#39; test.txt</code></li>\n<li><code>sed &#39;q&#39; test.txt</code>打印文件第一行</li>\n<li><code>sed -n &#39;N;P&#39; file</code>打印奇数行</li>\n<li><code>sed -n &#39;/regex/&#123;n;p&#125;&#39; test.txt</code> 打印匹配那一行的后一行</li>\n<li><code>sed -n &#39;/regex/&#123;=;x;1!p;g;$!N;p;D;&#125;; h&#39; test.txt</code>  打印匹配“regex”那一行的前后一行，并且打印匹配行的行号(类似grep -A1 -B1)</li>\n<li><code>sed -n &#39;/^.&#123;65&#125;/p&#39; test.txt</code>打印长于65个字符的行</li>\n<li><code>sed &#39;/^$/N;/n$/D&#39; test.txt</code>压缩连续空行(类似于cat -s)</li>\n<li><code>sed &#39;/./,$!d&#39;</code>删除文件开头的空行</li>\n<li><code>sed &#39;:a;/^n*$/&#123;$d;N;ba&#125;&#39; test.txt</code>删除文件结尾空行</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"sed作用原理\"><a href=\"#sed作用原理\" class=\"headerlink\" title=\"sed作用原理\"></a>sed作用原理</h3><p>sed首先将整个编辑脚本应用于第一个输入行(存在模式空间)，然后再读取第二个输入行。sed总是处理原始行的最新形式，所以生成的任何编辑动作都会作用于后续命令。</p>\n<h3 id=\"sed选项总结\"><a href=\"#sed选项总结\" class=\"headerlink\" title=\"sed选项总结\"></a>sed选项总结</h3><table>\n<thead>\n<tr>\n<th align=\"center\">options</th>\n<th align=\"center\">describe</th>\n<th align=\"center\">example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">编辑随后的指令</td>\n<td align=\"center\"><code>sed -e &#39;s/brown/green/;s/dog/cat/&#39; data.txt</code></td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">跟随脚本中的文件名</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">阻止输入行的自动输出</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">支持扩展的正则表达式</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">直接修改读取的文件内容,而不是由屏幕输出</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"在命令行上指定多重命令\"><a href=\"#在命令行上指定多重命令\" class=\"headerlink\" title=\"在命令行上指定多重命令\"></a>在命令行上指定多重命令</h3><ul>\n<li><code>sed &#39;s/MA/ma/; s/FA/fa/&#39; file</code></li>\n<li><code>sed -e &#39;/MA/ma/&#39; -e &#39;s/FA/fa/&#39; file</code></li>\n<li>bash等通用,输入单引号后回车,会出现<code>&gt;</code>多行输入提示符<br>sed为流编辑器,一次读取一行内容,并执行相应的命令,格式如下:<br><code>sed [options] &#39;[command]&#39; (file)</code></li>\n</ul>\n<h3 id=\"sed地址表示方法\"><a href=\"#sed地址表示方法\" class=\"headerlink\" title=\"sed地址表示方法\"></a>sed地址表示方法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">地址</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">n</td>\n<td align=\"center\">行号,n是一个正整数</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"center\">最后一行</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;regexp&#x2F;</td>\n<td align=\"center\">正则表达式匹配行</td>\n</tr>\n<tr>\n<td align=\"center\">addr1,addr2</td>\n<td align=\"center\">从addr1到addr2范围内的文本行,包含地址addr2在内,地址是上述任意的地址形式</td>\n</tr>\n<tr>\n<td align=\"center\">first~step</td>\n<td align=\"center\">匹配由数字first代表的文本行,然后随后的每个在step间隔处的文本行。例如1~2代表奇数行</td>\n</tr>\n<tr>\n<td align=\"center\">addr1,+n</td>\n<td align=\"center\">匹配地址addr1和随后的n个文本行</td>\n</tr>\n<tr>\n<td align=\"center\">addr!</td>\n<td align=\"center\">匹配所有文本行,除了addr之外,addr是上述任意的地址形式</td>\n</tr>\n</tbody></table>\n<h3 id=\"分组命令\"><a href=\"#分组命令\" class=\"headerlink\" title=\"分组命令\"></a>分组命令</h3><p>sed使用大括号<code>&#123;&#125;</code>将一个地址嵌套在另一个地址上，或在相同的地址上应用多个命令，左大括号必须在行末，右大括号独占一行，之后必须没空格<br><strong>例1：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">1,5&#123;<br>/^$/d<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>例2：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">1,5&#123;<br>/^$/d<br>s/a/b/<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"替换s\"><a href=\"#替换s\" class=\"headerlink\" title=\"替换s\"></a>替换s</h3><p><code>[address]s/pattern/replacement/flags</code></p>\n<h4 id=\"替换的标志位\"><a href=\"#替换的标志位\" class=\"headerlink\" title=\"替换的标志位\"></a>替换的标志位</h4><table>\n<thead>\n<tr>\n<th align=\"center\">flag</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">n</td>\n<td align=\"center\">1到512之间的一个数字,表示对文本模式中指定模式第n次出现的情况进行替换</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td align=\"center\">对模式空间的所有出现的情况进行全局更改</td>\n</tr>\n<tr>\n<td align=\"center\">p</td>\n<td align=\"center\">打印模式空间的内容,可以加感叹号，表示不打印</td>\n</tr>\n<tr>\n<td align=\"center\">W <file></td>\n<td align=\"center\">将模式空间的内容写到文件file中</td>\n</tr>\n</tbody></table>\n<h4 id=\"替换部分的元字符\"><a href=\"#替换部分的元字符\" class=\"headerlink\" title=\"替换部分的元字符\"></a>替换部分的元字符</h4><ul>\n<li><code>&amp;</code>:表示命中的正则表达式</li>\n<li><code>\\</code>:后面可接回车,其他元字符转义</li>\n<li><code>\\&lt;n&gt;</code>:表示匹配的部分,在pattern中用<code>\\(</code>和<code>\\)</code>括起来</li>\n</ul>\n<h4 id=\"界定符\"><a href=\"#界定符\" class=\"headerlink\" title=\"界定符\"></a>界定符</h4><ul>\n<li>如果模式中含有’&#x2F;‘可以用感叹号作定界符,如<code>s!/usr/mail!/usr2/mail!</code></li>\n<li>注意地址的界定符不能这么玩</li>\n</ul>\n<h3 id=\"删除d\"><a href=\"#删除d\" class=\"headerlink\" title=\"删除d\"></a>删除d</h3><p>匹配到这个地址就删除模式空间内容,并且会导致不再执行接下来的脚本，读取新的行。</p>\n<h3 id=\"a、i、c\"><a href=\"#a、i、c\" class=\"headerlink\" title=\"a、i、c\"></a>a、i、c</h3><ul>\n<li>追加<code>[line-address(单行)]a\\   \\&lt;text\\&gt;</code><br>加入模式空间内容之后</li>\n<li>插入<code>[line-address(单行)]i\\   \\&lt;text\\&gt;</code><br>插入模式空间内容之前</li>\n<li>更改<code>[address(可以是范围)]c\\   \\&lt;text\\&gt;</code><br>替换模式空间(范围的话,替换范围内的内容)的内容</li>\n</ul>\n<h4 id=\"注意项\"><a href=\"#注意项\" class=\"headerlink\" title=\"注意项\"></a>注意项</h4><ul>\n<li>每一个都要求后面跟一个反斜杠转义第一个行尾,text必须从下一行开始</li>\n<li>text内容如果是多行,则行末要加反斜线,最后一行不需要</li>\n<li>如果更改存在于组命令中,且是个范围，则会存在每一行都替换,而不是范围替换一次</li>\n<li>插入与追加的文本内容不受命令影响,也不影响行计数器</li>\n<li>更改命令则与删除命令类似,接下来的脚本不会作用，会立刻读入新行</li>\n</ul>\n<h3 id=\"读和写命令\"><a href=\"#读和写命令\" class=\"headerlink\" title=\"读和写命令\"></a>读和写命令</h3><ul>\n<li><code>[line-address]r file</code>读入某个文件的内容,追加到模式空间后</li>\n<li><code>[address]w file</code>把模式空间内容写到某个文件</li>\n</ul>\n<h4 id=\"注意项-1\"><a href=\"#注意项-1\" class=\"headerlink\" title=\"注意项\"></a>注意项</h4><ul>\n<li>文件不存在不会报错</li>\n<li>如果一个脚本中有多个指令写到同一个文件,那么每个写命令都将追加到这个文件</li>\n<li>读的内容不受之后命令影响</li>\n<li>sed最多打开10个文件</li>\n</ul>\n<h3 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h3><ul>\n<li>列表<code>[addess]l</code>:不仅显示内容,非打印字符显示为两个数字的ASCLL代码</li>\n<li><code>[line-address]=</code>:不打印内容,但打印行号</li>\n<li><code>[address]n</code>:输出模式空间内容(没抑制输出的话),读取输入的下一行,并且后续命令用于新行,之前的命令不会用于新行</li>\n<li><code>[line-address]q</code>:停止读入新行，退出脚本,经常用来打印前几行</li>\n<li>转换<code>[address]y/abc/xyz/</code>(类似于tr),有用的例子转换大小写y&#x2F;abcdefghijklmnopqrstuvwxyz&#x2F;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x2F;</li>\n</ul>\n<h3 id=\"反斜线圆括号用法\"><a href=\"#反斜线圆括号用法\" class=\"headerlink\" title=\"反斜线圆括号用法\"></a>反斜线圆括号用法</h3><p><code>s/\\([0-9]\\)-\\([0-9]\\)/\\2-\\1/g</code>指交换斜杠前后的两个数字</p>\n<h3 id=\"多行模式N\"><a href=\"#多行模式N\" class=\"headerlink\" title=\"多行模式N\"></a>多行模式N</h3><p>多行模式空间:多行Next(N)命令通过读取新的输入行,并将它添加到模式空间的现有内容来创建多行模式空间。模式空间最初的内容和新的输入行之间用换行符分隔。在模式空间中嵌入的换行符可以用转义序列”\\n”来匹配。在多行模式空间中,元字符”^”匹配空间中的第一个字条,而不匹配换行符后面的字符。同样,”$”只匹配模式空间中最后的换行符,而不匹配任何嵌入的换行符。在执行Next命令之后,控制将被传递给脚本中的后续命令。<br>这与next不同，next不创建多行模式，它输出内容，然后，读取新的行。<br>举例:例如要将”Owner and Operator Guide”换成”Installation Guide”,对于处于不同行的情况可以这样做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/Operator$/&#123;<br>N<br>s/Owner and Operator\\nGuide/Installation Guide/<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面比较不普遍,更普遍做法是:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">s/Owner and Operator Guide/Installtion Guide/<br>/Owner/&#123;<br>N<br>s/ *\\n/ /<br>s/Owner and Operator Guide */Installation Guide\\<br>/<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"多行模式D\"><a href=\"#多行模式D\" class=\"headerlink\" title=\"多行模式D\"></a>多行模式D</h3><p>删除命令(d)删除模式空间的内容并导致读入新的输入行,从而在脚本的顶端重新使用编辑方法。删除命令(D)稍微有些不同:它删除模式空间中直到第一个嵌入的换行符的这部分内容。他不会导致读入新的输入行,相反,<strong>它返回到脚本的顶端</strong>,将这些指令应用于模式空间的剩余内容。<br>例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/^ $/&#123;<br>N<br>/^ \\n$/D<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上可以删除连续多个空行,只保留一个空行</p>\n<h3 id=\"多行模式P\"><a href=\"#多行模式P\" class=\"headerlink\" title=\"多行模式P\"></a>多行模式P</h3><p>该命令输出多行模式空间的第一部分，直到第一个嵌入的换行符为止。<br>P命令经常出现在Next命令之后和Delete命令之前，建立一个输入&#x2F;输出循环，用来维护两行的模式空间，这样就能之输出第一行，然后返回到脚本的顶端，用于第二行。</p>\n<h3 id=\"保持空间\"><a href=\"#保持空间\" class=\"headerlink\" title=\"保持空间\"></a>保持空间</h3><p>保持空间:当改变模式空间中的原始内容时,用于保留当前输入行的副本。影响模式空间的命令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">命令</th>\n<th align=\"center\">缩写</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Hold</td>\n<td align=\"center\">h或H</td>\n<td align=\"center\">将模式空间的内容复制或追加到保持空间(大写追加)</td>\n</tr>\n<tr>\n<td align=\"center\">Get</td>\n<td align=\"center\">g或G</td>\n<td align=\"center\">将保持空间的内容复制或追加到模式空间(大写追加)</td>\n</tr>\n<tr>\n<td align=\"center\">Exchange</td>\n<td align=\"center\">x</td>\n<td align=\"center\">交换保持空间和模式空间的内容</td>\n</tr>\n</tbody></table>\n<h3 id=\"高级的流控制命令\"><a href=\"#高级的流控制命令\" class=\"headerlink\" title=\"高级的流控制命令\"></a>高级的流控制命令</h3><ul>\n<li>分支:在脚本中将控制转移到另一行<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:top<br>command1<br>command2<br>/pattern/b top<br>command3<br></code></pre></td></tr></table></figure>\n如果没有定义top或没有标签(可以为任意命名),则将跳转到脚本末尾,上面例子意思是如果找不到pattern,才执行commmand3<br><strong>注意</strong>不要在标签后加空格</li>\n<li>测试:如果当前匹配行上成功进行了替换,那么test命令就会转到标签处,用法和分支一样,把b改成t即可<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/sth/&#123;<br>s/a/b/<br>t<br>s/c/b/<br>t<br>s/d/b/<br>&#125;<br></code></pre></td></tr></table></figure>\n一旦一个替换被执行，控制就到脚本末尾</li>\n</ul>\n<h3 id=\"一些例子\"><a href=\"#一些例子\" class=\"headerlink\" title=\"一些例子\"></a>一些例子</h3><ul>\n<li><code>sed &#39;52q;d&#39; file</code>打印52行，效率高</li>\n<li><code>cat jane.txt | tr &#39;[A-Z]&#39; &#39;[a-z]&#39; | tr &#39;;.?\\047,():&quot;-&#39; &#39; &#39;|tr &#39; &#39; &#39;\\012&#39; | grep -v &#39;^ *$&#39; | sort | uniq -c | sort -n</code>:统计单词数,首先大写替换为小写，然后替换标点为空格,再替换空格为换行,去空行,排序，计数，再排序。</li>\n<li><code>sed &#39;G&#39; file</code>在每行后添加个空行</li>\n<li><code>sed -n &quot;$!N;/^(.*)n1$/!P;D&#39; test.txt</code>删除文件中连续且重复的行</li>\n<li><code>sed &#39;/^$/d;G&#39;</code>保证每一行后都有个空行，会删除连续空行，并添加空行</li>\n<li><code>sed &#39;n;d&#39; test.txt</code>删除偶数行</li>\n<li><code>sed &#39;/regex/&#123;x;p;x&#125;&#39; test.txt</code>匹配regex之前添加空行</li>\n<li><code>sed &#39;/regex/G&#39; test.txt</code>匹配regex之后添加空行</li>\n<li><code>sed &#39;/regex/&#123;x;p;x;G;&#125;&#39; test.txt</code>之前之后都添加空行</li>\n<li><code>sed &#39;n;n;n;n;G&#39;</code>每5行添加一个空行或<code>sed &#39;0~5G&#39; text.txt</code></li>\n<li><code>sed &#39;=&#39; test.txt | sed &#39;N;s/s*ns*/t/&#39;</code>给每一行添加行号，以制表符分隔</li>\n<li><code>sed &#39;/./=&#39; test.txt | sed &#39;/./N; s/s*ns*/t/&#39;</code>为非空行添加行号</li>\n<li><code>sed -n &#39;$=&#39; test.txt</code>统计行数</li>\n<li><code>sed &#39;s/^[[:blank:]]*|[[:blank:]]*$//&#39; test.txt</code>删除行首和行尾空白</li>\n<li><code>sed &#39;1!G;h;$!d&#39; test.txt</code>反转每一行的顺序(类似tac)</li>\n<li><code>sed &#39;/n/!G;s/(.)(.*n)/&amp;21/;//D;s/.//&#39;</code>反转每一行的字母顺序(类似rev)</li>\n<li><code>sed -e &#39;:a&#39; -e &#39;s/([0-9])([0-9]&#123;3&#125;)($|,)/1,2/;ta&#39; test.txt</code>给数字串加逗号或<code>sed -e &#39;:a&#39; -e &#39;s/(.*[0-9])([0-9]&#123;3&#125;)/1,2/;ta&#39; test.txt</code></li>\n<li><code>sed &#39;q&#39; test.txt</code>打印文件第一行</li>\n<li><code>sed -n &#39;N;P&#39; file</code>打印奇数行</li>\n<li><code>sed -n &#39;/regex/&#123;n;p&#125;&#39; test.txt</code> 打印匹配那一行的后一行</li>\n<li><code>sed -n &#39;/regex/&#123;=;x;1!p;g;$!N;p;D;&#125;; h&#39; test.txt</code>  打印匹配“regex”那一行的前后一行，并且打印匹配行的行号(类似grep -A1 -B1)</li>\n<li><code>sed -n &#39;/^.&#123;65&#125;/p&#39; test.txt</code>打印长于65个字符的行</li>\n<li><code>sed &#39;/^$/N;/n$/D&#39; test.txt</code>压缩连续空行(类似于cat -s)</li>\n<li><code>sed &#39;/./,$!d&#39;</code>删除文件开头的空行</li>\n<li><code>sed &#39;:a;/^n*$/&#123;$d;N;ba&#125;&#39; test.txt</code>删除文件结尾空行</li>\n</ul>\n"},{"title":"shell例子","date":"2019-07-20T09:04:05.000Z","subtitle":null,"index_img":"/images/shell_example.jpg","banner_img":"/images/shell_example.jpg","_content":"* 追加信息于文件\n`cat - >> filename`\n* 赋值日期命令\n`eval $(date '+weekday=\"%a\" month=\"%b\" day=\"%e\" year=\"%G\"')`\n* 判断是否符合正则表达式\n`expr string : pattern`\n- 追加内容到文件\necho的-n选项不会在添加内容前加换行符\n- 读取文件首行赋给变量\n`read -r line < file`,-r选项保证读入的内容是原始内容，反斜杠不会发生转义，read命令会删除开头和结尾的`IFS`中的所有字符，如果想保留，把`IFS`置为空:`IFS= read -r line < file`\n- 依次读入文件每一行\n```bash\nwhile IFS= read -r line; do\n    # do something with $line\ndone < file\n```\n- 随机读取一行内容\n`read -r random_line < <(shuf file)`\n- 读取文件首行前三个字段\n```bash\nwhile read -r field1 field2 field3 _; do\n    # do something with $field1, $field2, and $field3\ndone < file\n```\n`_`用来接受三个字段后的所有内容，如果没有他，field3会接受所有\n- 从文件路径中获取文件名\n`filename=${path##*/}`,这其实就是参数展开\n- 从文件路径中获取目录名\n`dirname=${path%/*}`\n- 相同路径下的快速拷贝/移动写法\n`cp /path/to/file{,_copy}`\n- 生成a到z字母表\n  - `echo {a..z}`\n  - `printf \"%c\" {a..z}`,字母间不含空格\n  - `printf \"%c\" {a..z} $'\\n'`结尾加空行\n  - `printf \"%c\\n\" {a..z}`每个字符后加个空行\n- 生成00-09数字\n  - `printf \"%02d\" {0..9}`\n  - `echo {00..09}`bash4以上支持\n- 生成若干单词\n`echo {w,t,}h{e{n{,ce{,forth}},re{,in,fore,with{,al}}},ither,at}`\n- 重复输出10次字符串\n`echo foo{,,,,,,,,,}`\n- 分割字符串\n  - `IFS=- read -r x y z <<< \"$str\"`\n  - `IFS=- read -ra parts <<< \"foo-bar-baz\"`保存到数组\n- 逐个字符处理字符串\n```bash\nwhile IFS= read -rn1 c; do\n    # do something with $c\ndone <<< \"$str\"\n```\n-n1表示一次读一个字符\n- 获取一个字符的ascll\n`printf '%02x' \"+\"`\n- 获取最后一个参数\n`echo ${@: -1}`或`echo ${!#}`\n- 遍历参数\n`for arg in \"$@\"`等价于`for arg`\n- 路径中含空格：\n  - 非递归：\n```bash\nfor i in *.mp3;\ndo\n\techo \"$i\"\ndone\n```\n  - 递归：\n```bash\nOLDIFS=\"$IFS\"\nfilelist=$(find -name '*.mp3' -print0|xargs --null ls)&&IFS=$'\\n'\nfor i in $filelist;\ndo\n\tIFS=\"$OLDIFS\"\n\techo \"$i\"\ndone\n```\n**注意，IFS必须单引号，filelist的变量是必须的,不能写在for后面,要即时还原IFS**\n## 函数特殊用法\n- 测试文件是否存在函数\n`function fileExists() [[ -f $1 ]]`\n- 测试是否及偶数\n`function isEven() (( $1 % 2 == 0 ))`\n- 使用小括号\n会fork个子进程，对环境的修改不会印象外面，不需要恢复现场\n```bash\nfunction name() ( \n... \n)\n```\n## 文件描述符与重定向\nbash启动时，文件描述符表如下所示：\n![](/images/file_descriptor.png)\n当bash执行命令时，他会fork一个子进程，它会继承父进程的描述符表\n### 重定向命令到stdout\n- `command >file`到底发生了啥？\n`>`是输出重定向操作符，bash首先打开文件准备写入，如果文件打开成功，command的stdout指向打开的文件，如果失败，不执行命令，其实等价于`command 1 >file`\n### 重定向命令到stderr\n`command 2>file`\n### 重定向命令stdout和stderr到同一个文件\n`command &>file`等价于`command >file 2>&1`\n当只有一个重定向时，重定向位置可以任意放，甚至可以在命令的前面，但注意遇到多个重定向操作时,顺序很重要，会从左到右依次处理:  \n首先`>file`会发生如下：\n![](/images/file_descriptor1.png)\n然后`2>&1`会发生如下：\n![](/images/file_descriptor2.png)\n如果顺序错了，为节省流量,你自己想会发生啥吧\n### 重定向stdin\n`command <file`Bash 在执行命令之前，打开文件file准备读入。如果打开文件出错，Bash 会直接返错，不会继续执行命令。相反如果打开成功，Bash 会使用打开的文件的文件描述符作为命令的标准输入\n### 重定向一堆字符到stdin\n这是最常见的here document语法`<<MARKER`,当bash遇到该操作符时，会从标输入读取每一行，直到遇到`MARKER`,例子：\n```bash\nsed 's|http://||' <<EOF\nhttp://url1.com\nhttp://url2.com\nhttp://url3.com\nEOF\n```\n```bash\nwhile read line2; do\n    let b++\n    echo ??$line2??\ndone << EOF\n`grep -v 1 /tmp/test.txt`\nEOF\n```\n如果MARKER用引号括起来，那么变量是不会展开的：\n```bash\ncat<<\"EOF\"\nhello, $USER #USER不会展开\nEOF\n```\n### exec\n见另一篇\n### 通过bash访问web站点\n```bash\nexec 3<>/dev/tcp/www.google.com/80\necho -e \"GET / HTTP/1.1\\n\\n\" >&3\ncat <&3\n```\nBash 将/dev/tcp/host/port当作一种特殊的文件(套接字文件？)，它并不需要实际存在于系统中，这种类型的特殊文件是给 Bash 建立 tcp 连接用的。\n### 重定向进程的stdout和stderr到另外一个进程的输入\n`command1 |& command2`等价于`command1 2>&1|command2`\n### 交换标准输出与标准错误\n`command 3>&1 1>&2 2>&3`\n### 重定向标准输出与错误给不同进程\n主要就是使用进程替换\n`command > >(stdout_cmd) 2> >(stderr_cmd)`\n### 获取管道流中的所有命令执行退出码\n```bash\necho 'pants are cool' | grep 'moo' | sed 's/o/x/' | awk '{ print $1 }'\necho ${PIPESTATUS[@]}\n```\n","source":"_posts/shell例子.md","raw":"---\ntitle: shell例子\ndate: 2019-07-20 17:04:05\nsubtitle:\ncategories: Linux\ntags:\nindex_img: /images/shell_example.jpg\nbanner_img: /images/shell_example.jpg\n---\n* 追加信息于文件\n`cat - >> filename`\n* 赋值日期命令\n`eval $(date '+weekday=\"%a\" month=\"%b\" day=\"%e\" year=\"%G\"')`\n* 判断是否符合正则表达式\n`expr string : pattern`\n- 追加内容到文件\necho的-n选项不会在添加内容前加换行符\n- 读取文件首行赋给变量\n`read -r line < file`,-r选项保证读入的内容是原始内容，反斜杠不会发生转义，read命令会删除开头和结尾的`IFS`中的所有字符，如果想保留，把`IFS`置为空:`IFS= read -r line < file`\n- 依次读入文件每一行\n```bash\nwhile IFS= read -r line; do\n    # do something with $line\ndone < file\n```\n- 随机读取一行内容\n`read -r random_line < <(shuf file)`\n- 读取文件首行前三个字段\n```bash\nwhile read -r field1 field2 field3 _; do\n    # do something with $field1, $field2, and $field3\ndone < file\n```\n`_`用来接受三个字段后的所有内容，如果没有他，field3会接受所有\n- 从文件路径中获取文件名\n`filename=${path##*/}`,这其实就是参数展开\n- 从文件路径中获取目录名\n`dirname=${path%/*}`\n- 相同路径下的快速拷贝/移动写法\n`cp /path/to/file{,_copy}`\n- 生成a到z字母表\n  - `echo {a..z}`\n  - `printf \"%c\" {a..z}`,字母间不含空格\n  - `printf \"%c\" {a..z} $'\\n'`结尾加空行\n  - `printf \"%c\\n\" {a..z}`每个字符后加个空行\n- 生成00-09数字\n  - `printf \"%02d\" {0..9}`\n  - `echo {00..09}`bash4以上支持\n- 生成若干单词\n`echo {w,t,}h{e{n{,ce{,forth}},re{,in,fore,with{,al}}},ither,at}`\n- 重复输出10次字符串\n`echo foo{,,,,,,,,,}`\n- 分割字符串\n  - `IFS=- read -r x y z <<< \"$str\"`\n  - `IFS=- read -ra parts <<< \"foo-bar-baz\"`保存到数组\n- 逐个字符处理字符串\n```bash\nwhile IFS= read -rn1 c; do\n    # do something with $c\ndone <<< \"$str\"\n```\n-n1表示一次读一个字符\n- 获取一个字符的ascll\n`printf '%02x' \"+\"`\n- 获取最后一个参数\n`echo ${@: -1}`或`echo ${!#}`\n- 遍历参数\n`for arg in \"$@\"`等价于`for arg`\n- 路径中含空格：\n  - 非递归：\n```bash\nfor i in *.mp3;\ndo\n\techo \"$i\"\ndone\n```\n  - 递归：\n```bash\nOLDIFS=\"$IFS\"\nfilelist=$(find -name '*.mp3' -print0|xargs --null ls)&&IFS=$'\\n'\nfor i in $filelist;\ndo\n\tIFS=\"$OLDIFS\"\n\techo \"$i\"\ndone\n```\n**注意，IFS必须单引号，filelist的变量是必须的,不能写在for后面,要即时还原IFS**\n## 函数特殊用法\n- 测试文件是否存在函数\n`function fileExists() [[ -f $1 ]]`\n- 测试是否及偶数\n`function isEven() (( $1 % 2 == 0 ))`\n- 使用小括号\n会fork个子进程，对环境的修改不会印象外面，不需要恢复现场\n```bash\nfunction name() ( \n... \n)\n```\n## 文件描述符与重定向\nbash启动时，文件描述符表如下所示：\n![](/images/file_descriptor.png)\n当bash执行命令时，他会fork一个子进程，它会继承父进程的描述符表\n### 重定向命令到stdout\n- `command >file`到底发生了啥？\n`>`是输出重定向操作符，bash首先打开文件准备写入，如果文件打开成功，command的stdout指向打开的文件，如果失败，不执行命令，其实等价于`command 1 >file`\n### 重定向命令到stderr\n`command 2>file`\n### 重定向命令stdout和stderr到同一个文件\n`command &>file`等价于`command >file 2>&1`\n当只有一个重定向时，重定向位置可以任意放，甚至可以在命令的前面，但注意遇到多个重定向操作时,顺序很重要，会从左到右依次处理:  \n首先`>file`会发生如下：\n![](/images/file_descriptor1.png)\n然后`2>&1`会发生如下：\n![](/images/file_descriptor2.png)\n如果顺序错了，为节省流量,你自己想会发生啥吧\n### 重定向stdin\n`command <file`Bash 在执行命令之前，打开文件file准备读入。如果打开文件出错，Bash 会直接返错，不会继续执行命令。相反如果打开成功，Bash 会使用打开的文件的文件描述符作为命令的标准输入\n### 重定向一堆字符到stdin\n这是最常见的here document语法`<<MARKER`,当bash遇到该操作符时，会从标输入读取每一行，直到遇到`MARKER`,例子：\n```bash\nsed 's|http://||' <<EOF\nhttp://url1.com\nhttp://url2.com\nhttp://url3.com\nEOF\n```\n```bash\nwhile read line2; do\n    let b++\n    echo ??$line2??\ndone << EOF\n`grep -v 1 /tmp/test.txt`\nEOF\n```\n如果MARKER用引号括起来，那么变量是不会展开的：\n```bash\ncat<<\"EOF\"\nhello, $USER #USER不会展开\nEOF\n```\n### exec\n见另一篇\n### 通过bash访问web站点\n```bash\nexec 3<>/dev/tcp/www.google.com/80\necho -e \"GET / HTTP/1.1\\n\\n\" >&3\ncat <&3\n```\nBash 将/dev/tcp/host/port当作一种特殊的文件(套接字文件？)，它并不需要实际存在于系统中，这种类型的特殊文件是给 Bash 建立 tcp 连接用的。\n### 重定向进程的stdout和stderr到另外一个进程的输入\n`command1 |& command2`等价于`command1 2>&1|command2`\n### 交换标准输出与标准错误\n`command 3>&1 1>&2 2>&3`\n### 重定向标准输出与错误给不同进程\n主要就是使用进程替换\n`command > >(stdout_cmd) 2> >(stderr_cmd)`\n### 获取管道流中的所有命令执行退出码\n```bash\necho 'pants are cool' | grep 'moo' | sed 's/o/x/' | awk '{ print $1 }'\necho ${PIPESTATUS[@]}\n```\n","slug":"shell例子","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi77001pgwq218wf9njb","content":"<ul>\n<li>追加信息于文件<br><code>cat - &gt;&gt; filename</code></li>\n<li>赋值日期命令<br><code>eval $(date &#39;+weekday=&quot;%a&quot; month=&quot;%b&quot; day=&quot;%e&quot; year=&quot;%G&quot;&#39;)</code></li>\n<li>判断是否符合正则表达式<br><code>expr string : pattern</code></li>\n</ul>\n<ul>\n<li>追加内容到文件<br>echo的-n选项不会在添加内容前加换行符</li>\n<li>读取文件首行赋给变量<br><code>read -r line &lt; file</code>,-r选项保证读入的内容是原始内容，反斜杠不会发生转义，read命令会删除开头和结尾的<code>IFS</code>中的所有字符，如果想保留，把<code>IFS</code>置为空:<code>IFS= read -r line &lt; file</code></li>\n<li>依次读入文件每一行<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> IFS= <span class=\"hljs-built_in\">read</span> -r line; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-comment\"># do something with $line</span><br><span class=\"hljs-keyword\">done</span> &lt; file<br></code></pre></td></tr></table></figure></li>\n<li>随机读取一行内容<br><code>read -r random_line &lt; &lt;(shuf file)</code></li>\n<li>读取文件首行前三个字段<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> -r field1 field2 field3 _; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-comment\"># do something with $field1, $field2, and $field3</span><br><span class=\"hljs-keyword\">done</span> &lt; file<br></code></pre></td></tr></table></figure>\n<code>_</code>用来接受三个字段后的所有内容，如果没有他，field3会接受所有</li>\n<li>从文件路径中获取文件名<br><code>filename=$&#123;path##*/&#125;</code>,这其实就是参数展开</li>\n<li>从文件路径中获取目录名<br><code>dirname=$&#123;path%/*&#125;</code></li>\n<li>相同路径下的快速拷贝&#x2F;移动写法<br><code>cp /path/to/file&#123;,_copy&#125;</code></li>\n<li>生成a到z字母表<ul>\n<li><code>echo &#123;a..z&#125;</code></li>\n<li><code>printf &quot;%c&quot; &#123;a..z&#125;</code>,字母间不含空格</li>\n<li><code>printf &quot;%c&quot; &#123;a..z&#125; $&#39;\\n&#39;</code>结尾加空行</li>\n<li><code>printf &quot;%c\\n&quot; &#123;a..z&#125;</code>每个字符后加个空行</li>\n</ul>\n</li>\n<li>生成00-09数字<ul>\n<li><code>printf &quot;%02d&quot; &#123;0..9&#125;</code></li>\n<li><code>echo &#123;00..09&#125;</code>bash4以上支持</li>\n</ul>\n</li>\n<li>生成若干单词<br><code>echo &#123;w,t,&#125;h&#123;e&#123;n&#123;,ce&#123;,forth&#125;&#125;,re&#123;,in,fore,with&#123;,al&#125;&#125;&#125;,ither,at&#125;</code></li>\n<li>重复输出10次字符串<br><code>echo foo&#123;,,,,,,,,,&#125;</code></li>\n<li>分割字符串<ul>\n<li><code>IFS=- read -r x y z &lt;&lt;&lt; &quot;$str&quot;</code></li>\n<li><code>IFS=- read -ra parts &lt;&lt;&lt; &quot;foo-bar-baz&quot;</code>保存到数组</li>\n</ul>\n</li>\n<li>逐个字符处理字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> IFS= <span class=\"hljs-built_in\">read</span> -rn1 c; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-comment\"># do something with $c</span><br><span class=\"hljs-keyword\">done</span> &lt;&lt;&lt; <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$str</span>&quot;</span><br></code></pre></td></tr></table></figure>\n-n1表示一次读一个字符</li>\n<li>获取一个字符的ascll<br><code>printf &#39;%02x&#39; &quot;+&quot;</code></li>\n<li>获取最后一个参数<br><code>echo $&#123;@: -1&#125;</code>或<code>echo $&#123;!#&#125;</code></li>\n<li>遍历参数<br><code>for arg in &quot;$@&quot;</code>等价于<code>for arg</code></li>\n<li>路径中含空格：<ul>\n<li>非递归：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> *.mp3;<br><span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$i</span>&quot;</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure></li>\n<li>递归：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">OLDIFS=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$IFS</span>&quot;</span><br>filelist=$(find -name <span class=\"hljs-string\">&#x27;*.mp3&#x27;</span> -print0|xargs --null <span class=\"hljs-built_in\">ls</span>)&amp;&amp;IFS=$<span class=\"hljs-string\">&#x27;\\n&#x27;</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable\">$filelist</span>;<br><span class=\"hljs-keyword\">do</span><br>\tIFS=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$OLDIFS</span>&quot;</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$i</span>&quot;</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<strong>注意，IFS必须单引号，filelist的变量是必须的,不能写在for后面,要即时还原IFS</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"函数特殊用法\"><a href=\"#函数特殊用法\" class=\"headerlink\" title=\"函数特殊用法\"></a>函数特殊用法</h2><ul>\n<li>测试文件是否存在函数<br><code>function fileExists() [[ -f $1 ]]</code></li>\n<li>测试是否及偶数<br><code>function isEven() (( $1 % 2 == 0 ))</code></li>\n<li>使用小括号<br>会fork个子进程，对环境的修改不会印象外面，不需要恢复现场<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">function</span> name() ( <br>... <br>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"文件描述符与重定向\"><a href=\"#文件描述符与重定向\" class=\"headerlink\" title=\"文件描述符与重定向\"></a>文件描述符与重定向</h2><p>bash启动时，文件描述符表如下所示：<br><img src=\"/images/file_descriptor.png\"><br>当bash执行命令时，他会fork一个子进程，它会继承父进程的描述符表</p>\n<h3 id=\"重定向命令到stdout\"><a href=\"#重定向命令到stdout\" class=\"headerlink\" title=\"重定向命令到stdout\"></a>重定向命令到stdout</h3><ul>\n<li><code>command &gt;file</code>到底发生了啥？<br><code>&gt;</code>是输出重定向操作符，bash首先打开文件准备写入，如果文件打开成功，command的stdout指向打开的文件，如果失败，不执行命令，其实等价于<code>command 1 &gt;file</code></li>\n</ul>\n<h3 id=\"重定向命令到stderr\"><a href=\"#重定向命令到stderr\" class=\"headerlink\" title=\"重定向命令到stderr\"></a>重定向命令到stderr</h3><p><code>command 2&gt;file</code></p>\n<h3 id=\"重定向命令stdout和stderr到同一个文件\"><a href=\"#重定向命令stdout和stderr到同一个文件\" class=\"headerlink\" title=\"重定向命令stdout和stderr到同一个文件\"></a>重定向命令stdout和stderr到同一个文件</h3><p><code>command &amp;&gt;file</code>等价于<code>command &gt;file 2&gt;&amp;1</code><br>当只有一个重定向时，重定向位置可以任意放，甚至可以在命令的前面，但注意遇到多个重定向操作时,顺序很重要，会从左到右依次处理:<br>首先<code>&gt;file</code>会发生如下：<br><img src=\"/images/file_descriptor1.png\"><br>然后<code>2&gt;&amp;1</code>会发生如下：<br><img src=\"/images/file_descriptor2.png\"><br>如果顺序错了，为节省流量,你自己想会发生啥吧</p>\n<h3 id=\"重定向stdin\"><a href=\"#重定向stdin\" class=\"headerlink\" title=\"重定向stdin\"></a>重定向stdin</h3><p><code>command &lt;file</code>Bash 在执行命令之前，打开文件file准备读入。如果打开文件出错，Bash 会直接返错，不会继续执行命令。相反如果打开成功，Bash 会使用打开的文件的文件描述符作为命令的标准输入</p>\n<h3 id=\"重定向一堆字符到stdin\"><a href=\"#重定向一堆字符到stdin\" class=\"headerlink\" title=\"重定向一堆字符到stdin\"></a>重定向一堆字符到stdin</h3><p>这是最常见的here document语法<code>&lt;&lt;MARKER</code>,当bash遇到该操作符时，会从标输入读取每一行，直到遇到<code>MARKER</code>,例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sed <span class=\"hljs-string\">&#x27;s|http://||&#x27;</span> &lt;&lt;<span class=\"hljs-string\">EOF</span><br><span class=\"hljs-string\">http://url1.com</span><br><span class=\"hljs-string\">http://url2.com</span><br><span class=\"hljs-string\">http://url3.com</span><br><span class=\"hljs-string\">EOF</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> line2; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">let</span> b++<br>    <span class=\"hljs-built_in\">echo</span> ??<span class=\"hljs-variable\">$line2</span>??<br><span class=\"hljs-keyword\">done</span> &lt;&lt; <span class=\"hljs-string\">EOF</span><br><span class=\"hljs-string\">`grep -v 1 /tmp/test.txt`</span><br><span class=\"hljs-string\">EOF</span><br></code></pre></td></tr></table></figure>\n<p>如果MARKER用引号括起来，那么变量是不会展开的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cat</span>&lt;&lt;<span class=\"hljs-string\">&quot;EOF&quot;</span><br>hello, <span class=\"hljs-variable\">$USER</span> <span class=\"hljs-comment\">#USER不会展开</span><br>EOF<br></code></pre></td></tr></table></figure>\n<h3 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h3><p>见另一篇</p>\n<h3 id=\"通过bash访问web站点\"><a href=\"#通过bash访问web站点\" class=\"headerlink\" title=\"通过bash访问web站点\"></a>通过bash访问web站点</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">exec</span> 3&lt;&gt;/dev/tcp/www.google.com/80<br><span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">&quot;GET / HTTP/1.1\\n\\n&quot;</span> &gt;&amp;3<br><span class=\"hljs-built_in\">cat</span> &lt;&amp;3<br></code></pre></td></tr></table></figure>\n<p>Bash 将&#x2F;dev&#x2F;tcp&#x2F;host&#x2F;port当作一种特殊的文件(套接字文件？)，它并不需要实际存在于系统中，这种类型的特殊文件是给 Bash 建立 tcp 连接用的。</p>\n<h3 id=\"重定向进程的stdout和stderr到另外一个进程的输入\"><a href=\"#重定向进程的stdout和stderr到另外一个进程的输入\" class=\"headerlink\" title=\"重定向进程的stdout和stderr到另外一个进程的输入\"></a>重定向进程的stdout和stderr到另外一个进程的输入</h3><p><code>command1 |&amp; command2</code>等价于<code>command1 2&gt;&amp;1|command2</code></p>\n<h3 id=\"交换标准输出与标准错误\"><a href=\"#交换标准输出与标准错误\" class=\"headerlink\" title=\"交换标准输出与标准错误\"></a>交换标准输出与标准错误</h3><p><code>command 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3</code></p>\n<h3 id=\"重定向标准输出与错误给不同进程\"><a href=\"#重定向标准输出与错误给不同进程\" class=\"headerlink\" title=\"重定向标准输出与错误给不同进程\"></a>重定向标准输出与错误给不同进程</h3><p>主要就是使用进程替换<br><code>command &gt; &gt;(stdout_cmd) 2&gt; &gt;(stderr_cmd)</code></p>\n<h3 id=\"获取管道流中的所有命令执行退出码\"><a href=\"#获取管道流中的所有命令执行退出码\" class=\"headerlink\" title=\"获取管道流中的所有命令执行退出码\"></a>获取管道流中的所有命令执行退出码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;pants are cool&#x27;</span> | grep <span class=\"hljs-string\">&#x27;moo&#x27;</span> | sed <span class=\"hljs-string\">&#x27;s/o/x/&#x27;</span> | awk <span class=\"hljs-string\">&#x27;&#123; print $1 &#125;&#x27;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;PIPESTATUS[@]&#125;</span><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<ul>\n<li>追加信息于文件<br><code>cat - &gt;&gt; filename</code></li>\n<li>赋值日期命令<br><code>eval $(date &#39;+weekday=&quot;%a&quot; month=&quot;%b&quot; day=&quot;%e&quot; year=&quot;%G&quot;&#39;)</code></li>\n<li>判断是否符合正则表达式<br><code>expr string : pattern</code></li>\n</ul>\n<ul>\n<li>追加内容到文件<br>echo的-n选项不会在添加内容前加换行符</li>\n<li>读取文件首行赋给变量<br><code>read -r line &lt; file</code>,-r选项保证读入的内容是原始内容，反斜杠不会发生转义，read命令会删除开头和结尾的<code>IFS</code>中的所有字符，如果想保留，把<code>IFS</code>置为空:<code>IFS= read -r line &lt; file</code></li>\n<li>依次读入文件每一行<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> IFS= <span class=\"hljs-built_in\">read</span> -r line; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-comment\"># do something with $line</span><br><span class=\"hljs-keyword\">done</span> &lt; file<br></code></pre></td></tr></table></figure></li>\n<li>随机读取一行内容<br><code>read -r random_line &lt; &lt;(shuf file)</code></li>\n<li>读取文件首行前三个字段<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> -r field1 field2 field3 _; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-comment\"># do something with $field1, $field2, and $field3</span><br><span class=\"hljs-keyword\">done</span> &lt; file<br></code></pre></td></tr></table></figure>\n<code>_</code>用来接受三个字段后的所有内容，如果没有他，field3会接受所有</li>\n<li>从文件路径中获取文件名<br><code>filename=$&#123;path##*/&#125;</code>,这其实就是参数展开</li>\n<li>从文件路径中获取目录名<br><code>dirname=$&#123;path%/*&#125;</code></li>\n<li>相同路径下的快速拷贝&#x2F;移动写法<br><code>cp /path/to/file&#123;,_copy&#125;</code></li>\n<li>生成a到z字母表<ul>\n<li><code>echo &#123;a..z&#125;</code></li>\n<li><code>printf &quot;%c&quot; &#123;a..z&#125;</code>,字母间不含空格</li>\n<li><code>printf &quot;%c&quot; &#123;a..z&#125; $&#39;\\n&#39;</code>结尾加空行</li>\n<li><code>printf &quot;%c\\n&quot; &#123;a..z&#125;</code>每个字符后加个空行</li>\n</ul>\n</li>\n<li>生成00-09数字<ul>\n<li><code>printf &quot;%02d&quot; &#123;0..9&#125;</code></li>\n<li><code>echo &#123;00..09&#125;</code>bash4以上支持</li>\n</ul>\n</li>\n<li>生成若干单词<br><code>echo &#123;w,t,&#125;h&#123;e&#123;n&#123;,ce&#123;,forth&#125;&#125;,re&#123;,in,fore,with&#123;,al&#125;&#125;&#125;,ither,at&#125;</code></li>\n<li>重复输出10次字符串<br><code>echo foo&#123;,,,,,,,,,&#125;</code></li>\n<li>分割字符串<ul>\n<li><code>IFS=- read -r x y z &lt;&lt;&lt; &quot;$str&quot;</code></li>\n<li><code>IFS=- read -ra parts &lt;&lt;&lt; &quot;foo-bar-baz&quot;</code>保存到数组</li>\n</ul>\n</li>\n<li>逐个字符处理字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> IFS= <span class=\"hljs-built_in\">read</span> -rn1 c; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-comment\"># do something with $c</span><br><span class=\"hljs-keyword\">done</span> &lt;&lt;&lt; <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$str</span>&quot;</span><br></code></pre></td></tr></table></figure>\n-n1表示一次读一个字符</li>\n<li>获取一个字符的ascll<br><code>printf &#39;%02x&#39; &quot;+&quot;</code></li>\n<li>获取最后一个参数<br><code>echo $&#123;@: -1&#125;</code>或<code>echo $&#123;!#&#125;</code></li>\n<li>遍历参数<br><code>for arg in &quot;$@&quot;</code>等价于<code>for arg</code></li>\n<li>路径中含空格：<ul>\n<li>非递归：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> *.mp3;<br><span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$i</span>&quot;</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure></li>\n<li>递归：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">OLDIFS=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$IFS</span>&quot;</span><br>filelist=$(find -name <span class=\"hljs-string\">&#x27;*.mp3&#x27;</span> -print0|xargs --null <span class=\"hljs-built_in\">ls</span>)&amp;&amp;IFS=$<span class=\"hljs-string\">&#x27;\\n&#x27;</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable\">$filelist</span>;<br><span class=\"hljs-keyword\">do</span><br>\tIFS=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$OLDIFS</span>&quot;</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$i</span>&quot;</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<strong>注意，IFS必须单引号，filelist的变量是必须的,不能写在for后面,要即时还原IFS</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"函数特殊用法\"><a href=\"#函数特殊用法\" class=\"headerlink\" title=\"函数特殊用法\"></a>函数特殊用法</h2><ul>\n<li>测试文件是否存在函数<br><code>function fileExists() [[ -f $1 ]]</code></li>\n<li>测试是否及偶数<br><code>function isEven() (( $1 % 2 == 0 ))</code></li>\n<li>使用小括号<br>会fork个子进程，对环境的修改不会印象外面，不需要恢复现场<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">function</span> name() ( <br>... <br>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"文件描述符与重定向\"><a href=\"#文件描述符与重定向\" class=\"headerlink\" title=\"文件描述符与重定向\"></a>文件描述符与重定向</h2><p>bash启动时，文件描述符表如下所示：<br><img src=\"/images/file_descriptor.png\"><br>当bash执行命令时，他会fork一个子进程，它会继承父进程的描述符表</p>\n<h3 id=\"重定向命令到stdout\"><a href=\"#重定向命令到stdout\" class=\"headerlink\" title=\"重定向命令到stdout\"></a>重定向命令到stdout</h3><ul>\n<li><code>command &gt;file</code>到底发生了啥？<br><code>&gt;</code>是输出重定向操作符，bash首先打开文件准备写入，如果文件打开成功，command的stdout指向打开的文件，如果失败，不执行命令，其实等价于<code>command 1 &gt;file</code></li>\n</ul>\n<h3 id=\"重定向命令到stderr\"><a href=\"#重定向命令到stderr\" class=\"headerlink\" title=\"重定向命令到stderr\"></a>重定向命令到stderr</h3><p><code>command 2&gt;file</code></p>\n<h3 id=\"重定向命令stdout和stderr到同一个文件\"><a href=\"#重定向命令stdout和stderr到同一个文件\" class=\"headerlink\" title=\"重定向命令stdout和stderr到同一个文件\"></a>重定向命令stdout和stderr到同一个文件</h3><p><code>command &amp;&gt;file</code>等价于<code>command &gt;file 2&gt;&amp;1</code><br>当只有一个重定向时，重定向位置可以任意放，甚至可以在命令的前面，但注意遇到多个重定向操作时,顺序很重要，会从左到右依次处理:<br>首先<code>&gt;file</code>会发生如下：<br><img src=\"/images/file_descriptor1.png\"><br>然后<code>2&gt;&amp;1</code>会发生如下：<br><img src=\"/images/file_descriptor2.png\"><br>如果顺序错了，为节省流量,你自己想会发生啥吧</p>\n<h3 id=\"重定向stdin\"><a href=\"#重定向stdin\" class=\"headerlink\" title=\"重定向stdin\"></a>重定向stdin</h3><p><code>command &lt;file</code>Bash 在执行命令之前，打开文件file准备读入。如果打开文件出错，Bash 会直接返错，不会继续执行命令。相反如果打开成功，Bash 会使用打开的文件的文件描述符作为命令的标准输入</p>\n<h3 id=\"重定向一堆字符到stdin\"><a href=\"#重定向一堆字符到stdin\" class=\"headerlink\" title=\"重定向一堆字符到stdin\"></a>重定向一堆字符到stdin</h3><p>这是最常见的here document语法<code>&lt;&lt;MARKER</code>,当bash遇到该操作符时，会从标输入读取每一行，直到遇到<code>MARKER</code>,例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sed <span class=\"hljs-string\">&#x27;s|http://||&#x27;</span> &lt;&lt;<span class=\"hljs-string\">EOF</span><br><span class=\"hljs-string\">http://url1.com</span><br><span class=\"hljs-string\">http://url2.com</span><br><span class=\"hljs-string\">http://url3.com</span><br><span class=\"hljs-string\">EOF</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> line2; <span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">let</span> b++<br>    <span class=\"hljs-built_in\">echo</span> ??<span class=\"hljs-variable\">$line2</span>??<br><span class=\"hljs-keyword\">done</span> &lt;&lt; <span class=\"hljs-string\">EOF</span><br><span class=\"hljs-string\">`grep -v 1 /tmp/test.txt`</span><br><span class=\"hljs-string\">EOF</span><br></code></pre></td></tr></table></figure>\n<p>如果MARKER用引号括起来，那么变量是不会展开的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cat</span>&lt;&lt;<span class=\"hljs-string\">&quot;EOF&quot;</span><br>hello, <span class=\"hljs-variable\">$USER</span> <span class=\"hljs-comment\">#USER不会展开</span><br>EOF<br></code></pre></td></tr></table></figure>\n<h3 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h3><p>见另一篇</p>\n<h3 id=\"通过bash访问web站点\"><a href=\"#通过bash访问web站点\" class=\"headerlink\" title=\"通过bash访问web站点\"></a>通过bash访问web站点</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">exec</span> 3&lt;&gt;/dev/tcp/www.google.com/80<br><span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">&quot;GET / HTTP/1.1\\n\\n&quot;</span> &gt;&amp;3<br><span class=\"hljs-built_in\">cat</span> &lt;&amp;3<br></code></pre></td></tr></table></figure>\n<p>Bash 将&#x2F;dev&#x2F;tcp&#x2F;host&#x2F;port当作一种特殊的文件(套接字文件？)，它并不需要实际存在于系统中，这种类型的特殊文件是给 Bash 建立 tcp 连接用的。</p>\n<h3 id=\"重定向进程的stdout和stderr到另外一个进程的输入\"><a href=\"#重定向进程的stdout和stderr到另外一个进程的输入\" class=\"headerlink\" title=\"重定向进程的stdout和stderr到另外一个进程的输入\"></a>重定向进程的stdout和stderr到另外一个进程的输入</h3><p><code>command1 |&amp; command2</code>等价于<code>command1 2&gt;&amp;1|command2</code></p>\n<h3 id=\"交换标准输出与标准错误\"><a href=\"#交换标准输出与标准错误\" class=\"headerlink\" title=\"交换标准输出与标准错误\"></a>交换标准输出与标准错误</h3><p><code>command 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3</code></p>\n<h3 id=\"重定向标准输出与错误给不同进程\"><a href=\"#重定向标准输出与错误给不同进程\" class=\"headerlink\" title=\"重定向标准输出与错误给不同进程\"></a>重定向标准输出与错误给不同进程</h3><p>主要就是使用进程替换<br><code>command &gt; &gt;(stdout_cmd) 2&gt; &gt;(stderr_cmd)</code></p>\n<h3 id=\"获取管道流中的所有命令执行退出码\"><a href=\"#获取管道流中的所有命令执行退出码\" class=\"headerlink\" title=\"获取管道流中的所有命令执行退出码\"></a>获取管道流中的所有命令执行退出码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;pants are cool&#x27;</span> | grep <span class=\"hljs-string\">&#x27;moo&#x27;</span> | sed <span class=\"hljs-string\">&#x27;s/o/x/&#x27;</span> | awk <span class=\"hljs-string\">&#x27;&#123; print $1 &#125;&#x27;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;PIPESTATUS[@]&#125;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"shell基本概念","date":"2021-10-15T12:10:51.000Z","subtitle":null,"index_img":"/images/bash.jpg","banner_img":"/images/bash.jpg","_content":"### 注释\n* 单行注释: \\#\n* 多行注释:  `:<<EOF ... EOF`或者 `:<<! ... !`\n\n### 变量\n* 创建普通变量: **name=\"test\"** (=两边不可有空格)\n* 创建函数体中的局部变量: ** local name=\"test\"**,函数体及整个脚本中的变量默认都是全局变量,函数体内外皆可访问和改变,函数体内的变量最好用这个加以限制,同时为了得到命令替换的返回码时最好分开写(否则只会捕获local的成功码)：\n```bash\nlocal varname\nvarname=$(command)\nre=$?\n```\n* 使用变量: **echo $name 或者 echo $(name)** 使用时要加$,重新赋值时不需要\n* 只读变量: **name=\"only_read\" -> readonly name**\n* 删除变量: **unset name**\n  \n### 字符串变量\n字符串与变量展开有密切联系,可以参考那节\n1) 单引号\n* 单引号变量var='test',只能原样输出,不能解释变量\n* 单引号中不能出现一个单引号,转义也不行\n\n2) 双引号\n* 双引号变量`var=\"my name is ${name}\"`,可以解释变量\n* 可以出现转移字符\n\n3) 拼接字符串\n* `name=\"this is\"\"my name\";name=\"this is my name\";name=\"this\"is\"my name\"`等效\n\n4) 获取字符串长度\n```bash\necho ${#str}\n```\n  \n5) 提取子字符串\n```bash\nname=\"this is my name\";\necho ${name:1:4} #输出his\necho ${name::4} #输出this\n```\n6) 大小写\n```bash\ndeclare -u upper\ndeclare -l lower\n#upper将会强制转成SL\nupper=\"sl\"\n#lower将会强制转成sl\nlower=\"SL\"\n```\n### 数组\nbash只支持以为数组,不支持多维数组\n* 定义数组: **array_name=(li wang xiang zhang)** (小括号做边界、使用空格分离)或者**declare -a array_name**\n* 单独定义数组的元素: **arraypara[0]=\"w\";arraypara[3]=\"s\"** (定义时下标可以不连续,同样可以用于赋值)\n* 获取数组元素\n```bash\narray_name[0]=\"li\"\narray_name[3]=\"zhang\"\necho ${array_name[0]} #输出\"li\"\necho ${array_name[1]} #输出空\necho ${array_name[@]} #输出\"li zhang\"输出数组所有元素,没有元素的下标省略\n#等价于下面\necho ${array_name[*]}\n```\n* 取得元素个数:\n```bash\n${#arrayname[@]}\n#或者\n${#arrayname[\\*]}\n```\n* 取得单个元素长度: \n```bash\n${#array_name[1]}\n```\n* `for i in \"${!foo[@]}\"`取得每个非空元素的下标\n* `foo+=(d e f)`添加3个元素\n* 删除数组不能通过赋空值,只能通过unset,unset还能删除某个元素(这样后面元素往前补)\n* 没有指明数组下标的访问或赋值皆指向第一个值\n* 最新版本bash支持关联数组`declare -A colors;colors[\"red\"]=\"red\"`\n* [函数与数组](#funAndArr)\n* 取切片`echo ${array:0:3}`\n* 遍历数组\n```bash\n#方法1\nfor(( i=0;i<${#array[@]};i++)) do\necho ${array[i]};\ndone;\n#方法2\nfor element in ${array[@]}\ndo\necho $element\ndone\n#方法3\nfor i in \"${!arr[@]}\";\ndo\n    printf \"%s\\t%s\\n\" \"$i\" \"${arr[$i]}\"\ndone\n```\n- 添加数组元素\n`$arr+=(a b)`\n### 环境变量\n#### FUNCNAME\n该环境变量是个数组，存储当前位置函数调用的堆栈，当只有主程序时，个数为0,当存在调用函数时，第一个总是当前函数名，最后一个为main表示主程序\n#### BASH_SOURCE\n是一个数组，不过它的第一个元素是当前脚本名称，然后是source它的脚本，依次类推，常用如下\n```bash\n# 如果脚本是被source的话\nif [ -n \"$BASH_SOURCE\" -a \"$BASH_SOURCE\" != \"$0\" ]\nthen\n    do_something\nelse # Otherwise, run directly in the shell\n    do_other\nfi\n```\n\n### 参数传递的相关特殊变量\n\n|变量|意义|\n|:-:|:-:|\n|`$0`| 代表执行的文件名|\n|`$n`| 代表传入的第n个参数|\n|`$#`|参数个数,不包括程序名本身|\n|`$`|以一个单字符串显示所有向脚本传递的参数。即为\"$1 $2...$n\"|\n|`$@`|展开成一个从 1 开始的位置参数列表。当它被用双引号引 起来的时候，展开成一个由双引号引起来的字符串，包含了 所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个 字符（默认为一个空格）分隔开。|\n|`$*`|把所有参数当成一个大字符串|\n|`$$`| 该脚本进程ID|\n|`$!`| 后台运行的最后一个进程ID|\n|`$?`|上个调用(最后命令)返回值,0表示没有错误|\n\n有个**shift**命令可以方便处理命令行参数,每次执行该命令的时候,变量$2会移动到$1,变量$3会移动到变量$2,以此类推,$#值也会减1。例子:\n```bash\ncount=1\nwhile [[ $# -gt 0 ]];\ndo\n\techo \"Argument $count = $1\"\n\tcount=$((count + 1))\n\tshift\ndone\n```\n[getopt和getopts两个命令经常被用来处理传递的参数](#jumpopt)\n\n\n### 运算符\n### let\nlet使数字运算更方便:`let a++`,`let a+=2`\n\n#### 算数运算\n * `+ - * /`\n * 加法运算\n     * `bash val=$(expr 2 + 2)` 这么写乘号要加转义,空格也是必须\n     * `val=$[2+2]` (4个空格不是必要的,不同于条件判断)\n     * `val=$((2+2))`(4个空格不是必要的)\n\nbash支持任意进制\n\n|表示法|描述|\n|:-:|:-:|\n|number|默认10进制|\n|0number|8进制|\n|0xnumber|16进制|\n|base#number|base进制|\n\n在双括号中会被解释成数字,否则默认为字符串\n\n#### 数字关系运算符\n关系运算符只支持数字,不支持字符串,除非字符串是数字\n\n|符号|意义|\n|:-:|:-:|\n|`-eq`|相等返回true,`[$a -eq $b]`|\n|`-ne`|不相等返回true,`[$a -ne $b]`||\n|`-gt`|大于号|\n|`-lt`|小于号|\n|`-ge`|大于等于号|\n|`-le`|小于等于号|\n\n#### 字符串运算符\n\n|符号|意义|\n|:-:|:-:|\n|**=**|相等返回true,`[$a = $b]`|\n|**!=**|不相等返回true,`[$a != $b]`|\n|**-z**|字符串长度为0返回true,`[-z $b]`|\n|**-n**|字符串长度不为0返回true,`[-n $b]`|\n|**$**|不为空返回true,`[$a]`|\n\n#### 逻辑运算符\n\n|符号|意义|\n|:-:|:-:|\n|**!**|非运算,`[! false]`|\n|**&&**|与运算,`[[ $a -lt 20 ]] && [[$b -gt 100 ]]`|\n|**||**|或运算,`[[ $a -lt 20 ]] || [[$b -gt 100 ]]`,`[[ $a -lt 20 || $b -gt 100 ]]`|\n\n逻辑判断的括号\n1.`[]`:中括号旁边和运算符两边必须添加空格(可以使用，等价于test命令,本文不讲test命令,不推荐)\n2.`[[]]`:中括号旁边和运算符两边必须添加空格(字符串验证,文件名时，推荐)\n3.`(())`:中括号旁边和运算符两边必须添加空格(数字验证时，推荐)\n4.`[[]]和(())`分别是针对数学表达式和字符串表达式的加强版\n5.`[]`基本舍弃的原因，它与**&&、||、<和>**不兼容,会报错,它只能用-ne等等这些,例如下面是等价的\n`if [[ $a != 1 && $a !=2 ]]`,`if [ $a -ne 1 ] && [ $a != 2 ]`,`if [ $a -ne 1 -a $a !=2 ]`\n6.双括号支持以下额外的符号(没列全,C语言能用的都能用,包括?:)\n\n|符号|描述|\n|:-:|:-:|\n|val++|后增|\n|val--|后减|\n|++val|前增|\n|--val|前减|\n|!|逻辑求反|\n|~|位求反|\n|**|幂运算|\n|<<|左位移|\n|>>|右位移|\n|&|布尔和|\n|`|`|布尔或|\n|`||`|逻辑或|\n|&&|逻辑与|\n|=~|用于字符串的模式匹配,右边加上引号会丧失正则的含义，变成普通字符串,避免反斜杠转移，可以赋值给一个变量|\n|==|用于字符串的类型匹配(通配符等),例子`if [[ $FILE == foo.* ]]`|\n|=|用于字符串是否相同，右边一定要引号括起来，否则是模式匹配，如`*`则会永远为true|\n\n\n#### 文件运算符\nfile是代表文件名的字符串\n\n|符号|意义|\n|:-:|:-:|\n|$file1 -ef $file2|拥有相同的索引号返回True(硬连接)|\n|$file1 -nt $file2|file1新于file2返回true|\n|$file1 -ot $file2|file1早于file2返回true|\n|`[-b $file]`|是块设备文件返回true|\n|`[-c $file]`|是字符备文件返回true|\n|`[-d $file]`|是目录返回true|\n|`[-f $file]`|是普通文件返回true|\n|`[-g $file]`|设置了SGID位文件返回true|\n|`[-h $file]`|是符号链接返回true|\n|`[-G $file]`|由有效组(即当前进程用户组)ID拥有返回true|\n|`[-L $file]`|是符号链接返回true|\n|`[-k $file]`|设置了stick位文件返回true|\n|`[-N $file]`|atime和mtime一样的文件|\n|`[-p $file]`|是有名管道文件返回true|\n|`[-u $file]`|设置了SUID位文件返回true|\n|`[-O $file]`|由有效用户(即当前进程用户)件D拥有返回true|\n|`[-r $file]`|是可读文件返回true|\n|`[-w $file]`|是可写文件返回true|\n|`[-x $file]`|是可执行文件返回true|\n|`[-s $file]`|非空文件返回true|\n|`[-S $file]`|是一个网络Socket返回true|\n|`[-e $file]`|文件存在返回true|\n|`[-t $fd]`|fd是一个定向到终端/从终端定向的文件描述符。这可以被用来判断是否重定向了标准输入/错误|\n\n### 输出\n**echo**只用于字符串,自动添加换行符号`echo nanbert male 66.1234`\n**printf**不自动加换行符号,例:`printf \"%-10s %-8s %-4.2f\\n\" nanbert male 66.1234`\n\n### 流程控制\n#### if\n```bash\n#then后必须有语句,空语句可以用:\nif condition\nthen \n\tcommand1\n\t...\nelif condition\nthen\n\tcommand2\n\t...\nelse\n\tcommand3\n\t...\nfi\n```\n#### for\n```bash\nfor var in item1 item2 ... itemN\ndo \n\tcommand1\n\t...\ndone\n#等价于c语言\nfor (( expression1;expression2; expression3 ));do\n\tcommands\ndone\n```\n如果省略in，默认处理位置参数\n#### while\n```bash\nwhile condition\ndo \n\tcommand1\n\t...\ndone\n#无限循环\nwhile :\ndo\n\tcommand\ndone\n```\n#### until\n```bash\nuntil condition\ndo \n\tcommand1\n\t...\ndone\n```\n#### case\nShell case匹配一个值与一个模式,用两个分号表示break\n```bash\ncase value in\n\tpattern1)\n\t\tcommand1\n\t\t...\n\t\tcommandN\n\t\t;;\n\tpattern2)\n\t\tcommand1\n\t\t...\n\t\tcommandN\n\t\t;;\nesac\n```\n\n循环都支持**continue**和**break**,`break n`则可以指定跳出n层循环,n默认为1\n,continue也支持数字。\n### 定义函数\n* 函数定义\n```bash\nfunction fun(){\n\taction;\n\t[return int;]\n}\n#等价于下面\nfun1(){\n\taction;\n\t[return int;]\n}\n```\n* 参数传递\n函数中直接使用特殊变量来获取参数,可以加上{}\n```bash\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\necho $?  # 判断执行是否成功\n```\n* 函数返回值\n    * 返回值是可选的\n\t* return只能为**return [0-255]**,可通过$?获取该值\n\t* 如果不加return,则最后一条语句的执行状态为返回值,0为成功\n\t* 如果用反引号执行函数,结果是函数内的所有输出而非返回值\n* [函数与数组](#funAndArr)\n\n- 函数本质上是一组命令集合,不一定用大括号括起来,更多见shell例子\n- 可以使用`declare -F | sed 's/declare -f//'`来查看当前脚本定义的函数\n### 读取外部输入\n`read arg`从键盘读取输入并赋值给arg\n\n|选项|说明|\n|:-:|:-:|\n|-a array|把输入赋值到数组array中|\n|-d delimiter|用字符串delimiter中的第一个字符指示输入结束,而不是一个换行符|\n|-e|使用readline来处理输入|\n|-n num|读取num个输入字符,而不是整行|\n|-p prompt|为输入显示提示信息,使用字符串prompt|\n|-r |Raw mode,不把反斜杠解释为转义字符|\n|-s |Silent mode,不会在屏幕上显示输入的字符。输入密码的时候很有用|\n|-t seconds|超过时间，终止输入,read会非0状态退出|\n|-u fd|使用文件描述符fd中的输入,而不是标准输入|\n|-k n|只读n个字节|\n\nIFS是字段分割符,默认为空格,tab,换行符。可以自行改变。如下:\n`IFS=:`改成冒号\n`IFS=$'\\n':;\"`改成换行符、冒号、分号和双引号\nread不应该使用管道线来接受赋值，如下是错误的:\n```bash\necho \"$file_info\" | IFS=\":\" read user pw uid gid name home shell\n```\n而应该这么写\n```bash\nIFS=\":\" read user pw uid gid name home shell <<< \"$file_info\"\n```\n这是因为管道线会开个子进程,子进程变量的变化不会影响父进程,可以用[进程替换](#jump)解决\n如果输入的数多余接受的变量,则多出来的会保存在变量REPLY中\n\n### 包含其他shell文件\n* `. filepath/filename`\n* `source filepath/filename`\n\n### 颜色标识\n```bash\nprintf  \"\\033[32m SUCCESS: yay \\033[0m\\n\";\nprintf  \"\\033[33m WARNING: hmm \\033[0m\\n\";\nprintf  \"\\033[31m ERROR: fubar \\033[0m\\n\";\n```\n具体内容有待研究\n\n### 长句换行\n在shell中为避免一个语句过长,可以使用\"\\\"进行换行,注意\"\\\"前加一个空格,之后无空格直接换行。\n\n### 退出脚本\n`exit [num]`num为0表示执行成功,可以不加num\n`set -e 或 set +e`set -e表示从当前位置开始,如果出现任何错误都将触发exit。相反,set +e表示不管出现任何错误继续执行脚本\n\n### 调试\n-n表示检查有无语法错误,-x表示调试\n\n### 变量展开\n\n|操作符|意义|\n|:-:|:-:|\n|`:${parameter:=word}`|如果parameter没有设置或者为空,展开的结果是word的值,并且word的值会赋给parameter;否则展开为parameter的值|\n|`${parameter:-word}`|如果parameter没有设置或者为空,展开的结果是word的值,否则是parameter的值|\n| `${parameter:?word}` |如果parameter没有设置或者为空,会带有错误的推出,否则是parameter的值|\n| `${parameter:+word}` |如果parameter没有设置或者为空,展开为空,否则是word的值;不管如何parameter值不会变|\n|`${parameter#pattern}`|pattern是通配符模式,会从parameter开头开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上|\n|`${parameter##pattern}`|pattern是通配符模式,会从parameter开头开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上|\n|`${parameter%pattern}`|pattern是通配符模式,会从parameter结尾开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上|\n|`${parameter%%pattern}`|pattern是通配符模式,会从parameter结尾开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上|\n|`${parameter/pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,只替换第一次匹配到的|\n|`${parameter//pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,替换所有匹配到的|\n|`${parameter/#pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter开头开始匹配,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上|\n|`${parameter/%pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter结尾开始匹配,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上|\n|`${parameter,,}`|把parameter全部展开成小写字母|\n|`${parameter,}`|把parameter首字母展开成小写字母|\n|`${parameter^^}`|把parameter全部展开成大写字母|\n|`${parameter^}`|把parameter首字母展开成大写字母|\n\n\n`${!prefix*}`等价于`${!prefix@}`这种展开会返回以prefix开头的已有变量名(而不是变量的值)\n字符串的长度和切片其实也是一种展开\n\n<span id = \"jump\"></span>\n### 进程替换\n进程替换可以用来解决子进程问题,它实质是把子进程的输出当作一个用于重定向的普通文件(文件描述符)。\n标准输出\n`<(cmd1;cmd2)`\n标准输入\n`>(cmd1;cmd2)`\n由此可以解决read管道线的问题\n```bash\nwhile read attr links owner group size date time filename;do\n\tcat <<- EOF\n\t\tFilename: $filename\n\t\tSize:     $size\n\t\tOwner:    $owner\n\t\tGroup:    $group\n\t\tModified: $date $time\n\t\tLinks:    $links\n\t\tAttributes: $attr\n\tEOF\ndone < <(ls -l | tail -n +2)\n```\n<span id = \"jumpopt\"></span>\n### getopt和getopts\n\n#### getopt\n格式:`getopt [options] optstring parameters`,例:\n`getopt ab:cd -a -b test1 -cd test2 test3`该命令会产生如下输出:\n`-a -b test1 -c -d -- test2 test3`,optstring定义了四个有效项字母:a、b、c和d。冒号(:)表示b选项需要个参数值,它会将-cd选项分成两个单独选项,插入'--'来分隔额外的参数,如果提供'-cde'由于e不在optstring中,会报错**getopt: invalid option -- e**,但还会输出结果,可以加-q选项忽略报错结果。\n在脚本中经常与set的'--'选项来使用,来把getopt的输出转成当前脚本的输入参数,示例如下:\n```bash\n#!/bin/bash\n# Extract command line options & values with getopt\n#\nset -- $(getopt -q ab:cd \"$@\")\n#\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n    -a) echo \"Found the -a option\" ;;\n    -b) param=\"$2\"\n        echo \"Found the -b option, with parameter value $param\"\n        shift ;;\n    -c) echo \"Found the -c option\" ;;\n    --) shift\n        break ;;\n    *) echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n#\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Parameter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\n#\n```\n\n#### getopts\n格式:`getopts optstring variable`,这里variable为命令行上检测到的第一个参数(getopts会去除'-',这点与getopt不同),处理完所有参数后,它会返回一个大于0的退出状态码。可以用\":optstring\"格式来忽略未识别选项的错误信息。会用到两个环境变量,如果选项用到一个参数值,OPTARG会保存该值,OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。\ngetopts可以识别双引号内的带括号参数值,而getopt不可以。getopts将命令行上找到的所有未定义选项统一输成问号,getopt遇到未识别的非选项值时,会结束识别,即使后面有正确的选项。可以用以下脚本自行测试getopts的行为:\n```bash\necho\nwhile getopts :ab:cd opt\ndo\n    case \"$opt\" in\n        a) echo \"Found the -a option\"  ;;\n        b) echo \"Found the -b option, with value $OPTARG\" ;;\n        c) echo \"Found the -c option\"  ;;\n        d) echo \"Found the -d option\"  ;;\n        *) echo \"Unknown option: $opt\" ;;\n    esac\ndone\n#\nshift $[ $OPTIND - 1 ]\n#\necho\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Parameter $count: $param\"\n    count=$[ $count + 1 ]\ndone\n```\n### set命令\nset 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。可以使用`echo $-`查看当前设置,默认是（himxBH）\n参数说明：\n\n|参数|说明|\n|:-:||:-:|\n|-a|标示已修改的变量，以供输出至环境变量|\n|-b|使被中止的后台程序立刻回报执行状态|\n|-B|启用大括号展开|\n|-d|Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消|\n|-e|若指令传回值不等于0，则立即退出shell|\n|-f|取消使用通配符|\n|-h|自动缓存命令的所在位置,如果在PATH指定路径内，更换命令的位置,缓存就不会同步，就会发生错误，不过谁会换命令的位置呢,可以使用which更新缓存|\n|-i|设置当前选项为交互式|\n|-k|指令所给的参数都会被视为此指令的环境变量|\n|-l|记录for循环的变量名称|\n|-m|使用监视模式,可以控制进程的停止、继续、后台前台等，默认打开|\n|-n|测试模式，只读取指令，而不实际执行|\n|-p|启动优先顺序模式|\n|-P|启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接|\n|-t|执行完随后的指令，即退出shell|\n|-u|当执行时使用到未定义过的变量，则显示错误信息|\n|-v|显示shell所读取的输入值|\n|-H shell|可利用\"!\"加<指令编号>的方式来执行 history 中记录的指令,最好不用|\n|-x|执行指令后，会先显示该指令及所下的参数|\n|+<参数>|取消某个set曾启动的参数。与-<参数>相反|\n|-o [option]|特殊属性有很多,见下面|\n\n**option属性**\n- pipefail:管道流水线中有一个失败，则返回失败值，从右往左数起(默认只返回最后一个命令的退出码)\n- noclobber:防止>重定向操作符覆盖已有内容，你可以使用`command >| file`强制覆盖\n\n### Tips\n* 波浪号展开只能**紧跟**在`=`和`:`之后才能正确展开,引号中无法正确展开\n* **<<**和**<<-**的区别在于,<<-会忽略接下来输入的tab建,一般用于格式化脚本,便于读代码\n* 组命令(在当前shell执行)--`{ command1;command2;command3  }`,子shell--`(command1;command2;command3)`一般配合管道符\n* trap命令\n`trap \"命令\" \"信号\"`当脚本遇到信号前执行的命令\n```bash\ntrap \"echo I am ignoring you\" SIGINT SIGTERM\n```\n常见信号有:\n\n|编号|英文名|含义|\n|:-:|:-:|:-:|\n|1|SIGHUP|挂起进程|\n|2|SIGINT|终止进程|\n|3|SIGQUIT|停止进程|\n|9|SIGKILL|无条件终止进程|\n|15|SIGTERM|尽可能终止进程|\n|17|SIGSTOP|无条件停止进程,但不是终止进程|\n|18|IGTSTP|停止或暂停进程,但不终止进程|\n|19|SIGCONT|继续运行停止的进程|\n\n    * tap除了捕获信号外,还会捕获脚本退出:`trap \"echo Goodbye...\" EXIT`,不管正常还是非正常,都会打印Goodbye\n    * `trap -- SIGINT`取消某个信号的设置\n\t* `trap -`恢复信号的默认行为\n* wait命令\n`wait $pid`等待子进程\n```bash\n#小火车子进程\nsl &\npid=$!\n#父进程继续干事\nsleep 2\n#干完事等子进程\nwait $pid\necho \"子父进程都结束了\"\n```\n* 命名管道\n```bash\n#创建一个命名管道文件\nmkfifo pipe1\n#子进程写入(写入完会阻塞,等待另一端读,所以不要wait)\nls -l > pipe1 &\n#父进程读\nsleep 5\ncat<pipe1\n```\n- IFS默认是空白字符(回车，空格，制表符等)，位于字符串和结尾的空白字符都被删除，中间连续空格会被压缩成一个\n* 子shell的全局环境变量改变并不会影响父shell,甚至用export也不行\n* 命令替换`$(command)`,子shell`(command)`两个是不同概念,命令替换会开个子shell(貌似都会开子shell)\n* 文件描述符与exec\n    * 配合exec可以使标准输入输出永久重定向:`exec 2>testerror`重定向标准错误至文件。\n    * exec可以创建文件描述:`exec 3>testxx;echo hello>&3`这可以用来恢复正常的输入输出,如下:\n```bash\nexec 3>&1\nexec 1>test14out\necho \"这会输入到test14out\"\nexec 1>&3\necho \"这会输入到屏幕\"\n```\n    * exec创建读写描述符:`exec 3<>testfile`,这要特别小心,任何读或写都会从文件指针的上次位置开始\n    * exec关闭文件描述符:`exec 3>&-`\n\t* lsof命令可以查看已经打开的文件描述符,见Linux命令博客\n\n<span id = \"funAndArr\"></span>\n* 函数与数组\n将数组变量当作但个参数传递的话,它不会其作用,只会传递第一个值,可以借鉴以下例子:\n```bash\n#!/bin/bash\n# array variable to function test\nfunction testit {\n    local newarray\n    newarray=`echo \"$@\"`\n    echo \"The new array value is: ${newarray[*]}\"\n}\nmyarray=(1 2 3 4 5)\necho \"The original array is ${myarray[*]}\"\ntestit ${myarray[*]}\n```\n* 预处理替换优先级\na.shell替换:文件通配符\nb.变量替换\nc.命令替换,如下示例:  \n\n* shell元字符汇总\n  \n|符号|意义|\n|:-:|:-:|\n|空格、制表符| 命令行参数的分隔符|\n|回车| 执行键入的命令|\n|&lt; > &brvbar;| 重定向与管道|\n|; |多个命令分隔符|\n|& |后台运行|\n|$ |引用shell的变量|\n|\\`| 命令替换,`\\\\`代表反斜线自身,`\\``代表反撇号自身|\n|\\* [] ?| 文件通配符,不匹配\\*和/|\n|()| 用于定义shell函数或子shell中执行命令|\n|\\\\| 转义字符取消元字符特殊含义，若不用于元字符跟不加一样|\n|\" \"| 其中的内容除$和\\`外取消元字符的特殊含义|\n|' '| 取消所有元字符特殊含义|\n\n* RANDOM是个内建的随机值\n* `<<<`\nhere-string语法，允许直接传递字符串给标准输入\n* eval\neval 的功能是将字符串作为代码来执行。看上去好像很简单，但实际涉及很复杂的内容，主要是符号转义导致的语义问题。\n```\nstr1=str2\nstr2=abc\neval echo \\$$str1\n```\n","source":"_posts/shell基本概念.md","raw":"---\ntitle: shell基本概念\ndate: 2021-10-15 20:10:51\nsubtitle:\ncategories:\ntags:\nindex_img: /images/bash.jpg\nbanner_img: /images/bash.jpg\n---\n### 注释\n* 单行注释: \\#\n* 多行注释:  `:<<EOF ... EOF`或者 `:<<! ... !`\n\n### 变量\n* 创建普通变量: **name=\"test\"** (=两边不可有空格)\n* 创建函数体中的局部变量: ** local name=\"test\"**,函数体及整个脚本中的变量默认都是全局变量,函数体内外皆可访问和改变,函数体内的变量最好用这个加以限制,同时为了得到命令替换的返回码时最好分开写(否则只会捕获local的成功码)：\n```bash\nlocal varname\nvarname=$(command)\nre=$?\n```\n* 使用变量: **echo $name 或者 echo $(name)** 使用时要加$,重新赋值时不需要\n* 只读变量: **name=\"only_read\" -> readonly name**\n* 删除变量: **unset name**\n  \n### 字符串变量\n字符串与变量展开有密切联系,可以参考那节\n1) 单引号\n* 单引号变量var='test',只能原样输出,不能解释变量\n* 单引号中不能出现一个单引号,转义也不行\n\n2) 双引号\n* 双引号变量`var=\"my name is ${name}\"`,可以解释变量\n* 可以出现转移字符\n\n3) 拼接字符串\n* `name=\"this is\"\"my name\";name=\"this is my name\";name=\"this\"is\"my name\"`等效\n\n4) 获取字符串长度\n```bash\necho ${#str}\n```\n  \n5) 提取子字符串\n```bash\nname=\"this is my name\";\necho ${name:1:4} #输出his\necho ${name::4} #输出this\n```\n6) 大小写\n```bash\ndeclare -u upper\ndeclare -l lower\n#upper将会强制转成SL\nupper=\"sl\"\n#lower将会强制转成sl\nlower=\"SL\"\n```\n### 数组\nbash只支持以为数组,不支持多维数组\n* 定义数组: **array_name=(li wang xiang zhang)** (小括号做边界、使用空格分离)或者**declare -a array_name**\n* 单独定义数组的元素: **arraypara[0]=\"w\";arraypara[3]=\"s\"** (定义时下标可以不连续,同样可以用于赋值)\n* 获取数组元素\n```bash\narray_name[0]=\"li\"\narray_name[3]=\"zhang\"\necho ${array_name[0]} #输出\"li\"\necho ${array_name[1]} #输出空\necho ${array_name[@]} #输出\"li zhang\"输出数组所有元素,没有元素的下标省略\n#等价于下面\necho ${array_name[*]}\n```\n* 取得元素个数:\n```bash\n${#arrayname[@]}\n#或者\n${#arrayname[\\*]}\n```\n* 取得单个元素长度: \n```bash\n${#array_name[1]}\n```\n* `for i in \"${!foo[@]}\"`取得每个非空元素的下标\n* `foo+=(d e f)`添加3个元素\n* 删除数组不能通过赋空值,只能通过unset,unset还能删除某个元素(这样后面元素往前补)\n* 没有指明数组下标的访问或赋值皆指向第一个值\n* 最新版本bash支持关联数组`declare -A colors;colors[\"red\"]=\"red\"`\n* [函数与数组](#funAndArr)\n* 取切片`echo ${array:0:3}`\n* 遍历数组\n```bash\n#方法1\nfor(( i=0;i<${#array[@]};i++)) do\necho ${array[i]};\ndone;\n#方法2\nfor element in ${array[@]}\ndo\necho $element\ndone\n#方法3\nfor i in \"${!arr[@]}\";\ndo\n    printf \"%s\\t%s\\n\" \"$i\" \"${arr[$i]}\"\ndone\n```\n- 添加数组元素\n`$arr+=(a b)`\n### 环境变量\n#### FUNCNAME\n该环境变量是个数组，存储当前位置函数调用的堆栈，当只有主程序时，个数为0,当存在调用函数时，第一个总是当前函数名，最后一个为main表示主程序\n#### BASH_SOURCE\n是一个数组，不过它的第一个元素是当前脚本名称，然后是source它的脚本，依次类推，常用如下\n```bash\n# 如果脚本是被source的话\nif [ -n \"$BASH_SOURCE\" -a \"$BASH_SOURCE\" != \"$0\" ]\nthen\n    do_something\nelse # Otherwise, run directly in the shell\n    do_other\nfi\n```\n\n### 参数传递的相关特殊变量\n\n|变量|意义|\n|:-:|:-:|\n|`$0`| 代表执行的文件名|\n|`$n`| 代表传入的第n个参数|\n|`$#`|参数个数,不包括程序名本身|\n|`$`|以一个单字符串显示所有向脚本传递的参数。即为\"$1 $2...$n\"|\n|`$@`|展开成一个从 1 开始的位置参数列表。当它被用双引号引 起来的时候，展开成一个由双引号引起来的字符串，包含了 所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个 字符（默认为一个空格）分隔开。|\n|`$*`|把所有参数当成一个大字符串|\n|`$$`| 该脚本进程ID|\n|`$!`| 后台运行的最后一个进程ID|\n|`$?`|上个调用(最后命令)返回值,0表示没有错误|\n\n有个**shift**命令可以方便处理命令行参数,每次执行该命令的时候,变量$2会移动到$1,变量$3会移动到变量$2,以此类推,$#值也会减1。例子:\n```bash\ncount=1\nwhile [[ $# -gt 0 ]];\ndo\n\techo \"Argument $count = $1\"\n\tcount=$((count + 1))\n\tshift\ndone\n```\n[getopt和getopts两个命令经常被用来处理传递的参数](#jumpopt)\n\n\n### 运算符\n### let\nlet使数字运算更方便:`let a++`,`let a+=2`\n\n#### 算数运算\n * `+ - * /`\n * 加法运算\n     * `bash val=$(expr 2 + 2)` 这么写乘号要加转义,空格也是必须\n     * `val=$[2+2]` (4个空格不是必要的,不同于条件判断)\n     * `val=$((2+2))`(4个空格不是必要的)\n\nbash支持任意进制\n\n|表示法|描述|\n|:-:|:-:|\n|number|默认10进制|\n|0number|8进制|\n|0xnumber|16进制|\n|base#number|base进制|\n\n在双括号中会被解释成数字,否则默认为字符串\n\n#### 数字关系运算符\n关系运算符只支持数字,不支持字符串,除非字符串是数字\n\n|符号|意义|\n|:-:|:-:|\n|`-eq`|相等返回true,`[$a -eq $b]`|\n|`-ne`|不相等返回true,`[$a -ne $b]`||\n|`-gt`|大于号|\n|`-lt`|小于号|\n|`-ge`|大于等于号|\n|`-le`|小于等于号|\n\n#### 字符串运算符\n\n|符号|意义|\n|:-:|:-:|\n|**=**|相等返回true,`[$a = $b]`|\n|**!=**|不相等返回true,`[$a != $b]`|\n|**-z**|字符串长度为0返回true,`[-z $b]`|\n|**-n**|字符串长度不为0返回true,`[-n $b]`|\n|**$**|不为空返回true,`[$a]`|\n\n#### 逻辑运算符\n\n|符号|意义|\n|:-:|:-:|\n|**!**|非运算,`[! false]`|\n|**&&**|与运算,`[[ $a -lt 20 ]] && [[$b -gt 100 ]]`|\n|**||**|或运算,`[[ $a -lt 20 ]] || [[$b -gt 100 ]]`,`[[ $a -lt 20 || $b -gt 100 ]]`|\n\n逻辑判断的括号\n1.`[]`:中括号旁边和运算符两边必须添加空格(可以使用，等价于test命令,本文不讲test命令,不推荐)\n2.`[[]]`:中括号旁边和运算符两边必须添加空格(字符串验证,文件名时，推荐)\n3.`(())`:中括号旁边和运算符两边必须添加空格(数字验证时，推荐)\n4.`[[]]和(())`分别是针对数学表达式和字符串表达式的加强版\n5.`[]`基本舍弃的原因，它与**&&、||、<和>**不兼容,会报错,它只能用-ne等等这些,例如下面是等价的\n`if [[ $a != 1 && $a !=2 ]]`,`if [ $a -ne 1 ] && [ $a != 2 ]`,`if [ $a -ne 1 -a $a !=2 ]`\n6.双括号支持以下额外的符号(没列全,C语言能用的都能用,包括?:)\n\n|符号|描述|\n|:-:|:-:|\n|val++|后增|\n|val--|后减|\n|++val|前增|\n|--val|前减|\n|!|逻辑求反|\n|~|位求反|\n|**|幂运算|\n|<<|左位移|\n|>>|右位移|\n|&|布尔和|\n|`|`|布尔或|\n|`||`|逻辑或|\n|&&|逻辑与|\n|=~|用于字符串的模式匹配,右边加上引号会丧失正则的含义，变成普通字符串,避免反斜杠转移，可以赋值给一个变量|\n|==|用于字符串的类型匹配(通配符等),例子`if [[ $FILE == foo.* ]]`|\n|=|用于字符串是否相同，右边一定要引号括起来，否则是模式匹配，如`*`则会永远为true|\n\n\n#### 文件运算符\nfile是代表文件名的字符串\n\n|符号|意义|\n|:-:|:-:|\n|$file1 -ef $file2|拥有相同的索引号返回True(硬连接)|\n|$file1 -nt $file2|file1新于file2返回true|\n|$file1 -ot $file2|file1早于file2返回true|\n|`[-b $file]`|是块设备文件返回true|\n|`[-c $file]`|是字符备文件返回true|\n|`[-d $file]`|是目录返回true|\n|`[-f $file]`|是普通文件返回true|\n|`[-g $file]`|设置了SGID位文件返回true|\n|`[-h $file]`|是符号链接返回true|\n|`[-G $file]`|由有效组(即当前进程用户组)ID拥有返回true|\n|`[-L $file]`|是符号链接返回true|\n|`[-k $file]`|设置了stick位文件返回true|\n|`[-N $file]`|atime和mtime一样的文件|\n|`[-p $file]`|是有名管道文件返回true|\n|`[-u $file]`|设置了SUID位文件返回true|\n|`[-O $file]`|由有效用户(即当前进程用户)件D拥有返回true|\n|`[-r $file]`|是可读文件返回true|\n|`[-w $file]`|是可写文件返回true|\n|`[-x $file]`|是可执行文件返回true|\n|`[-s $file]`|非空文件返回true|\n|`[-S $file]`|是一个网络Socket返回true|\n|`[-e $file]`|文件存在返回true|\n|`[-t $fd]`|fd是一个定向到终端/从终端定向的文件描述符。这可以被用来判断是否重定向了标准输入/错误|\n\n### 输出\n**echo**只用于字符串,自动添加换行符号`echo nanbert male 66.1234`\n**printf**不自动加换行符号,例:`printf \"%-10s %-8s %-4.2f\\n\" nanbert male 66.1234`\n\n### 流程控制\n#### if\n```bash\n#then后必须有语句,空语句可以用:\nif condition\nthen \n\tcommand1\n\t...\nelif condition\nthen\n\tcommand2\n\t...\nelse\n\tcommand3\n\t...\nfi\n```\n#### for\n```bash\nfor var in item1 item2 ... itemN\ndo \n\tcommand1\n\t...\ndone\n#等价于c语言\nfor (( expression1;expression2; expression3 ));do\n\tcommands\ndone\n```\n如果省略in，默认处理位置参数\n#### while\n```bash\nwhile condition\ndo \n\tcommand1\n\t...\ndone\n#无限循环\nwhile :\ndo\n\tcommand\ndone\n```\n#### until\n```bash\nuntil condition\ndo \n\tcommand1\n\t...\ndone\n```\n#### case\nShell case匹配一个值与一个模式,用两个分号表示break\n```bash\ncase value in\n\tpattern1)\n\t\tcommand1\n\t\t...\n\t\tcommandN\n\t\t;;\n\tpattern2)\n\t\tcommand1\n\t\t...\n\t\tcommandN\n\t\t;;\nesac\n```\n\n循环都支持**continue**和**break**,`break n`则可以指定跳出n层循环,n默认为1\n,continue也支持数字。\n### 定义函数\n* 函数定义\n```bash\nfunction fun(){\n\taction;\n\t[return int;]\n}\n#等价于下面\nfun1(){\n\taction;\n\t[return int;]\n}\n```\n* 参数传递\n函数中直接使用特殊变量来获取参数,可以加上{}\n```bash\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\necho $?  # 判断执行是否成功\n```\n* 函数返回值\n    * 返回值是可选的\n\t* return只能为**return [0-255]**,可通过$?获取该值\n\t* 如果不加return,则最后一条语句的执行状态为返回值,0为成功\n\t* 如果用反引号执行函数,结果是函数内的所有输出而非返回值\n* [函数与数组](#funAndArr)\n\n- 函数本质上是一组命令集合,不一定用大括号括起来,更多见shell例子\n- 可以使用`declare -F | sed 's/declare -f//'`来查看当前脚本定义的函数\n### 读取外部输入\n`read arg`从键盘读取输入并赋值给arg\n\n|选项|说明|\n|:-:|:-:|\n|-a array|把输入赋值到数组array中|\n|-d delimiter|用字符串delimiter中的第一个字符指示输入结束,而不是一个换行符|\n|-e|使用readline来处理输入|\n|-n num|读取num个输入字符,而不是整行|\n|-p prompt|为输入显示提示信息,使用字符串prompt|\n|-r |Raw mode,不把反斜杠解释为转义字符|\n|-s |Silent mode,不会在屏幕上显示输入的字符。输入密码的时候很有用|\n|-t seconds|超过时间，终止输入,read会非0状态退出|\n|-u fd|使用文件描述符fd中的输入,而不是标准输入|\n|-k n|只读n个字节|\n\nIFS是字段分割符,默认为空格,tab,换行符。可以自行改变。如下:\n`IFS=:`改成冒号\n`IFS=$'\\n':;\"`改成换行符、冒号、分号和双引号\nread不应该使用管道线来接受赋值，如下是错误的:\n```bash\necho \"$file_info\" | IFS=\":\" read user pw uid gid name home shell\n```\n而应该这么写\n```bash\nIFS=\":\" read user pw uid gid name home shell <<< \"$file_info\"\n```\n这是因为管道线会开个子进程,子进程变量的变化不会影响父进程,可以用[进程替换](#jump)解决\n如果输入的数多余接受的变量,则多出来的会保存在变量REPLY中\n\n### 包含其他shell文件\n* `. filepath/filename`\n* `source filepath/filename`\n\n### 颜色标识\n```bash\nprintf  \"\\033[32m SUCCESS: yay \\033[0m\\n\";\nprintf  \"\\033[33m WARNING: hmm \\033[0m\\n\";\nprintf  \"\\033[31m ERROR: fubar \\033[0m\\n\";\n```\n具体内容有待研究\n\n### 长句换行\n在shell中为避免一个语句过长,可以使用\"\\\"进行换行,注意\"\\\"前加一个空格,之后无空格直接换行。\n\n### 退出脚本\n`exit [num]`num为0表示执行成功,可以不加num\n`set -e 或 set +e`set -e表示从当前位置开始,如果出现任何错误都将触发exit。相反,set +e表示不管出现任何错误继续执行脚本\n\n### 调试\n-n表示检查有无语法错误,-x表示调试\n\n### 变量展开\n\n|操作符|意义|\n|:-:|:-:|\n|`:${parameter:=word}`|如果parameter没有设置或者为空,展开的结果是word的值,并且word的值会赋给parameter;否则展开为parameter的值|\n|`${parameter:-word}`|如果parameter没有设置或者为空,展开的结果是word的值,否则是parameter的值|\n| `${parameter:?word}` |如果parameter没有设置或者为空,会带有错误的推出,否则是parameter的值|\n| `${parameter:+word}` |如果parameter没有设置或者为空,展开为空,否则是word的值;不管如何parameter值不会变|\n|`${parameter#pattern}`|pattern是通配符模式,会从parameter开头开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上|\n|`${parameter##pattern}`|pattern是通配符模式,会从parameter开头开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上|\n|`${parameter%pattern}`|pattern是通配符模式,会从parameter结尾开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上|\n|`${parameter%%pattern}`|pattern是通配符模式,会从parameter结尾开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上|\n|`${parameter/pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,只替换第一次匹配到的|\n|`${parameter//pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,替换所有匹配到的|\n|`${parameter/#pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter开头开始匹配,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上|\n|`${parameter/%pattern/string}`|在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter结尾开始匹配,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上|\n|`${parameter,,}`|把parameter全部展开成小写字母|\n|`${parameter,}`|把parameter首字母展开成小写字母|\n|`${parameter^^}`|把parameter全部展开成大写字母|\n|`${parameter^}`|把parameter首字母展开成大写字母|\n\n\n`${!prefix*}`等价于`${!prefix@}`这种展开会返回以prefix开头的已有变量名(而不是变量的值)\n字符串的长度和切片其实也是一种展开\n\n<span id = \"jump\"></span>\n### 进程替换\n进程替换可以用来解决子进程问题,它实质是把子进程的输出当作一个用于重定向的普通文件(文件描述符)。\n标准输出\n`<(cmd1;cmd2)`\n标准输入\n`>(cmd1;cmd2)`\n由此可以解决read管道线的问题\n```bash\nwhile read attr links owner group size date time filename;do\n\tcat <<- EOF\n\t\tFilename: $filename\n\t\tSize:     $size\n\t\tOwner:    $owner\n\t\tGroup:    $group\n\t\tModified: $date $time\n\t\tLinks:    $links\n\t\tAttributes: $attr\n\tEOF\ndone < <(ls -l | tail -n +2)\n```\n<span id = \"jumpopt\"></span>\n### getopt和getopts\n\n#### getopt\n格式:`getopt [options] optstring parameters`,例:\n`getopt ab:cd -a -b test1 -cd test2 test3`该命令会产生如下输出:\n`-a -b test1 -c -d -- test2 test3`,optstring定义了四个有效项字母:a、b、c和d。冒号(:)表示b选项需要个参数值,它会将-cd选项分成两个单独选项,插入'--'来分隔额外的参数,如果提供'-cde'由于e不在optstring中,会报错**getopt: invalid option -- e**,但还会输出结果,可以加-q选项忽略报错结果。\n在脚本中经常与set的'--'选项来使用,来把getopt的输出转成当前脚本的输入参数,示例如下:\n```bash\n#!/bin/bash\n# Extract command line options & values with getopt\n#\nset -- $(getopt -q ab:cd \"$@\")\n#\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n    -a) echo \"Found the -a option\" ;;\n    -b) param=\"$2\"\n        echo \"Found the -b option, with parameter value $param\"\n        shift ;;\n    -c) echo \"Found the -c option\" ;;\n    --) shift\n        break ;;\n    *) echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n#\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Parameter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\n#\n```\n\n#### getopts\n格式:`getopts optstring variable`,这里variable为命令行上检测到的第一个参数(getopts会去除'-',这点与getopt不同),处理完所有参数后,它会返回一个大于0的退出状态码。可以用\":optstring\"格式来忽略未识别选项的错误信息。会用到两个环境变量,如果选项用到一个参数值,OPTARG会保存该值,OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。\ngetopts可以识别双引号内的带括号参数值,而getopt不可以。getopts将命令行上找到的所有未定义选项统一输成问号,getopt遇到未识别的非选项值时,会结束识别,即使后面有正确的选项。可以用以下脚本自行测试getopts的行为:\n```bash\necho\nwhile getopts :ab:cd opt\ndo\n    case \"$opt\" in\n        a) echo \"Found the -a option\"  ;;\n        b) echo \"Found the -b option, with value $OPTARG\" ;;\n        c) echo \"Found the -c option\"  ;;\n        d) echo \"Found the -d option\"  ;;\n        *) echo \"Unknown option: $opt\" ;;\n    esac\ndone\n#\nshift $[ $OPTIND - 1 ]\n#\necho\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Parameter $count: $param\"\n    count=$[ $count + 1 ]\ndone\n```\n### set命令\nset 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。可以使用`echo $-`查看当前设置,默认是（himxBH）\n参数说明：\n\n|参数|说明|\n|:-:||:-:|\n|-a|标示已修改的变量，以供输出至环境变量|\n|-b|使被中止的后台程序立刻回报执行状态|\n|-B|启用大括号展开|\n|-d|Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消|\n|-e|若指令传回值不等于0，则立即退出shell|\n|-f|取消使用通配符|\n|-h|自动缓存命令的所在位置,如果在PATH指定路径内，更换命令的位置,缓存就不会同步，就会发生错误，不过谁会换命令的位置呢,可以使用which更新缓存|\n|-i|设置当前选项为交互式|\n|-k|指令所给的参数都会被视为此指令的环境变量|\n|-l|记录for循环的变量名称|\n|-m|使用监视模式,可以控制进程的停止、继续、后台前台等，默认打开|\n|-n|测试模式，只读取指令，而不实际执行|\n|-p|启动优先顺序模式|\n|-P|启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接|\n|-t|执行完随后的指令，即退出shell|\n|-u|当执行时使用到未定义过的变量，则显示错误信息|\n|-v|显示shell所读取的输入值|\n|-H shell|可利用\"!\"加<指令编号>的方式来执行 history 中记录的指令,最好不用|\n|-x|执行指令后，会先显示该指令及所下的参数|\n|+<参数>|取消某个set曾启动的参数。与-<参数>相反|\n|-o [option]|特殊属性有很多,见下面|\n\n**option属性**\n- pipefail:管道流水线中有一个失败，则返回失败值，从右往左数起(默认只返回最后一个命令的退出码)\n- noclobber:防止>重定向操作符覆盖已有内容，你可以使用`command >| file`强制覆盖\n\n### Tips\n* 波浪号展开只能**紧跟**在`=`和`:`之后才能正确展开,引号中无法正确展开\n* **<<**和**<<-**的区别在于,<<-会忽略接下来输入的tab建,一般用于格式化脚本,便于读代码\n* 组命令(在当前shell执行)--`{ command1;command2;command3  }`,子shell--`(command1;command2;command3)`一般配合管道符\n* trap命令\n`trap \"命令\" \"信号\"`当脚本遇到信号前执行的命令\n```bash\ntrap \"echo I am ignoring you\" SIGINT SIGTERM\n```\n常见信号有:\n\n|编号|英文名|含义|\n|:-:|:-:|:-:|\n|1|SIGHUP|挂起进程|\n|2|SIGINT|终止进程|\n|3|SIGQUIT|停止进程|\n|9|SIGKILL|无条件终止进程|\n|15|SIGTERM|尽可能终止进程|\n|17|SIGSTOP|无条件停止进程,但不是终止进程|\n|18|IGTSTP|停止或暂停进程,但不终止进程|\n|19|SIGCONT|继续运行停止的进程|\n\n    * tap除了捕获信号外,还会捕获脚本退出:`trap \"echo Goodbye...\" EXIT`,不管正常还是非正常,都会打印Goodbye\n    * `trap -- SIGINT`取消某个信号的设置\n\t* `trap -`恢复信号的默认行为\n* wait命令\n`wait $pid`等待子进程\n```bash\n#小火车子进程\nsl &\npid=$!\n#父进程继续干事\nsleep 2\n#干完事等子进程\nwait $pid\necho \"子父进程都结束了\"\n```\n* 命名管道\n```bash\n#创建一个命名管道文件\nmkfifo pipe1\n#子进程写入(写入完会阻塞,等待另一端读,所以不要wait)\nls -l > pipe1 &\n#父进程读\nsleep 5\ncat<pipe1\n```\n- IFS默认是空白字符(回车，空格，制表符等)，位于字符串和结尾的空白字符都被删除，中间连续空格会被压缩成一个\n* 子shell的全局环境变量改变并不会影响父shell,甚至用export也不行\n* 命令替换`$(command)`,子shell`(command)`两个是不同概念,命令替换会开个子shell(貌似都会开子shell)\n* 文件描述符与exec\n    * 配合exec可以使标准输入输出永久重定向:`exec 2>testerror`重定向标准错误至文件。\n    * exec可以创建文件描述:`exec 3>testxx;echo hello>&3`这可以用来恢复正常的输入输出,如下:\n```bash\nexec 3>&1\nexec 1>test14out\necho \"这会输入到test14out\"\nexec 1>&3\necho \"这会输入到屏幕\"\n```\n    * exec创建读写描述符:`exec 3<>testfile`,这要特别小心,任何读或写都会从文件指针的上次位置开始\n    * exec关闭文件描述符:`exec 3>&-`\n\t* lsof命令可以查看已经打开的文件描述符,见Linux命令博客\n\n<span id = \"funAndArr\"></span>\n* 函数与数组\n将数组变量当作但个参数传递的话,它不会其作用,只会传递第一个值,可以借鉴以下例子:\n```bash\n#!/bin/bash\n# array variable to function test\nfunction testit {\n    local newarray\n    newarray=`echo \"$@\"`\n    echo \"The new array value is: ${newarray[*]}\"\n}\nmyarray=(1 2 3 4 5)\necho \"The original array is ${myarray[*]}\"\ntestit ${myarray[*]}\n```\n* 预处理替换优先级\na.shell替换:文件通配符\nb.变量替换\nc.命令替换,如下示例:  \n\n* shell元字符汇总\n  \n|符号|意义|\n|:-:|:-:|\n|空格、制表符| 命令行参数的分隔符|\n|回车| 执行键入的命令|\n|&lt; > &brvbar;| 重定向与管道|\n|; |多个命令分隔符|\n|& |后台运行|\n|$ |引用shell的变量|\n|\\`| 命令替换,`\\\\`代表反斜线自身,`\\``代表反撇号自身|\n|\\* [] ?| 文件通配符,不匹配\\*和/|\n|()| 用于定义shell函数或子shell中执行命令|\n|\\\\| 转义字符取消元字符特殊含义，若不用于元字符跟不加一样|\n|\" \"| 其中的内容除$和\\`外取消元字符的特殊含义|\n|' '| 取消所有元字符特殊含义|\n\n* RANDOM是个内建的随机值\n* `<<<`\nhere-string语法，允许直接传递字符串给标准输入\n* eval\neval 的功能是将字符串作为代码来执行。看上去好像很简单，但实际涉及很复杂的内容，主要是符号转义导致的语义问题。\n```\nstr1=str2\nstr2=abc\neval echo \\$$str1\n```\n","slug":"shell基本概念","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi77001rgwq2f9i6bv72","content":"<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ul>\n<li>单行注释: #</li>\n<li>多行注释:  <code>:&lt;&lt;EOF ... EOF</code>或者 <code>:&lt;&lt;! ... !</code></li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li>创建普通变量: <strong>name&#x3D;”test”</strong> (&#x3D;两边不可有空格)</li>\n<li>创建函数体中的局部变量: ** local name&#x3D;”test”**,函数体及整个脚本中的变量默认都是全局变量,函数体内外皆可访问和改变,函数体内的变量最好用这个加以限制,同时为了得到命令替换的返回码时最好分开写(否则只会捕获local的成功码)：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">local</span> varname<br>varname=$(<span class=\"hljs-built_in\">command</span>)<br>re=$?<br></code></pre></td></tr></table></figure></li>\n<li>使用变量: <strong>echo $name 或者 echo $(name)</strong> 使用时要加$,重新赋值时不需要</li>\n<li>只读变量: <strong>name&#x3D;”only_read” -&gt; readonly name</strong></li>\n<li>删除变量: <strong>unset name</strong></li>\n</ul>\n<h3 id=\"字符串变量\"><a href=\"#字符串变量\" class=\"headerlink\" title=\"字符串变量\"></a>字符串变量</h3><p>字符串与变量展开有密切联系,可以参考那节</p>\n<ol>\n<li>单引号</li>\n</ol>\n<ul>\n<li>单引号变量var&#x3D;’test’,只能原样输出,不能解释变量</li>\n<li>单引号中不能出现一个单引号,转义也不行</li>\n</ul>\n<ol start=\"2\">\n<li>双引号</li>\n</ol>\n<ul>\n<li>双引号变量<code>var=&quot;my name is $&#123;name&#125;&quot;</code>,可以解释变量</li>\n<li>可以出现转移字符</li>\n</ul>\n<ol start=\"3\">\n<li>拼接字符串</li>\n</ol>\n<ul>\n<li><code>name=&quot;this is&quot;&quot;my name&quot;;name=&quot;this is my name&quot;;name=&quot;this&quot;is&quot;my name&quot;</code>等效</li>\n</ul>\n<ol start=\"4\">\n<li><p>获取字符串长度</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;#str&#125;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>提取子字符串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">name=<span class=\"hljs-string\">&quot;this is my name&quot;</span>;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;name:1:4&#125;</span> <span class=\"hljs-comment\">#输出his</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;name::4&#125;</span> <span class=\"hljs-comment\">#输出this</span><br></code></pre></td></tr></table></figure></li>\n<li><p>大小写</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">declare</span> -u upper<br><span class=\"hljs-built_in\">declare</span> -l lower<br><span class=\"hljs-comment\">#upper将会强制转成SL</span><br>upper=<span class=\"hljs-string\">&quot;sl&quot;</span><br><span class=\"hljs-comment\">#lower将会强制转成sl</span><br>lower=<span class=\"hljs-string\">&quot;SL&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>bash只支持以为数组,不支持多维数组</p>\n<ul>\n<li>定义数组: <strong>array_name&#x3D;(li wang xiang zhang)</strong> (小括号做边界、使用空格分离)或者<strong>declare -a array_name</strong></li>\n<li>单独定义数组的元素: <strong>arraypara[0]&#x3D;”w”;arraypara[3]&#x3D;”s”</strong> (定义时下标可以不连续,同样可以用于赋值)</li>\n<li>获取数组元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array_name[0]=<span class=\"hljs-string\">&quot;li&quot;</span><br>array_name[3]=<span class=\"hljs-string\">&quot;zhang&quot;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[0]&#125;</span> <span class=\"hljs-comment\">#输出&quot;li&quot;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[1]&#125;</span> <span class=\"hljs-comment\">#输出空</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[@]&#125;</span> <span class=\"hljs-comment\">#输出&quot;li zhang&quot;输出数组所有元素,没有元素的下标省略</span><br><span class=\"hljs-comment\">#等价于下面</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>取得元素个数:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$&#123;#arrayname[@]&#125;</span><br><span class=\"hljs-comment\">#或者</span><br><span class=\"hljs-variable\">$&#123;#arrayname[\\*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>取得单个元素长度: <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$&#123;#array_name[1]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li><code>for i in &quot;$&#123;!foo[@]&#125;&quot;</code>取得每个非空元素的下标</li>\n<li><code>foo+=(d e f)</code>添加3个元素</li>\n<li>删除数组不能通过赋空值,只能通过unset,unset还能删除某个元素(这样后面元素往前补)</li>\n<li>没有指明数组下标的访问或赋值皆指向第一个值</li>\n<li>最新版本bash支持关联数组<code>declare -A colors;colors[&quot;red&quot;]=&quot;red&quot;</code></li>\n<li><a href=\"#funAndArr\">函数与数组</a></li>\n<li>取切片<code>echo $&#123;array:0:3&#125;</code></li>\n<li>遍历数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#方法1</span><br><span class=\"hljs-keyword\">for</span>(( i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-variable\">$&#123;#array[@]&#125;</span>;i++)) <span class=\"hljs-keyword\">do</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array[i]&#125;</span>;<br><span class=\"hljs-keyword\">done</span>;<br><span class=\"hljs-comment\">#方法2</span><br><span class=\"hljs-keyword\">for</span> element <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable\">$&#123;array[@]&#125;</span><br><span class=\"hljs-keyword\">do</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$element</span><br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#方法3</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;!arr[@]&#125;</span>&quot;</span>;<br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">printf</span> <span class=\"hljs-string\">&quot;%s\\t%s\\n&quot;</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$i</span>&quot;</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;arr[$i]&#125;</span>&quot;</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>添加数组元素<br><code>$arr+=(a b)</code></li>\n</ul>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><h4 id=\"FUNCNAME\"><a href=\"#FUNCNAME\" class=\"headerlink\" title=\"FUNCNAME\"></a>FUNCNAME</h4><p>该环境变量是个数组，存储当前位置函数调用的堆栈，当只有主程序时，个数为0,当存在调用函数时，第一个总是当前函数名，最后一个为main表示主程序</p>\n<h4 id=\"BASH-SOURCE\"><a href=\"#BASH-SOURCE\" class=\"headerlink\" title=\"BASH_SOURCE\"></a>BASH_SOURCE</h4><p>是一个数组，不过它的第一个元素是当前脚本名称，然后是source它的脚本，依次类推，常用如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 如果脚本是被source的话</span><br><span class=\"hljs-keyword\">if</span> [ -n <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$BASH_SOURCE</span>&quot;</span> -a <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$BASH_SOURCE</span>&quot;</span> != <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$0</span>&quot;</span> ]<br><span class=\"hljs-keyword\">then</span><br>    do_something<br><span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\"># Otherwise, run directly in the shell</span><br>    do_other<br><span class=\"hljs-keyword\">fi</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数传递的相关特殊变量\"><a href=\"#参数传递的相关特殊变量\" class=\"headerlink\" title=\"参数传递的相关特殊变量\"></a>参数传递的相关特殊变量</h3><table>\n<thead>\n<tr>\n<th align=\"center\">变量</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>$0</code></td>\n<td align=\"center\">代表执行的文件名</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$n</code></td>\n<td align=\"center\">代表传入的第n个参数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$#</code></td>\n<td align=\"center\">参数个数,不包括程序名本身</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$</code></td>\n<td align=\"center\">以一个单字符串显示所有向脚本传递的参数。即为”$1 $2…$n”</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$@</code></td>\n<td align=\"center\">展开成一个从 1 开始的位置参数列表。当它被用双引号引 起来的时候，展开成一个由双引号引起来的字符串，包含了 所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个 字符（默认为一个空格）分隔开。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$*</code></td>\n<td align=\"center\">把所有参数当成一个大字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$$</code></td>\n<td align=\"center\">该脚本进程ID</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$!</code></td>\n<td align=\"center\">后台运行的最后一个进程ID</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$?</code></td>\n<td align=\"center\">上个调用(最后命令)返回值,0表示没有错误</td>\n</tr>\n</tbody></table>\n<p>有个<strong>shift</strong>命令可以方便处理命令行参数,每次执行该命令的时候,变量$2会移动到$1,变量$3会移动到变量$2,以此类推,$#值也会减1。例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">count=1<br><span class=\"hljs-keyword\">while</span> [[ <span class=\"hljs-variable\">$#</span> -gt 0 ]];<br><span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Argument <span class=\"hljs-variable\">$count</span> = <span class=\"hljs-variable\">$1</span>&quot;</span><br>\tcount=$((count + <span class=\"hljs-number\">1</span>))<br>\t<span class=\"hljs-built_in\">shift</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<p><a href=\"#jumpopt\">getopt和getopts两个命令经常被用来处理传递的参数</a></p>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>let使数字运算更方便:<code>let a++</code>,<code>let a+=2</code></p>\n<h4 id=\"算数运算\"><a href=\"#算数运算\" class=\"headerlink\" title=\"算数运算\"></a>算数运算</h4><ul>\n<li><code>+ - * /</code></li>\n<li>加法运算<ul>\n<li><code>bash val=$(expr 2 + 2)</code> 这么写乘号要加转义,空格也是必须</li>\n<li><code>val=$[2+2]</code> (4个空格不是必要的,不同于条件判断)</li>\n<li><code>val=$((2+2))</code>(4个空格不是必要的)</li>\n</ul>\n</li>\n</ul>\n<p>bash支持任意进制</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表示法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">number</td>\n<td align=\"center\">默认10进制</td>\n</tr>\n<tr>\n<td align=\"center\">0number</td>\n<td align=\"center\">8进制</td>\n</tr>\n<tr>\n<td align=\"center\">0xnumber</td>\n<td align=\"center\">16进制</td>\n</tr>\n<tr>\n<td align=\"center\">base#number</td>\n<td align=\"center\">base进制</td>\n</tr>\n</tbody></table>\n<p>在双括号中会被解释成数字,否则默认为字符串</p>\n<h4 id=\"数字关系运算符\"><a href=\"#数字关系运算符\" class=\"headerlink\" title=\"数字关系运算符\"></a>数字关系运算符</h4><p>关系运算符只支持数字,不支持字符串,除非字符串是数字</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>-eq</code></td>\n<td align=\"center\">相等返回true,<code>[$a -eq $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>-ne</code></td>\n<td align=\"center\">不相等返回true,<code>[$a -ne $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>-gt</code></td>\n<td align=\"center\">大于号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-lt</code></td>\n<td align=\"center\">小于号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-ge</code></td>\n<td align=\"center\">大于等于号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-le</code></td>\n<td align=\"center\">小于等于号</td>\n</tr>\n</tbody></table>\n<h4 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h4><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>&#x3D;</strong></td>\n<td align=\"center\">相等返回true,<code>[$a = $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>!&#x3D;</strong></td>\n<td align=\"center\">不相等返回true,<code>[$a != $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>-z</strong></td>\n<td align=\"center\">字符串长度为0返回true,<code>[-z $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>-n</strong></td>\n<td align=\"center\">字符串长度不为0返回true,<code>[-n $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>$</strong></td>\n<td align=\"center\">不为空返回true,<code>[$a]</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h4><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>!</strong></td>\n<td align=\"center\">非运算,<code>[! false]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>&amp;&amp;</strong></td>\n<td align=\"center\">与运算,<code>[[ $a -lt 20 ]] &amp;&amp; [[$b -gt 100 ]]</code></td>\n</tr>\n<tr>\n<td align=\"center\">**</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>逻辑判断的括号<br>1.<code>[]</code>:中括号旁边和运算符两边必须添加空格(可以使用，等价于test命令,本文不讲test命令,不推荐)<br>2.<code>[[]]</code>:中括号旁边和运算符两边必须添加空格(字符串验证,文件名时，推荐)<br>3.<code>(())</code>:中括号旁边和运算符两边必须添加空格(数字验证时，推荐)<br>4.<code>[[]]和(())</code>分别是针对数学表达式和字符串表达式的加强版<br>5.<code>[]</code>基本舍弃的原因，它与**&amp;&amp;、||、&lt;和&gt;**不兼容,会报错,它只能用-ne等等这些,例如下面是等价的<br><code>if [[ $a != 1 &amp;&amp; $a !=2 ]]</code>,<code>if [ $a -ne 1 ] &amp;&amp; [ $a != 2 ]</code>,<code>if [ $a -ne 1 -a $a !=2 ]</code><br>6.双括号支持以下额外的符号(没列全,C语言能用的都能用,包括?:)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">val++</td>\n<td align=\"center\">后增</td>\n</tr>\n<tr>\n<td align=\"center\">val–</td>\n<td align=\"center\">后减</td>\n</tr>\n<tr>\n<td align=\"center\">++val</td>\n<td align=\"center\">前增</td>\n</tr>\n<tr>\n<td align=\"center\">–val</td>\n<td align=\"center\">前减</td>\n</tr>\n<tr>\n<td align=\"center\">!</td>\n<td align=\"center\">逻辑求反</td>\n</tr>\n<tr>\n<td align=\"center\">~</td>\n<td align=\"center\">位求反</td>\n</tr>\n<tr>\n<td align=\"center\">**</td>\n<td align=\"center\">幂运算</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;&lt;</td>\n<td align=\"center\">左位移</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;&gt;</td>\n<td align=\"center\">右位移</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;</td>\n<td align=\"center\">布尔和</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">&amp;&amp;</td>\n<td align=\"center\">逻辑与</td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;~</td>\n<td align=\"center\">用于字符串的模式匹配,右边加上引号会丧失正则的含义，变成普通字符串,避免反斜杠转移，可以赋值给一个变量</td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;&#x3D;</td>\n<td align=\"center\">用于字符串的类型匹配(通配符等),例子<code>if [[ $FILE == foo.* ]]</code></td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;</td>\n<td align=\"center\">用于字符串是否相同，右边一定要引号括起来，否则是模式匹配，如<code>*</code>则会永远为true</td>\n</tr>\n</tbody></table>\n<h4 id=\"文件运算符\"><a href=\"#文件运算符\" class=\"headerlink\" title=\"文件运算符\"></a>文件运算符</h4><p>file是代表文件名的字符串</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$file1 -ef $file2</td>\n<td align=\"center\">拥有相同的索引号返回True(硬连接)</td>\n</tr>\n<tr>\n<td align=\"center\">$file1 -nt $file2</td>\n<td align=\"center\">file1新于file2返回true</td>\n</tr>\n<tr>\n<td align=\"center\">$file1 -ot $file2</td>\n<td align=\"center\">file1早于file2返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-b $file]</code></td>\n<td align=\"center\">是块设备文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-c $file]</code></td>\n<td align=\"center\">是字符备文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-d $file]</code></td>\n<td align=\"center\">是目录返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-f $file]</code></td>\n<td align=\"center\">是普通文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-g $file]</code></td>\n<td align=\"center\">设置了SGID位文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-h $file]</code></td>\n<td align=\"center\">是符号链接返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-G $file]</code></td>\n<td align=\"center\">由有效组(即当前进程用户组)ID拥有返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-L $file]</code></td>\n<td align=\"center\">是符号链接返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-k $file]</code></td>\n<td align=\"center\">设置了stick位文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-N $file]</code></td>\n<td align=\"center\">atime和mtime一样的文件</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-p $file]</code></td>\n<td align=\"center\">是有名管道文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-u $file]</code></td>\n<td align=\"center\">设置了SUID位文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-O $file]</code></td>\n<td align=\"center\">由有效用户(即当前进程用户)件D拥有返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-r $file]</code></td>\n<td align=\"center\">是可读文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-w $file]</code></td>\n<td align=\"center\">是可写文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-x $file]</code></td>\n<td align=\"center\">是可执行文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-s $file]</code></td>\n<td align=\"center\">非空文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-S $file]</code></td>\n<td align=\"center\">是一个网络Socket返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-e $file]</code></td>\n<td align=\"center\">文件存在返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-t $fd]</code></td>\n<td align=\"center\">fd是一个定向到终端&#x2F;从终端定向的文件描述符。这可以被用来判断是否重定向了标准输入&#x2F;错误</td>\n</tr>\n</tbody></table>\n<h3 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h3><p><strong>echo</strong>只用于字符串,自动添加换行符号<code>echo nanbert male 66.1234</code><br><strong>printf</strong>不自动加换行符号,例:<code>printf &quot;%-10s %-8s %-4.2f\\n&quot; nanbert male 66.1234</code></p>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><h4 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#then后必须有语句,空语句可以用:</span><br><span class=\"hljs-keyword\">if</span> condition<br><span class=\"hljs-keyword\">then</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">elif</span> condition<br><span class=\"hljs-keyword\">then</span><br>\tcommand2<br>\t...<br><span class=\"hljs-keyword\">else</span><br>\tcommand3<br>\t...<br><span class=\"hljs-keyword\">fi</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> var <span class=\"hljs-keyword\">in</span> item1 item2 ... itemN<br><span class=\"hljs-keyword\">do</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#等价于c语言</span><br><span class=\"hljs-keyword\">for</span> (( expression1;expression2; expression3 ));<span class=\"hljs-keyword\">do</span><br>\tcommands<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<p>如果省略in，默认处理位置参数</p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> condition<br><span class=\"hljs-keyword\">do</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#无限循环</span><br><span class=\"hljs-keyword\">while</span> :<br><span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">command</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"until\"><a href=\"#until\" class=\"headerlink\" title=\"until\"></a>until</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">until</span> condition<br><span class=\"hljs-keyword\">do</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"case\"><a href=\"#case\" class=\"headerlink\" title=\"case\"></a>case</h4><p>Shell case匹配一个值与一个模式,用两个分号表示break</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">case</span> value <span class=\"hljs-keyword\">in</span><br>\tpattern1)<br>\t\tcommand1<br>\t\t...<br>\t\tcommandN<br>\t\t;;<br>\tpattern2)<br>\t\tcommand1<br>\t\t...<br>\t\tcommandN<br>\t\t;;<br><span class=\"hljs-keyword\">esac</span><br></code></pre></td></tr></table></figure>\n\n<p>循环都支持<strong>continue</strong>和<strong>break</strong>,<code>break n</code>则可以指定跳出n层循环,n默认为1<br>,continue也支持数字。</p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><ul>\n<li>函数定义<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span></span>()&#123;<br>\taction;<br>\t[<span class=\"hljs-built_in\">return</span> int;]<br>&#125;<br><span class=\"hljs-comment\">#等价于下面</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">fun1</span></span>()&#123;<br>\taction;<br>\t[<span class=\"hljs-built_in\">return</span> int;]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>参数传递<br>函数中直接使用特殊变量来获取参数,可以加上{}<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-function\"><span class=\"hljs-title\">funWithParam</span></span>()&#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第一个参数为 <span class=\"hljs-variable\">$1</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第二个参数为 <span class=\"hljs-variable\">$2</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第十个参数为 <span class=\"hljs-variable\">$10</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第十个参数为 <span class=\"hljs-variable\">$&#123;10&#125;</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第十一个参数为 <span class=\"hljs-variable\">$&#123;11&#125;</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;参数总数有 <span class=\"hljs-variable\">$#</span> 个!&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;作为一个字符串输出所有参数 $* !&quot;</span>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br><span class=\"hljs-built_in\">echo</span> $?  <span class=\"hljs-comment\"># 判断执行是否成功</span><br></code></pre></td></tr></table></figure></li>\n<li>函数返回值<ul>\n<li>返回值是可选的</li>\n<li>return只能为<strong>return [0-255]</strong>,可通过$?获取该值</li>\n<li>如果不加return,则最后一条语句的执行状态为返回值,0为成功</li>\n<li>如果用反引号执行函数,结果是函数内的所有输出而非返回值</li>\n</ul>\n</li>\n<li><a href=\"#funAndArr\">函数与数组</a></li>\n</ul>\n<ul>\n<li>函数本质上是一组命令集合,不一定用大括号括起来,更多见shell例子</li>\n<li>可以使用<code>declare -F | sed &#39;s/declare -f//&#39;</code>来查看当前脚本定义的函数</li>\n</ul>\n<h3 id=\"读取外部输入\"><a href=\"#读取外部输入\" class=\"headerlink\" title=\"读取外部输入\"></a>读取外部输入</h3><p><code>read arg</code>从键盘读取输入并赋值给arg</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a array</td>\n<td align=\"center\">把输入赋值到数组array中</td>\n</tr>\n<tr>\n<td align=\"center\">-d delimiter</td>\n<td align=\"center\">用字符串delimiter中的第一个字符指示输入结束,而不是一个换行符</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">使用readline来处理输入</td>\n</tr>\n<tr>\n<td align=\"center\">-n num</td>\n<td align=\"center\">读取num个输入字符,而不是整行</td>\n</tr>\n<tr>\n<td align=\"center\">-p prompt</td>\n<td align=\"center\">为输入显示提示信息,使用字符串prompt</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">Raw mode,不把反斜杠解释为转义字符</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">Silent mode,不会在屏幕上显示输入的字符。输入密码的时候很有用</td>\n</tr>\n<tr>\n<td align=\"center\">-t seconds</td>\n<td align=\"center\">超过时间，终止输入,read会非0状态退出</td>\n</tr>\n<tr>\n<td align=\"center\">-u fd</td>\n<td align=\"center\">使用文件描述符fd中的输入,而不是标准输入</td>\n</tr>\n<tr>\n<td align=\"center\">-k n</td>\n<td align=\"center\">只读n个字节</td>\n</tr>\n</tbody></table>\n<p>IFS是字段分割符,默认为空格,tab,换行符。可以自行改变。如下:<br><code>IFS=:</code>改成冒号<br><code>IFS=$&#39;\\n&#39;:;&quot;</code>改成换行符、冒号、分号和双引号<br>read不应该使用管道线来接受赋值，如下是错误的:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$file_info</span>&quot;</span> | IFS=<span class=\"hljs-string\">&quot;:&quot;</span> <span class=\"hljs-built_in\">read</span> user pw uid gid name home shell<br></code></pre></td></tr></table></figure>\n<p>而应该这么写</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">IFS=<span class=\"hljs-string\">&quot;:&quot;</span> <span class=\"hljs-built_in\">read</span> user pw uid gid name home shell &lt;&lt;&lt; <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$file_info</span>&quot;</span><br></code></pre></td></tr></table></figure>\n<p>这是因为管道线会开个子进程,子进程变量的变化不会影响父进程,可以用<a href=\"#jump\">进程替换</a>解决<br>如果输入的数多余接受的变量,则多出来的会保存在变量REPLY中</p>\n<h3 id=\"包含其他shell文件\"><a href=\"#包含其他shell文件\" class=\"headerlink\" title=\"包含其他shell文件\"></a>包含其他shell文件</h3><ul>\n<li><code>. filepath/filename</code></li>\n<li><code>source filepath/filename</code></li>\n</ul>\n<h3 id=\"颜色标识\"><a href=\"#颜色标识\" class=\"headerlink\" title=\"颜色标识\"></a>颜色标识</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">printf</span>  <span class=\"hljs-string\">&quot;\\033[32m SUCCESS: yay \\033[0m\\n&quot;</span>;<br><span class=\"hljs-built_in\">printf</span>  <span class=\"hljs-string\">&quot;\\033[33m WARNING: hmm \\033[0m\\n&quot;</span>;<br><span class=\"hljs-built_in\">printf</span>  <span class=\"hljs-string\">&quot;\\033[31m ERROR: fubar \\033[0m\\n&quot;</span>;<br></code></pre></td></tr></table></figure>\n<p>具体内容有待研究</p>\n<h3 id=\"长句换行\"><a href=\"#长句换行\" class=\"headerlink\" title=\"长句换行\"></a>长句换行</h3><p>在shell中为避免一个语句过长,可以使用”&quot;进行换行,注意”&quot;前加一个空格,之后无空格直接换行。</p>\n<h3 id=\"退出脚本\"><a href=\"#退出脚本\" class=\"headerlink\" title=\"退出脚本\"></a>退出脚本</h3><p><code>exit [num]</code>num为0表示执行成功,可以不加num<br><code>set -e 或 set +e</code>set -e表示从当前位置开始,如果出现任何错误都将触发exit。相反,set +e表示不管出现任何错误继续执行脚本</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>-n表示检查有无语法错误,-x表示调试</p>\n<h3 id=\"变量展开\"><a href=\"#变量展开\" class=\"headerlink\" title=\"变量展开\"></a>变量展开</h3><table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>:$&#123;parameter:=word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,展开的结果是word的值,并且word的值会赋给parameter;否则展开为parameter的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter:-word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,展开的结果是word的值,否则是parameter的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter:?word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,会带有错误的推出,否则是parameter的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter:+word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,展开为空,否则是word的值;不管如何parameter值不会变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter#pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter开头开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter##pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter开头开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter%pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter结尾开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter%%pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter结尾开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter/pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,只替换第一次匹配到的</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter//pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,替换所有匹配到的</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter/#pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter开头开始匹配,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter/%pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter结尾开始匹配,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter,,&#125;</code></td>\n<td align=\"center\">把parameter全部展开成小写字母</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter,&#125;</code></td>\n<td align=\"center\">把parameter首字母展开成小写字母</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter^^&#125;</code></td>\n<td align=\"center\">把parameter全部展开成大写字母</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter^&#125;</code></td>\n<td align=\"center\">把parameter首字母展开成大写字母</td>\n</tr>\n</tbody></table>\n<p><code>$&#123;!prefix*&#125;</code>等价于<code>$&#123;!prefix@&#125;</code>这种展开会返回以prefix开头的已有变量名(而不是变量的值)<br>字符串的长度和切片其实也是一种展开</p>\n<p><span id = \"jump\"></span></p>\n<h3 id=\"进程替换\"><a href=\"#进程替换\" class=\"headerlink\" title=\"进程替换\"></a>进程替换</h3><p>进程替换可以用来解决子进程问题,它实质是把子进程的输出当作一个用于重定向的普通文件(文件描述符)。<br>标准输出<br><code>&lt;(cmd1;cmd2)</code><br>标准输入<br><code>&gt;(cmd1;cmd2)</code><br>由此可以解决read管道线的问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> attr links owner group size <span class=\"hljs-built_in\">date</span> time filename;<span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">cat</span> &lt;&lt;- <span class=\"hljs-string\">EOF</span><br><span class=\"hljs-string\">\t\tFilename: $filename</span><br><span class=\"hljs-string\">\t\tSize:     $size</span><br><span class=\"hljs-string\">\t\tOwner:    $owner</span><br><span class=\"hljs-string\">\t\tGroup:    $group</span><br><span class=\"hljs-string\">\t\tModified: $date $time</span><br><span class=\"hljs-string\">\t\tLinks:    $links</span><br><span class=\"hljs-string\">\t\tAttributes: $attr</span><br><span class=\"hljs-string\">\tEOF</span><br><span class=\"hljs-keyword\">done</span> &lt; &lt;(<span class=\"hljs-built_in\">ls</span> -l | <span class=\"hljs-built_in\">tail</span> -n +2)<br></code></pre></td></tr></table></figure>\n<p><span id = \"jumpopt\"></span></p>\n<h3 id=\"getopt和getopts\"><a href=\"#getopt和getopts\" class=\"headerlink\" title=\"getopt和getopts\"></a>getopt和getopts</h3><h4 id=\"getopt\"><a href=\"#getopt\" class=\"headerlink\" title=\"getopt\"></a>getopt</h4><p>格式:<code>getopt [options] optstring parameters</code>,例:<br><code>getopt ab:cd -a -b test1 -cd test2 test3</code>该命令会产生如下输出:<br><code>-a -b test1 -c -d -- test2 test3</code>,optstring定义了四个有效项字母:a、b、c和d。冒号(:)表示b选项需要个参数值,它会将-cd选项分成两个单独选项,插入’–’来分隔额外的参数,如果提供’-cde’由于e不在optstring中,会报错<strong>getopt: invalid option – e</strong>,但还会输出结果,可以加-q选项忽略报错结果。<br>在脚本中经常与set的’–’选项来使用,来把getopt的输出转成当前脚本的输入参数,示例如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-comment\"># Extract command line options &amp; values with getopt</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">set</span> -- $(getopt -q ab:<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span>)<br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">echo</span><br><span class=\"hljs-keyword\">while</span> [ -n <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span> ]<br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span> <span class=\"hljs-keyword\">in</span><br>    -a) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -a option&quot;</span> ;;<br>    -b) param=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$2</span>&quot;</span><br>        <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -b option, with parameter value <span class=\"hljs-variable\">$param</span>&quot;</span><br>        <span class=\"hljs-built_in\">shift</span> ;;<br>    -c) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -c option&quot;</span> ;;<br>    --) <span class=\"hljs-built_in\">shift</span><br>        <span class=\"hljs-built_in\">break</span> ;;<br>    *) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span> is not an option&quot;</span>;;<br>    <span class=\"hljs-keyword\">esac</span><br>    <span class=\"hljs-built_in\">shift</span><br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#</span><br>count=1<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span><br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Parameter #<span class=\"hljs-variable\">$count</span>: <span class=\"hljs-variable\">$param</span>&quot;</span><br>    count=$[ <span class=\"hljs-variable\">$count</span> + 1 ]<br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"getopts\"><a href=\"#getopts\" class=\"headerlink\" title=\"getopts\"></a>getopts</h4><p>格式:<code>getopts optstring variable</code>,这里variable为命令行上检测到的第一个参数(getopts会去除’-‘,这点与getopt不同),处理完所有参数后,它会返回一个大于0的退出状态码。可以用”:optstring”格式来忽略未识别选项的错误信息。会用到两个环境变量,如果选项用到一个参数值,OPTARG会保存该值,OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。<br>getopts可以识别双引号内的带括号参数值,而getopt不可以。getopts将命令行上找到的所有未定义选项统一输成问号,getopt遇到未识别的非选项值时,会结束识别,即使后面有正确的选项。可以用以下脚本自行测试getopts的行为:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span><br><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">getopts</span> :ab:<span class=\"hljs-built_in\">cd</span> opt<br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$opt</span>&quot;</span> <span class=\"hljs-keyword\">in</span><br>        a) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -a option&quot;</span>  ;;<br>        b) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -b option, with value <span class=\"hljs-variable\">$OPTARG</span>&quot;</span> ;;<br>        c) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -c option&quot;</span>  ;;<br>        d) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -d option&quot;</span>  ;;<br>        *) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Unknown option: <span class=\"hljs-variable\">$opt</span>&quot;</span> ;;<br>    <span class=\"hljs-keyword\">esac</span><br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">shift</span> $[ <span class=\"hljs-variable\">$OPTIND</span> - 1 ]<br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">echo</span><br>count=1<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span><br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Parameter <span class=\"hljs-variable\">$count</span>: <span class=\"hljs-variable\">$param</span>&quot;</span><br>    count=$[ <span class=\"hljs-variable\">$count</span> + 1 ]<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"set命令\"><a href=\"#set命令\" class=\"headerlink\" title=\"set命令\"></a>set命令</h3><p>set 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。可以使用<code>echo $-</code>查看当前设置,默认是（himxBH）<br>参数说明：</p>\n<p>|参数|说明|<br>|:-:||:-:|<br>|-a|标示已修改的变量，以供输出至环境变量|<br>|-b|使被中止的后台程序立刻回报执行状态|<br>|-B|启用大括号展开|<br>|-d|Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消|<br>|-e|若指令传回值不等于0，则立即退出shell|<br>|-f|取消使用通配符|<br>|-h|自动缓存命令的所在位置,如果在PATH指定路径内，更换命令的位置,缓存就不会同步，就会发生错误，不过谁会换命令的位置呢,可以使用which更新缓存|<br>|-i|设置当前选项为交互式|<br>|-k|指令所给的参数都会被视为此指令的环境变量|<br>|-l|记录for循环的变量名称|<br>|-m|使用监视模式,可以控制进程的停止、继续、后台前台等，默认打开|<br>|-n|测试模式，只读取指令，而不实际执行|<br>|-p|启动优先顺序模式|<br>|-P|启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接|<br>|-t|执行完随后的指令，即退出shell|<br>|-u|当执行时使用到未定义过的变量，则显示错误信息|<br>|-v|显示shell所读取的输入值|<br>|-H shell|可利用”!”加&lt;指令编号&gt;的方式来执行 history 中记录的指令,最好不用|<br>|-x|执行指令后，会先显示该指令及所下的参数|<br>|+&lt;参数&gt;|取消某个set曾启动的参数。与-&lt;参数&gt;相反|<br>|-o [option]|特殊属性有很多,见下面|</p>\n<p><strong>option属性</strong></p>\n<ul>\n<li>pipefail:管道流水线中有一个失败，则返回失败值，从右往左数起(默认只返回最后一个命令的退出码)</li>\n<li>noclobber:防止&gt;重定向操作符覆盖已有内容，你可以使用<code>command &gt;| file</code>强制覆盖</li>\n</ul>\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ul>\n<li>波浪号展开只能<strong>紧跟</strong>在<code>=</code>和<code>:</code>之后才能正确展开,引号中无法正确展开</li>\n<li>**&lt;&lt;<strong>和</strong>&lt;&lt;-**的区别在于,&lt;&lt;-会忽略接下来输入的tab建,一般用于格式化脚本,便于读代码</li>\n<li>组命令(在当前shell执行)–<code>&#123; command1;command2;command3  &#125;</code>,子shell–<code>(command1;command2;command3)</code>一般配合管道符</li>\n<li>trap命令<br><code>trap &quot;命令&quot; &quot;信号&quot;</code>当脚本遇到信号前执行的命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">trap</span> <span class=\"hljs-string\">&quot;echo I am ignoring you&quot;</span> SIGINT SIGTERM<br></code></pre></td></tr></table></figure>\n常见信号有:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">编号</th>\n<th align=\"center\">英文名</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">SIGHUP</td>\n<td align=\"center\">挂起进程</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">SIGINT</td>\n<td align=\"center\">终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">SIGQUIT</td>\n<td align=\"center\">停止进程</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">SIGKILL</td>\n<td align=\"center\">无条件终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">15</td>\n<td align=\"center\">SIGTERM</td>\n<td align=\"center\">尽可能终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">17</td>\n<td align=\"center\">SIGSTOP</td>\n<td align=\"center\">无条件停止进程,但不是终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">18</td>\n<td align=\"center\">IGTSTP</td>\n<td align=\"center\">停止或暂停进程,但不终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">19</td>\n<td align=\"center\">SIGCONT</td>\n<td align=\"center\">继续运行停止的进程</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs\">* tap除了捕获信号外,还会捕获脚本退出:`trap &quot;echo Goodbye...&quot; EXIT`,不管正常还是非正常,都会打印Goodbye\n* `trap -- SIGINT`取消某个信号的设置\n* `trap -`恢复信号的默认行为\n</code></pre>\n<ul>\n<li>wait命令<br><code>wait $pid</code>等待子进程<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#小火车子进程</span><br>sl &amp;<br>pid=$!<br><span class=\"hljs-comment\">#父进程继续干事</span><br><span class=\"hljs-built_in\">sleep</span> 2<br><span class=\"hljs-comment\">#干完事等子进程</span><br><span class=\"hljs-built_in\">wait</span> <span class=\"hljs-variable\">$pid</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;子父进程都结束了&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li>命名管道<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建一个命名管道文件</span><br><span class=\"hljs-built_in\">mkfifo</span> pipe1<br><span class=\"hljs-comment\">#子进程写入(写入完会阻塞,等待另一端读,所以不要wait)</span><br><span class=\"hljs-built_in\">ls</span> -l &gt; pipe1 &amp;<br><span class=\"hljs-comment\">#父进程读</span><br><span class=\"hljs-built_in\">sleep</span> 5<br><span class=\"hljs-built_in\">cat</span>&lt;pipe1<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>IFS默认是空白字符(回车，空格，制表符等)，位于字符串和结尾的空白字符都被删除，中间连续空格会被压缩成一个</li>\n</ul>\n<ul>\n<li>子shell的全局环境变量改变并不会影响父shell,甚至用export也不行</li>\n<li>命令替换<code>$(command)</code>,子shell<code>(command)</code>两个是不同概念,命令替换会开个子shell(貌似都会开子shell)</li>\n<li>文件描述符与exec<ul>\n<li>配合exec可以使标准输入输出永久重定向:<code>exec 2&gt;testerror</code>重定向标准错误至文件。</li>\n<li>exec可以创建文件描述:<code>exec 3&gt;testxx;echo hello&gt;&amp;3</code>这可以用来恢复正常的输入输出,如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">exec</span> 3&gt;&amp;1<br><span class=\"hljs-built_in\">exec</span> 1&gt;test14out<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;这会输入到test14out&quot;</span><br><span class=\"hljs-built_in\">exec</span> 1&gt;&amp;3<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;这会输入到屏幕&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li>exec创建读写描述符:<code>exec 3&lt;&gt;testfile</code>,这要特别小心,任何读或写都会从文件指针的上次位置开始</li>\n<li>exec关闭文件描述符:<code>exec 3&gt;&amp;-</code></li>\n<li>lsof命令可以查看已经打开的文件描述符,见Linux命令博客</li>\n</ul>\n</li>\n</ul>\n<p><span id = \"funAndArr\"></span></p>\n<ul>\n<li><p>函数与数组<br>将数组变量当作但个参数传递的话,它不会其作用,只会传递第一个值,可以借鉴以下例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-comment\"># array variable to function test</span><br><span class=\"hljs-keyword\">function</span> testit &#123;<br>    <span class=\"hljs-built_in\">local</span> newarray<br>    newarray=`<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span>`<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;The new array value is: <span class=\"hljs-variable\">$&#123;newarray[*]&#125;</span>&quot;</span><br>&#125;<br>myarray=(1 2 3 4 5)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;The original array is <span class=\"hljs-variable\">$&#123;myarray[*]&#125;</span>&quot;</span><br>testit <span class=\"hljs-variable\">$&#123;myarray[*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>预处理替换优先级<br>a.shell替换:文件通配符<br>b.变量替换<br>c.命令替换,如下示例:  </p>\n</li>\n<li><p>shell元字符汇总</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">空格、制表符</td>\n<td align=\"center\">命令行参数的分隔符</td>\n</tr>\n<tr>\n<td align=\"center\">回车</td>\n<td align=\"center\">执行键入的命令</td>\n</tr>\n<tr>\n<td align=\"center\">&lt; &gt; &brvbar;</td>\n<td align=\"center\">重定向与管道</td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\">多个命令分隔符</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;</td>\n<td align=\"center\">后台运行</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"center\">引用shell的变量</td>\n</tr>\n<tr>\n<td align=\"center\">`</td>\n<td align=\"center\">命令替换,<code>\\\\</code>代表反斜线自身,&#96;`&#96;代表反撇号自身</td>\n</tr>\n<tr>\n<td align=\"center\">* [] ?</td>\n<td align=\"center\">文件通配符,不匹配*和&#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">()</td>\n<td align=\"center\">用于定义shell函数或子shell中执行命令</td>\n</tr>\n<tr>\n<td align=\"center\">\\</td>\n<td align=\"center\">转义字符取消元字符特殊含义，若不用于元字符跟不加一样</td>\n</tr>\n<tr>\n<td align=\"center\">“ “</td>\n<td align=\"center\">其中的内容除$和`外取消元字符的特殊含义</td>\n</tr>\n<tr>\n<td align=\"center\">‘ ‘</td>\n<td align=\"center\">取消所有元字符特殊含义</td>\n</tr>\n</tbody></table>\n<ul>\n<li>RANDOM是个内建的随机值</li>\n<li><code>&lt;&lt;&lt;</code><br>here-string语法，允许直接传递字符串给标准输入</li>\n<li>eval<br>eval 的功能是将字符串作为代码来执行。看上去好像很简单，但实际涉及很复杂的内容，主要是符号转义导致的语义问题。<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-attribute\">str1</span>=str2<br><span class=\"hljs-attribute\">str2</span>=abc<br>eval echo \\$<span class=\"hljs-variable\">$str1</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n","excerpt":"","more":"<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ul>\n<li>单行注释: #</li>\n<li>多行注释:  <code>:&lt;&lt;EOF ... EOF</code>或者 <code>:&lt;&lt;! ... !</code></li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li>创建普通变量: <strong>name&#x3D;”test”</strong> (&#x3D;两边不可有空格)</li>\n<li>创建函数体中的局部变量: ** local name&#x3D;”test”**,函数体及整个脚本中的变量默认都是全局变量,函数体内外皆可访问和改变,函数体内的变量最好用这个加以限制,同时为了得到命令替换的返回码时最好分开写(否则只会捕获local的成功码)：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">local</span> varname<br>varname=$(<span class=\"hljs-built_in\">command</span>)<br>re=$?<br></code></pre></td></tr></table></figure></li>\n<li>使用变量: <strong>echo $name 或者 echo $(name)</strong> 使用时要加$,重新赋值时不需要</li>\n<li>只读变量: <strong>name&#x3D;”only_read” -&gt; readonly name</strong></li>\n<li>删除变量: <strong>unset name</strong></li>\n</ul>\n<h3 id=\"字符串变量\"><a href=\"#字符串变量\" class=\"headerlink\" title=\"字符串变量\"></a>字符串变量</h3><p>字符串与变量展开有密切联系,可以参考那节</p>\n<ol>\n<li>单引号</li>\n</ol>\n<ul>\n<li>单引号变量var&#x3D;’test’,只能原样输出,不能解释变量</li>\n<li>单引号中不能出现一个单引号,转义也不行</li>\n</ul>\n<ol start=\"2\">\n<li>双引号</li>\n</ol>\n<ul>\n<li>双引号变量<code>var=&quot;my name is $&#123;name&#125;&quot;</code>,可以解释变量</li>\n<li>可以出现转移字符</li>\n</ul>\n<ol start=\"3\">\n<li>拼接字符串</li>\n</ol>\n<ul>\n<li><code>name=&quot;this is&quot;&quot;my name&quot;;name=&quot;this is my name&quot;;name=&quot;this&quot;is&quot;my name&quot;</code>等效</li>\n</ul>\n<ol start=\"4\">\n<li><p>获取字符串长度</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;#str&#125;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>提取子字符串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">name=<span class=\"hljs-string\">&quot;this is my name&quot;</span>;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;name:1:4&#125;</span> <span class=\"hljs-comment\">#输出his</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;name::4&#125;</span> <span class=\"hljs-comment\">#输出this</span><br></code></pre></td></tr></table></figure></li>\n<li><p>大小写</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">declare</span> -u upper<br><span class=\"hljs-built_in\">declare</span> -l lower<br><span class=\"hljs-comment\">#upper将会强制转成SL</span><br>upper=<span class=\"hljs-string\">&quot;sl&quot;</span><br><span class=\"hljs-comment\">#lower将会强制转成sl</span><br>lower=<span class=\"hljs-string\">&quot;SL&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>bash只支持以为数组,不支持多维数组</p>\n<ul>\n<li>定义数组: <strong>array_name&#x3D;(li wang xiang zhang)</strong> (小括号做边界、使用空格分离)或者<strong>declare -a array_name</strong></li>\n<li>单独定义数组的元素: <strong>arraypara[0]&#x3D;”w”;arraypara[3]&#x3D;”s”</strong> (定义时下标可以不连续,同样可以用于赋值)</li>\n<li>获取数组元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array_name[0]=<span class=\"hljs-string\">&quot;li&quot;</span><br>array_name[3]=<span class=\"hljs-string\">&quot;zhang&quot;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[0]&#125;</span> <span class=\"hljs-comment\">#输出&quot;li&quot;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[1]&#125;</span> <span class=\"hljs-comment\">#输出空</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[@]&#125;</span> <span class=\"hljs-comment\">#输出&quot;li zhang&quot;输出数组所有元素,没有元素的下标省略</span><br><span class=\"hljs-comment\">#等价于下面</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array_name[*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>取得元素个数:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$&#123;#arrayname[@]&#125;</span><br><span class=\"hljs-comment\">#或者</span><br><span class=\"hljs-variable\">$&#123;#arrayname[\\*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>取得单个元素长度: <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$&#123;#array_name[1]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li><code>for i in &quot;$&#123;!foo[@]&#125;&quot;</code>取得每个非空元素的下标</li>\n<li><code>foo+=(d e f)</code>添加3个元素</li>\n<li>删除数组不能通过赋空值,只能通过unset,unset还能删除某个元素(这样后面元素往前补)</li>\n<li>没有指明数组下标的访问或赋值皆指向第一个值</li>\n<li>最新版本bash支持关联数组<code>declare -A colors;colors[&quot;red&quot;]=&quot;red&quot;</code></li>\n<li><a href=\"#funAndArr\">函数与数组</a></li>\n<li>取切片<code>echo $&#123;array:0:3&#125;</code></li>\n<li>遍历数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#方法1</span><br><span class=\"hljs-keyword\">for</span>(( i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-variable\">$&#123;#array[@]&#125;</span>;i++)) <span class=\"hljs-keyword\">do</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array[i]&#125;</span>;<br><span class=\"hljs-keyword\">done</span>;<br><span class=\"hljs-comment\">#方法2</span><br><span class=\"hljs-keyword\">for</span> element <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable\">$&#123;array[@]&#125;</span><br><span class=\"hljs-keyword\">do</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$element</span><br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#方法3</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;!arr[@]&#125;</span>&quot;</span>;<br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">printf</span> <span class=\"hljs-string\">&quot;%s\\t%s\\n&quot;</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$i</span>&quot;</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;arr[$i]&#125;</span>&quot;</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>添加数组元素<br><code>$arr+=(a b)</code></li>\n</ul>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><h4 id=\"FUNCNAME\"><a href=\"#FUNCNAME\" class=\"headerlink\" title=\"FUNCNAME\"></a>FUNCNAME</h4><p>该环境变量是个数组，存储当前位置函数调用的堆栈，当只有主程序时，个数为0,当存在调用函数时，第一个总是当前函数名，最后一个为main表示主程序</p>\n<h4 id=\"BASH-SOURCE\"><a href=\"#BASH-SOURCE\" class=\"headerlink\" title=\"BASH_SOURCE\"></a>BASH_SOURCE</h4><p>是一个数组，不过它的第一个元素是当前脚本名称，然后是source它的脚本，依次类推，常用如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 如果脚本是被source的话</span><br><span class=\"hljs-keyword\">if</span> [ -n <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$BASH_SOURCE</span>&quot;</span> -a <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$BASH_SOURCE</span>&quot;</span> != <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$0</span>&quot;</span> ]<br><span class=\"hljs-keyword\">then</span><br>    do_something<br><span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\"># Otherwise, run directly in the shell</span><br>    do_other<br><span class=\"hljs-keyword\">fi</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数传递的相关特殊变量\"><a href=\"#参数传递的相关特殊变量\" class=\"headerlink\" title=\"参数传递的相关特殊变量\"></a>参数传递的相关特殊变量</h3><table>\n<thead>\n<tr>\n<th align=\"center\">变量</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>$0</code></td>\n<td align=\"center\">代表执行的文件名</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$n</code></td>\n<td align=\"center\">代表传入的第n个参数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$#</code></td>\n<td align=\"center\">参数个数,不包括程序名本身</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$</code></td>\n<td align=\"center\">以一个单字符串显示所有向脚本传递的参数。即为”$1 $2…$n”</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$@</code></td>\n<td align=\"center\">展开成一个从 1 开始的位置参数列表。当它被用双引号引 起来的时候，展开成一个由双引号引起来的字符串，包含了 所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个 字符（默认为一个空格）分隔开。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$*</code></td>\n<td align=\"center\">把所有参数当成一个大字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$$</code></td>\n<td align=\"center\">该脚本进程ID</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$!</code></td>\n<td align=\"center\">后台运行的最后一个进程ID</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$?</code></td>\n<td align=\"center\">上个调用(最后命令)返回值,0表示没有错误</td>\n</tr>\n</tbody></table>\n<p>有个<strong>shift</strong>命令可以方便处理命令行参数,每次执行该命令的时候,变量$2会移动到$1,变量$3会移动到变量$2,以此类推,$#值也会减1。例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">count=1<br><span class=\"hljs-keyword\">while</span> [[ <span class=\"hljs-variable\">$#</span> -gt 0 ]];<br><span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Argument <span class=\"hljs-variable\">$count</span> = <span class=\"hljs-variable\">$1</span>&quot;</span><br>\tcount=$((count + <span class=\"hljs-number\">1</span>))<br>\t<span class=\"hljs-built_in\">shift</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<p><a href=\"#jumpopt\">getopt和getopts两个命令经常被用来处理传递的参数</a></p>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>let使数字运算更方便:<code>let a++</code>,<code>let a+=2</code></p>\n<h4 id=\"算数运算\"><a href=\"#算数运算\" class=\"headerlink\" title=\"算数运算\"></a>算数运算</h4><ul>\n<li><code>+ - * /</code></li>\n<li>加法运算<ul>\n<li><code>bash val=$(expr 2 + 2)</code> 这么写乘号要加转义,空格也是必须</li>\n<li><code>val=$[2+2]</code> (4个空格不是必要的,不同于条件判断)</li>\n<li><code>val=$((2+2))</code>(4个空格不是必要的)</li>\n</ul>\n</li>\n</ul>\n<p>bash支持任意进制</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表示法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">number</td>\n<td align=\"center\">默认10进制</td>\n</tr>\n<tr>\n<td align=\"center\">0number</td>\n<td align=\"center\">8进制</td>\n</tr>\n<tr>\n<td align=\"center\">0xnumber</td>\n<td align=\"center\">16进制</td>\n</tr>\n<tr>\n<td align=\"center\">base#number</td>\n<td align=\"center\">base进制</td>\n</tr>\n</tbody></table>\n<p>在双括号中会被解释成数字,否则默认为字符串</p>\n<h4 id=\"数字关系运算符\"><a href=\"#数字关系运算符\" class=\"headerlink\" title=\"数字关系运算符\"></a>数字关系运算符</h4><p>关系运算符只支持数字,不支持字符串,除非字符串是数字</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>-eq</code></td>\n<td align=\"center\">相等返回true,<code>[$a -eq $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>-ne</code></td>\n<td align=\"center\">不相等返回true,<code>[$a -ne $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>-gt</code></td>\n<td align=\"center\">大于号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-lt</code></td>\n<td align=\"center\">小于号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-ge</code></td>\n<td align=\"center\">大于等于号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-le</code></td>\n<td align=\"center\">小于等于号</td>\n</tr>\n</tbody></table>\n<h4 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h4><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>&#x3D;</strong></td>\n<td align=\"center\">相等返回true,<code>[$a = $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>!&#x3D;</strong></td>\n<td align=\"center\">不相等返回true,<code>[$a != $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>-z</strong></td>\n<td align=\"center\">字符串长度为0返回true,<code>[-z $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>-n</strong></td>\n<td align=\"center\">字符串长度不为0返回true,<code>[-n $b]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>$</strong></td>\n<td align=\"center\">不为空返回true,<code>[$a]</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h4><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>!</strong></td>\n<td align=\"center\">非运算,<code>[! false]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>&amp;&amp;</strong></td>\n<td align=\"center\">与运算,<code>[[ $a -lt 20 ]] &amp;&amp; [[$b -gt 100 ]]</code></td>\n</tr>\n<tr>\n<td align=\"center\">**</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>逻辑判断的括号<br>1.<code>[]</code>:中括号旁边和运算符两边必须添加空格(可以使用，等价于test命令,本文不讲test命令,不推荐)<br>2.<code>[[]]</code>:中括号旁边和运算符两边必须添加空格(字符串验证,文件名时，推荐)<br>3.<code>(())</code>:中括号旁边和运算符两边必须添加空格(数字验证时，推荐)<br>4.<code>[[]]和(())</code>分别是针对数学表达式和字符串表达式的加强版<br>5.<code>[]</code>基本舍弃的原因，它与**&amp;&amp;、||、&lt;和&gt;**不兼容,会报错,它只能用-ne等等这些,例如下面是等价的<br><code>if [[ $a != 1 &amp;&amp; $a !=2 ]]</code>,<code>if [ $a -ne 1 ] &amp;&amp; [ $a != 2 ]</code>,<code>if [ $a -ne 1 -a $a !=2 ]</code><br>6.双括号支持以下额外的符号(没列全,C语言能用的都能用,包括?:)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">val++</td>\n<td align=\"center\">后增</td>\n</tr>\n<tr>\n<td align=\"center\">val–</td>\n<td align=\"center\">后减</td>\n</tr>\n<tr>\n<td align=\"center\">++val</td>\n<td align=\"center\">前增</td>\n</tr>\n<tr>\n<td align=\"center\">–val</td>\n<td align=\"center\">前减</td>\n</tr>\n<tr>\n<td align=\"center\">!</td>\n<td align=\"center\">逻辑求反</td>\n</tr>\n<tr>\n<td align=\"center\">~</td>\n<td align=\"center\">位求反</td>\n</tr>\n<tr>\n<td align=\"center\">**</td>\n<td align=\"center\">幂运算</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;&lt;</td>\n<td align=\"center\">左位移</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;&gt;</td>\n<td align=\"center\">右位移</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;</td>\n<td align=\"center\">布尔和</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;</td>\n<td align=\"center\">&#96;</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">&amp;&amp;</td>\n<td align=\"center\">逻辑与</td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;~</td>\n<td align=\"center\">用于字符串的模式匹配,右边加上引号会丧失正则的含义，变成普通字符串,避免反斜杠转移，可以赋值给一个变量</td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;&#x3D;</td>\n<td align=\"center\">用于字符串的类型匹配(通配符等),例子<code>if [[ $FILE == foo.* ]]</code></td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;</td>\n<td align=\"center\">用于字符串是否相同，右边一定要引号括起来，否则是模式匹配，如<code>*</code>则会永远为true</td>\n</tr>\n</tbody></table>\n<h4 id=\"文件运算符\"><a href=\"#文件运算符\" class=\"headerlink\" title=\"文件运算符\"></a>文件运算符</h4><p>file是代表文件名的字符串</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$file1 -ef $file2</td>\n<td align=\"center\">拥有相同的索引号返回True(硬连接)</td>\n</tr>\n<tr>\n<td align=\"center\">$file1 -nt $file2</td>\n<td align=\"center\">file1新于file2返回true</td>\n</tr>\n<tr>\n<td align=\"center\">$file1 -ot $file2</td>\n<td align=\"center\">file1早于file2返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-b $file]</code></td>\n<td align=\"center\">是块设备文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-c $file]</code></td>\n<td align=\"center\">是字符备文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-d $file]</code></td>\n<td align=\"center\">是目录返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-f $file]</code></td>\n<td align=\"center\">是普通文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-g $file]</code></td>\n<td align=\"center\">设置了SGID位文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-h $file]</code></td>\n<td align=\"center\">是符号链接返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-G $file]</code></td>\n<td align=\"center\">由有效组(即当前进程用户组)ID拥有返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-L $file]</code></td>\n<td align=\"center\">是符号链接返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-k $file]</code></td>\n<td align=\"center\">设置了stick位文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-N $file]</code></td>\n<td align=\"center\">atime和mtime一样的文件</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-p $file]</code></td>\n<td align=\"center\">是有名管道文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-u $file]</code></td>\n<td align=\"center\">设置了SUID位文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-O $file]</code></td>\n<td align=\"center\">由有效用户(即当前进程用户)件D拥有返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-r $file]</code></td>\n<td align=\"center\">是可读文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-w $file]</code></td>\n<td align=\"center\">是可写文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-x $file]</code></td>\n<td align=\"center\">是可执行文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-s $file]</code></td>\n<td align=\"center\">非空文件返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-S $file]</code></td>\n<td align=\"center\">是一个网络Socket返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-e $file]</code></td>\n<td align=\"center\">文件存在返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[-t $fd]</code></td>\n<td align=\"center\">fd是一个定向到终端&#x2F;从终端定向的文件描述符。这可以被用来判断是否重定向了标准输入&#x2F;错误</td>\n</tr>\n</tbody></table>\n<h3 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h3><p><strong>echo</strong>只用于字符串,自动添加换行符号<code>echo nanbert male 66.1234</code><br><strong>printf</strong>不自动加换行符号,例:<code>printf &quot;%-10s %-8s %-4.2f\\n&quot; nanbert male 66.1234</code></p>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><h4 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#then后必须有语句,空语句可以用:</span><br><span class=\"hljs-keyword\">if</span> condition<br><span class=\"hljs-keyword\">then</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">elif</span> condition<br><span class=\"hljs-keyword\">then</span><br>\tcommand2<br>\t...<br><span class=\"hljs-keyword\">else</span><br>\tcommand3<br>\t...<br><span class=\"hljs-keyword\">fi</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> var <span class=\"hljs-keyword\">in</span> item1 item2 ... itemN<br><span class=\"hljs-keyword\">do</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#等价于c语言</span><br><span class=\"hljs-keyword\">for</span> (( expression1;expression2; expression3 ));<span class=\"hljs-keyword\">do</span><br>\tcommands<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<p>如果省略in，默认处理位置参数</p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> condition<br><span class=\"hljs-keyword\">do</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#无限循环</span><br><span class=\"hljs-keyword\">while</span> :<br><span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">command</span><br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"until\"><a href=\"#until\" class=\"headerlink\" title=\"until\"></a>until</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">until</span> condition<br><span class=\"hljs-keyword\">do</span> <br>\tcommand1<br>\t...<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"case\"><a href=\"#case\" class=\"headerlink\" title=\"case\"></a>case</h4><p>Shell case匹配一个值与一个模式,用两个分号表示break</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">case</span> value <span class=\"hljs-keyword\">in</span><br>\tpattern1)<br>\t\tcommand1<br>\t\t...<br>\t\tcommandN<br>\t\t;;<br>\tpattern2)<br>\t\tcommand1<br>\t\t...<br>\t\tcommandN<br>\t\t;;<br><span class=\"hljs-keyword\">esac</span><br></code></pre></td></tr></table></figure>\n\n<p>循环都支持<strong>continue</strong>和<strong>break</strong>,<code>break n</code>则可以指定跳出n层循环,n默认为1<br>,continue也支持数字。</p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><ul>\n<li>函数定义<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span></span>()&#123;<br>\taction;<br>\t[<span class=\"hljs-built_in\">return</span> int;]<br>&#125;<br><span class=\"hljs-comment\">#等价于下面</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">fun1</span></span>()&#123;<br>\taction;<br>\t[<span class=\"hljs-built_in\">return</span> int;]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>参数传递<br>函数中直接使用特殊变量来获取参数,可以加上{}<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-function\"><span class=\"hljs-title\">funWithParam</span></span>()&#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第一个参数为 <span class=\"hljs-variable\">$1</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第二个参数为 <span class=\"hljs-variable\">$2</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第十个参数为 <span class=\"hljs-variable\">$10</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第十个参数为 <span class=\"hljs-variable\">$&#123;10&#125;</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;第十一个参数为 <span class=\"hljs-variable\">$&#123;11&#125;</span> !&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;参数总数有 <span class=\"hljs-variable\">$#</span> 个!&quot;</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;作为一个字符串输出所有参数 $* !&quot;</span>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br><span class=\"hljs-built_in\">echo</span> $?  <span class=\"hljs-comment\"># 判断执行是否成功</span><br></code></pre></td></tr></table></figure></li>\n<li>函数返回值<ul>\n<li>返回值是可选的</li>\n<li>return只能为<strong>return [0-255]</strong>,可通过$?获取该值</li>\n<li>如果不加return,则最后一条语句的执行状态为返回值,0为成功</li>\n<li>如果用反引号执行函数,结果是函数内的所有输出而非返回值</li>\n</ul>\n</li>\n<li><a href=\"#funAndArr\">函数与数组</a></li>\n</ul>\n<ul>\n<li>函数本质上是一组命令集合,不一定用大括号括起来,更多见shell例子</li>\n<li>可以使用<code>declare -F | sed &#39;s/declare -f//&#39;</code>来查看当前脚本定义的函数</li>\n</ul>\n<h3 id=\"读取外部输入\"><a href=\"#读取外部输入\" class=\"headerlink\" title=\"读取外部输入\"></a>读取外部输入</h3><p><code>read arg</code>从键盘读取输入并赋值给arg</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a array</td>\n<td align=\"center\">把输入赋值到数组array中</td>\n</tr>\n<tr>\n<td align=\"center\">-d delimiter</td>\n<td align=\"center\">用字符串delimiter中的第一个字符指示输入结束,而不是一个换行符</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">使用readline来处理输入</td>\n</tr>\n<tr>\n<td align=\"center\">-n num</td>\n<td align=\"center\">读取num个输入字符,而不是整行</td>\n</tr>\n<tr>\n<td align=\"center\">-p prompt</td>\n<td align=\"center\">为输入显示提示信息,使用字符串prompt</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">Raw mode,不把反斜杠解释为转义字符</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">Silent mode,不会在屏幕上显示输入的字符。输入密码的时候很有用</td>\n</tr>\n<tr>\n<td align=\"center\">-t seconds</td>\n<td align=\"center\">超过时间，终止输入,read会非0状态退出</td>\n</tr>\n<tr>\n<td align=\"center\">-u fd</td>\n<td align=\"center\">使用文件描述符fd中的输入,而不是标准输入</td>\n</tr>\n<tr>\n<td align=\"center\">-k n</td>\n<td align=\"center\">只读n个字节</td>\n</tr>\n</tbody></table>\n<p>IFS是字段分割符,默认为空格,tab,换行符。可以自行改变。如下:<br><code>IFS=:</code>改成冒号<br><code>IFS=$&#39;\\n&#39;:;&quot;</code>改成换行符、冒号、分号和双引号<br>read不应该使用管道线来接受赋值，如下是错误的:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$file_info</span>&quot;</span> | IFS=<span class=\"hljs-string\">&quot;:&quot;</span> <span class=\"hljs-built_in\">read</span> user pw uid gid name home shell<br></code></pre></td></tr></table></figure>\n<p>而应该这么写</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">IFS=<span class=\"hljs-string\">&quot;:&quot;</span> <span class=\"hljs-built_in\">read</span> user pw uid gid name home shell &lt;&lt;&lt; <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$file_info</span>&quot;</span><br></code></pre></td></tr></table></figure>\n<p>这是因为管道线会开个子进程,子进程变量的变化不会影响父进程,可以用<a href=\"#jump\">进程替换</a>解决<br>如果输入的数多余接受的变量,则多出来的会保存在变量REPLY中</p>\n<h3 id=\"包含其他shell文件\"><a href=\"#包含其他shell文件\" class=\"headerlink\" title=\"包含其他shell文件\"></a>包含其他shell文件</h3><ul>\n<li><code>. filepath/filename</code></li>\n<li><code>source filepath/filename</code></li>\n</ul>\n<h3 id=\"颜色标识\"><a href=\"#颜色标识\" class=\"headerlink\" title=\"颜色标识\"></a>颜色标识</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">printf</span>  <span class=\"hljs-string\">&quot;\\033[32m SUCCESS: yay \\033[0m\\n&quot;</span>;<br><span class=\"hljs-built_in\">printf</span>  <span class=\"hljs-string\">&quot;\\033[33m WARNING: hmm \\033[0m\\n&quot;</span>;<br><span class=\"hljs-built_in\">printf</span>  <span class=\"hljs-string\">&quot;\\033[31m ERROR: fubar \\033[0m\\n&quot;</span>;<br></code></pre></td></tr></table></figure>\n<p>具体内容有待研究</p>\n<h3 id=\"长句换行\"><a href=\"#长句换行\" class=\"headerlink\" title=\"长句换行\"></a>长句换行</h3><p>在shell中为避免一个语句过长,可以使用”&quot;进行换行,注意”&quot;前加一个空格,之后无空格直接换行。</p>\n<h3 id=\"退出脚本\"><a href=\"#退出脚本\" class=\"headerlink\" title=\"退出脚本\"></a>退出脚本</h3><p><code>exit [num]</code>num为0表示执行成功,可以不加num<br><code>set -e 或 set +e</code>set -e表示从当前位置开始,如果出现任何错误都将触发exit。相反,set +e表示不管出现任何错误继续执行脚本</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>-n表示检查有无语法错误,-x表示调试</p>\n<h3 id=\"变量展开\"><a href=\"#变量展开\" class=\"headerlink\" title=\"变量展开\"></a>变量展开</h3><table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>:$&#123;parameter:=word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,展开的结果是word的值,并且word的值会赋给parameter;否则展开为parameter的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter:-word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,展开的结果是word的值,否则是parameter的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter:?word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,会带有错误的推出,否则是parameter的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter:+word&#125;</code></td>\n<td align=\"center\">如果parameter没有设置或者为空,展开为空,否则是word的值;不管如何parameter值不会变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter#pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter开头开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter##pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter开头开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter%pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter结尾开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter%%pattern&#125;</code></td>\n<td align=\"center\">pattern是通配符模式,会从parameter结尾开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter/pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,只替换第一次匹配到的</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter//pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,替换所有匹配到的</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter/#pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter开头开始匹配,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter/%pattern/string&#125;</code></td>\n<td align=\"center\">在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter结尾开始匹配,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter,,&#125;</code></td>\n<td align=\"center\">把parameter全部展开成小写字母</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter,&#125;</code></td>\n<td align=\"center\">把parameter首字母展开成小写字母</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter^^&#125;</code></td>\n<td align=\"center\">把parameter全部展开成大写字母</td>\n</tr>\n<tr>\n<td align=\"center\"><code>$&#123;parameter^&#125;</code></td>\n<td align=\"center\">把parameter首字母展开成大写字母</td>\n</tr>\n</tbody></table>\n<p><code>$&#123;!prefix*&#125;</code>等价于<code>$&#123;!prefix@&#125;</code>这种展开会返回以prefix开头的已有变量名(而不是变量的值)<br>字符串的长度和切片其实也是一种展开</p>\n<p><span id = \"jump\"></span></p>\n<h3 id=\"进程替换\"><a href=\"#进程替换\" class=\"headerlink\" title=\"进程替换\"></a>进程替换</h3><p>进程替换可以用来解决子进程问题,它实质是把子进程的输出当作一个用于重定向的普通文件(文件描述符)。<br>标准输出<br><code>&lt;(cmd1;cmd2)</code><br>标准输入<br><code>&gt;(cmd1;cmd2)</code><br>由此可以解决read管道线的问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> attr links owner group size <span class=\"hljs-built_in\">date</span> time filename;<span class=\"hljs-keyword\">do</span><br>\t<span class=\"hljs-built_in\">cat</span> &lt;&lt;- <span class=\"hljs-string\">EOF</span><br><span class=\"hljs-string\">\t\tFilename: $filename</span><br><span class=\"hljs-string\">\t\tSize:     $size</span><br><span class=\"hljs-string\">\t\tOwner:    $owner</span><br><span class=\"hljs-string\">\t\tGroup:    $group</span><br><span class=\"hljs-string\">\t\tModified: $date $time</span><br><span class=\"hljs-string\">\t\tLinks:    $links</span><br><span class=\"hljs-string\">\t\tAttributes: $attr</span><br><span class=\"hljs-string\">\tEOF</span><br><span class=\"hljs-keyword\">done</span> &lt; &lt;(<span class=\"hljs-built_in\">ls</span> -l | <span class=\"hljs-built_in\">tail</span> -n +2)<br></code></pre></td></tr></table></figure>\n<p><span id = \"jumpopt\"></span></p>\n<h3 id=\"getopt和getopts\"><a href=\"#getopt和getopts\" class=\"headerlink\" title=\"getopt和getopts\"></a>getopt和getopts</h3><h4 id=\"getopt\"><a href=\"#getopt\" class=\"headerlink\" title=\"getopt\"></a>getopt</h4><p>格式:<code>getopt [options] optstring parameters</code>,例:<br><code>getopt ab:cd -a -b test1 -cd test2 test3</code>该命令会产生如下输出:<br><code>-a -b test1 -c -d -- test2 test3</code>,optstring定义了四个有效项字母:a、b、c和d。冒号(:)表示b选项需要个参数值,它会将-cd选项分成两个单独选项,插入’–’来分隔额外的参数,如果提供’-cde’由于e不在optstring中,会报错<strong>getopt: invalid option – e</strong>,但还会输出结果,可以加-q选项忽略报错结果。<br>在脚本中经常与set的’–’选项来使用,来把getopt的输出转成当前脚本的输入参数,示例如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-comment\"># Extract command line options &amp; values with getopt</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">set</span> -- $(getopt -q ab:<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span>)<br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">echo</span><br><span class=\"hljs-keyword\">while</span> [ -n <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span> ]<br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span> <span class=\"hljs-keyword\">in</span><br>    -a) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -a option&quot;</span> ;;<br>    -b) param=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$2</span>&quot;</span><br>        <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -b option, with parameter value <span class=\"hljs-variable\">$param</span>&quot;</span><br>        <span class=\"hljs-built_in\">shift</span> ;;<br>    -c) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -c option&quot;</span> ;;<br>    --) <span class=\"hljs-built_in\">shift</span><br>        <span class=\"hljs-built_in\">break</span> ;;<br>    *) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span> is not an option&quot;</span>;;<br>    <span class=\"hljs-keyword\">esac</span><br>    <span class=\"hljs-built_in\">shift</span><br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#</span><br>count=1<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span><br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Parameter #<span class=\"hljs-variable\">$count</span>: <span class=\"hljs-variable\">$param</span>&quot;</span><br>    count=$[ <span class=\"hljs-variable\">$count</span> + 1 ]<br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"getopts\"><a href=\"#getopts\" class=\"headerlink\" title=\"getopts\"></a>getopts</h4><p>格式:<code>getopts optstring variable</code>,这里variable为命令行上检测到的第一个参数(getopts会去除’-‘,这点与getopt不同),处理完所有参数后,它会返回一个大于0的退出状态码。可以用”:optstring”格式来忽略未识别选项的错误信息。会用到两个环境变量,如果选项用到一个参数值,OPTARG会保存该值,OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。<br>getopts可以识别双引号内的带括号参数值,而getopt不可以。getopts将命令行上找到的所有未定义选项统一输成问号,getopt遇到未识别的非选项值时,会结束识别,即使后面有正确的选项。可以用以下脚本自行测试getopts的行为:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span><br><span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">getopts</span> :ab:<span class=\"hljs-built_in\">cd</span> opt<br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$opt</span>&quot;</span> <span class=\"hljs-keyword\">in</span><br>        a) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -a option&quot;</span>  ;;<br>        b) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -b option, with value <span class=\"hljs-variable\">$OPTARG</span>&quot;</span> ;;<br>        c) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -c option&quot;</span>  ;;<br>        d) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Found the -d option&quot;</span>  ;;<br>        *) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Unknown option: <span class=\"hljs-variable\">$opt</span>&quot;</span> ;;<br>    <span class=\"hljs-keyword\">esac</span><br><span class=\"hljs-keyword\">done</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">shift</span> $[ <span class=\"hljs-variable\">$OPTIND</span> - 1 ]<br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-built_in\">echo</span><br>count=1<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span><br><span class=\"hljs-keyword\">do</span><br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Parameter <span class=\"hljs-variable\">$count</span>: <span class=\"hljs-variable\">$param</span>&quot;</span><br>    count=$[ <span class=\"hljs-variable\">$count</span> + 1 ]<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"set命令\"><a href=\"#set命令\" class=\"headerlink\" title=\"set命令\"></a>set命令</h3><p>set 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。可以使用<code>echo $-</code>查看当前设置,默认是（himxBH）<br>参数说明：</p>\n<p>|参数|说明|<br>|:-:||:-:|<br>|-a|标示已修改的变量，以供输出至环境变量|<br>|-b|使被中止的后台程序立刻回报执行状态|<br>|-B|启用大括号展开|<br>|-d|Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消|<br>|-e|若指令传回值不等于0，则立即退出shell|<br>|-f|取消使用通配符|<br>|-h|自动缓存命令的所在位置,如果在PATH指定路径内，更换命令的位置,缓存就不会同步，就会发生错误，不过谁会换命令的位置呢,可以使用which更新缓存|<br>|-i|设置当前选项为交互式|<br>|-k|指令所给的参数都会被视为此指令的环境变量|<br>|-l|记录for循环的变量名称|<br>|-m|使用监视模式,可以控制进程的停止、继续、后台前台等，默认打开|<br>|-n|测试模式，只读取指令，而不实际执行|<br>|-p|启动优先顺序模式|<br>|-P|启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接|<br>|-t|执行完随后的指令，即退出shell|<br>|-u|当执行时使用到未定义过的变量，则显示错误信息|<br>|-v|显示shell所读取的输入值|<br>|-H shell|可利用”!”加&lt;指令编号&gt;的方式来执行 history 中记录的指令,最好不用|<br>|-x|执行指令后，会先显示该指令及所下的参数|<br>|+&lt;参数&gt;|取消某个set曾启动的参数。与-&lt;参数&gt;相反|<br>|-o [option]|特殊属性有很多,见下面|</p>\n<p><strong>option属性</strong></p>\n<ul>\n<li>pipefail:管道流水线中有一个失败，则返回失败值，从右往左数起(默认只返回最后一个命令的退出码)</li>\n<li>noclobber:防止&gt;重定向操作符覆盖已有内容，你可以使用<code>command &gt;| file</code>强制覆盖</li>\n</ul>\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ul>\n<li>波浪号展开只能<strong>紧跟</strong>在<code>=</code>和<code>:</code>之后才能正确展开,引号中无法正确展开</li>\n<li>**&lt;&lt;<strong>和</strong>&lt;&lt;-**的区别在于,&lt;&lt;-会忽略接下来输入的tab建,一般用于格式化脚本,便于读代码</li>\n<li>组命令(在当前shell执行)–<code>&#123; command1;command2;command3  &#125;</code>,子shell–<code>(command1;command2;command3)</code>一般配合管道符</li>\n<li>trap命令<br><code>trap &quot;命令&quot; &quot;信号&quot;</code>当脚本遇到信号前执行的命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">trap</span> <span class=\"hljs-string\">&quot;echo I am ignoring you&quot;</span> SIGINT SIGTERM<br></code></pre></td></tr></table></figure>\n常见信号有:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">编号</th>\n<th align=\"center\">英文名</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">SIGHUP</td>\n<td align=\"center\">挂起进程</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">SIGINT</td>\n<td align=\"center\">终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">SIGQUIT</td>\n<td align=\"center\">停止进程</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">SIGKILL</td>\n<td align=\"center\">无条件终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">15</td>\n<td align=\"center\">SIGTERM</td>\n<td align=\"center\">尽可能终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">17</td>\n<td align=\"center\">SIGSTOP</td>\n<td align=\"center\">无条件停止进程,但不是终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">18</td>\n<td align=\"center\">IGTSTP</td>\n<td align=\"center\">停止或暂停进程,但不终止进程</td>\n</tr>\n<tr>\n<td align=\"center\">19</td>\n<td align=\"center\">SIGCONT</td>\n<td align=\"center\">继续运行停止的进程</td>\n</tr>\n</tbody></table>\n<pre><code>* tap除了捕获信号外,还会捕获脚本退出:`trap &quot;echo Goodbye...&quot; EXIT`,不管正常还是非正常,都会打印Goodbye\n* `trap -- SIGINT`取消某个信号的设置\n* `trap -`恢复信号的默认行为\n</code></pre>\n<ul>\n<li>wait命令<br><code>wait $pid</code>等待子进程<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#小火车子进程</span><br>sl &amp;<br>pid=$!<br><span class=\"hljs-comment\">#父进程继续干事</span><br><span class=\"hljs-built_in\">sleep</span> 2<br><span class=\"hljs-comment\">#干完事等子进程</span><br><span class=\"hljs-built_in\">wait</span> <span class=\"hljs-variable\">$pid</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;子父进程都结束了&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li>命名管道<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建一个命名管道文件</span><br><span class=\"hljs-built_in\">mkfifo</span> pipe1<br><span class=\"hljs-comment\">#子进程写入(写入完会阻塞,等待另一端读,所以不要wait)</span><br><span class=\"hljs-built_in\">ls</span> -l &gt; pipe1 &amp;<br><span class=\"hljs-comment\">#父进程读</span><br><span class=\"hljs-built_in\">sleep</span> 5<br><span class=\"hljs-built_in\">cat</span>&lt;pipe1<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>IFS默认是空白字符(回车，空格，制表符等)，位于字符串和结尾的空白字符都被删除，中间连续空格会被压缩成一个</li>\n</ul>\n<ul>\n<li>子shell的全局环境变量改变并不会影响父shell,甚至用export也不行</li>\n<li>命令替换<code>$(command)</code>,子shell<code>(command)</code>两个是不同概念,命令替换会开个子shell(貌似都会开子shell)</li>\n<li>文件描述符与exec<ul>\n<li>配合exec可以使标准输入输出永久重定向:<code>exec 2&gt;testerror</code>重定向标准错误至文件。</li>\n<li>exec可以创建文件描述:<code>exec 3&gt;testxx;echo hello&gt;&amp;3</code>这可以用来恢复正常的输入输出,如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">exec</span> 3&gt;&amp;1<br><span class=\"hljs-built_in\">exec</span> 1&gt;test14out<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;这会输入到test14out&quot;</span><br><span class=\"hljs-built_in\">exec</span> 1&gt;&amp;3<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;这会输入到屏幕&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li>exec创建读写描述符:<code>exec 3&lt;&gt;testfile</code>,这要特别小心,任何读或写都会从文件指针的上次位置开始</li>\n<li>exec关闭文件描述符:<code>exec 3&gt;&amp;-</code></li>\n<li>lsof命令可以查看已经打开的文件描述符,见Linux命令博客</li>\n</ul>\n</li>\n</ul>\n<p><span id = \"funAndArr\"></span></p>\n<ul>\n<li><p>函数与数组<br>将数组变量当作但个参数传递的话,它不会其作用,只会传递第一个值,可以借鉴以下例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-comment\"># array variable to function test</span><br><span class=\"hljs-keyword\">function</span> testit &#123;<br>    <span class=\"hljs-built_in\">local</span> newarray<br>    newarray=`<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span>`<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;The new array value is: <span class=\"hljs-variable\">$&#123;newarray[*]&#125;</span>&quot;</span><br>&#125;<br>myarray=(1 2 3 4 5)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;The original array is <span class=\"hljs-variable\">$&#123;myarray[*]&#125;</span>&quot;</span><br>testit <span class=\"hljs-variable\">$&#123;myarray[*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>预处理替换优先级<br>a.shell替换:文件通配符<br>b.变量替换<br>c.命令替换,如下示例:  </p>\n</li>\n<li><p>shell元字符汇总</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">空格、制表符</td>\n<td align=\"center\">命令行参数的分隔符</td>\n</tr>\n<tr>\n<td align=\"center\">回车</td>\n<td align=\"center\">执行键入的命令</td>\n</tr>\n<tr>\n<td align=\"center\">&lt; &gt; &brvbar;</td>\n<td align=\"center\">重定向与管道</td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\">多个命令分隔符</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;</td>\n<td align=\"center\">后台运行</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"center\">引用shell的变量</td>\n</tr>\n<tr>\n<td align=\"center\">`</td>\n<td align=\"center\">命令替换,<code>\\\\</code>代表反斜线自身,&#96;`&#96;代表反撇号自身</td>\n</tr>\n<tr>\n<td align=\"center\">* [] ?</td>\n<td align=\"center\">文件通配符,不匹配*和&#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">()</td>\n<td align=\"center\">用于定义shell函数或子shell中执行命令</td>\n</tr>\n<tr>\n<td align=\"center\">\\</td>\n<td align=\"center\">转义字符取消元字符特殊含义，若不用于元字符跟不加一样</td>\n</tr>\n<tr>\n<td align=\"center\">“ “</td>\n<td align=\"center\">其中的内容除$和`外取消元字符的特殊含义</td>\n</tr>\n<tr>\n<td align=\"center\">‘ ‘</td>\n<td align=\"center\">取消所有元字符特殊含义</td>\n</tr>\n</tbody></table>\n<ul>\n<li>RANDOM是个内建的随机值</li>\n<li><code>&lt;&lt;&lt;</code><br>here-string语法，允许直接传递字符串给标准输入</li>\n<li>eval<br>eval 的功能是将字符串作为代码来执行。看上去好像很简单，但实际涉及很复杂的内容，主要是符号转义导致的语义问题。<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-attribute\">str1</span>=str2<br><span class=\"hljs-attribute\">str2</span>=abc<br>eval echo \\$<span class=\"hljs-variable\">$str1</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"tokio","date":"2022-06-27T13:04:09.000Z","subtitle":null,"index_img":"/images/tokio.png","banner_img":"/images/tokio.png","_content":"## 不适用场景\n- 并行运行CPU密集型的任务（并行计算）\n- 读取大量的文件\n- 发送少量HTTP请求\n## async main\n异步main函数的意义：\n- .await只能在async函数中使用\n- 异步运行时本身需要初始化，`#[tokio::main]`宏将`async fn main`隐式转换为`fn main`，同时还对整个异步运行时进行了初始化：\n```rust\n#[tokio::main]\nasync fn main() {\n    println!(\"hello\");\n}\n```\n转化为：\n```rust\nfn main() {\n    let mut rt = tokio::runtime::Runtime::new().unwrap();\n    rt.block_on(async {\n        println!(\"hello\");\n    })\n}\n```\n","source":"_posts/tokio.md","raw":"---\ntitle: tokio\ndate: 2022-06-27 21:04:09\nsubtitle:\ncategories:\ntags:\nindex_img: /images/tokio.png\nbanner_img: /images/tokio.png\n---\n## 不适用场景\n- 并行运行CPU密集型的任务（并行计算）\n- 读取大量的文件\n- 发送少量HTTP请求\n## async main\n异步main函数的意义：\n- .await只能在async函数中使用\n- 异步运行时本身需要初始化，`#[tokio::main]`宏将`async fn main`隐式转换为`fn main`，同时还对整个异步运行时进行了初始化：\n```rust\n#[tokio::main]\nasync fn main() {\n    println!(\"hello\");\n}\n```\n转化为：\n```rust\nfn main() {\n    let mut rt = tokio::runtime::Runtime::new().unwrap();\n    rt.block_on(async {\n        println!(\"hello\");\n    })\n}\n```\n","slug":"tokio","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi78001tgwq24d2tceii","content":"<h2 id=\"不适用场景\"><a href=\"#不适用场景\" class=\"headerlink\" title=\"不适用场景\"></a>不适用场景</h2><ul>\n<li>并行运行CPU密集型的任务（并行计算）</li>\n<li>读取大量的文件</li>\n<li>发送少量HTTP请求</li>\n</ul>\n<h2 id=\"async-main\"><a href=\"#async-main\" class=\"headerlink\" title=\"async main\"></a>async main</h2><p>异步main函数的意义：</p>\n<ul>\n<li>.await只能在async函数中使用</li>\n<li>异步运行时本身需要初始化，<code>#[tokio::main]</code>宏将<code>async fn main</code>隐式转换为<code>fn main</code>，同时还对整个异步运行时进行了初始化：<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[tokio::main]</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() &#123;<br>    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n转化为：<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() &#123;<br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">rt</span> = tokio::runtime::Runtime::<span class=\"hljs-title function_ invoke__\">new</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();<br>    rt.<span class=\"hljs-title function_ invoke__\">block_on</span>(<span class=\"hljs-keyword\">async</span> &#123;<br>        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"不适用场景\"><a href=\"#不适用场景\" class=\"headerlink\" title=\"不适用场景\"></a>不适用场景</h2><ul>\n<li>并行运行CPU密集型的任务（并行计算）</li>\n<li>读取大量的文件</li>\n<li>发送少量HTTP请求</li>\n</ul>\n<h2 id=\"async-main\"><a href=\"#async-main\" class=\"headerlink\" title=\"async main\"></a>async main</h2><p>异步main函数的意义：</p>\n<ul>\n<li>.await只能在async函数中使用</li>\n<li>异步运行时本身需要初始化，<code>#[tokio::main]</code>宏将<code>async fn main</code>隐式转换为<code>fn main</code>，同时还对整个异步运行时进行了初始化：<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[tokio::main]</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() &#123;<br>    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n转化为：<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() &#123;<br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">rt</span> = tokio::runtime::Runtime::<span class=\"hljs-title function_ invoke__\">new</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();<br>    rt.<span class=\"hljs-title function_ invoke__\">block_on</span>(<span class=\"hljs-keyword\">async</span> &#123;<br>        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"zsh","date":"2022-02-03T11:54:32.000Z","subtitle":null,"index_img":"/images/zsh.png","banner_img":"/images/zsh.png","_content":"\n### 变量定义\nZsh的变量除了哈希表以外，都直接赋值使用,包括整数(64位带符号)、浮点数(64位带符号)、字符串、数组、哈希表,`$+var`,判断变量是否定义,未定义返回0,否则为1\n\n### 字符串变量\n1) 获取字符串长度\n`str=abcde echo $#str`\n2) 字符串拼接\n`str2+=$str1;str3=$str1$str2`\n<span id = \"slice\"></span>\n3) 字符串切片\n字符位置从1开始算,bash风格的则从0开始算\n`echo $str[2,4]`\n4) 字符串截断\n```bash\nstr=abcdeabcde\n#删除左端匹配到的内容,最小匹配\necho ${str#*b} #输出cdeabcde\n#删除右端匹配到的内容,最小匹配\necho ${str%d*} #输出abcdeabc\n#删除左端匹配到的内容,最大匹配\necho ${str##*b} #输出cde\n#删除右端匹配到的内容,最大匹配\necho ${str%%d*} #输出abc\n```\n<span id = \"find\"></span>\n5) 字符串查找\n```bash\n#从左往右找cd字符串,找不到返回数组大小+1\necho $str[(i)cd]\n#从右往左找cd字符串,找不到返回0\necho $str[(I)cd]\n#从第二个位置开始找\necho ${str[(in:2:)cd]}\n```\n6) 遍历字符\n```bash\nfor i ({1..$#str}){\n\techo $str[i]\n}\n```\n7) 字符串替换\n```bash\nstr=abcabc\n#只替换找到第一个\necho ${str/bc/ef} #aefabc\n#只删除找到第一个\necho ${str/bc} #aabc\n#上面两个的所有版本\necho ${str//bc/ef}\necho ${str//bc}\n\nstr=abcABCabcABCabc\n\n# /# 只从字符串开头开始匹配，${str/#abc} 也同理\necho ${str/#abc/123} #123ABCabcABCabc\n\n# /% 只从字符串结尾开始匹配，echo ${str/%abc} 也同理\necho ${str/%abc/123} #abcABCabcABC123\n\nstr=abc\n# 如果匹配到了则输出空字符串\necho ${str:#ab*}\n\n# 如果匹配不到，则输出原字符串\necho ${str:#ab}\n\n#按位置删除字符和替换字符,就是指定位置赋值\nstr[1]=\nstr[2,4]=\nstr[1]=k\nstr[2,4]=sjkg #可以不一一对应\n```\n8) 字符串是否匹配\n```bash\n#是否包含\n[[ $str1 == *$str2* ]] && echo good\n#正则匹配\n[[ $str =~ 'c[0-9]' ]]\n```\n9) 大小写转换\n```bash\n#转成大写\necho ${(U)str}\necho ${str:u}\n#转成小写\necho ${(L)str}\necho ${str:l}\n#首字母大写\necho ${(C)str}\n```\n10) 目录文件名截取\n```bash\nfilepath=/a/b/c.x\n# :h 是取目录名，即最后一个 / 之前的部分，如果没有 / 则为 .\necho ${filepath:h} #/a/b\n# :t 是取文件名，即最后一个 / 之后的部分，如果没有 / 则为字符串本身\necho ${filepath:t} #c.x\n# :e 是取文件扩展名，即文件名中最后一个点之后的部分，如果没有点则为空\necho ${filepath:e} #x\n# :r 是去掉末尾扩展名的路径\necho ${filepath:r} #/a/b/c\n```\n11) 相对路径转绝对路径\n```bash\n#功能相当于$(readlink -f $filepath)\nfilepath1=a.txt\necho ${filepath1:A}\n```\n12) 分割字符串\n```bash\n# 使用空格作为分隔符，多个空格也只算一个分隔符\nstr='aa bb cc dd'\necho ${str[(w)2]}#bb\n\n# 指定分隔符\nstr='aa--bb--cc'\n# 如果分隔符是 : 就用别的字符作为左右界，比如 ws.:.\necho ${str[(ws:--:)3]}#cc\n```\n\n<span id = \"arrAndStr\"></span>\n* 转成数组\n```bash\narray=()${=str})#默认按空格分隔,可以设置IFS环境变量设置,也可以按以下方法\nstr=\"1:2::4\"\n\n#可以是多个字符,如**s/::/**,以**::**为分隔,同时也可以写成**.::.**,不必一定\n#使用**/**,可以用任意符号\nstr_array=(${(s/:/)str})\necho $str_array #1 2 4 #忽略空字符串\n# 保留其中的空字符串\nstr_array=(\"${(@s/:/)str}\")\necho $str_array[3]#该值为空\necho $str_array[4]\nstr+=(1234)#字符串直接变成一个包含两个元素的数组\n```\n13) 读取文件内容到字符串\n```bash\n# 比用 str=$(cat filename) 性能好很多\nstr=$(<filename)\n\n# 比用 cat filename 性能好很多，引号不能省略\necho \"$(<filename)\"\n\n# 遍历每行，引号不能省略\nfor i (${(f)\"$(<filename)\"}) {\n    echo $i\n}\n# 小文件或者需要频繁调用时，尽量不要用 sed\n#输出第2行\necho ${\"$(<test.txt)\"[(f)2]}\n# 输出包含 “ang” 的第一行\necho ${\"$(<test.txt)\"[(fr)*ang*]}\n```\n14) 读取进程输出到字符串\n就是把\\$(<filename)换城\\$(cmd)\n\n### 条件语句\n```bash\nif [some condition]{\n} elif{\n} else{\n}\n```\n\n### print和printf\nzsh支持print和printf,`print -`再按tab健就可以查看所有选项,`printf %`再按tab键就可以查看所有格式化的东西\n\nprint支持的选项\n\n|选项|功能|参数|\n|:-:|:-:|:-:|\n|-C|按列输出|列数|\n|-D|替换路径成带~的版本|无|\n|-N|使用\\x00(null)作为字符串的间隔,默认是空格|无|\n|-O|降序排列|无|\n|-P|输出颜色和特殊样式|无|\n|-R|模拟echo命令|无|\n|-S|放命令放入了历史命令文件(要加引号)|无|\n|-X|替换所有tab为空格|tab对应空格数|\n|-a|和-c/-C一起使用时,改为从左到右|无|\n|-b|识别出bindkey转义字符串|无|\n|-c|按列输出(自动决定列数)|无|\n|-f|同printf|无|\n|-i|和-o/-O一起使用时,大小写不敏感排序|无|\n|-l|使用换行符作为字符串分隔符|无|\n|-m|只输出匹配的字符串|匹配模式字符串|\n|-n|不自动添加最后的换行符|无|\n|-o|升序排列|无|\n|-r|不处理转义字符|无|\n|-s|放命令放入历史命令文件(不要加引号)|无|\n|-u|指定fd输出|fd号|\n|-v|把内容保存到变量|变量名|\n|-x|替换行首的tab为空格|tab对应空格数|\n|-z|把内容放置到命令行编辑区|无|\n\n* 颜色\n```\n# %B 加粗 %b 取消加粗\n# %F{red} 前景色 %f 取消前景色\n# %K{red} 背景色 %k 取消背景色\n# %U 下滑线 %u 取消下滑线\n# %S 反色 %s 取消反色\n#\n# black or 0  red     or 1\n# green or 2  yellow  or 3\n# blue  or 4  magenta or 5\n# cyan  or 6  white   or 7\n\n# 显示加粗的红色 abc\nprint -P '%B%F{red}abc'\n\n# 没覆盖到的功能可以用原始的转义符号，可读性比较差\n# 4[0-7] 背景色\n# 3[0-7] 前景色\n# 0m 正常 1m 加粗 2m 变灰 3m 斜体 4m 下滑钱 5m 闪烁 6m 快速闪烁 7m 反色\n\n# 显示闪烁的红底绿字 abc\n% print \"\\033[41;32;5mabc\\033[0m\"\n```\n\n### 通配符\n\n|通配符|含义|\n|:-:|:-:|\n|*|任意数量的字符|\n|?|任意一个字符|\n|[abcd]|abcd中的任意一个字符|\n|[^abcd]|除abcd中的任意一个字符|\n|[a-c]|a和c之间的一个字符|\n|[a-cB-Dxyz]|a和c之间、B和D之间以及xyz中的一个字符|\n|<1-100>|1和100之间的整数|\n|<-50>|0和50之间的整数|\n|<100->|大于100的整数|\n|-|任意正整数和0|\n|([a-c]\\|<1-100>)|a和c之间的一个字符或者1和100之间的整数|\n\n**加强版,要支持需要加上`setopt EXTENDED_GLOB`**\n\n|通配符|含义|匹配的样式|\n|:-:|:-:|:-:|\n|^abc|除了 abc 外的任意字符串|aaa|\n|abc^abc|以 abc 开头，但后边不是 abc 的字符串|abcabd|\n|a\\*c~abc|符合 a\\*c 但不是 abc 的字符串|adc|\n|a#|任意数量（包括 0）个 a|aaa|\n|b##|一个或者多个b|b|\n|(ab)##|一个或者多个ab|abab|\n|(#i)abc|忽略大小写的abc|AbC|\n|(#i)ab(#I)c|忽略大小写的 ab 接着 c|ABc|\n|(#l)aBc| 和 c 忽略大小写，但 B 必须大写 的 aBc|aBC|\n|(#a1)abc|最多错（多或缺也算）一个字符的 abc|a2c 或 ab 或 abcd|\n\n### 数组变量\n1) 数组定义\n```bash\narray=(a \"bb cc\" dd)\necho $array #打印所有元素在一行\nprint -l $array #每行输出一个元素\n```\n2) 元素读写\n```bash\necho $array[3]\necho $array[-1]\necho $#array #获取长度\narray[3]=some\narray[3]=() #删除元素\narray+=eeee #添加元素\nunset array #删除整个数组\n```\n3) 数组拼接\n```bash\narray1+=(e f g)\narray1+=($array2) #小括号必须加,不加的话,则array2视为一个字符串\n```\n4) [字符串与数组](#arrAndStr)\n5) 数组遍历\n```\nfor i ($array1){\n\techo $i\n}\n#同时遍历两个数组\nfor i ($array1 $array2){\n\techo $i\n}\n```\n6) [切片访问](#slice)\n7) [元素查找](#find)\n8) 元素排序\n```bash\necho ${(o)array} #升序排列\necho ${(O)array} #降序排列\necho ${(oi)array} #大小写不敏感升序排列\necho ${(on)array} #按数字升序排列\necho ${(Oa)array} #反转数组元素\n```\n9) 去重\n```bash\necho ${(u)array}\n```\n10) 构造连续字符或数值数组\n```bash\narray=(aa{bb,cc,11}) && echo $array #aabb aacc aa11\narray=(aa{1..3}) && echo $array #aa1 aa2 aa3\narray=(aa{15..19..2}) && echo $array #aa15 aa17 aa19\narray=(aa{19..15..2}) && echo $array #aa19 aa17 aa15\narray=(aa{01..03}) && echo $array #aa01 aa02 aa03\narray=(aa{a..c}) && echo $array #aaa aab aac\narray=(aa{Y..c}) && echo $array #ASCII码顺序\n```\n11) 从文件构造数组\n```bash\n# f 的功能是将字符串以换行符分隔成数组\n# 双引号不可省略，不然会变成一个字符串，引号也可以加在 ${ } 上\narray=(${(f)\"$(<test.txt)\"})\nprint -l $array\n#a\n#bb\n#ccc\n#dddd\n# 不加引号的效果\narray=(${(f)$(<test.txt)})\nprint -l $array\n#a bb ccc dddd\n\n# 从文件构造数组，并将每行按分隔符 : 分隔后输出所有列\nfor i (${(f)\"$(<test.txt)\"}) {\n    array=(${(s.:.)i})\n    echo $array[1,-1]\n}\n```\n12) 从文件列表构造数组\n```bash\narray=(/usr/bin/vim*)\nprint -l $array\n#/usr/bin/vim\n#/usr/bin/vimdiff\n#/usr/bin/vimtutor\n\n# 要比 ls /usr/bin/[a-b]?? | wc -l 快很多\narray=(/usr/bin/[a-b]??) && print $#array\n```\n13) 数组交集差集\n```bash\n# 两个数组的交集，只输出两个数组都有的元素,如果有重复元素不会去重\necho ${array1:*array2}\n# 两个数组的差集，只输出 array1 中有，而 array2 中没有的元素\necho ${array1:|array2}\n```\n14) 数组交叉合并\n```bash\n# 从 array1 取一个，再从 array2 取一个，以此类推，一个数组取完了就结束\necho ${array1:^array2}\n# 如果用 :^^，只有一个数组取完了的话，继续从头取，直到第二个数组也取完了\n% echo ${array1:^^array2}\n```\n15) 对数组中的字符串进行统一处理\n```bash\n# :t 是取字符串中的文件名，可以用在数组上，取所有元素的文件名\nprint -l ${array:t}\n# :e 是取扩展名，如果没有没有扩展名，结果数组中不会添加空字符串\nprint -l ${array:e}\n# 字符串替换等操作也可以对数组使用，替换所有字符串\nprint -l ${array/a/j}\n# :# 是排除匹配到的元素，类似 grep -v\nprint ${array:#a*}\n# 前边加 (M)，是反转后边的效果，即只输出匹配到的元素，类似 grep\nprint ${(M)array:#a*}\n# 多个操作可以同时进行，(U) 是把字符串转成大写字母\nprint ${(UM)array:#a*}\n\n# 截断或对齐数组中的字符串\narray=(abc bcde cdefg defghi)\n\n# 只取每个字符串的最后两个字符\necho ${(l:2:)array}\nbc de fg hi\n\n# 用空格补全字符串并且右对齐\nprint -l ${(l:7:)array}\n    abc\n   bcde\n  cdefg\n defghi\n\n# 用指定字符补全\nprint -l ${(l:7::0:)array}\n0000abc\n000bcde\n00cdefg\n0defghi\n\n# 用指定字符补全，第二个字符只用一次\nprint -l ${(l:7::0::1:)array}\n0001abc\n001bcde\n01cdefg\n1defghi\n\n# 左对齐\nprint -l ${(r:7::0::1:)array}\nabc1000\nbcde100\ncdefg10\ndefghi1\n```\n### 字典变量\n1) 定义\n```bash\ntypeset -A table\n# 先声明,或者用 local，二者功能是一样的\nlocal -A table\n\n# 赋值的语法和数组一样，但顺序依次是键、值、键、值\ntable=(k1 v1 k2 v2)\n#可以声明赋值一块,local -A table=(k1 v1 k2 v2)\n\n# 直接用 echo 只能输出值\necho $table #v1 v2\n\n# 使用 (kv) 同时输出键和值，(kv) 会把键和值都放到同一个数组里\n% echo ${(kv)table} #k1 v1 k2 v2\n\n# 哈希表的大小是键值对的数量\necho $#table\n```\n2) 读写\n```bash\necho $table[k2]\ntable[k2]=\"v2\"\n# 删除元素的方法和数组不同，引号不能省略\nunset \"table[k1]\"\n```\n3) 哈希表拼接\n```bash\n# 追加元素的方法和数组一样\ntable+=(k4 v4 k5 v5)\n# 拼接哈希表，要展开成数组再追加\ntable1+=(${(kv)table2})\n```\n4) 哈希表遍历\n```bash\n# 只遍历值\nfor i ($table) {\necho $i\n}\n# 只遍历键\nfor i (${(k)table}) {\necho $i\n}\n# 同时遍历键和值\nfor k v (${(kv)table}) {\necho \"$k -> $v\"\n}\n```\n5) 键是否存在\n```bash\n(($+table[k1]))\n```\n6) 元素排序\n和数组类似,增加k、v两个选项\n```bash\n# 只对值排序\necho ${(o)table}\n\n# 只对键排序\necho ${(ok)table}\n\n# 键值放在一起排序\necho ${(okv)table}\n```\n7) 从字符串、文件构造哈希表\n```bash\nstr=\"k1 v1 k2 v2\"\nlocal -A table=(${=str})\n#从文件构造和数组类似\n```\n8) 对哈希表的每个元素统一处理\n可参见数组,同时增加kv两个选项\n```bash\n#值转成大写\nprint ${(U)table}\n#键转成大写\nprint ${(Uk)table}\n#键值转成大写\nprint ${(Ukv)table}\n# 排除匹配到的值\necho ${table:#v1}\n# 只输出匹配到的键\necho ${(Mk)table:#k[1-2]}\n```\n\n### 数值类型\nzsh通常不指定数值是整形还是浮点型,通常直接赋值，**虽然默认为字符串**,但作数值计算时自动判断,但可以如下指明类型,同时在双小括号里做c语言的任何符号计算,同时括号内变量可以不需要加$符号(貌似是zsh的一般特性,适用于许多其他场合)\n```bash\ninteger i=123\nfloat f=12.56\n#(t)用于输出变量类型\necho ${(t)i} #integer\necho ${(t)f} #float\n# 注意一旦指定了变量类型，类型就不会变了，除非再重新指定其他类型，或者用 unset 删除掉 \n# 如果把浮点数赋值给整数变量，会取整\ni=12.34\necho $i #会输出12\n```\n* 数学函数\nzsh/mathfunc模块包含数学函数\n```\nzmodload -i zsh/mathfunc\necho $((sin(0)+ceil(14.4)))\n```\n**函数列表**\n\n|函数名|功能|\n|:-:|:-:|\n|abs|取绝对值|\n|ceil|向上取整|\n|floor|向下取整|\n|int|截断取整|\n|float|转换成浮点数|\n|sqrt|开平方|\n|cbrt|开立方|\n|log|自然对数|\n|log10|常用对数|\n|rand48|随机数|\n\n还有:acos、acosh、asin、asinh、atan、atanh、cos、cosh、erf、erfc、exp、 expm1、fabs、gamma、j0、j1、lgamma、log1p、logb、sin、sinh、tan、 tanh、y0、y1、ilogb、signgam、copysign、fmod、hypot、nextafter、jn、 yn、ldexp、scalb\n\n### 变量修饰语\n**一般两种格式:**\n* `${(x)var}` var是变量名,x是一个或多个字母,\n* `${var:x}` var是变量名,x是一个或多个字母,或其他符号\n\n**注意:加了修饰语的变量依然是变量,可以当普通变量处理,可以嵌套使用,$符号后不可以有空格**\n\n|修饰符|举例|说明|\n|:-:|:-:|:-:|\n|:-|`echo ${var:-abc}`|如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc|\n|-|`echo ${var-abc}`|如果变量有值,则输出原值,如果变量不存在,则输出abc|\n|:=|`echo ${var:=abc}`|如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc并且赋值给var|\n|::=|`echo ${var::=123}`|不管有没有值，村不存在，都输出123，并且重新赋值|\n|:?|`echo ${var:?error}`|var没有值或不存在,则直接报错,否则输出原值|\n|:+|`echo ${var:+123}`|如果var有值,则输出123,否则输出空|\n|(F)|`echo ${(F)array}`|把数组中的元素以换行符拼接成字符串,不加任何修饰的话则是空格拼接|\n|(j/x/)|`echo ${(j/-=/)array}`|把数组中的元素以-=两个字符连接|\n|(s/x/)|`echo ${(s/==/)str}`|把字符串中的字符以==两个字符为分隔符分成数组|\n|(t)|`echo ${(t)var}`|输出变量的类型:integer float scalar array association|\n|`(P)`|`var=abc abc=123 echo ${(P)var}`|多重替换,输出123|\n|[#n]|`echo $(([#16] 255))`|以n进制显示十进制整数|\n|n#|`echo $((16#ff))`|显示n进制整数为十进制|\n\n### 函数\n与bash基本一致,增加了`unfunction fun`删除某个函数的功能,还有就是规避了`$*`和`$@`的区别,zsh推荐只用`$*`\n\n### 替代find和ls\n需要开启扩展通配符:setopt EXTENDED_GLOB\n**通配符修饰语列表**\n\n|名称|含义|使用样例或补充说明|\n|:-:|:-:|:-:|\n|/|目录||\n|F|非空|/F(非空目录) /^F(空目录)|\n|.|普通文件||\n|@|符号链接||\n|=|socket文件||\n|p|FIFO 文件||\n|\\*|可执行的普通文件||\n|%|设备文件||\n|%b|块设备文件||\n|%c|字符设备文件||\n|r|文件拥有着有读权限||\n|w|文件拥有着有写权限||\n|x|文件拥有着有执行权限||\n|A|文件拥有组用户有读权限||\n|I|文件拥有组用户有写权限||\n|E|文件拥有组用户有执行权限||\n|R|任何用户都有读权限||\n|W|任何用户都有写权限||\n|X|任何用户都有执行权限||\n|s|设置了setuid的文件||\n|S|设置了setgid的文件||\n|t|设置了粘滞位（sticky bit）的文件||\n|f|符合指定的权限|f0644 f4755 f700|\n|e||暂无|\n|+|大于某个数|通常跟数字,与其他配合使用|\n|d|指定设备号||\n|l|硬连接个数|l-2（小于 2） l+3（大于 3）|\n|U|当前用户拥有||\n|G|当前用户所在组拥有||\n|u|指定用户 id 拥有|u1000|\n|g|指定用户组 id 拥有|g1000|\n|a|指定文件的 atime|访问时间,默认单位是天,可跟单位M(月)、w(周)、h(小时)、m(分钟)、s(秒)、+(指定时间之前)、-(指定时间之内)|\n|m|指定文件的 mtime|修改时间,可跟单位、+-,`print -l *(.mm+1)`|\n|c|指定文件的 ctime|文件状态属性修改时间,可跟单位、+-,`print -l *(.cm+1)`|\n|L|指定文件大小|默认单位是字节,单位有k、m和p(512字节的块),也可以大写,`print -l *(.Lm-1)`|\n|^|取反|/^F|\n|-|小于某个数|通常跟数字,与其他配合使用|\n|M||暂无|\n|T||暂无|\n|N|如果没匹配到，返回空而不报错|\n|D|包含隐藏文件（. 开头）|\n|n|按数值大小排序|下文有说明|\n|o|递增排序|下文有说明|\n|O|递减排序|下文有说明|\n|[n]|只取第 n 个文件|.[5]|\n|[n1,n2]|取第 n1 到 n2 个文件|/[5,10]|\n|:X||暂无|\n\n1) 文件排序\n\n可供排序的因子:n(文件名),L(大小),I(硬连接数),a(atime),m(mtime),c(ctime),d(所在目录深度,从深到浅)\n```bash\n# 按文件名排序，同一目录下的文件和目录名会一起排，而不是先排目录再排文件\n#**/*,指当前目录和子目录\nprint -l **/*(.on)\nbb.txt\ncc/aa.txt\ncc/dd.txt\nzz.txt\n\n# 按文件的目录深度逆序排，d 是从深往浅排，O 是逆序\nprint -l **/*(.Od)\nzz.txt\nbb.txt\ncc/dd.txt\ncc/aa.txt\n\n# 先按文件名排序，然后再按大小排序，这样大小相同的文件依然是按文件名排的\nprint -l **/*(.onoL)\nbb.txt\ncc/aa.txt\ncc/dd.txt\ncc.txt\n```\n2) 组合使用\n\n\t类型和类型之间要用逗号个开,逗号前后内容互不干扰(取反^只影响到逗号之前的内容)\n\n\t`print -l *(/m-2,.Lm-3oL,@D)`\n\n3) 批量重命名zmv\n```bash\n# 使用前需要先加载进来\nautoload -U zmv\n\n# 将所有 txt 文件扩展名改成 conf\n# 参数要用单引号扩起来，$1 代表第一个参数中括号中的内容\n zmv '(*).txt' '$1.conf'\n\n# 如果加了 -W 参数，zmv 会自动识别文件名中需要保留的部分\n zmv -W '*.txt' '*.conf'\n\n# 调整文件名各部分的前后顺序\nzmv '(*).(*).txt' '$2.$1.txt'\n# 加 -n 预览而不实际运行\nzmv -n '(*).(*).txt' '$2.$1.txt'\nmv -- a.b.txt b.a.txt\n\n# 0 1 2 ... 前添加 0，以便和 10 11 12 ... 宽度一致\nzmv '([0-9]).(*)' '0$1.$2'\n# 去掉开头的一个 0\nzmv '(0)(*)' '$2'\n\n# 文件整理到目录\nzmv '(*) - (*) - (*).txt' '$1/$2 - $3.txt'\n\n# 转换大小写\nzmv '(*).txt' '${(U)1}.txt'\nzmv '(*).txt' '${(L)1}.txt'\n```\n4) 不展开通配符\n```bash\ncalc() {\n    zmodload zsh/mathfunc\n    echo $(($*))\n}\ncalc 12+12\ncalc 12*12 #会报错\nnoglob calc 12*12 #可以\n```\n### local和typeset \nlocal和typeset基本一样(除了不能用-f和-g这两个选项)\n\n|选项|含义|举例|\n|:-:|:-:|:-:|\n|-l|强制字符串内容为小写|`local -l str=abcABC`|\n|-u|强制字符串内容为大写|`local -u str=abcABC`|\n|-x|设置为环境变量|`export str=abc`等价于`local -x str=abc`|\n|-r|只读|`local -r strl=abc`等价于`readonly str1=abc`|\n|-U|设置数组不包含重复元素|`local -U array=(aa bb aa cc)`|\n|-Z n|设置整数位数|不够用0不全,超过会被截断|\n|-i n|设置整数为其他进制显示|支持2-36|\n|`local {i,j,k}=123`|赋值多个变量为同一个值||\n|-T|绑定字符串和数组|`local -T DIR dir`,DIR为字符串,dir为数组,以冒号连接,主要用于path变量|\n|-p|显示变量的定义方式|显示脚本如何定义该变量的|\n\n### 双引号问题\nzsh不需要像bash那样频繁加双引号来避免错误。\nzsh需要加双引号的场景:\n1) 像这样的包含字符或者特殊符号的字符串 `\"aa bb \\t \\n *\"` 出现在代码中时，两边要加双引号\n2) 在用`$()`调用命令时，如果希望结果按一个字符串处理，需要加上双引\n3) 如果想将数组当单个字符串处理，需要加双引号，`array=(a b); print -l \"$array\"`\n4) 其他的原本不是单个字符串的东西，需要转成单个字符串的场景，要加双引号\n\n其余通常不加,其中典型场景:\n1) 任何情况下，字符串变量的两边都不需要加双引号，无论里边的内容多么特殊，或者变量存不存在，都没有关系，如`$str`\n2) 如果不转换类型（比如数组转成字符串），任何变量的两边都不需要加双引号\n3) `$1 $2 $*`这些参数（其实它们也都是单个字符串），都不需要加双引号，无论内容是什么，或者参数是否存在。\n\n### mapfile读写文件\n```bash\nzmodload zsh/mapfile\n\n# 这样就可以创建文件并写入内容，如果文件存在则会被覆盖\nmapfile[test.txt]=\"ab cd\"\ncat test.txt\n#ab cd\n\n# 判断文件是否存在\n(($+mapfile[test.txt])) && echo good\n#good\n\n# 读取文件\necho $mapfile[test.txt]\n#ab cd\n\n# 删除文件\nunset \"mapfile[test.txt]\"\n\n# 遍历文件\nfor i (${(k)mapfile}) {\necho $i\n}\n#test1.txt\n#test2.txt\n```\n\n### 循环语句\n```bash\nwhile [some condition]{\n\tbreak/continue\n}\n```\n```\nuntil [some condition]{\n\tbreak/continue\n}\n```\n```bash\n#样例\nfor i (aa bb cc){\n\techo $i\n}\narray=(aa bb cc)\nfor i ($array) {\n\techo $i\n}\nfor ((i=0; i < 10; i++)){\n\techo $i\n}\nfor i ({1..10}){\n\techo $i\n}\n```\n```\nrepeat 5{\n\techo good\n}\n```\n\n### 分支语句\n```bash\ncase $i {\n\t(a)\n\techo 1\n\t;;\n\n\t(b)\n\techo 2\n\t#继续执行下一个匹配的语句(不再进行匹配)\n\t;&\n\n\t(c)\n\techo 3\n\t#继续向下匹配，看是否有满足条件的分支\n\t;|\n\n\t(c)\n\techo 33\n\t;;\n\n\t(*)\n\techo oher\n\t;;\n}\n```\n\n### 用户输入选择语句\n```bash\nselect i (aa bb cc){\n\techo $i\n}\n```\n必须加break,否则会一直让用户选择\n\n### 异常处理语句\n```bash\n{\n\t语句1\n} always{\n\t语句2\n}\n```\n无论语句1是否出错,都执行语句2\n\n### socket模块\n```bash\n# 监听连接端=======\n# 首先要加载 socket 模块\nzmodload zsh/net/socket\n\nzsocket -l test.sock\nlistenfd=$REPLY\n# 此处阻塞等待连接\nzsocket -a $listenfd\n# 连接建立完成\nfd=$REPLY\n# 然后 $fd 就可读可写\ncat <&$fd\n\n# 发起连接端==========\nzmodload zsh/net/socket\nzsocket test.sock\nfd=$REPLY\necho good >&$fd\n\n# 关闭监听端========\nexec {listenfd}>&-\nexec {fd}>&-\nrm test.sock\n\n# 关闭连接端======\nexec {fd}>&-\n```\n\n### TCP模块\n```bash\n# 监听连接端=======\n# 首先要加载 tcp 模块\nzmodload zsh/net/tcp\n\nztcp -l 1234\nlistenfd=$REPLY\n# 此处阻塞等待连接\nztcp -a $listenfd\n# 连接建立完成\nfd=$REPLY\n\n# 然后 $fd 就可读可写\ncat <&$fd\n\n# 发起连接端===========\n# 首先要加载 tcp 模块\nzmodload zsh/net/tcp\n\nztcp 127.0.0.1 1234\n# 连接建立完成\nfd=$REPLY\n\n# 然后 $fd 就可读可写\necho good >&$fd\n\n# 关闭发起连接端===============\n# fd 是之前存放 fd 号的变量\n% ztcp -c $fd\n\n# 关闭监听连接端=============\n% ztcp -c $listenfd\n% ztcp -c $fd\n```\n接受端例子:\n```bash\n#!/bin/zsh\n\nzmodload zsh/net/tcp\n\n(($+1)) || {\n    echo \"Usage: ${0:t} port\"\n    exit 1\n}\n\nztcp -l $1\nlistenfd=$REPLY\n\n[[ $listenfd == <-> ]] || exit 1\n\nwhile ((1)) {\n    ztcp -a $listenfd\n    fd=$REPLY\n    [[ $fd == <-> ]] || continue\n\n    cat <&$fd\n    ztcp -c $fd\n}\n```\n发送端例子:\n```bash\n#!/bin/zsh\n\nzmodload zsh/net/tcp\n\n(($# >= 2)) || {\n    echo \"Usage: ${0:t} [hostname] port message\"\n    exit 1\n}\n\nif [[ $1 == <0-65535> ]] {\n    ztcp 127.0.0.1 $1\n} else {\n    ztcp $1 $2\n    shift\n}\n\nfd=$REPLY\n[[ \"$fd\" == <-> ]] || exit 1\n\necho ${*[2,-1]} >&$fd\nztcp -c $fd\n```\n\n### 日期模块:zmodload zsh/datetime\n\n|例子|含义|\n|:-:|:-:|\n|`echo $EPOCHSECONDS`|从光标1970年到现在的秒数,等价于`date +%s`|\n|`echo $EPOCHREALTIME`|输出高精度当前时间戳|\n|`echo $epochtime`|输出当前时间戳的秒和纳秒|\n|`strftime \"%Y-%m-%d %H:%M:%S (%u)\" $EPOCHSECONDS`|按指定格式输出|\n|`strftime -s str \"%Y-%m-%d %H:%M:%S (%u)\" $EPOCHSECONDS`|存到变量str中|\n|`strftime -r \"%Y-%m-%d %H:%M:%S (%u)\" \"2017-09-01 10:10:58 (5)\"`|上述的反操作|\n\n### gdbm模块--存在文件里的哈希表\n```bash\n% zmodload zsh/db/gdbm\n\n# 声明数据库文件对应的哈希表\nlocal -A sampledb\n# 创建数据库文件，文件名是 sample.gdbm，对应 sampledb 哈希表\n# 如果该文件已经存在，则会继续使用该文件\nztie -d db/gdbm -f sample.gdbm sampledb\n\n# 然后正常使用 sampledb 哈希表即可，数据会同步写入到数据库文件中\nsampledb[k1]=v1\nsampledb+=(k2 v2 k3 v3)\necho ${(kv)sampledb}\n#k1 v1 k2 v2 k3 v3\n\n# 获取数据库文件路径\n% zgdbmpath sampledb\necho $REPLY\n#/home/goreliu/sample.gdbm\n\n# 释放数据库文件\nzuntie -u sampledb\n\n\n# 也可以用只读的方式加载数据库文件\nztie -r -d db/gdbm -f sample.gdbm sampledb\n# 但这样的话，需要用 zuntie -u 释放数据库文件\nzuntie -u sampledb\n```\n\n### sched-->计划调度命令\nzmodload zsh/sched\n* `sched +5 ls`5秒后运行ls\n* `sched`列出已有任务\n* `sched -n`去除第n个待运行命令\n\n### 模块简介\n可以用man zshmodules查看模块功能\n* zsh/system:底层文件读写\n* zsh/pcre:正则表达式库\n* zsh/stat:内部stat，取代stat\n* zsh/zftp:内部ftp客户端\n* zsh/zprof:性能追踪工具\n* zsh/zpty:操作pty的命令\n* zsh/zselect:select系统调用的封装\n\n### TRAPINT\n该函数名,捕获任意信号?有待研究,如下的代码竟然捕捉到SIGINT信号\n```\n#!/bin/zsh\n\n# SIGINT 是 2 信号，ctrl + c 会触发\nTRAPINT() {\n    # 处理一些退出前的善后工作\n    sleep 333\n}\n\nsleep 1000\n```\n### 代码风格\n1) 统一使用4个空格来缩进\n2) 非特殊场景,每行代码不超过100个字符\n3) 在前一行尾部加一个空格和 \\ 折行，折行后缩进一层（4 个空格）。\n4) 如果缩进的是一个文本块，可以使用对齐缩进，也可以使用 4 个空格的固定缩进。\n5) 如果是在 aa && bb || cc、[[ ]] 或者 (( )) 中折行，&& || 放在下一行的行首。\n6) 在缩进和对齐之外的场景，不允许出现逻辑上不必要的连续多个空格。\n7) + && | 等双元运算符左右要加一个空格。\n8) ! ~等一元运算符和作用对象之间不加空格。\n9) ( ) 和 (( )) { } 内侧不加空格，[[ ]] 因为语法需要，内侧加一个空格。\n10) `;`之前不加空格，之后加一个空格。\n11) 定义函数时（以及在 (( )) 中调用函数时），函数名和 ( 之间不加空格。\n12) if while 等关键字和后边的内容之间加一个空格\n13) if`[[ ]] {`等场景中，`{`和前边的内容之间加一个空格。\n14) 变量和`[ ]`之间不加空格，用`[ ]`取数组或者哈希表值时，`[ ]`内侧不加空格。\n15) `> <`等重定向符号和文件或者文件描述符之间不加空格。\n17) 非特殊场景，不允许出现超过两个连续空行。\n18) #!/bin/zsh 后加一个空行。\n19) if while 等语句块之后加一个空行。\n20) 定义函数后加一个空行。\n21) 逻辑关系不强的两行（或者两块）代码之间，根据逻辑关系强弱（自行判断），加一个或两个空行。\n22) 在判断条件的场景，不使用`[ ]`，用`[[ ]]`代替。\n23) 在数值计算的场景，使用`$(( ))`而不是`$[ ]`。\n24) 使用数值时，两端不加引号。\n25) 用`$var`取变量值时，两边不加双引号，除非需要将非字符串变量转换成字符串。\n26) 在非必须场景，不需要加`${var}`中的大括号。\n27) 变量使用前要明确指明是局部变量（用 local 定义）还是全局变量（用 typeset -g 定义）。\n28) 能用局部变量的地方全部使用局部变量（用 local 定义）。\n29) 变量名中的单词可以使用下划线分隔或者驼峰风格，在不影响可读性的情况也可以使用全小写字母，但在同一个文件中要一致。\n30) 字符串常量两端可以添加双引号或者单引号，但同一个文件中风格要一致。\n31) 可以使用 name() 或者 function name() 定义函数，但同一个文件中风格要一致。\n32) 非特殊场景，单个脚本文件不超过 1000 行。 \n\n### bash和zsh的简明对比\n\n|bash|zsh|说明|\n|:-:|:-:|:-:|\n|`\"$var\"`|`$var`|避免变量中有空格导致异常|\n|`\"$@\"`|`$*`|避免变量中有空格导致异常|\n|`\"${array[@]}\"`|`$array`|取数组所有元素，@ 可改成 *|\n|`\"${#array[@]}\"`|`$#array`|取数组中元素个数，@ 可改成 *|\n|`\"${array[n - 1]}\"`|`$array[n]`|取数组第 n 个元素，bash 从 0 开始，zsh 从 1 开始|\n|`\"$array\"`|`$array[1]`|Bash 中的 $array 是取数组的第一个元素|\n|`echo a*b`|`echo \"a*b\"`|Zsh 默认配置中，通配符如果匹配不到文件会报错|\n|`if true; then :; fi`|`if true {}`|Zsh 中不需要使用 : 作为空语句|\n|`[ \"$var\" == value ]`|`[[ $var == value ]]`|Zsh 中的 [ ] 里不支持 ==，一律用 [[ ]]|\n`ls \\| tee file \\| less`|`ls >file \\| less`|Zsh 中不需要用 tee 即可实现相同功能|\n\n","source":"_posts/zsh.md","raw":"---\ntitle: zsh\ndate: 2022-02-03 19:54:32\nsubtitle:\ncategories:\ntags:\nindex_img: /images/zsh.png\nbanner_img: /images/zsh.png\n---\n\n### 变量定义\nZsh的变量除了哈希表以外，都直接赋值使用,包括整数(64位带符号)、浮点数(64位带符号)、字符串、数组、哈希表,`$+var`,判断变量是否定义,未定义返回0,否则为1\n\n### 字符串变量\n1) 获取字符串长度\n`str=abcde echo $#str`\n2) 字符串拼接\n`str2+=$str1;str3=$str1$str2`\n<span id = \"slice\"></span>\n3) 字符串切片\n字符位置从1开始算,bash风格的则从0开始算\n`echo $str[2,4]`\n4) 字符串截断\n```bash\nstr=abcdeabcde\n#删除左端匹配到的内容,最小匹配\necho ${str#*b} #输出cdeabcde\n#删除右端匹配到的内容,最小匹配\necho ${str%d*} #输出abcdeabc\n#删除左端匹配到的内容,最大匹配\necho ${str##*b} #输出cde\n#删除右端匹配到的内容,最大匹配\necho ${str%%d*} #输出abc\n```\n<span id = \"find\"></span>\n5) 字符串查找\n```bash\n#从左往右找cd字符串,找不到返回数组大小+1\necho $str[(i)cd]\n#从右往左找cd字符串,找不到返回0\necho $str[(I)cd]\n#从第二个位置开始找\necho ${str[(in:2:)cd]}\n```\n6) 遍历字符\n```bash\nfor i ({1..$#str}){\n\techo $str[i]\n}\n```\n7) 字符串替换\n```bash\nstr=abcabc\n#只替换找到第一个\necho ${str/bc/ef} #aefabc\n#只删除找到第一个\necho ${str/bc} #aabc\n#上面两个的所有版本\necho ${str//bc/ef}\necho ${str//bc}\n\nstr=abcABCabcABCabc\n\n# /# 只从字符串开头开始匹配，${str/#abc} 也同理\necho ${str/#abc/123} #123ABCabcABCabc\n\n# /% 只从字符串结尾开始匹配，echo ${str/%abc} 也同理\necho ${str/%abc/123} #abcABCabcABC123\n\nstr=abc\n# 如果匹配到了则输出空字符串\necho ${str:#ab*}\n\n# 如果匹配不到，则输出原字符串\necho ${str:#ab}\n\n#按位置删除字符和替换字符,就是指定位置赋值\nstr[1]=\nstr[2,4]=\nstr[1]=k\nstr[2,4]=sjkg #可以不一一对应\n```\n8) 字符串是否匹配\n```bash\n#是否包含\n[[ $str1 == *$str2* ]] && echo good\n#正则匹配\n[[ $str =~ 'c[0-9]' ]]\n```\n9) 大小写转换\n```bash\n#转成大写\necho ${(U)str}\necho ${str:u}\n#转成小写\necho ${(L)str}\necho ${str:l}\n#首字母大写\necho ${(C)str}\n```\n10) 目录文件名截取\n```bash\nfilepath=/a/b/c.x\n# :h 是取目录名，即最后一个 / 之前的部分，如果没有 / 则为 .\necho ${filepath:h} #/a/b\n# :t 是取文件名，即最后一个 / 之后的部分，如果没有 / 则为字符串本身\necho ${filepath:t} #c.x\n# :e 是取文件扩展名，即文件名中最后一个点之后的部分，如果没有点则为空\necho ${filepath:e} #x\n# :r 是去掉末尾扩展名的路径\necho ${filepath:r} #/a/b/c\n```\n11) 相对路径转绝对路径\n```bash\n#功能相当于$(readlink -f $filepath)\nfilepath1=a.txt\necho ${filepath1:A}\n```\n12) 分割字符串\n```bash\n# 使用空格作为分隔符，多个空格也只算一个分隔符\nstr='aa bb cc dd'\necho ${str[(w)2]}#bb\n\n# 指定分隔符\nstr='aa--bb--cc'\n# 如果分隔符是 : 就用别的字符作为左右界，比如 ws.:.\necho ${str[(ws:--:)3]}#cc\n```\n\n<span id = \"arrAndStr\"></span>\n* 转成数组\n```bash\narray=()${=str})#默认按空格分隔,可以设置IFS环境变量设置,也可以按以下方法\nstr=\"1:2::4\"\n\n#可以是多个字符,如**s/::/**,以**::**为分隔,同时也可以写成**.::.**,不必一定\n#使用**/**,可以用任意符号\nstr_array=(${(s/:/)str})\necho $str_array #1 2 4 #忽略空字符串\n# 保留其中的空字符串\nstr_array=(\"${(@s/:/)str}\")\necho $str_array[3]#该值为空\necho $str_array[4]\nstr+=(1234)#字符串直接变成一个包含两个元素的数组\n```\n13) 读取文件内容到字符串\n```bash\n# 比用 str=$(cat filename) 性能好很多\nstr=$(<filename)\n\n# 比用 cat filename 性能好很多，引号不能省略\necho \"$(<filename)\"\n\n# 遍历每行，引号不能省略\nfor i (${(f)\"$(<filename)\"}) {\n    echo $i\n}\n# 小文件或者需要频繁调用时，尽量不要用 sed\n#输出第2行\necho ${\"$(<test.txt)\"[(f)2]}\n# 输出包含 “ang” 的第一行\necho ${\"$(<test.txt)\"[(fr)*ang*]}\n```\n14) 读取进程输出到字符串\n就是把\\$(<filename)换城\\$(cmd)\n\n### 条件语句\n```bash\nif [some condition]{\n} elif{\n} else{\n}\n```\n\n### print和printf\nzsh支持print和printf,`print -`再按tab健就可以查看所有选项,`printf %`再按tab键就可以查看所有格式化的东西\n\nprint支持的选项\n\n|选项|功能|参数|\n|:-:|:-:|:-:|\n|-C|按列输出|列数|\n|-D|替换路径成带~的版本|无|\n|-N|使用\\x00(null)作为字符串的间隔,默认是空格|无|\n|-O|降序排列|无|\n|-P|输出颜色和特殊样式|无|\n|-R|模拟echo命令|无|\n|-S|放命令放入了历史命令文件(要加引号)|无|\n|-X|替换所有tab为空格|tab对应空格数|\n|-a|和-c/-C一起使用时,改为从左到右|无|\n|-b|识别出bindkey转义字符串|无|\n|-c|按列输出(自动决定列数)|无|\n|-f|同printf|无|\n|-i|和-o/-O一起使用时,大小写不敏感排序|无|\n|-l|使用换行符作为字符串分隔符|无|\n|-m|只输出匹配的字符串|匹配模式字符串|\n|-n|不自动添加最后的换行符|无|\n|-o|升序排列|无|\n|-r|不处理转义字符|无|\n|-s|放命令放入历史命令文件(不要加引号)|无|\n|-u|指定fd输出|fd号|\n|-v|把内容保存到变量|变量名|\n|-x|替换行首的tab为空格|tab对应空格数|\n|-z|把内容放置到命令行编辑区|无|\n\n* 颜色\n```\n# %B 加粗 %b 取消加粗\n# %F{red} 前景色 %f 取消前景色\n# %K{red} 背景色 %k 取消背景色\n# %U 下滑线 %u 取消下滑线\n# %S 反色 %s 取消反色\n#\n# black or 0  red     or 1\n# green or 2  yellow  or 3\n# blue  or 4  magenta or 5\n# cyan  or 6  white   or 7\n\n# 显示加粗的红色 abc\nprint -P '%B%F{red}abc'\n\n# 没覆盖到的功能可以用原始的转义符号，可读性比较差\n# 4[0-7] 背景色\n# 3[0-7] 前景色\n# 0m 正常 1m 加粗 2m 变灰 3m 斜体 4m 下滑钱 5m 闪烁 6m 快速闪烁 7m 反色\n\n# 显示闪烁的红底绿字 abc\n% print \"\\033[41;32;5mabc\\033[0m\"\n```\n\n### 通配符\n\n|通配符|含义|\n|:-:|:-:|\n|*|任意数量的字符|\n|?|任意一个字符|\n|[abcd]|abcd中的任意一个字符|\n|[^abcd]|除abcd中的任意一个字符|\n|[a-c]|a和c之间的一个字符|\n|[a-cB-Dxyz]|a和c之间、B和D之间以及xyz中的一个字符|\n|<1-100>|1和100之间的整数|\n|<-50>|0和50之间的整数|\n|<100->|大于100的整数|\n|-|任意正整数和0|\n|([a-c]\\|<1-100>)|a和c之间的一个字符或者1和100之间的整数|\n\n**加强版,要支持需要加上`setopt EXTENDED_GLOB`**\n\n|通配符|含义|匹配的样式|\n|:-:|:-:|:-:|\n|^abc|除了 abc 外的任意字符串|aaa|\n|abc^abc|以 abc 开头，但后边不是 abc 的字符串|abcabd|\n|a\\*c~abc|符合 a\\*c 但不是 abc 的字符串|adc|\n|a#|任意数量（包括 0）个 a|aaa|\n|b##|一个或者多个b|b|\n|(ab)##|一个或者多个ab|abab|\n|(#i)abc|忽略大小写的abc|AbC|\n|(#i)ab(#I)c|忽略大小写的 ab 接着 c|ABc|\n|(#l)aBc| 和 c 忽略大小写，但 B 必须大写 的 aBc|aBC|\n|(#a1)abc|最多错（多或缺也算）一个字符的 abc|a2c 或 ab 或 abcd|\n\n### 数组变量\n1) 数组定义\n```bash\narray=(a \"bb cc\" dd)\necho $array #打印所有元素在一行\nprint -l $array #每行输出一个元素\n```\n2) 元素读写\n```bash\necho $array[3]\necho $array[-1]\necho $#array #获取长度\narray[3]=some\narray[3]=() #删除元素\narray+=eeee #添加元素\nunset array #删除整个数组\n```\n3) 数组拼接\n```bash\narray1+=(e f g)\narray1+=($array2) #小括号必须加,不加的话,则array2视为一个字符串\n```\n4) [字符串与数组](#arrAndStr)\n5) 数组遍历\n```\nfor i ($array1){\n\techo $i\n}\n#同时遍历两个数组\nfor i ($array1 $array2){\n\techo $i\n}\n```\n6) [切片访问](#slice)\n7) [元素查找](#find)\n8) 元素排序\n```bash\necho ${(o)array} #升序排列\necho ${(O)array} #降序排列\necho ${(oi)array} #大小写不敏感升序排列\necho ${(on)array} #按数字升序排列\necho ${(Oa)array} #反转数组元素\n```\n9) 去重\n```bash\necho ${(u)array}\n```\n10) 构造连续字符或数值数组\n```bash\narray=(aa{bb,cc,11}) && echo $array #aabb aacc aa11\narray=(aa{1..3}) && echo $array #aa1 aa2 aa3\narray=(aa{15..19..2}) && echo $array #aa15 aa17 aa19\narray=(aa{19..15..2}) && echo $array #aa19 aa17 aa15\narray=(aa{01..03}) && echo $array #aa01 aa02 aa03\narray=(aa{a..c}) && echo $array #aaa aab aac\narray=(aa{Y..c}) && echo $array #ASCII码顺序\n```\n11) 从文件构造数组\n```bash\n# f 的功能是将字符串以换行符分隔成数组\n# 双引号不可省略，不然会变成一个字符串，引号也可以加在 ${ } 上\narray=(${(f)\"$(<test.txt)\"})\nprint -l $array\n#a\n#bb\n#ccc\n#dddd\n# 不加引号的效果\narray=(${(f)$(<test.txt)})\nprint -l $array\n#a bb ccc dddd\n\n# 从文件构造数组，并将每行按分隔符 : 分隔后输出所有列\nfor i (${(f)\"$(<test.txt)\"}) {\n    array=(${(s.:.)i})\n    echo $array[1,-1]\n}\n```\n12) 从文件列表构造数组\n```bash\narray=(/usr/bin/vim*)\nprint -l $array\n#/usr/bin/vim\n#/usr/bin/vimdiff\n#/usr/bin/vimtutor\n\n# 要比 ls /usr/bin/[a-b]?? | wc -l 快很多\narray=(/usr/bin/[a-b]??) && print $#array\n```\n13) 数组交集差集\n```bash\n# 两个数组的交集，只输出两个数组都有的元素,如果有重复元素不会去重\necho ${array1:*array2}\n# 两个数组的差集，只输出 array1 中有，而 array2 中没有的元素\necho ${array1:|array2}\n```\n14) 数组交叉合并\n```bash\n# 从 array1 取一个，再从 array2 取一个，以此类推，一个数组取完了就结束\necho ${array1:^array2}\n# 如果用 :^^，只有一个数组取完了的话，继续从头取，直到第二个数组也取完了\n% echo ${array1:^^array2}\n```\n15) 对数组中的字符串进行统一处理\n```bash\n# :t 是取字符串中的文件名，可以用在数组上，取所有元素的文件名\nprint -l ${array:t}\n# :e 是取扩展名，如果没有没有扩展名，结果数组中不会添加空字符串\nprint -l ${array:e}\n# 字符串替换等操作也可以对数组使用，替换所有字符串\nprint -l ${array/a/j}\n# :# 是排除匹配到的元素，类似 grep -v\nprint ${array:#a*}\n# 前边加 (M)，是反转后边的效果，即只输出匹配到的元素，类似 grep\nprint ${(M)array:#a*}\n# 多个操作可以同时进行，(U) 是把字符串转成大写字母\nprint ${(UM)array:#a*}\n\n# 截断或对齐数组中的字符串\narray=(abc bcde cdefg defghi)\n\n# 只取每个字符串的最后两个字符\necho ${(l:2:)array}\nbc de fg hi\n\n# 用空格补全字符串并且右对齐\nprint -l ${(l:7:)array}\n    abc\n   bcde\n  cdefg\n defghi\n\n# 用指定字符补全\nprint -l ${(l:7::0:)array}\n0000abc\n000bcde\n00cdefg\n0defghi\n\n# 用指定字符补全，第二个字符只用一次\nprint -l ${(l:7::0::1:)array}\n0001abc\n001bcde\n01cdefg\n1defghi\n\n# 左对齐\nprint -l ${(r:7::0::1:)array}\nabc1000\nbcde100\ncdefg10\ndefghi1\n```\n### 字典变量\n1) 定义\n```bash\ntypeset -A table\n# 先声明,或者用 local，二者功能是一样的\nlocal -A table\n\n# 赋值的语法和数组一样，但顺序依次是键、值、键、值\ntable=(k1 v1 k2 v2)\n#可以声明赋值一块,local -A table=(k1 v1 k2 v2)\n\n# 直接用 echo 只能输出值\necho $table #v1 v2\n\n# 使用 (kv) 同时输出键和值，(kv) 会把键和值都放到同一个数组里\n% echo ${(kv)table} #k1 v1 k2 v2\n\n# 哈希表的大小是键值对的数量\necho $#table\n```\n2) 读写\n```bash\necho $table[k2]\ntable[k2]=\"v2\"\n# 删除元素的方法和数组不同，引号不能省略\nunset \"table[k1]\"\n```\n3) 哈希表拼接\n```bash\n# 追加元素的方法和数组一样\ntable+=(k4 v4 k5 v5)\n# 拼接哈希表，要展开成数组再追加\ntable1+=(${(kv)table2})\n```\n4) 哈希表遍历\n```bash\n# 只遍历值\nfor i ($table) {\necho $i\n}\n# 只遍历键\nfor i (${(k)table}) {\necho $i\n}\n# 同时遍历键和值\nfor k v (${(kv)table}) {\necho \"$k -> $v\"\n}\n```\n5) 键是否存在\n```bash\n(($+table[k1]))\n```\n6) 元素排序\n和数组类似,增加k、v两个选项\n```bash\n# 只对值排序\necho ${(o)table}\n\n# 只对键排序\necho ${(ok)table}\n\n# 键值放在一起排序\necho ${(okv)table}\n```\n7) 从字符串、文件构造哈希表\n```bash\nstr=\"k1 v1 k2 v2\"\nlocal -A table=(${=str})\n#从文件构造和数组类似\n```\n8) 对哈希表的每个元素统一处理\n可参见数组,同时增加kv两个选项\n```bash\n#值转成大写\nprint ${(U)table}\n#键转成大写\nprint ${(Uk)table}\n#键值转成大写\nprint ${(Ukv)table}\n# 排除匹配到的值\necho ${table:#v1}\n# 只输出匹配到的键\necho ${(Mk)table:#k[1-2]}\n```\n\n### 数值类型\nzsh通常不指定数值是整形还是浮点型,通常直接赋值，**虽然默认为字符串**,但作数值计算时自动判断,但可以如下指明类型,同时在双小括号里做c语言的任何符号计算,同时括号内变量可以不需要加$符号(貌似是zsh的一般特性,适用于许多其他场合)\n```bash\ninteger i=123\nfloat f=12.56\n#(t)用于输出变量类型\necho ${(t)i} #integer\necho ${(t)f} #float\n# 注意一旦指定了变量类型，类型就不会变了，除非再重新指定其他类型，或者用 unset 删除掉 \n# 如果把浮点数赋值给整数变量，会取整\ni=12.34\necho $i #会输出12\n```\n* 数学函数\nzsh/mathfunc模块包含数学函数\n```\nzmodload -i zsh/mathfunc\necho $((sin(0)+ceil(14.4)))\n```\n**函数列表**\n\n|函数名|功能|\n|:-:|:-:|\n|abs|取绝对值|\n|ceil|向上取整|\n|floor|向下取整|\n|int|截断取整|\n|float|转换成浮点数|\n|sqrt|开平方|\n|cbrt|开立方|\n|log|自然对数|\n|log10|常用对数|\n|rand48|随机数|\n\n还有:acos、acosh、asin、asinh、atan、atanh、cos、cosh、erf、erfc、exp、 expm1、fabs、gamma、j0、j1、lgamma、log1p、logb、sin、sinh、tan、 tanh、y0、y1、ilogb、signgam、copysign、fmod、hypot、nextafter、jn、 yn、ldexp、scalb\n\n### 变量修饰语\n**一般两种格式:**\n* `${(x)var}` var是变量名,x是一个或多个字母,\n* `${var:x}` var是变量名,x是一个或多个字母,或其他符号\n\n**注意:加了修饰语的变量依然是变量,可以当普通变量处理,可以嵌套使用,$符号后不可以有空格**\n\n|修饰符|举例|说明|\n|:-:|:-:|:-:|\n|:-|`echo ${var:-abc}`|如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc|\n|-|`echo ${var-abc}`|如果变量有值,则输出原值,如果变量不存在,则输出abc|\n|:=|`echo ${var:=abc}`|如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc并且赋值给var|\n|::=|`echo ${var::=123}`|不管有没有值，村不存在，都输出123，并且重新赋值|\n|:?|`echo ${var:?error}`|var没有值或不存在,则直接报错,否则输出原值|\n|:+|`echo ${var:+123}`|如果var有值,则输出123,否则输出空|\n|(F)|`echo ${(F)array}`|把数组中的元素以换行符拼接成字符串,不加任何修饰的话则是空格拼接|\n|(j/x/)|`echo ${(j/-=/)array}`|把数组中的元素以-=两个字符连接|\n|(s/x/)|`echo ${(s/==/)str}`|把字符串中的字符以==两个字符为分隔符分成数组|\n|(t)|`echo ${(t)var}`|输出变量的类型:integer float scalar array association|\n|`(P)`|`var=abc abc=123 echo ${(P)var}`|多重替换,输出123|\n|[#n]|`echo $(([#16] 255))`|以n进制显示十进制整数|\n|n#|`echo $((16#ff))`|显示n进制整数为十进制|\n\n### 函数\n与bash基本一致,增加了`unfunction fun`删除某个函数的功能,还有就是规避了`$*`和`$@`的区别,zsh推荐只用`$*`\n\n### 替代find和ls\n需要开启扩展通配符:setopt EXTENDED_GLOB\n**通配符修饰语列表**\n\n|名称|含义|使用样例或补充说明|\n|:-:|:-:|:-:|\n|/|目录||\n|F|非空|/F(非空目录) /^F(空目录)|\n|.|普通文件||\n|@|符号链接||\n|=|socket文件||\n|p|FIFO 文件||\n|\\*|可执行的普通文件||\n|%|设备文件||\n|%b|块设备文件||\n|%c|字符设备文件||\n|r|文件拥有着有读权限||\n|w|文件拥有着有写权限||\n|x|文件拥有着有执行权限||\n|A|文件拥有组用户有读权限||\n|I|文件拥有组用户有写权限||\n|E|文件拥有组用户有执行权限||\n|R|任何用户都有读权限||\n|W|任何用户都有写权限||\n|X|任何用户都有执行权限||\n|s|设置了setuid的文件||\n|S|设置了setgid的文件||\n|t|设置了粘滞位（sticky bit）的文件||\n|f|符合指定的权限|f0644 f4755 f700|\n|e||暂无|\n|+|大于某个数|通常跟数字,与其他配合使用|\n|d|指定设备号||\n|l|硬连接个数|l-2（小于 2） l+3（大于 3）|\n|U|当前用户拥有||\n|G|当前用户所在组拥有||\n|u|指定用户 id 拥有|u1000|\n|g|指定用户组 id 拥有|g1000|\n|a|指定文件的 atime|访问时间,默认单位是天,可跟单位M(月)、w(周)、h(小时)、m(分钟)、s(秒)、+(指定时间之前)、-(指定时间之内)|\n|m|指定文件的 mtime|修改时间,可跟单位、+-,`print -l *(.mm+1)`|\n|c|指定文件的 ctime|文件状态属性修改时间,可跟单位、+-,`print -l *(.cm+1)`|\n|L|指定文件大小|默认单位是字节,单位有k、m和p(512字节的块),也可以大写,`print -l *(.Lm-1)`|\n|^|取反|/^F|\n|-|小于某个数|通常跟数字,与其他配合使用|\n|M||暂无|\n|T||暂无|\n|N|如果没匹配到，返回空而不报错|\n|D|包含隐藏文件（. 开头）|\n|n|按数值大小排序|下文有说明|\n|o|递增排序|下文有说明|\n|O|递减排序|下文有说明|\n|[n]|只取第 n 个文件|.[5]|\n|[n1,n2]|取第 n1 到 n2 个文件|/[5,10]|\n|:X||暂无|\n\n1) 文件排序\n\n可供排序的因子:n(文件名),L(大小),I(硬连接数),a(atime),m(mtime),c(ctime),d(所在目录深度,从深到浅)\n```bash\n# 按文件名排序，同一目录下的文件和目录名会一起排，而不是先排目录再排文件\n#**/*,指当前目录和子目录\nprint -l **/*(.on)\nbb.txt\ncc/aa.txt\ncc/dd.txt\nzz.txt\n\n# 按文件的目录深度逆序排，d 是从深往浅排，O 是逆序\nprint -l **/*(.Od)\nzz.txt\nbb.txt\ncc/dd.txt\ncc/aa.txt\n\n# 先按文件名排序，然后再按大小排序，这样大小相同的文件依然是按文件名排的\nprint -l **/*(.onoL)\nbb.txt\ncc/aa.txt\ncc/dd.txt\ncc.txt\n```\n2) 组合使用\n\n\t类型和类型之间要用逗号个开,逗号前后内容互不干扰(取反^只影响到逗号之前的内容)\n\n\t`print -l *(/m-2,.Lm-3oL,@D)`\n\n3) 批量重命名zmv\n```bash\n# 使用前需要先加载进来\nautoload -U zmv\n\n# 将所有 txt 文件扩展名改成 conf\n# 参数要用单引号扩起来，$1 代表第一个参数中括号中的内容\n zmv '(*).txt' '$1.conf'\n\n# 如果加了 -W 参数，zmv 会自动识别文件名中需要保留的部分\n zmv -W '*.txt' '*.conf'\n\n# 调整文件名各部分的前后顺序\nzmv '(*).(*).txt' '$2.$1.txt'\n# 加 -n 预览而不实际运行\nzmv -n '(*).(*).txt' '$2.$1.txt'\nmv -- a.b.txt b.a.txt\n\n# 0 1 2 ... 前添加 0，以便和 10 11 12 ... 宽度一致\nzmv '([0-9]).(*)' '0$1.$2'\n# 去掉开头的一个 0\nzmv '(0)(*)' '$2'\n\n# 文件整理到目录\nzmv '(*) - (*) - (*).txt' '$1/$2 - $3.txt'\n\n# 转换大小写\nzmv '(*).txt' '${(U)1}.txt'\nzmv '(*).txt' '${(L)1}.txt'\n```\n4) 不展开通配符\n```bash\ncalc() {\n    zmodload zsh/mathfunc\n    echo $(($*))\n}\ncalc 12+12\ncalc 12*12 #会报错\nnoglob calc 12*12 #可以\n```\n### local和typeset \nlocal和typeset基本一样(除了不能用-f和-g这两个选项)\n\n|选项|含义|举例|\n|:-:|:-:|:-:|\n|-l|强制字符串内容为小写|`local -l str=abcABC`|\n|-u|强制字符串内容为大写|`local -u str=abcABC`|\n|-x|设置为环境变量|`export str=abc`等价于`local -x str=abc`|\n|-r|只读|`local -r strl=abc`等价于`readonly str1=abc`|\n|-U|设置数组不包含重复元素|`local -U array=(aa bb aa cc)`|\n|-Z n|设置整数位数|不够用0不全,超过会被截断|\n|-i n|设置整数为其他进制显示|支持2-36|\n|`local {i,j,k}=123`|赋值多个变量为同一个值||\n|-T|绑定字符串和数组|`local -T DIR dir`,DIR为字符串,dir为数组,以冒号连接,主要用于path变量|\n|-p|显示变量的定义方式|显示脚本如何定义该变量的|\n\n### 双引号问题\nzsh不需要像bash那样频繁加双引号来避免错误。\nzsh需要加双引号的场景:\n1) 像这样的包含字符或者特殊符号的字符串 `\"aa bb \\t \\n *\"` 出现在代码中时，两边要加双引号\n2) 在用`$()`调用命令时，如果希望结果按一个字符串处理，需要加上双引\n3) 如果想将数组当单个字符串处理，需要加双引号，`array=(a b); print -l \"$array\"`\n4) 其他的原本不是单个字符串的东西，需要转成单个字符串的场景，要加双引号\n\n其余通常不加,其中典型场景:\n1) 任何情况下，字符串变量的两边都不需要加双引号，无论里边的内容多么特殊，或者变量存不存在，都没有关系，如`$str`\n2) 如果不转换类型（比如数组转成字符串），任何变量的两边都不需要加双引号\n3) `$1 $2 $*`这些参数（其实它们也都是单个字符串），都不需要加双引号，无论内容是什么，或者参数是否存在。\n\n### mapfile读写文件\n```bash\nzmodload zsh/mapfile\n\n# 这样就可以创建文件并写入内容，如果文件存在则会被覆盖\nmapfile[test.txt]=\"ab cd\"\ncat test.txt\n#ab cd\n\n# 判断文件是否存在\n(($+mapfile[test.txt])) && echo good\n#good\n\n# 读取文件\necho $mapfile[test.txt]\n#ab cd\n\n# 删除文件\nunset \"mapfile[test.txt]\"\n\n# 遍历文件\nfor i (${(k)mapfile}) {\necho $i\n}\n#test1.txt\n#test2.txt\n```\n\n### 循环语句\n```bash\nwhile [some condition]{\n\tbreak/continue\n}\n```\n```\nuntil [some condition]{\n\tbreak/continue\n}\n```\n```bash\n#样例\nfor i (aa bb cc){\n\techo $i\n}\narray=(aa bb cc)\nfor i ($array) {\n\techo $i\n}\nfor ((i=0; i < 10; i++)){\n\techo $i\n}\nfor i ({1..10}){\n\techo $i\n}\n```\n```\nrepeat 5{\n\techo good\n}\n```\n\n### 分支语句\n```bash\ncase $i {\n\t(a)\n\techo 1\n\t;;\n\n\t(b)\n\techo 2\n\t#继续执行下一个匹配的语句(不再进行匹配)\n\t;&\n\n\t(c)\n\techo 3\n\t#继续向下匹配，看是否有满足条件的分支\n\t;|\n\n\t(c)\n\techo 33\n\t;;\n\n\t(*)\n\techo oher\n\t;;\n}\n```\n\n### 用户输入选择语句\n```bash\nselect i (aa bb cc){\n\techo $i\n}\n```\n必须加break,否则会一直让用户选择\n\n### 异常处理语句\n```bash\n{\n\t语句1\n} always{\n\t语句2\n}\n```\n无论语句1是否出错,都执行语句2\n\n### socket模块\n```bash\n# 监听连接端=======\n# 首先要加载 socket 模块\nzmodload zsh/net/socket\n\nzsocket -l test.sock\nlistenfd=$REPLY\n# 此处阻塞等待连接\nzsocket -a $listenfd\n# 连接建立完成\nfd=$REPLY\n# 然后 $fd 就可读可写\ncat <&$fd\n\n# 发起连接端==========\nzmodload zsh/net/socket\nzsocket test.sock\nfd=$REPLY\necho good >&$fd\n\n# 关闭监听端========\nexec {listenfd}>&-\nexec {fd}>&-\nrm test.sock\n\n# 关闭连接端======\nexec {fd}>&-\n```\n\n### TCP模块\n```bash\n# 监听连接端=======\n# 首先要加载 tcp 模块\nzmodload zsh/net/tcp\n\nztcp -l 1234\nlistenfd=$REPLY\n# 此处阻塞等待连接\nztcp -a $listenfd\n# 连接建立完成\nfd=$REPLY\n\n# 然后 $fd 就可读可写\ncat <&$fd\n\n# 发起连接端===========\n# 首先要加载 tcp 模块\nzmodload zsh/net/tcp\n\nztcp 127.0.0.1 1234\n# 连接建立完成\nfd=$REPLY\n\n# 然后 $fd 就可读可写\necho good >&$fd\n\n# 关闭发起连接端===============\n# fd 是之前存放 fd 号的变量\n% ztcp -c $fd\n\n# 关闭监听连接端=============\n% ztcp -c $listenfd\n% ztcp -c $fd\n```\n接受端例子:\n```bash\n#!/bin/zsh\n\nzmodload zsh/net/tcp\n\n(($+1)) || {\n    echo \"Usage: ${0:t} port\"\n    exit 1\n}\n\nztcp -l $1\nlistenfd=$REPLY\n\n[[ $listenfd == <-> ]] || exit 1\n\nwhile ((1)) {\n    ztcp -a $listenfd\n    fd=$REPLY\n    [[ $fd == <-> ]] || continue\n\n    cat <&$fd\n    ztcp -c $fd\n}\n```\n发送端例子:\n```bash\n#!/bin/zsh\n\nzmodload zsh/net/tcp\n\n(($# >= 2)) || {\n    echo \"Usage: ${0:t} [hostname] port message\"\n    exit 1\n}\n\nif [[ $1 == <0-65535> ]] {\n    ztcp 127.0.0.1 $1\n} else {\n    ztcp $1 $2\n    shift\n}\n\nfd=$REPLY\n[[ \"$fd\" == <-> ]] || exit 1\n\necho ${*[2,-1]} >&$fd\nztcp -c $fd\n```\n\n### 日期模块:zmodload zsh/datetime\n\n|例子|含义|\n|:-:|:-:|\n|`echo $EPOCHSECONDS`|从光标1970年到现在的秒数,等价于`date +%s`|\n|`echo $EPOCHREALTIME`|输出高精度当前时间戳|\n|`echo $epochtime`|输出当前时间戳的秒和纳秒|\n|`strftime \"%Y-%m-%d %H:%M:%S (%u)\" $EPOCHSECONDS`|按指定格式输出|\n|`strftime -s str \"%Y-%m-%d %H:%M:%S (%u)\" $EPOCHSECONDS`|存到变量str中|\n|`strftime -r \"%Y-%m-%d %H:%M:%S (%u)\" \"2017-09-01 10:10:58 (5)\"`|上述的反操作|\n\n### gdbm模块--存在文件里的哈希表\n```bash\n% zmodload zsh/db/gdbm\n\n# 声明数据库文件对应的哈希表\nlocal -A sampledb\n# 创建数据库文件，文件名是 sample.gdbm，对应 sampledb 哈希表\n# 如果该文件已经存在，则会继续使用该文件\nztie -d db/gdbm -f sample.gdbm sampledb\n\n# 然后正常使用 sampledb 哈希表即可，数据会同步写入到数据库文件中\nsampledb[k1]=v1\nsampledb+=(k2 v2 k3 v3)\necho ${(kv)sampledb}\n#k1 v1 k2 v2 k3 v3\n\n# 获取数据库文件路径\n% zgdbmpath sampledb\necho $REPLY\n#/home/goreliu/sample.gdbm\n\n# 释放数据库文件\nzuntie -u sampledb\n\n\n# 也可以用只读的方式加载数据库文件\nztie -r -d db/gdbm -f sample.gdbm sampledb\n# 但这样的话，需要用 zuntie -u 释放数据库文件\nzuntie -u sampledb\n```\n\n### sched-->计划调度命令\nzmodload zsh/sched\n* `sched +5 ls`5秒后运行ls\n* `sched`列出已有任务\n* `sched -n`去除第n个待运行命令\n\n### 模块简介\n可以用man zshmodules查看模块功能\n* zsh/system:底层文件读写\n* zsh/pcre:正则表达式库\n* zsh/stat:内部stat，取代stat\n* zsh/zftp:内部ftp客户端\n* zsh/zprof:性能追踪工具\n* zsh/zpty:操作pty的命令\n* zsh/zselect:select系统调用的封装\n\n### TRAPINT\n该函数名,捕获任意信号?有待研究,如下的代码竟然捕捉到SIGINT信号\n```\n#!/bin/zsh\n\n# SIGINT 是 2 信号，ctrl + c 会触发\nTRAPINT() {\n    # 处理一些退出前的善后工作\n    sleep 333\n}\n\nsleep 1000\n```\n### 代码风格\n1) 统一使用4个空格来缩进\n2) 非特殊场景,每行代码不超过100个字符\n3) 在前一行尾部加一个空格和 \\ 折行，折行后缩进一层（4 个空格）。\n4) 如果缩进的是一个文本块，可以使用对齐缩进，也可以使用 4 个空格的固定缩进。\n5) 如果是在 aa && bb || cc、[[ ]] 或者 (( )) 中折行，&& || 放在下一行的行首。\n6) 在缩进和对齐之外的场景，不允许出现逻辑上不必要的连续多个空格。\n7) + && | 等双元运算符左右要加一个空格。\n8) ! ~等一元运算符和作用对象之间不加空格。\n9) ( ) 和 (( )) { } 内侧不加空格，[[ ]] 因为语法需要，内侧加一个空格。\n10) `;`之前不加空格，之后加一个空格。\n11) 定义函数时（以及在 (( )) 中调用函数时），函数名和 ( 之间不加空格。\n12) if while 等关键字和后边的内容之间加一个空格\n13) if`[[ ]] {`等场景中，`{`和前边的内容之间加一个空格。\n14) 变量和`[ ]`之间不加空格，用`[ ]`取数组或者哈希表值时，`[ ]`内侧不加空格。\n15) `> <`等重定向符号和文件或者文件描述符之间不加空格。\n17) 非特殊场景，不允许出现超过两个连续空行。\n18) #!/bin/zsh 后加一个空行。\n19) if while 等语句块之后加一个空行。\n20) 定义函数后加一个空行。\n21) 逻辑关系不强的两行（或者两块）代码之间，根据逻辑关系强弱（自行判断），加一个或两个空行。\n22) 在判断条件的场景，不使用`[ ]`，用`[[ ]]`代替。\n23) 在数值计算的场景，使用`$(( ))`而不是`$[ ]`。\n24) 使用数值时，两端不加引号。\n25) 用`$var`取变量值时，两边不加双引号，除非需要将非字符串变量转换成字符串。\n26) 在非必须场景，不需要加`${var}`中的大括号。\n27) 变量使用前要明确指明是局部变量（用 local 定义）还是全局变量（用 typeset -g 定义）。\n28) 能用局部变量的地方全部使用局部变量（用 local 定义）。\n29) 变量名中的单词可以使用下划线分隔或者驼峰风格，在不影响可读性的情况也可以使用全小写字母，但在同一个文件中要一致。\n30) 字符串常量两端可以添加双引号或者单引号，但同一个文件中风格要一致。\n31) 可以使用 name() 或者 function name() 定义函数，但同一个文件中风格要一致。\n32) 非特殊场景，单个脚本文件不超过 1000 行。 \n\n### bash和zsh的简明对比\n\n|bash|zsh|说明|\n|:-:|:-:|:-:|\n|`\"$var\"`|`$var`|避免变量中有空格导致异常|\n|`\"$@\"`|`$*`|避免变量中有空格导致异常|\n|`\"${array[@]}\"`|`$array`|取数组所有元素，@ 可改成 *|\n|`\"${#array[@]}\"`|`$#array`|取数组中元素个数，@ 可改成 *|\n|`\"${array[n - 1]}\"`|`$array[n]`|取数组第 n 个元素，bash 从 0 开始，zsh 从 1 开始|\n|`\"$array\"`|`$array[1]`|Bash 中的 $array 是取数组的第一个元素|\n|`echo a*b`|`echo \"a*b\"`|Zsh 默认配置中，通配符如果匹配不到文件会报错|\n|`if true; then :; fi`|`if true {}`|Zsh 中不需要使用 : 作为空语句|\n|`[ \"$var\" == value ]`|`[[ $var == value ]]`|Zsh 中的 [ ] 里不支持 ==，一律用 [[ ]]|\n`ls \\| tee file \\| less`|`ls >file \\| less`|Zsh 中不需要用 tee 即可实现相同功能|\n\n","slug":"zsh","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi78001vgwq263kihcr9","content":"<h3 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h3><p>Zsh的变量除了哈希表以外，都直接赋值使用,包括整数(64位带符号)、浮点数(64位带符号)、字符串、数组、哈希表,<code>$+var</code>,判断变量是否定义,未定义返回0,否则为1</p>\n<h3 id=\"字符串变量\"><a href=\"#字符串变量\" class=\"headerlink\" title=\"字符串变量\"></a>字符串变量</h3><ol>\n<li>获取字符串长度<br><code>str=abcde echo $#str</code></li>\n<li>字符串拼接<br><code>str2+=$str1;str3=$str1$str2</code><br><span id = \"slice\"></span></li>\n<li>字符串切片<br>字符位置从1开始算,bash风格的则从0开始算<br><code>echo $str[2,4]</code></li>\n<li>字符串截断<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">str=abcdeabcde<br><span class=\"hljs-comment\">#删除左端匹配到的内容,最小匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str#*b&#125;</span> <span class=\"hljs-comment\">#输出cdeabcde</span><br><span class=\"hljs-comment\">#删除右端匹配到的内容,最小匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str%d*&#125;</span> <span class=\"hljs-comment\">#输出abcdeabc</span><br><span class=\"hljs-comment\">#删除左端匹配到的内容,最大匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str##*b&#125;</span> <span class=\"hljs-comment\">#输出cde</span><br><span class=\"hljs-comment\">#删除右端匹配到的内容,最大匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str%%d*&#125;</span> <span class=\"hljs-comment\">#输出abc</span><br></code></pre></td></tr></table></figure>\n<span id = \"find\"></span></li>\n<li>字符串查找<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#从左往右找cd字符串,找不到返回数组大小+1</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str</span>[(i)<span class=\"hljs-built_in\">cd</span>]<br><span class=\"hljs-comment\">#从右往左找cd字符串,找不到返回0</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str</span>[(I)<span class=\"hljs-built_in\">cd</span>]<br><span class=\"hljs-comment\">#从第二个位置开始找</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str[(in:2:)cd]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>遍历字符<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> i (&#123;1..<span class=\"hljs-variable\">$#str</span>&#125;)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str</span>[i]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>字符串替换<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">str=abcabc<br><span class=\"hljs-comment\">#只替换找到第一个</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/bc/ef&#125;</span> <span class=\"hljs-comment\">#aefabc</span><br><span class=\"hljs-comment\">#只删除找到第一个</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/bc&#125;</span> <span class=\"hljs-comment\">#aabc</span><br><span class=\"hljs-comment\">#上面两个的所有版本</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str//bc/ef&#125;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str//bc&#125;</span><br><br>str=abcABCabcABCabc<br><br><span class=\"hljs-comment\"># /# 只从字符串开头开始匹配，$&#123;str/#abc&#125; 也同理</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/#abc/123&#125;</span> <span class=\"hljs-comment\">#123ABCabcABCabc</span><br><br><span class=\"hljs-comment\"># /% 只从字符串结尾开始匹配，echo $&#123;str/%abc&#125; 也同理</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/%abc/123&#125;</span> <span class=\"hljs-comment\">#abcABCabcABC123</span><br><br>str=abc<br><span class=\"hljs-comment\"># 如果匹配到了则输出空字符串</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:#ab*&#125;</span><br><br><span class=\"hljs-comment\"># 如果匹配不到，则输出原字符串</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:#ab&#125;</span><br><br><span class=\"hljs-comment\">#按位置删除字符和替换字符,就是指定位置赋值</span><br>str[1]=<br>str[2,4]=<br>str[1]=k<br>str[2,4]=sjkg <span class=\"hljs-comment\">#可以不一一对应</span><br></code></pre></td></tr></table></figure></li>\n<li>字符串是否匹配<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#是否包含</span><br>[[ <span class=\"hljs-variable\">$str1</span> == *<span class=\"hljs-variable\">$str2</span>* ]] &amp;&amp; <span class=\"hljs-built_in\">echo</span> good<br><span class=\"hljs-comment\">#正则匹配</span><br>[[ <span class=\"hljs-variable\">$str</span> =~ <span class=\"hljs-string\">&#x27;c[0-9]&#x27;</span> ]]<br></code></pre></td></tr></table></figure></li>\n<li>大小写转换<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#转成大写</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(U)str&#125;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:u&#125;</span><br><span class=\"hljs-comment\">#转成小写</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(L)str&#125;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:l&#125;</span><br><span class=\"hljs-comment\">#首字母大写</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(C)str&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>目录文件名截取<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">filepath=/a/b/c.x<br><span class=\"hljs-comment\"># :h 是取目录名，即最后一个 / 之前的部分，如果没有 / 则为 .</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:h&#125;</span> <span class=\"hljs-comment\">#/a/b</span><br><span class=\"hljs-comment\"># :t 是取文件名，即最后一个 / 之后的部分，如果没有 / 则为字符串本身</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:t&#125;</span> <span class=\"hljs-comment\">#c.x</span><br><span class=\"hljs-comment\"># :e 是取文件扩展名，即文件名中最后一个点之后的部分，如果没有点则为空</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:e&#125;</span> <span class=\"hljs-comment\">#x</span><br><span class=\"hljs-comment\"># :r 是去掉末尾扩展名的路径</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:r&#125;</span> <span class=\"hljs-comment\">#/a/b/c</span><br></code></pre></td></tr></table></figure></li>\n<li>相对路径转绝对路径<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#功能相当于$(readlink -f $filepath)</span><br>filepath1=a.txt<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath1:A&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>分割字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用空格作为分隔符，多个空格也只算一个分隔符</span><br>str=<span class=\"hljs-string\">&#x27;aa bb cc dd&#x27;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str[(w)2]&#125;</span><span class=\"hljs-comment\">#bb</span><br><br><span class=\"hljs-comment\"># 指定分隔符</span><br>str=<span class=\"hljs-string\">&#x27;aa--bb--cc&#x27;</span><br><span class=\"hljs-comment\"># 如果分隔符是 : 就用别的字符作为左右界，比如 ws.:.</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str[(ws:--:)3]&#125;</span><span class=\"hljs-comment\">#cc</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<p><span id = \"arrAndStr\"></span></p>\n<ul>\n<li>转成数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=()<span class=\"hljs-variable\">$&#123;=str&#125;</span>)<span class=\"hljs-comment\">#默认按空格分隔,可以设置IFS环境变量设置,也可以按以下方法</span><br>str=<span class=\"hljs-string\">&quot;1:2::4&quot;</span><br><br><span class=\"hljs-comment\">#可以是多个字符,如**s/::/**,以**::**为分隔,同时也可以写成**.::.**,不必一定</span><br><span class=\"hljs-comment\">#使用**/**,可以用任意符号</span><br>str_array=(<span class=\"hljs-variable\">$&#123;(s/:/)str&#125;</span>)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str_array</span> <span class=\"hljs-comment\">#1 2 4 #忽略空字符串</span><br><span class=\"hljs-comment\"># 保留其中的空字符串</span><br>str_array=(<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;(@s/:/)str&#125;</span>&quot;</span>)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str_array</span>[3]<span class=\"hljs-comment\">#该值为空</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str_array</span>[4]<br>str+=(1234)<span class=\"hljs-comment\">#字符串直接变成一个包含两个元素的数组</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"13\">\n<li>读取文件内容到字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 比用 str=$(cat filename) 性能好很多</span><br>str=$(&lt;filename)<br><br><span class=\"hljs-comment\"># 比用 cat filename 性能好很多，引号不能省略</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(&lt;filename)</span>&quot;</span><br><br><span class=\"hljs-comment\"># 遍历每行，引号不能省略</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(f)&quot;$(&lt;filename)&quot;&#125;</span>) &#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\"># 小文件或者需要频繁调用时，尽量不要用 sed</span><br><span class=\"hljs-comment\">#输出第2行</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;&quot;$(&lt;test.txt)&quot;[(f)2]&#125;</span><br><span class=\"hljs-comment\"># 输出包含 “ang” 的第一行</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;&quot;$(&lt;test.txt)&quot;[(fr)*ang*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>读取进程输出到字符串<br>就是把$(&lt;filename)换城$(cmd)</li>\n</ol>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">if</span> [some condition]&#123;<br>&#125; <span class=\"hljs-keyword\">elif</span>&#123;<br>&#125; <span class=\"hljs-keyword\">else</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"print和printf\"><a href=\"#print和printf\" class=\"headerlink\" title=\"print和printf\"></a>print和printf</h3><p>zsh支持print和printf,<code>print -</code>再按tab健就可以查看所有选项,<code>printf %</code>再按tab键就可以查看所有格式化的东西</p>\n<p>print支持的选项</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">参数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-C</td>\n<td align=\"center\">按列输出</td>\n<td align=\"center\">列数</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">替换路径成带~的版本</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-N</td>\n<td align=\"center\">使用\\x00(null)作为字符串的间隔,默认是空格</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-O</td>\n<td align=\"center\">降序排列</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-P</td>\n<td align=\"center\">输出颜色和特殊样式</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-R</td>\n<td align=\"center\">模拟echo命令</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-S</td>\n<td align=\"center\">放命令放入了历史命令文件(要加引号)</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-X</td>\n<td align=\"center\">替换所有tab为空格</td>\n<td align=\"center\">tab对应空格数</td>\n</tr>\n<tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">和-c&#x2F;-C一起使用时,改为从左到右</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-b</td>\n<td align=\"center\">识别出bindkey转义字符串</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">按列输出(自动决定列数)</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">同printf</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">和-o&#x2F;-O一起使用时,大小写不敏感排序</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">使用换行符作为字符串分隔符</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">只输出匹配的字符串</td>\n<td align=\"center\">匹配模式字符串</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">不自动添加最后的换行符</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-o</td>\n<td align=\"center\">升序排列</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">不处理转义字符</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">放命令放入历史命令文件(不要加引号)</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">指定fd输出</td>\n<td align=\"center\">fd号</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">把内容保存到变量</td>\n<td align=\"center\">变量名</td>\n</tr>\n<tr>\n<td align=\"center\">-x</td>\n<td align=\"center\">替换行首的tab为空格</td>\n<td align=\"center\">tab对应空格数</td>\n</tr>\n<tr>\n<td align=\"center\">-z</td>\n<td align=\"center\">把内容放置到命令行编辑区</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<ul>\n<li>颜色<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># %B 加粗 %b 取消加粗</span><br><span class=\"hljs-comment\"># %F&#123;red&#125; 前景色 %f 取消前景色</span><br><span class=\"hljs-comment\"># %K&#123;red&#125; 背景色 %k 取消背景色</span><br><span class=\"hljs-comment\"># %U 下滑线 %u 取消下滑线</span><br><span class=\"hljs-comment\"># %S 反色 %s 取消反色</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># black or 0  red     or 1</span><br><span class=\"hljs-comment\"># green or 2  yellow  or 3</span><br><span class=\"hljs-comment\"># blue  or 4  magenta or 5</span><br><span class=\"hljs-comment\"># cyan  or 6  white   or 7</span><br><br><span class=\"hljs-comment\"># 显示加粗的红色 abc</span><br><span class=\"hljs-built_in\">print</span> -P <span class=\"hljs-string\">&#x27;%B%F&#123;red&#125;abc&#x27;</span><br><br><span class=\"hljs-comment\"># 没覆盖到的功能可以用原始的转义符号，可读性比较差</span><br><span class=\"hljs-comment\"># 4[0-7] 背景色</span><br><span class=\"hljs-comment\"># 3[0-7] 前景色</span><br><span class=\"hljs-comment\"># 0m 正常 1m 加粗 2m 变灰 3m 斜体 4m 下滑钱 5m 闪烁 6m 快速闪烁 7m 反色</span><br><br><span class=\"hljs-comment\"># 显示闪烁的红底绿字 abc</span><br>% <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&quot;\\033[41;32;5mabc\\033[0m&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">通配符</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">*</td>\n<td align=\"center\">任意数量的字符</td>\n</tr>\n<tr>\n<td align=\"center\">?</td>\n<td align=\"center\">任意一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[abcd]</td>\n<td align=\"center\">abcd中的任意一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[^abcd]</td>\n<td align=\"center\">除abcd中的任意一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[a-c]</td>\n<td align=\"center\">a和c之间的一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[a-cB-Dxyz]</td>\n<td align=\"center\">a和c之间、B和D之间以及xyz中的一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;1-100&gt;</td>\n<td align=\"center\">1和100之间的整数</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;-50&gt;</td>\n<td align=\"center\">0和50之间的整数</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;100-&gt;</td>\n<td align=\"center\">大于100的整数</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">任意正整数和0</td>\n</tr>\n<tr>\n<td align=\"center\">([a-c]|&lt;1-100&gt;)</td>\n<td align=\"center\">a和c之间的一个字符或者1和100之间的整数</td>\n</tr>\n</tbody></table>\n<p><strong>加强版,要支持需要加上<code>setopt EXTENDED_GLOB</code></strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">通配符</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">匹配的样式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">^abc</td>\n<td align=\"center\">除了 abc 外的任意字符串</td>\n<td align=\"center\">aaa</td>\n</tr>\n<tr>\n<td align=\"center\">abc^abc</td>\n<td align=\"center\">以 abc 开头，但后边不是 abc 的字符串</td>\n<td align=\"center\">abcabd</td>\n</tr>\n<tr>\n<td align=\"center\">a*c~abc</td>\n<td align=\"center\">符合 a*c 但不是 abc 的字符串</td>\n<td align=\"center\">adc</td>\n</tr>\n<tr>\n<td align=\"center\">a#</td>\n<td align=\"center\">任意数量（包括 0）个 a</td>\n<td align=\"center\">aaa</td>\n</tr>\n<tr>\n<td align=\"center\">b##</td>\n<td align=\"center\">一个或者多个b</td>\n<td align=\"center\">b</td>\n</tr>\n<tr>\n<td align=\"center\">(ab)##</td>\n<td align=\"center\">一个或者多个ab</td>\n<td align=\"center\">abab</td>\n</tr>\n<tr>\n<td align=\"center\">(#i)abc</td>\n<td align=\"center\">忽略大小写的abc</td>\n<td align=\"center\">AbC</td>\n</tr>\n<tr>\n<td align=\"center\">(#i)ab(#I)c</td>\n<td align=\"center\">忽略大小写的 ab 接着 c</td>\n<td align=\"center\">ABc</td>\n</tr>\n<tr>\n<td align=\"center\">(#l)aBc</td>\n<td align=\"center\">和 c 忽略大小写，但 B 必须大写 的 aBc</td>\n<td align=\"center\">aBC</td>\n</tr>\n<tr>\n<td align=\"center\">(#a1)abc</td>\n<td align=\"center\">最多错（多或缺也算）一个字符的 abc</td>\n<td align=\"center\">a2c 或 ab 或 abcd</td>\n</tr>\n</tbody></table>\n<h3 id=\"数组变量\"><a href=\"#数组变量\" class=\"headerlink\" title=\"数组变量\"></a>数组变量</h3><ol>\n<li>数组定义<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=(a <span class=\"hljs-string\">&quot;bb cc&quot;</span> <span class=\"hljs-built_in\">dd</span>)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#打印所有元素在一行</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#每行输出一个元素</span><br></code></pre></td></tr></table></figure></li>\n<li>元素读写<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span>[3]<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span>[-1]<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$#array</span> <span class=\"hljs-comment\">#获取长度</span><br>array[3]=some<br>array[3]=() <span class=\"hljs-comment\">#删除元素</span><br>array+=eeee <span class=\"hljs-comment\">#添加元素</span><br><span class=\"hljs-built_in\">unset</span> array <span class=\"hljs-comment\">#删除整个数组</span><br></code></pre></td></tr></table></figure></li>\n<li>数组拼接<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array1+=(e f g)<br>array1+=(<span class=\"hljs-variable\">$array2</span>) <span class=\"hljs-comment\">#小括号必须加,不加的话,则array2视为一个字符串</span><br></code></pre></td></tr></table></figure></li>\n<li><a href=\"#arrAndStr\">字符串与数组</a></li>\n<li>数组遍历<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">for</span> i (<span class=\"hljs-variable\">$array1</span>)&#123;<br>\t<span class=\"hljs-attribute\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\">#同时遍历两个数组</span><br>for i (<span class=\"hljs-variable\">$array1</span> <span class=\"hljs-variable\">$array2</span>)&#123;<br>\t<span class=\"hljs-attribute\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><a href=\"#slice\">切片访问</a></li>\n<li><a href=\"#find\">元素查找</a></li>\n<li>元素排序<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(o)array&#125;</span> <span class=\"hljs-comment\">#升序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(O)array&#125;</span> <span class=\"hljs-comment\">#降序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(oi)array&#125;</span> <span class=\"hljs-comment\">#大小写不敏感升序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(on)array&#125;</span> <span class=\"hljs-comment\">#按数字升序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(Oa)array&#125;</span> <span class=\"hljs-comment\">#反转数组元素</span><br></code></pre></td></tr></table></figure></li>\n<li>去重<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(u)array&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>构造连续字符或数值数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=(aa&#123;bb,cc,11&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aabb aacc aa11</span><br>array=(aa&#123;1..3&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa1 aa2 aa3</span><br>array=(aa&#123;15..19..2&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa15 aa17 aa19</span><br>array=(aa&#123;19..15..2&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa19 aa17 aa15</span><br>array=(aa&#123;01..03&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa01 aa02 aa03</span><br>array=(aa&#123;a..c&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aaa aab aac</span><br>array=(aa&#123;Y..c&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#ASCII码顺序</span><br></code></pre></td></tr></table></figure></li>\n<li>从文件构造数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># f 的功能是将字符串以换行符分隔成数组</span><br><span class=\"hljs-comment\"># 双引号不可省略，不然会变成一个字符串，引号也可以加在 $&#123; &#125; 上</span><br>array=(<span class=\"hljs-variable\">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>)<br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span><br><span class=\"hljs-comment\">#a</span><br><span class=\"hljs-comment\">#bb</span><br><span class=\"hljs-comment\">#ccc</span><br><span class=\"hljs-comment\">#dddd</span><br><span class=\"hljs-comment\"># 不加引号的效果</span><br>array=(<span class=\"hljs-variable\">$&#123;(f)$(&lt;test.txt)&#125;</span>)<br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span><br><span class=\"hljs-comment\">#a bb ccc dddd</span><br><br><span class=\"hljs-comment\"># 从文件构造数组，并将每行按分隔符 : 分隔后输出所有列</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>) &#123;<br>    array=(<span class=\"hljs-variable\">$&#123;(s.:.)i&#125;</span>)<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span>[1,-1]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>从文件列表构造数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=(/usr/bin/vim*)<br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span><br><span class=\"hljs-comment\">#/usr/bin/vim</span><br><span class=\"hljs-comment\">#/usr/bin/vimdiff</span><br><span class=\"hljs-comment\">#/usr/bin/vimtutor</span><br><br><span class=\"hljs-comment\"># 要比 ls /usr/bin/[a-b]?? | wc -l 快很多</span><br>array=(/usr/bin/[a-b]??) &amp;&amp; <span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$#array</span><br></code></pre></td></tr></table></figure></li>\n<li>数组交集差集<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 两个数组的交集，只输出两个数组都有的元素,如果有重复元素不会去重</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:*array2&#125;</span><br><span class=\"hljs-comment\"># 两个数组的差集，只输出 array1 中有，而 array2 中没有的元素</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:|array2&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>数组交叉合并<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 从 array1 取一个，再从 array2 取一个，以此类推，一个数组取完了就结束</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:^array2&#125;</span><br><span class=\"hljs-comment\"># 如果用 :^^，只有一个数组取完了的话，继续从头取，直到第二个数组也取完了</span><br>% <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:^^array2&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>对数组中的字符串进行统一处理<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># :t 是取字符串中的文件名，可以用在数组上，取所有元素的文件名</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;array:t&#125;</span><br><span class=\"hljs-comment\"># :e 是取扩展名，如果没有没有扩展名，结果数组中不会添加空字符串</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;array:e&#125;</span><br><span class=\"hljs-comment\"># 字符串替换等操作也可以对数组使用，替换所有字符串</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;array/a/j&#125;</span><br><span class=\"hljs-comment\"># :# 是排除匹配到的元素，类似 grep -v</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;array:#a*&#125;</span><br><span class=\"hljs-comment\"># 前边加 (M)，是反转后边的效果，即只输出匹配到的元素，类似 grep</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(M)array:#a*&#125;</span><br><span class=\"hljs-comment\"># 多个操作可以同时进行，(U) 是把字符串转成大写字母</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(UM)array:#a*&#125;</span><br><br><span class=\"hljs-comment\"># 截断或对齐数组中的字符串</span><br>array=(abc bcde cdefg defghi)<br><br><span class=\"hljs-comment\"># 只取每个字符串的最后两个字符</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(l:2:)array&#125;</span><br>bc de <span class=\"hljs-built_in\">fg</span> hi<br><br><span class=\"hljs-comment\"># 用空格补全字符串并且右对齐</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(l:7:)array&#125;</span><br>    abc<br>   bcde<br>  cdefg<br> defghi<br><br><span class=\"hljs-comment\"># 用指定字符补全</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(l:7::0:)array&#125;</span><br>0000abc<br>000bcde<br>00cdefg<br>0defghi<br><br><span class=\"hljs-comment\"># 用指定字符补全，第二个字符只用一次</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(l:7::0::1:)array&#125;</span><br>0001abc<br>001bcde<br>01cdefg<br>1defghi<br><br><span class=\"hljs-comment\"># 左对齐</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(r:7::0::1:)array&#125;</span><br>abc1000<br>bcde100<br>cdefg10<br>defghi1<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"字典变量\"><a href=\"#字典变量\" class=\"headerlink\" title=\"字典变量\"></a>字典变量</h3><ol>\n<li>定义<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">typeset</span> -A table<br><span class=\"hljs-comment\"># 先声明,或者用 local，二者功能是一样的</span><br><span class=\"hljs-built_in\">local</span> -A table<br><br><span class=\"hljs-comment\"># 赋值的语法和数组一样，但顺序依次是键、值、键、值</span><br>table=(k1 v1 k2 v2)<br><span class=\"hljs-comment\">#可以声明赋值一块,local -A table=(k1 v1 k2 v2)</span><br><br><span class=\"hljs-comment\"># 直接用 echo 只能输出值</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$table</span> <span class=\"hljs-comment\">#v1 v2</span><br><br><span class=\"hljs-comment\"># 使用 (kv) 同时输出键和值，(kv) 会把键和值都放到同一个数组里</span><br>% <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(kv)table&#125;</span> <span class=\"hljs-comment\">#k1 v1 k2 v2</span><br><br><span class=\"hljs-comment\"># 哈希表的大小是键值对的数量</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$#table</span><br></code></pre></td></tr></table></figure></li>\n<li>读写<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$table</span>[k2]<br>table[k2]=<span class=\"hljs-string\">&quot;v2&quot;</span><br><span class=\"hljs-comment\"># 删除元素的方法和数组不同，引号不能省略</span><br><span class=\"hljs-built_in\">unset</span> <span class=\"hljs-string\">&quot;table[k1]&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li>哈希表拼接<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 追加元素的方法和数组一样</span><br>table+=(k4 v4 k5 v5)<br><span class=\"hljs-comment\"># 拼接哈希表，要展开成数组再追加</span><br>table1+=(<span class=\"hljs-variable\">$&#123;(kv)table2&#125;</span>)<br></code></pre></td></tr></table></figure></li>\n<li>哈希表遍历<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 只遍历值</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$table</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\"># 只遍历键</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(k)table&#125;</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\"># 同时遍历键和值</span><br><span class=\"hljs-keyword\">for</span> k v (<span class=\"hljs-variable\">$&#123;(kv)table&#125;</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$k</span> -&gt; <span class=\"hljs-variable\">$v</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>键是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(($+table[k1]))<br></code></pre></td></tr></table></figure></li>\n<li>元素排序<br>和数组类似,增加k、v两个选项<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 只对值排序</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(o)table&#125;</span><br><br><span class=\"hljs-comment\"># 只对键排序</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(ok)table&#125;</span><br><br><span class=\"hljs-comment\"># 键值放在一起排序</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(okv)table&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>从字符串、文件构造哈希表<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">str=<span class=\"hljs-string\">&quot;k1 v1 k2 v2&quot;</span><br><span class=\"hljs-built_in\">local</span> -A table=(<span class=\"hljs-variable\">$&#123;=str&#125;</span>)<br><span class=\"hljs-comment\">#从文件构造和数组类似</span><br></code></pre></td></tr></table></figure></li>\n<li>对哈希表的每个元素统一处理<br>可参见数组,同时增加kv两个选项<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#值转成大写</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(U)table&#125;</span><br><span class=\"hljs-comment\">#键转成大写</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(Uk)table&#125;</span><br><span class=\"hljs-comment\">#键值转成大写</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(Ukv)table&#125;</span><br><span class=\"hljs-comment\"># 排除匹配到的值</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;table:#v1&#125;</span><br><span class=\"hljs-comment\"># 只输出匹配到的键</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(Mk)table:#k[1-2]&#125;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h3><p>zsh通常不指定数值是整形还是浮点型,通常直接赋值，<strong>虽然默认为字符串</strong>,但作数值计算时自动判断,但可以如下指明类型,同时在双小括号里做c语言的任何符号计算,同时括号内变量可以不需要加$符号(貌似是zsh的一般特性,适用于许多其他场合)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">integer</span> i=123<br><span class=\"hljs-built_in\">float</span> f=12.56<br><span class=\"hljs-comment\">#(t)用于输出变量类型</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(t)i&#125;</span> <span class=\"hljs-comment\">#integer</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(t)f&#125;</span> <span class=\"hljs-comment\">#float</span><br><span class=\"hljs-comment\"># 注意一旦指定了变量类型，类型就不会变了，除非再重新指定其他类型，或者用 unset 删除掉 </span><br><span class=\"hljs-comment\"># 如果把浮点数赋值给整数变量，会取整</span><br>i=12.34<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span> <span class=\"hljs-comment\">#会输出12</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>数学函数<br>zsh&#x2F;mathfunc模块包含数学函数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">zmodload</span> -i zsh/mathfunc<br><span class=\"hljs-built_in\">echo</span> $((sin(<span class=\"hljs-number\">0</span>)+ceil(<span class=\"hljs-number\">14.4</span>)))<br></code></pre></td></tr></table></figure>\n<strong>函数列表</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数名</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">abs</td>\n<td align=\"center\">取绝对值</td>\n</tr>\n<tr>\n<td align=\"center\">ceil</td>\n<td align=\"center\">向上取整</td>\n</tr>\n<tr>\n<td align=\"center\">floor</td>\n<td align=\"center\">向下取整</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">截断取整</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">转换成浮点数</td>\n</tr>\n<tr>\n<td align=\"center\">sqrt</td>\n<td align=\"center\">开平方</td>\n</tr>\n<tr>\n<td align=\"center\">cbrt</td>\n<td align=\"center\">开立方</td>\n</tr>\n<tr>\n<td align=\"center\">log</td>\n<td align=\"center\">自然对数</td>\n</tr>\n<tr>\n<td align=\"center\">log10</td>\n<td align=\"center\">常用对数</td>\n</tr>\n<tr>\n<td align=\"center\">rand48</td>\n<td align=\"center\">随机数</td>\n</tr>\n</tbody></table>\n<p>还有:acos、acosh、asin、asinh、atan、atanh、cos、cosh、erf、erfc、exp、 expm1、fabs、gamma、j0、j1、lgamma、log1p、logb、sin、sinh、tan、 tanh、y0、y1、ilogb、signgam、copysign、fmod、hypot、nextafter、jn、 yn、ldexp、scalb</p>\n<h3 id=\"变量修饰语\"><a href=\"#变量修饰语\" class=\"headerlink\" title=\"变量修饰语\"></a>变量修饰语</h3><p><strong>一般两种格式:</strong></p>\n<ul>\n<li><code>$&#123;(x)var&#125;</code> var是变量名,x是一个或多个字母,</li>\n<li><code>$&#123;var:x&#125;</code> var是变量名,x是一个或多个字母,或其他符号</li>\n</ul>\n<p><strong>注意:加了修饰语的变量依然是变量,可以当普通变量处理,可以嵌套使用,$符号后不可以有空格</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"center\">举例</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">:-</td>\n<td align=\"center\"><code>echo $&#123;var:-abc&#125;</code></td>\n<td align=\"center\">如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\"><code>echo $&#123;var-abc&#125;</code></td>\n<td align=\"center\">如果变量有值,则输出原值,如果变量不存在,则输出abc</td>\n</tr>\n<tr>\n<td align=\"center\">:&#x3D;</td>\n<td align=\"center\"><code>echo $&#123;var:=abc&#125;</code></td>\n<td align=\"center\">如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc并且赋值给var</td>\n</tr>\n<tr>\n<td align=\"center\">::&#x3D;</td>\n<td align=\"center\"><code>echo $&#123;var::=123&#125;</code></td>\n<td align=\"center\">不管有没有值，村不存在，都输出123，并且重新赋值</td>\n</tr>\n<tr>\n<td align=\"center\">:?</td>\n<td align=\"center\"><code>echo $&#123;var:?error&#125;</code></td>\n<td align=\"center\">var没有值或不存在,则直接报错,否则输出原值</td>\n</tr>\n<tr>\n<td align=\"center\">:+</td>\n<td align=\"center\"><code>echo $&#123;var:+123&#125;</code></td>\n<td align=\"center\">如果var有值,则输出123,否则输出空</td>\n</tr>\n<tr>\n<td align=\"center\">(F)</td>\n<td align=\"center\"><code>echo $&#123;(F)array&#125;</code></td>\n<td align=\"center\">把数组中的元素以换行符拼接成字符串,不加任何修饰的话则是空格拼接</td>\n</tr>\n<tr>\n<td align=\"center\">(j&#x2F;x&#x2F;)</td>\n<td align=\"center\"><code>echo $&#123;(j/-=/)array&#125;</code></td>\n<td align=\"center\">把数组中的元素以-&#x3D;两个字符连接</td>\n</tr>\n<tr>\n<td align=\"center\">(s&#x2F;x&#x2F;)</td>\n<td align=\"center\"><code>echo $&#123;(s/==/)str&#125;</code></td>\n<td align=\"center\">把字符串中的字符以&#x3D;&#x3D;两个字符为分隔符分成数组</td>\n</tr>\n<tr>\n<td align=\"center\">(t)</td>\n<td align=\"center\"><code>echo $&#123;(t)var&#125;</code></td>\n<td align=\"center\">输出变量的类型:integer float scalar array association</td>\n</tr>\n<tr>\n<td align=\"center\"><code>(P)</code></td>\n<td align=\"center\"><code>var=abc abc=123 echo $&#123;(P)var&#125;</code></td>\n<td align=\"center\">多重替换,输出123</td>\n</tr>\n<tr>\n<td align=\"center\">[#n]</td>\n<td align=\"center\"><code>echo $(([#16] 255))</code></td>\n<td align=\"center\">以n进制显示十进制整数</td>\n</tr>\n<tr>\n<td align=\"center\">n#</td>\n<td align=\"center\"><code>echo $((16#ff))</code></td>\n<td align=\"center\">显示n进制整数为十进制</td>\n</tr>\n</tbody></table>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>与bash基本一致,增加了<code>unfunction fun</code>删除某个函数的功能,还有就是规避了<code>$*</code>和<code>$@</code>的区别,zsh推荐只用<code>$*</code></p>\n<h3 id=\"替代find和ls\"><a href=\"#替代find和ls\" class=\"headerlink\" title=\"替代find和ls\"></a>替代find和ls</h3><p>需要开启扩展通配符:setopt EXTENDED_GLOB<br><strong>通配符修饰语列表</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">使用样例或补充说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;</td>\n<td align=\"center\">目录</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">F</td>\n<td align=\"center\">非空</td>\n<td align=\"center\">&#x2F;F(非空目录) &#x2F;^F(空目录)</td>\n</tr>\n<tr>\n<td align=\"center\">.</td>\n<td align=\"center\">普通文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">@</td>\n<td align=\"center\">符号链接</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;</td>\n<td align=\"center\">socket文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">p</td>\n<td align=\"center\">FIFO 文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">*</td>\n<td align=\"center\">可执行的普通文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">%</td>\n<td align=\"center\">设备文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">%b</td>\n<td align=\"center\">块设备文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">%c</td>\n<td align=\"center\">字符设备文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">r</td>\n<td align=\"center\">文件拥有着有读权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">w</td>\n<td align=\"center\">文件拥有着有写权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">x</td>\n<td align=\"center\">文件拥有着有执行权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\">文件拥有组用户有读权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">I</td>\n<td align=\"center\">文件拥有组用户有写权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">E</td>\n<td align=\"center\">文件拥有组用户有执行权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">R</td>\n<td align=\"center\">任何用户都有读权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">W</td>\n<td align=\"center\">任何用户都有写权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">X</td>\n<td align=\"center\">任何用户都有执行权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">s</td>\n<td align=\"center\">设置了setuid的文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">S</td>\n<td align=\"center\">设置了setgid的文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">设置了粘滞位（sticky bit）的文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">符合指定的权限</td>\n<td align=\"center\">f0644 f4755 f700</td>\n</tr>\n<tr>\n<td align=\"center\">e</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">大于某个数</td>\n<td align=\"center\">通常跟数字,与其他配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">指定设备号</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">l</td>\n<td align=\"center\">硬连接个数</td>\n<td align=\"center\">l-2（小于 2） l+3（大于 3）</td>\n</tr>\n<tr>\n<td align=\"center\">U</td>\n<td align=\"center\">当前用户拥有</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">G</td>\n<td align=\"center\">当前用户所在组拥有</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">u</td>\n<td align=\"center\">指定用户 id 拥有</td>\n<td align=\"center\">u1000</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td align=\"center\">指定用户组 id 拥有</td>\n<td align=\"center\">g1000</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"center\">指定文件的 atime</td>\n<td align=\"center\">访问时间,默认单位是天,可跟单位M(月)、w(周)、h(小时)、m(分钟)、s(秒)、+(指定时间之前)、-(指定时间之内)</td>\n</tr>\n<tr>\n<td align=\"center\">m</td>\n<td align=\"center\">指定文件的 mtime</td>\n<td align=\"center\">修改时间,可跟单位、+-,<code>print -l *(.mm+1)</code></td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">指定文件的 ctime</td>\n<td align=\"center\">文件状态属性修改时间,可跟单位、+-,<code>print -l *(.cm+1)</code></td>\n</tr>\n<tr>\n<td align=\"center\">L</td>\n<td align=\"center\">指定文件大小</td>\n<td align=\"center\">默认单位是字节,单位有k、m和p(512字节的块),也可以大写,<code>print -l *(.Lm-1)</code></td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td align=\"center\">取反</td>\n<td align=\"center\">&#x2F;^F</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">小于某个数</td>\n<td align=\"center\">通常跟数字,与其他配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">M</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n<tr>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n<tr>\n<td align=\"center\">N</td>\n<td align=\"center\">如果没匹配到，返回空而不报错</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">D</td>\n<td align=\"center\">包含隐藏文件（. 开头）</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">n</td>\n<td align=\"center\">按数值大小排序</td>\n<td align=\"center\">下文有说明</td>\n</tr>\n<tr>\n<td align=\"center\">o</td>\n<td align=\"center\">递增排序</td>\n<td align=\"center\">下文有说明</td>\n</tr>\n<tr>\n<td align=\"center\">O</td>\n<td align=\"center\">递减排序</td>\n<td align=\"center\">下文有说明</td>\n</tr>\n<tr>\n<td align=\"center\">[n]</td>\n<td align=\"center\">只取第 n 个文件</td>\n<td align=\"center\">.[5]</td>\n</tr>\n<tr>\n<td align=\"center\">[n1,n2]</td>\n<td align=\"center\">取第 n1 到 n2 个文件</td>\n<td align=\"center\">&#x2F;[5,10]</td>\n</tr>\n<tr>\n<td align=\"center\">:X</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n</tbody></table>\n<ol>\n<li>文件排序</li>\n</ol>\n<p>可供排序的因子:n(文件名),L(大小),I(硬连接数),a(atime),m(mtime),c(ctime),d(所在目录深度,从深到浅)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 按文件名排序，同一目录下的文件和目录名会一起排，而不是先排目录再排文件</span><br><span class=\"hljs-comment\">#**/*,指当前目录和子目录</span><br><span class=\"hljs-built_in\">print</span> -l **/*(.on)<br>bb.txt<br>cc/aa.txt<br>cc/dd.txt<br>zz.txt<br><br><span class=\"hljs-comment\"># 按文件的目录深度逆序排，d 是从深往浅排，O 是逆序</span><br><span class=\"hljs-built_in\">print</span> -l **/*(.Od)<br>zz.txt<br>bb.txt<br>cc/dd.txt<br>cc/aa.txt<br><br><span class=\"hljs-comment\"># 先按文件名排序，然后再按大小排序，这样大小相同的文件依然是按文件名排的</span><br><span class=\"hljs-built_in\">print</span> -l **/*(.onoL)<br>bb.txt<br>cc/aa.txt<br>cc/dd.txt<br>cc.txt<br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>组合使用</p>\n<p> 类型和类型之间要用逗号个开,逗号前后内容互不干扰(取反^只影响到逗号之前的内容)</p>\n<p> <code>print -l *(/m-2,.Lm-3oL,@D)</code></p>\n</li>\n<li><p>批量重命名zmv</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用前需要先加载进来</span><br><span class=\"hljs-built_in\">autoload</span> -U zmv<br><br><span class=\"hljs-comment\"># 将所有 txt 文件扩展名改成 conf</span><br><span class=\"hljs-comment\"># 参数要用单引号扩起来，$1 代表第一个参数中括号中的内容</span><br> zmv <span class=\"hljs-string\">&#x27;(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$1.conf&#x27;</span><br><br><span class=\"hljs-comment\"># 如果加了 -W 参数，zmv 会自动识别文件名中需要保留的部分</span><br> zmv -W <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> <span class=\"hljs-string\">&#x27;*.conf&#x27;</span><br><br><span class=\"hljs-comment\"># 调整文件名各部分的前后顺序</span><br>zmv <span class=\"hljs-string\">&#x27;(*).(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$2.$1.txt&#x27;</span><br><span class=\"hljs-comment\"># 加 -n 预览而不实际运行</span><br>zmv -n <span class=\"hljs-string\">&#x27;(*).(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$2.$1.txt&#x27;</span><br><span class=\"hljs-built_in\">mv</span> -- a.b.txt b.a.txt<br><br><span class=\"hljs-comment\"># 0 1 2 ... 前添加 0，以便和 10 11 12 ... 宽度一致</span><br>zmv <span class=\"hljs-string\">&#x27;([0-9]).(*)&#x27;</span> <span class=\"hljs-string\">&#x27;0$1.$2&#x27;</span><br><span class=\"hljs-comment\"># 去掉开头的一个 0</span><br>zmv <span class=\"hljs-string\">&#x27;(0)(*)&#x27;</span> <span class=\"hljs-string\">&#x27;$2&#x27;</span><br><br><span class=\"hljs-comment\"># 文件整理到目录</span><br>zmv <span class=\"hljs-string\">&#x27;(*) - (*) - (*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$1/$2 - $3.txt&#x27;</span><br><br><span class=\"hljs-comment\"># 转换大小写</span><br>zmv <span class=\"hljs-string\">&#x27;(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$&#123;(U)1&#125;.txt&#x27;</span><br>zmv <span class=\"hljs-string\">&#x27;(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$&#123;(L)1&#125;.txt&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>不展开通配符</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-function\"><span class=\"hljs-title\">calc</span></span>() &#123;<br>    <span class=\"hljs-built_in\">zmodload</span> zsh/mathfunc<br>    <span class=\"hljs-built_in\">echo</span> $(($*))<br>&#125;<br>calc 12+12<br>calc 12*12 <span class=\"hljs-comment\">#会报错</span><br><span class=\"hljs-built_in\">noglob</span> calc 12*12 <span class=\"hljs-comment\">#可以</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"local和typeset\"><a href=\"#local和typeset\" class=\"headerlink\" title=\"local和typeset\"></a>local和typeset</h3><p>local和typeset基本一样(除了不能用-f和-g这两个选项)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">强制字符串内容为小写</td>\n<td align=\"center\"><code>local -l str=abcABC</code></td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">强制字符串内容为大写</td>\n<td align=\"center\"><code>local -u str=abcABC</code></td>\n</tr>\n<tr>\n<td align=\"center\">-x</td>\n<td align=\"center\">设置为环境变量</td>\n<td align=\"center\"><code>export str=abc</code>等价于<code>local -x str=abc</code></td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">只读</td>\n<td align=\"center\"><code>local -r strl=abc</code>等价于<code>readonly str1=abc</code></td>\n</tr>\n<tr>\n<td align=\"center\">-U</td>\n<td align=\"center\">设置数组不包含重复元素</td>\n<td align=\"center\"><code>local -U array=(aa bb aa cc)</code></td>\n</tr>\n<tr>\n<td align=\"center\">-Z n</td>\n<td align=\"center\">设置整数位数</td>\n<td align=\"center\">不够用0不全,超过会被截断</td>\n</tr>\n<tr>\n<td align=\"center\">-i n</td>\n<td align=\"center\">设置整数为其他进制显示</td>\n<td align=\"center\">支持2-36</td>\n</tr>\n<tr>\n<td align=\"center\"><code>local &#123;i,j,k&#125;=123</code></td>\n<td align=\"center\">赋值多个变量为同一个值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-T</td>\n<td align=\"center\">绑定字符串和数组</td>\n<td align=\"center\"><code>local -T DIR dir</code>,DIR为字符串,dir为数组,以冒号连接,主要用于path变量</td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">显示变量的定义方式</td>\n<td align=\"center\">显示脚本如何定义该变量的</td>\n</tr>\n</tbody></table>\n<h3 id=\"双引号问题\"><a href=\"#双引号问题\" class=\"headerlink\" title=\"双引号问题\"></a>双引号问题</h3><p>zsh不需要像bash那样频繁加双引号来避免错误。<br>zsh需要加双引号的场景:</p>\n<ol>\n<li>像这样的包含字符或者特殊符号的字符串 <code>&quot;aa bb \\t \\n *&quot;</code> 出现在代码中时，两边要加双引号</li>\n<li>在用<code>$()</code>调用命令时，如果希望结果按一个字符串处理，需要加上双引</li>\n<li>如果想将数组当单个字符串处理，需要加双引号，<code>array=(a b); print -l &quot;$array&quot;</code></li>\n<li>其他的原本不是单个字符串的东西，需要转成单个字符串的场景，要加双引号</li>\n</ol>\n<p>其余通常不加,其中典型场景:</p>\n<ol>\n<li>任何情况下，字符串变量的两边都不需要加双引号，无论里边的内容多么特殊，或者变量存不存在，都没有关系，如<code>$str</code></li>\n<li>如果不转换类型（比如数组转成字符串），任何变量的两边都不需要加双引号</li>\n<li><code>$1 $2 $*</code>这些参数（其实它们也都是单个字符串），都不需要加双引号，无论内容是什么，或者参数是否存在。</li>\n</ol>\n<h3 id=\"mapfile读写文件\"><a href=\"#mapfile读写文件\" class=\"headerlink\" title=\"mapfile读写文件\"></a>mapfile读写文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">zmodload</span> zsh/mapfile<br><br><span class=\"hljs-comment\"># 这样就可以创建文件并写入内容，如果文件存在则会被覆盖</span><br><span class=\"hljs-built_in\">mapfile</span>[test.txt]=<span class=\"hljs-string\">&quot;ab cd&quot;</span><br><span class=\"hljs-built_in\">cat</span> test.txt<br><span class=\"hljs-comment\">#ab cd</span><br><br><span class=\"hljs-comment\"># 判断文件是否存在</span><br>(($+mapfile[test.txt])) &amp;&amp; <span class=\"hljs-built_in\">echo</span> good<br><span class=\"hljs-comment\">#good</span><br><br><span class=\"hljs-comment\"># 读取文件</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$mapfile</span>[test.txt]<br><span class=\"hljs-comment\">#ab cd</span><br><br><span class=\"hljs-comment\"># 删除文件</span><br><span class=\"hljs-built_in\">unset</span> <span class=\"hljs-string\">&quot;mapfile[test.txt]&quot;</span><br><br><span class=\"hljs-comment\"># 遍历文件</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(k)mapfile&#125;</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\">#test1.txt</span><br><span class=\"hljs-comment\">#test2.txt</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> [some condition]&#123;<br>\t<span class=\"hljs-built_in\">break</span>/continue<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">until [some condition]&#123;<br>\t<span class=\"hljs-keyword\">break</span>/<span class=\"hljs-keyword\">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#样例</span><br><span class=\"hljs-keyword\">for</span> i (aa bb cc)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br>array=(aa bb cc)<br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$array</span>) &#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-keyword\">for</span> ((i=<span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++))&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-keyword\">for</span> i (&#123;1..10&#125;)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">repeat</span> <span class=\"hljs-number\">5</span>&#123;<br>\t<span class=\"hljs-attribute\">echo</span> good<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"分支语句\"><a href=\"#分支语句\" class=\"headerlink\" title=\"分支语句\"></a>分支语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">case</span> <span class=\"hljs-variable\">$i</span> &#123;<br>\t(a)<br>\t<span class=\"hljs-built_in\">echo</span> 1<br>\t;;<br><br>\t(b)<br>\t<span class=\"hljs-built_in\">echo</span> 2<br>\t<span class=\"hljs-comment\">#继续执行下一个匹配的语句(不再进行匹配)</span><br>\t;&amp;<br><br>\t(c)<br>\t<span class=\"hljs-built_in\">echo</span> 3<br>\t<span class=\"hljs-comment\">#继续向下匹配，看是否有满足条件的分支</span><br>\t;|<br><br>\t(c)<br>\t<span class=\"hljs-built_in\">echo</span> 33<br>\t;;<br><br>\t(*)<br>\t<span class=\"hljs-built_in\">echo</span> oher<br>\t;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"用户输入选择语句\"><a href=\"#用户输入选择语句\" class=\"headerlink\" title=\"用户输入选择语句\"></a>用户输入选择语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">select</span> i (aa bb cc)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>必须加break,否则会一直让用户选择</p>\n<h3 id=\"异常处理语句\"><a href=\"#异常处理语句\" class=\"headerlink\" title=\"异常处理语句\"></a>异常处理语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t语句1<br>&#125; always&#123;<br>\t语句2<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>无论语句1是否出错,都执行语句2</p>\n<h3 id=\"socket模块\"><a href=\"#socket模块\" class=\"headerlink\" title=\"socket模块\"></a>socket模块</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 监听连接端=======</span><br><span class=\"hljs-comment\"># 首先要加载 socket 模块</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/socket<br><br><span class=\"hljs-built_in\">zsocket</span> -l test.sock<br>listenfd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\"># 此处阻塞等待连接</span><br><span class=\"hljs-built_in\">zsocket</span> -a <span class=\"hljs-variable\">$listenfd</span><br><span class=\"hljs-comment\"># 连接建立完成</span><br>fd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\"># 然后 $fd 就可读可写</span><br><span class=\"hljs-built_in\">cat</span> &lt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 发起连接端==========</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/socket<br><span class=\"hljs-built_in\">zsocket</span> test.sock<br>fd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-built_in\">echo</span> good &gt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 关闭监听端========</span><br><span class=\"hljs-built_in\">exec</span> &#123;listenfd&#125;&gt;&amp;-<br><span class=\"hljs-built_in\">exec</span> &#123;fd&#125;&gt;&amp;-<br><span class=\"hljs-built_in\">rm</span> test.sock<br><br><span class=\"hljs-comment\"># 关闭连接端======</span><br><span class=\"hljs-built_in\">exec</span> &#123;fd&#125;&gt;&amp;-<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"TCP模块\"><a href=\"#TCP模块\" class=\"headerlink\" title=\"TCP模块\"></a>TCP模块</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 监听连接端=======</span><br><span class=\"hljs-comment\"># 首先要加载 tcp 模块</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br><span class=\"hljs-built_in\">ztcp</span> -l 1234<br>listenfd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\"># 此处阻塞等待连接</span><br><span class=\"hljs-built_in\">ztcp</span> -a <span class=\"hljs-variable\">$listenfd</span><br><span class=\"hljs-comment\"># 连接建立完成</span><br>fd=<span class=\"hljs-variable\">$REPLY</span><br><br><span class=\"hljs-comment\"># 然后 $fd 就可读可写</span><br><span class=\"hljs-built_in\">cat</span> &lt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 发起连接端===========</span><br><span class=\"hljs-comment\"># 首先要加载 tcp 模块</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br><span class=\"hljs-built_in\">ztcp</span> 127.0.0.1 1234<br><span class=\"hljs-comment\"># 连接建立完成</span><br>fd=<span class=\"hljs-variable\">$REPLY</span><br><br><span class=\"hljs-comment\"># 然后 $fd 就可读可写</span><br><span class=\"hljs-built_in\">echo</span> good &gt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 关闭发起连接端===============</span><br><span class=\"hljs-comment\"># fd 是之前存放 fd 号的变量</span><br>% <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 关闭监听连接端=============</span><br>% <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$listenfd</span><br>% <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br></code></pre></td></tr></table></figure>\n<p>接受端例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/zsh</span><br><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br>(($+<span class=\"hljs-number\">1</span>)) || &#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Usage: <span class=\"hljs-variable\">$&#123;0:t&#125;</span> port&quot;</span><br>    <span class=\"hljs-built_in\">exit</span> 1<br>&#125;<br><br><span class=\"hljs-built_in\">ztcp</span> -l <span class=\"hljs-variable\">$1</span><br>listenfd=<span class=\"hljs-variable\">$REPLY</span><br><br>[[ <span class=\"hljs-variable\">$listenfd</span> == &lt;-&gt; ]] || <span class=\"hljs-built_in\">exit</span> 1<br><br><span class=\"hljs-keyword\">while</span> ((<span class=\"hljs-number\">1</span>)) &#123;<br>    <span class=\"hljs-built_in\">ztcp</span> -a <span class=\"hljs-variable\">$listenfd</span><br>    fd=<span class=\"hljs-variable\">$REPLY</span><br>    [[ <span class=\"hljs-variable\">$fd</span> == &lt;-&gt; ]] || <span class=\"hljs-built_in\">continue</span><br><br>    <span class=\"hljs-built_in\">cat</span> &lt;&amp;<span class=\"hljs-variable\">$fd</span><br>    <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>发送端例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/zsh</span><br><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br>((<span class=\"hljs-variable\">$#</span> &gt;= <span class=\"hljs-number\">2</span>)) || &#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Usage: <span class=\"hljs-variable\">$&#123;0:t&#125;</span> [hostname] port message&quot;</span><br>    <span class=\"hljs-built_in\">exit</span> 1<br>&#125;<br><br><span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-variable\">$1</span> == &lt;0-65535&gt; ]] &#123;<br>    <span class=\"hljs-built_in\">ztcp</span> 127.0.0.1 <span class=\"hljs-variable\">$1</span><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-built_in\">ztcp</span> <span class=\"hljs-variable\">$1</span> <span class=\"hljs-variable\">$2</span><br>    <span class=\"hljs-built_in\">shift</span><br>&#125;<br><br>fd=<span class=\"hljs-variable\">$REPLY</span><br>[[ <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$fd</span>&quot;</span> == &lt;-&gt; ]] || <span class=\"hljs-built_in\">exit</span> 1<br><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;*[2,-1]&#125;</span> &gt;&amp;<span class=\"hljs-variable\">$fd</span><br><span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"日期模块-zmodload-zsh-datetime\"><a href=\"#日期模块-zmodload-zsh-datetime\" class=\"headerlink\" title=\"日期模块:zmodload zsh&#x2F;datetime\"></a>日期模块:zmodload zsh&#x2F;datetime</h3><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>echo $EPOCHSECONDS</code></td>\n<td align=\"center\">从光标1970年到现在的秒数,等价于<code>date +%s</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>echo $EPOCHREALTIME</code></td>\n<td align=\"center\">输出高精度当前时间戳</td>\n</tr>\n<tr>\n<td align=\"center\"><code>echo $epochtime</code></td>\n<td align=\"center\">输出当前时间戳的秒和纳秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>strftime &quot;%Y-%m-%d %H:%M:%S (%u)&quot; $EPOCHSECONDS</code></td>\n<td align=\"center\">按指定格式输出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>strftime -s str &quot;%Y-%m-%d %H:%M:%S (%u)&quot; $EPOCHSECONDS</code></td>\n<td align=\"center\">存到变量str中</td>\n</tr>\n<tr>\n<td align=\"center\"><code>strftime -r &quot;%Y-%m-%d %H:%M:%S (%u)&quot; &quot;2017-09-01 10:10:58 (5)&quot;</code></td>\n<td align=\"center\">上述的反操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"gdbm模块–存在文件里的哈希表\"><a href=\"#gdbm模块–存在文件里的哈希表\" class=\"headerlink\" title=\"gdbm模块–存在文件里的哈希表\"></a>gdbm模块–存在文件里的哈希表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">% <span class=\"hljs-built_in\">zmodload</span> zsh/db/gdbm<br><br><span class=\"hljs-comment\"># 声明数据库文件对应的哈希表</span><br><span class=\"hljs-built_in\">local</span> -A sampledb<br><span class=\"hljs-comment\"># 创建数据库文件，文件名是 sample.gdbm，对应 sampledb 哈希表</span><br><span class=\"hljs-comment\"># 如果该文件已经存在，则会继续使用该文件</span><br>ztie -d db/gdbm -f sample.gdbm sampledb<br><br><span class=\"hljs-comment\"># 然后正常使用 sampledb 哈希表即可，数据会同步写入到数据库文件中</span><br>sampledb[k1]=v1<br>sampledb+=(k2 v2 k3 v3)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(kv)sampledb&#125;</span><br><span class=\"hljs-comment\">#k1 v1 k2 v2 k3 v3</span><br><br><span class=\"hljs-comment\"># 获取数据库文件路径</span><br>% zgdbmpath sampledb<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\">#/home/goreliu/sample.gdbm</span><br><br><span class=\"hljs-comment\"># 释放数据库文件</span><br>zuntie -u sampledb<br><br><br><span class=\"hljs-comment\"># 也可以用只读的方式加载数据库文件</span><br>ztie -r -d db/gdbm -f sample.gdbm sampledb<br><span class=\"hljs-comment\"># 但这样的话，需要用 zuntie -u 释放数据库文件</span><br>zuntie -u sampledb<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"sched–-计划调度命令\"><a href=\"#sched–-计划调度命令\" class=\"headerlink\" title=\"sched–&gt;计划调度命令\"></a>sched–&gt;计划调度命令</h3><p>zmodload zsh&#x2F;sched</p>\n<ul>\n<li><code>sched +5 ls</code>5秒后运行ls</li>\n<li><code>sched</code>列出已有任务</li>\n<li><code>sched -n</code>去除第n个待运行命令</li>\n</ul>\n<h3 id=\"模块简介\"><a href=\"#模块简介\" class=\"headerlink\" title=\"模块简介\"></a>模块简介</h3><p>可以用man zshmodules查看模块功能</p>\n<ul>\n<li>zsh&#x2F;system:底层文件读写</li>\n<li>zsh&#x2F;pcre:正则表达式库</li>\n<li>zsh&#x2F;stat:内部stat，取代stat</li>\n<li>zsh&#x2F;zftp:内部ftp客户端</li>\n<li>zsh&#x2F;zprof:性能追踪工具</li>\n<li>zsh&#x2F;zpty:操作pty的命令</li>\n<li>zsh&#x2F;zselect:select系统调用的封装</li>\n</ul>\n<h3 id=\"TRAPINT\"><a href=\"#TRAPINT\" class=\"headerlink\" title=\"TRAPINT\"></a>TRAPINT</h3><p>该函数名,捕获任意信号?有待研究,如下的代码竟然捕捉到SIGINT信号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/zsh</span><br><br><span class=\"hljs-comment\"># SIGINT 是 2 信号，ctrl + c 会触发</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">TRAPINT</span></span>() &#123;<br>    <span class=\"hljs-comment\"># 处理一些退出前的善后工作</span><br>    <span class=\"hljs-built_in\">sleep</span> 333<br>&#125;<br><br><span class=\"hljs-built_in\">sleep</span> 1000<br></code></pre></td></tr></table></figure>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><ol>\n<li>统一使用4个空格来缩进</li>\n<li>非特殊场景,每行代码不超过100个字符</li>\n<li>在前一行尾部加一个空格和 \\ 折行，折行后缩进一层（4 个空格）。</li>\n<li>如果缩进的是一个文本块，可以使用对齐缩进，也可以使用 4 个空格的固定缩进。</li>\n<li>如果是在 aa &amp;&amp; bb || cc、[[ ]] 或者 (( )) 中折行，&amp;&amp; || 放在下一行的行首。</li>\n<li>在缩进和对齐之外的场景，不允许出现逻辑上不必要的连续多个空格。</li>\n<li><ul>\n<li>&amp;&amp; | 等双元运算符左右要加一个空格。</li>\n</ul>\n</li>\n<li>! ~等一元运算符和作用对象之间不加空格。</li>\n<li>( ) 和 (( )) { } 内侧不加空格，[[ ]] 因为语法需要，内侧加一个空格。</li>\n<li><code>;</code>之前不加空格，之后加一个空格。</li>\n<li>定义函数时（以及在 (( )) 中调用函数时），函数名和 ( 之间不加空格。</li>\n<li>if while 等关键字和后边的内容之间加一个空格</li>\n<li>if<code>[[ ]] &#123;</code>等场景中，<code>&#123;</code>和前边的内容之间加一个空格。</li>\n<li>变量和<code>[ ]</code>之间不加空格，用<code>[ ]</code>取数组或者哈希表值时，<code>[ ]</code>内侧不加空格。</li>\n<li><code>&gt; &lt;</code>等重定向符号和文件或者文件描述符之间不加空格。</li>\n<li>非特殊场景，不允许出现超过两个连续空行。</li>\n<li>#!&#x2F;bin&#x2F;zsh 后加一个空行。</li>\n<li>if while 等语句块之后加一个空行。</li>\n<li>定义函数后加一个空行。</li>\n<li>逻辑关系不强的两行（或者两块）代码之间，根据逻辑关系强弱（自行判断），加一个或两个空行。</li>\n<li>在判断条件的场景，不使用<code>[ ]</code>，用<code>[[ ]]</code>代替。</li>\n<li>在数值计算的场景，使用<code>$(( ))</code>而不是<code>$[ ]</code>。</li>\n<li>使用数值时，两端不加引号。</li>\n<li>用<code>$var</code>取变量值时，两边不加双引号，除非需要将非字符串变量转换成字符串。</li>\n<li>在非必须场景，不需要加<code>$&#123;var&#125;</code>中的大括号。</li>\n<li>变量使用前要明确指明是局部变量（用 local 定义）还是全局变量（用 typeset -g 定义）。</li>\n<li>能用局部变量的地方全部使用局部变量（用 local 定义）。</li>\n<li>变量名中的单词可以使用下划线分隔或者驼峰风格，在不影响可读性的情况也可以使用全小写字母，但在同一个文件中要一致。</li>\n<li>字符串常量两端可以添加双引号或者单引号，但同一个文件中风格要一致。</li>\n<li>可以使用 name() 或者 function name() 定义函数，但同一个文件中风格要一致。</li>\n<li>非特殊场景，单个脚本文件不超过 1000 行。</li>\n</ol>\n<h3 id=\"bash和zsh的简明对比\"><a href=\"#bash和zsh的简明对比\" class=\"headerlink\" title=\"bash和zsh的简明对比\"></a>bash和zsh的简明对比</h3><table>\n<thead>\n<tr>\n<th align=\"center\">bash</th>\n<th align=\"center\">zsh</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&quot;$var&quot;</code></td>\n<td align=\"center\"><code>$var</code></td>\n<td align=\"center\">避免变量中有空格导致异常</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&quot;$@&quot;</code></td>\n<td align=\"center\"><code>$*</code></td>\n<td align=\"center\">避免变量中有空格导致异常</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&quot;$&#123;array[@]&#125;&quot;</code></td>\n<td align=\"center\"><code>$array</code></td>\n<td align=\"center\">取数组所有元素，@ 可改成 *</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;”$</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h3 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h3><p>Zsh的变量除了哈希表以外，都直接赋值使用,包括整数(64位带符号)、浮点数(64位带符号)、字符串、数组、哈希表,<code>$+var</code>,判断变量是否定义,未定义返回0,否则为1</p>\n<h3 id=\"字符串变量\"><a href=\"#字符串变量\" class=\"headerlink\" title=\"字符串变量\"></a>字符串变量</h3><ol>\n<li>获取字符串长度<br><code>str=abcde echo $#str</code></li>\n<li>字符串拼接<br><code>str2+=$str1;str3=$str1$str2</code><br><span id = \"slice\"></span></li>\n<li>字符串切片<br>字符位置从1开始算,bash风格的则从0开始算<br><code>echo $str[2,4]</code></li>\n<li>字符串截断<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">str=abcdeabcde<br><span class=\"hljs-comment\">#删除左端匹配到的内容,最小匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str#*b&#125;</span> <span class=\"hljs-comment\">#输出cdeabcde</span><br><span class=\"hljs-comment\">#删除右端匹配到的内容,最小匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str%d*&#125;</span> <span class=\"hljs-comment\">#输出abcdeabc</span><br><span class=\"hljs-comment\">#删除左端匹配到的内容,最大匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str##*b&#125;</span> <span class=\"hljs-comment\">#输出cde</span><br><span class=\"hljs-comment\">#删除右端匹配到的内容,最大匹配</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str%%d*&#125;</span> <span class=\"hljs-comment\">#输出abc</span><br></code></pre></td></tr></table></figure>\n<span id = \"find\"></span></li>\n<li>字符串查找<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#从左往右找cd字符串,找不到返回数组大小+1</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str</span>[(i)<span class=\"hljs-built_in\">cd</span>]<br><span class=\"hljs-comment\">#从右往左找cd字符串,找不到返回0</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str</span>[(I)<span class=\"hljs-built_in\">cd</span>]<br><span class=\"hljs-comment\">#从第二个位置开始找</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str[(in:2:)cd]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>遍历字符<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> i (&#123;1..<span class=\"hljs-variable\">$#str</span>&#125;)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str</span>[i]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>字符串替换<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">str=abcabc<br><span class=\"hljs-comment\">#只替换找到第一个</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/bc/ef&#125;</span> <span class=\"hljs-comment\">#aefabc</span><br><span class=\"hljs-comment\">#只删除找到第一个</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/bc&#125;</span> <span class=\"hljs-comment\">#aabc</span><br><span class=\"hljs-comment\">#上面两个的所有版本</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str//bc/ef&#125;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str//bc&#125;</span><br><br>str=abcABCabcABCabc<br><br><span class=\"hljs-comment\"># /# 只从字符串开头开始匹配，$&#123;str/#abc&#125; 也同理</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/#abc/123&#125;</span> <span class=\"hljs-comment\">#123ABCabcABCabc</span><br><br><span class=\"hljs-comment\"># /% 只从字符串结尾开始匹配，echo $&#123;str/%abc&#125; 也同理</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str/%abc/123&#125;</span> <span class=\"hljs-comment\">#abcABCabcABC123</span><br><br>str=abc<br><span class=\"hljs-comment\"># 如果匹配到了则输出空字符串</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:#ab*&#125;</span><br><br><span class=\"hljs-comment\"># 如果匹配不到，则输出原字符串</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:#ab&#125;</span><br><br><span class=\"hljs-comment\">#按位置删除字符和替换字符,就是指定位置赋值</span><br>str[1]=<br>str[2,4]=<br>str[1]=k<br>str[2,4]=sjkg <span class=\"hljs-comment\">#可以不一一对应</span><br></code></pre></td></tr></table></figure></li>\n<li>字符串是否匹配<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#是否包含</span><br>[[ <span class=\"hljs-variable\">$str1</span> == *<span class=\"hljs-variable\">$str2</span>* ]] &amp;&amp; <span class=\"hljs-built_in\">echo</span> good<br><span class=\"hljs-comment\">#正则匹配</span><br>[[ <span class=\"hljs-variable\">$str</span> =~ <span class=\"hljs-string\">&#x27;c[0-9]&#x27;</span> ]]<br></code></pre></td></tr></table></figure></li>\n<li>大小写转换<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#转成大写</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(U)str&#125;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:u&#125;</span><br><span class=\"hljs-comment\">#转成小写</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(L)str&#125;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str:l&#125;</span><br><span class=\"hljs-comment\">#首字母大写</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(C)str&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>目录文件名截取<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">filepath=/a/b/c.x<br><span class=\"hljs-comment\"># :h 是取目录名，即最后一个 / 之前的部分，如果没有 / 则为 .</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:h&#125;</span> <span class=\"hljs-comment\">#/a/b</span><br><span class=\"hljs-comment\"># :t 是取文件名，即最后一个 / 之后的部分，如果没有 / 则为字符串本身</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:t&#125;</span> <span class=\"hljs-comment\">#c.x</span><br><span class=\"hljs-comment\"># :e 是取文件扩展名，即文件名中最后一个点之后的部分，如果没有点则为空</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:e&#125;</span> <span class=\"hljs-comment\">#x</span><br><span class=\"hljs-comment\"># :r 是去掉末尾扩展名的路径</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath:r&#125;</span> <span class=\"hljs-comment\">#/a/b/c</span><br></code></pre></td></tr></table></figure></li>\n<li>相对路径转绝对路径<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#功能相当于$(readlink -f $filepath)</span><br>filepath1=a.txt<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;filepath1:A&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>分割字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用空格作为分隔符，多个空格也只算一个分隔符</span><br>str=<span class=\"hljs-string\">&#x27;aa bb cc dd&#x27;</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str[(w)2]&#125;</span><span class=\"hljs-comment\">#bb</span><br><br><span class=\"hljs-comment\"># 指定分隔符</span><br>str=<span class=\"hljs-string\">&#x27;aa--bb--cc&#x27;</span><br><span class=\"hljs-comment\"># 如果分隔符是 : 就用别的字符作为左右界，比如 ws.:.</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;str[(ws:--:)3]&#125;</span><span class=\"hljs-comment\">#cc</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<p><span id = \"arrAndStr\"></span></p>\n<ul>\n<li>转成数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=()<span class=\"hljs-variable\">$&#123;=str&#125;</span>)<span class=\"hljs-comment\">#默认按空格分隔,可以设置IFS环境变量设置,也可以按以下方法</span><br>str=<span class=\"hljs-string\">&quot;1:2::4&quot;</span><br><br><span class=\"hljs-comment\">#可以是多个字符,如**s/::/**,以**::**为分隔,同时也可以写成**.::.**,不必一定</span><br><span class=\"hljs-comment\">#使用**/**,可以用任意符号</span><br>str_array=(<span class=\"hljs-variable\">$&#123;(s/:/)str&#125;</span>)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str_array</span> <span class=\"hljs-comment\">#1 2 4 #忽略空字符串</span><br><span class=\"hljs-comment\"># 保留其中的空字符串</span><br>str_array=(<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;(@s/:/)str&#125;</span>&quot;</span>)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str_array</span>[3]<span class=\"hljs-comment\">#该值为空</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$str_array</span>[4]<br>str+=(1234)<span class=\"hljs-comment\">#字符串直接变成一个包含两个元素的数组</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"13\">\n<li>读取文件内容到字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 比用 str=$(cat filename) 性能好很多</span><br>str=$(&lt;filename)<br><br><span class=\"hljs-comment\"># 比用 cat filename 性能好很多，引号不能省略</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(&lt;filename)</span>&quot;</span><br><br><span class=\"hljs-comment\"># 遍历每行，引号不能省略</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(f)&quot;$(&lt;filename)&quot;&#125;</span>) &#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\"># 小文件或者需要频繁调用时，尽量不要用 sed</span><br><span class=\"hljs-comment\">#输出第2行</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;&quot;$(&lt;test.txt)&quot;[(f)2]&#125;</span><br><span class=\"hljs-comment\"># 输出包含 “ang” 的第一行</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;&quot;$(&lt;test.txt)&quot;[(fr)*ang*]&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>读取进程输出到字符串<br>就是把$(&lt;filename)换城$(cmd)</li>\n</ol>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">if</span> [some condition]&#123;<br>&#125; <span class=\"hljs-keyword\">elif</span>&#123;<br>&#125; <span class=\"hljs-keyword\">else</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"print和printf\"><a href=\"#print和printf\" class=\"headerlink\" title=\"print和printf\"></a>print和printf</h3><p>zsh支持print和printf,<code>print -</code>再按tab健就可以查看所有选项,<code>printf %</code>再按tab键就可以查看所有格式化的东西</p>\n<p>print支持的选项</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">参数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-C</td>\n<td align=\"center\">按列输出</td>\n<td align=\"center\">列数</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">替换路径成带~的版本</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-N</td>\n<td align=\"center\">使用\\x00(null)作为字符串的间隔,默认是空格</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-O</td>\n<td align=\"center\">降序排列</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-P</td>\n<td align=\"center\">输出颜色和特殊样式</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-R</td>\n<td align=\"center\">模拟echo命令</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-S</td>\n<td align=\"center\">放命令放入了历史命令文件(要加引号)</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-X</td>\n<td align=\"center\">替换所有tab为空格</td>\n<td align=\"center\">tab对应空格数</td>\n</tr>\n<tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">和-c&#x2F;-C一起使用时,改为从左到右</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-b</td>\n<td align=\"center\">识别出bindkey转义字符串</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">按列输出(自动决定列数)</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">同printf</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">和-o&#x2F;-O一起使用时,大小写不敏感排序</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">使用换行符作为字符串分隔符</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">只输出匹配的字符串</td>\n<td align=\"center\">匹配模式字符串</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">不自动添加最后的换行符</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-o</td>\n<td align=\"center\">升序排列</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">不处理转义字符</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">放命令放入历史命令文件(不要加引号)</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">指定fd输出</td>\n<td align=\"center\">fd号</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">把内容保存到变量</td>\n<td align=\"center\">变量名</td>\n</tr>\n<tr>\n<td align=\"center\">-x</td>\n<td align=\"center\">替换行首的tab为空格</td>\n<td align=\"center\">tab对应空格数</td>\n</tr>\n<tr>\n<td align=\"center\">-z</td>\n<td align=\"center\">把内容放置到命令行编辑区</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<ul>\n<li>颜色<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># %B 加粗 %b 取消加粗</span><br><span class=\"hljs-comment\"># %F&#123;red&#125; 前景色 %f 取消前景色</span><br><span class=\"hljs-comment\"># %K&#123;red&#125; 背景色 %k 取消背景色</span><br><span class=\"hljs-comment\"># %U 下滑线 %u 取消下滑线</span><br><span class=\"hljs-comment\"># %S 反色 %s 取消反色</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># black or 0  red     or 1</span><br><span class=\"hljs-comment\"># green or 2  yellow  or 3</span><br><span class=\"hljs-comment\"># blue  or 4  magenta or 5</span><br><span class=\"hljs-comment\"># cyan  or 6  white   or 7</span><br><br><span class=\"hljs-comment\"># 显示加粗的红色 abc</span><br><span class=\"hljs-built_in\">print</span> -P <span class=\"hljs-string\">&#x27;%B%F&#123;red&#125;abc&#x27;</span><br><br><span class=\"hljs-comment\"># 没覆盖到的功能可以用原始的转义符号，可读性比较差</span><br><span class=\"hljs-comment\"># 4[0-7] 背景色</span><br><span class=\"hljs-comment\"># 3[0-7] 前景色</span><br><span class=\"hljs-comment\"># 0m 正常 1m 加粗 2m 变灰 3m 斜体 4m 下滑钱 5m 闪烁 6m 快速闪烁 7m 反色</span><br><br><span class=\"hljs-comment\"># 显示闪烁的红底绿字 abc</span><br>% <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&quot;\\033[41;32;5mabc\\033[0m&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">通配符</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">*</td>\n<td align=\"center\">任意数量的字符</td>\n</tr>\n<tr>\n<td align=\"center\">?</td>\n<td align=\"center\">任意一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[abcd]</td>\n<td align=\"center\">abcd中的任意一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[^abcd]</td>\n<td align=\"center\">除abcd中的任意一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[a-c]</td>\n<td align=\"center\">a和c之间的一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">[a-cB-Dxyz]</td>\n<td align=\"center\">a和c之间、B和D之间以及xyz中的一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;1-100&gt;</td>\n<td align=\"center\">1和100之间的整数</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;-50&gt;</td>\n<td align=\"center\">0和50之间的整数</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;100-&gt;</td>\n<td align=\"center\">大于100的整数</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">任意正整数和0</td>\n</tr>\n<tr>\n<td align=\"center\">([a-c]|&lt;1-100&gt;)</td>\n<td align=\"center\">a和c之间的一个字符或者1和100之间的整数</td>\n</tr>\n</tbody></table>\n<p><strong>加强版,要支持需要加上<code>setopt EXTENDED_GLOB</code></strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">通配符</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">匹配的样式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">^abc</td>\n<td align=\"center\">除了 abc 外的任意字符串</td>\n<td align=\"center\">aaa</td>\n</tr>\n<tr>\n<td align=\"center\">abc^abc</td>\n<td align=\"center\">以 abc 开头，但后边不是 abc 的字符串</td>\n<td align=\"center\">abcabd</td>\n</tr>\n<tr>\n<td align=\"center\">a*c~abc</td>\n<td align=\"center\">符合 a*c 但不是 abc 的字符串</td>\n<td align=\"center\">adc</td>\n</tr>\n<tr>\n<td align=\"center\">a#</td>\n<td align=\"center\">任意数量（包括 0）个 a</td>\n<td align=\"center\">aaa</td>\n</tr>\n<tr>\n<td align=\"center\">b##</td>\n<td align=\"center\">一个或者多个b</td>\n<td align=\"center\">b</td>\n</tr>\n<tr>\n<td align=\"center\">(ab)##</td>\n<td align=\"center\">一个或者多个ab</td>\n<td align=\"center\">abab</td>\n</tr>\n<tr>\n<td align=\"center\">(#i)abc</td>\n<td align=\"center\">忽略大小写的abc</td>\n<td align=\"center\">AbC</td>\n</tr>\n<tr>\n<td align=\"center\">(#i)ab(#I)c</td>\n<td align=\"center\">忽略大小写的 ab 接着 c</td>\n<td align=\"center\">ABc</td>\n</tr>\n<tr>\n<td align=\"center\">(#l)aBc</td>\n<td align=\"center\">和 c 忽略大小写，但 B 必须大写 的 aBc</td>\n<td align=\"center\">aBC</td>\n</tr>\n<tr>\n<td align=\"center\">(#a1)abc</td>\n<td align=\"center\">最多错（多或缺也算）一个字符的 abc</td>\n<td align=\"center\">a2c 或 ab 或 abcd</td>\n</tr>\n</tbody></table>\n<h3 id=\"数组变量\"><a href=\"#数组变量\" class=\"headerlink\" title=\"数组变量\"></a>数组变量</h3><ol>\n<li>数组定义<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=(a <span class=\"hljs-string\">&quot;bb cc&quot;</span> <span class=\"hljs-built_in\">dd</span>)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#打印所有元素在一行</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#每行输出一个元素</span><br></code></pre></td></tr></table></figure></li>\n<li>元素读写<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span>[3]<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span>[-1]<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$#array</span> <span class=\"hljs-comment\">#获取长度</span><br>array[3]=some<br>array[3]=() <span class=\"hljs-comment\">#删除元素</span><br>array+=eeee <span class=\"hljs-comment\">#添加元素</span><br><span class=\"hljs-built_in\">unset</span> array <span class=\"hljs-comment\">#删除整个数组</span><br></code></pre></td></tr></table></figure></li>\n<li>数组拼接<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array1+=(e f g)<br>array1+=(<span class=\"hljs-variable\">$array2</span>) <span class=\"hljs-comment\">#小括号必须加,不加的话,则array2视为一个字符串</span><br></code></pre></td></tr></table></figure></li>\n<li><a href=\"#arrAndStr\">字符串与数组</a></li>\n<li>数组遍历<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">for</span> i (<span class=\"hljs-variable\">$array1</span>)&#123;<br>\t<span class=\"hljs-attribute\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\">#同时遍历两个数组</span><br>for i (<span class=\"hljs-variable\">$array1</span> <span class=\"hljs-variable\">$array2</span>)&#123;<br>\t<span class=\"hljs-attribute\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><a href=\"#slice\">切片访问</a></li>\n<li><a href=\"#find\">元素查找</a></li>\n<li>元素排序<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(o)array&#125;</span> <span class=\"hljs-comment\">#升序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(O)array&#125;</span> <span class=\"hljs-comment\">#降序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(oi)array&#125;</span> <span class=\"hljs-comment\">#大小写不敏感升序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(on)array&#125;</span> <span class=\"hljs-comment\">#按数字升序排列</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(Oa)array&#125;</span> <span class=\"hljs-comment\">#反转数组元素</span><br></code></pre></td></tr></table></figure></li>\n<li>去重<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(u)array&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>构造连续字符或数值数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=(aa&#123;bb,cc,11&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aabb aacc aa11</span><br>array=(aa&#123;1..3&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa1 aa2 aa3</span><br>array=(aa&#123;15..19..2&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa15 aa17 aa19</span><br>array=(aa&#123;19..15..2&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa19 aa17 aa15</span><br>array=(aa&#123;01..03&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aa01 aa02 aa03</span><br>array=(aa&#123;a..c&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#aaa aab aac</span><br>array=(aa&#123;Y..c&#125;) &amp;&amp; <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span> <span class=\"hljs-comment\">#ASCII码顺序</span><br></code></pre></td></tr></table></figure></li>\n<li>从文件构造数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># f 的功能是将字符串以换行符分隔成数组</span><br><span class=\"hljs-comment\"># 双引号不可省略，不然会变成一个字符串，引号也可以加在 $&#123; &#125; 上</span><br>array=(<span class=\"hljs-variable\">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>)<br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span><br><span class=\"hljs-comment\">#a</span><br><span class=\"hljs-comment\">#bb</span><br><span class=\"hljs-comment\">#ccc</span><br><span class=\"hljs-comment\">#dddd</span><br><span class=\"hljs-comment\"># 不加引号的效果</span><br>array=(<span class=\"hljs-variable\">$&#123;(f)$(&lt;test.txt)&#125;</span>)<br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span><br><span class=\"hljs-comment\">#a bb ccc dddd</span><br><br><span class=\"hljs-comment\"># 从文件构造数组，并将每行按分隔符 : 分隔后输出所有列</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>) &#123;<br>    array=(<span class=\"hljs-variable\">$&#123;(s.:.)i&#125;</span>)<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$array</span>[1,-1]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>从文件列表构造数组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">array=(/usr/bin/vim*)<br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$array</span><br><span class=\"hljs-comment\">#/usr/bin/vim</span><br><span class=\"hljs-comment\">#/usr/bin/vimdiff</span><br><span class=\"hljs-comment\">#/usr/bin/vimtutor</span><br><br><span class=\"hljs-comment\"># 要比 ls /usr/bin/[a-b]?? | wc -l 快很多</span><br>array=(/usr/bin/[a-b]??) &amp;&amp; <span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$#array</span><br></code></pre></td></tr></table></figure></li>\n<li>数组交集差集<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 两个数组的交集，只输出两个数组都有的元素,如果有重复元素不会去重</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:*array2&#125;</span><br><span class=\"hljs-comment\"># 两个数组的差集，只输出 array1 中有，而 array2 中没有的元素</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:|array2&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>数组交叉合并<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 从 array1 取一个，再从 array2 取一个，以此类推，一个数组取完了就结束</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:^array2&#125;</span><br><span class=\"hljs-comment\"># 如果用 :^^，只有一个数组取完了的话，继续从头取，直到第二个数组也取完了</span><br>% <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;array1:^^array2&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>对数组中的字符串进行统一处理<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># :t 是取字符串中的文件名，可以用在数组上，取所有元素的文件名</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;array:t&#125;</span><br><span class=\"hljs-comment\"># :e 是取扩展名，如果没有没有扩展名，结果数组中不会添加空字符串</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;array:e&#125;</span><br><span class=\"hljs-comment\"># 字符串替换等操作也可以对数组使用，替换所有字符串</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;array/a/j&#125;</span><br><span class=\"hljs-comment\"># :# 是排除匹配到的元素，类似 grep -v</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;array:#a*&#125;</span><br><span class=\"hljs-comment\"># 前边加 (M)，是反转后边的效果，即只输出匹配到的元素，类似 grep</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(M)array:#a*&#125;</span><br><span class=\"hljs-comment\"># 多个操作可以同时进行，(U) 是把字符串转成大写字母</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(UM)array:#a*&#125;</span><br><br><span class=\"hljs-comment\"># 截断或对齐数组中的字符串</span><br>array=(abc bcde cdefg defghi)<br><br><span class=\"hljs-comment\"># 只取每个字符串的最后两个字符</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(l:2:)array&#125;</span><br>bc de <span class=\"hljs-built_in\">fg</span> hi<br><br><span class=\"hljs-comment\"># 用空格补全字符串并且右对齐</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(l:7:)array&#125;</span><br>    abc<br>   bcde<br>  cdefg<br> defghi<br><br><span class=\"hljs-comment\"># 用指定字符补全</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(l:7::0:)array&#125;</span><br>0000abc<br>000bcde<br>00cdefg<br>0defghi<br><br><span class=\"hljs-comment\"># 用指定字符补全，第二个字符只用一次</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(l:7::0::1:)array&#125;</span><br>0001abc<br>001bcde<br>01cdefg<br>1defghi<br><br><span class=\"hljs-comment\"># 左对齐</span><br><span class=\"hljs-built_in\">print</span> -l <span class=\"hljs-variable\">$&#123;(r:7::0::1:)array&#125;</span><br>abc1000<br>bcde100<br>cdefg10<br>defghi1<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"字典变量\"><a href=\"#字典变量\" class=\"headerlink\" title=\"字典变量\"></a>字典变量</h3><ol>\n<li>定义<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">typeset</span> -A table<br><span class=\"hljs-comment\"># 先声明,或者用 local，二者功能是一样的</span><br><span class=\"hljs-built_in\">local</span> -A table<br><br><span class=\"hljs-comment\"># 赋值的语法和数组一样，但顺序依次是键、值、键、值</span><br>table=(k1 v1 k2 v2)<br><span class=\"hljs-comment\">#可以声明赋值一块,local -A table=(k1 v1 k2 v2)</span><br><br><span class=\"hljs-comment\"># 直接用 echo 只能输出值</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$table</span> <span class=\"hljs-comment\">#v1 v2</span><br><br><span class=\"hljs-comment\"># 使用 (kv) 同时输出键和值，(kv) 会把键和值都放到同一个数组里</span><br>% <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(kv)table&#125;</span> <span class=\"hljs-comment\">#k1 v1 k2 v2</span><br><br><span class=\"hljs-comment\"># 哈希表的大小是键值对的数量</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$#table</span><br></code></pre></td></tr></table></figure></li>\n<li>读写<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$table</span>[k2]<br>table[k2]=<span class=\"hljs-string\">&quot;v2&quot;</span><br><span class=\"hljs-comment\"># 删除元素的方法和数组不同，引号不能省略</span><br><span class=\"hljs-built_in\">unset</span> <span class=\"hljs-string\">&quot;table[k1]&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li>哈希表拼接<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 追加元素的方法和数组一样</span><br>table+=(k4 v4 k5 v5)<br><span class=\"hljs-comment\"># 拼接哈希表，要展开成数组再追加</span><br>table1+=(<span class=\"hljs-variable\">$&#123;(kv)table2&#125;</span>)<br></code></pre></td></tr></table></figure></li>\n<li>哈希表遍历<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 只遍历值</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$table</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\"># 只遍历键</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(k)table&#125;</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\"># 同时遍历键和值</span><br><span class=\"hljs-keyword\">for</span> k v (<span class=\"hljs-variable\">$&#123;(kv)table&#125;</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$k</span> -&gt; <span class=\"hljs-variable\">$v</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>键是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(($+table[k1]))<br></code></pre></td></tr></table></figure></li>\n<li>元素排序<br>和数组类似,增加k、v两个选项<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 只对值排序</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(o)table&#125;</span><br><br><span class=\"hljs-comment\"># 只对键排序</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(ok)table&#125;</span><br><br><span class=\"hljs-comment\"># 键值放在一起排序</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(okv)table&#125;</span><br></code></pre></td></tr></table></figure></li>\n<li>从字符串、文件构造哈希表<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">str=<span class=\"hljs-string\">&quot;k1 v1 k2 v2&quot;</span><br><span class=\"hljs-built_in\">local</span> -A table=(<span class=\"hljs-variable\">$&#123;=str&#125;</span>)<br><span class=\"hljs-comment\">#从文件构造和数组类似</span><br></code></pre></td></tr></table></figure></li>\n<li>对哈希表的每个元素统一处理<br>可参见数组,同时增加kv两个选项<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#值转成大写</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(U)table&#125;</span><br><span class=\"hljs-comment\">#键转成大写</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(Uk)table&#125;</span><br><span class=\"hljs-comment\">#键值转成大写</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-variable\">$&#123;(Ukv)table&#125;</span><br><span class=\"hljs-comment\"># 排除匹配到的值</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;table:#v1&#125;</span><br><span class=\"hljs-comment\"># 只输出匹配到的键</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(Mk)table:#k[1-2]&#125;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h3><p>zsh通常不指定数值是整形还是浮点型,通常直接赋值，<strong>虽然默认为字符串</strong>,但作数值计算时自动判断,但可以如下指明类型,同时在双小括号里做c语言的任何符号计算,同时括号内变量可以不需要加$符号(貌似是zsh的一般特性,适用于许多其他场合)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">integer</span> i=123<br><span class=\"hljs-built_in\">float</span> f=12.56<br><span class=\"hljs-comment\">#(t)用于输出变量类型</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(t)i&#125;</span> <span class=\"hljs-comment\">#integer</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(t)f&#125;</span> <span class=\"hljs-comment\">#float</span><br><span class=\"hljs-comment\"># 注意一旦指定了变量类型，类型就不会变了，除非再重新指定其他类型，或者用 unset 删除掉 </span><br><span class=\"hljs-comment\"># 如果把浮点数赋值给整数变量，会取整</span><br>i=12.34<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span> <span class=\"hljs-comment\">#会输出12</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>数学函数<br>zsh&#x2F;mathfunc模块包含数学函数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">zmodload</span> -i zsh/mathfunc<br><span class=\"hljs-built_in\">echo</span> $((sin(<span class=\"hljs-number\">0</span>)+ceil(<span class=\"hljs-number\">14.4</span>)))<br></code></pre></td></tr></table></figure>\n<strong>函数列表</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数名</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">abs</td>\n<td align=\"center\">取绝对值</td>\n</tr>\n<tr>\n<td align=\"center\">ceil</td>\n<td align=\"center\">向上取整</td>\n</tr>\n<tr>\n<td align=\"center\">floor</td>\n<td align=\"center\">向下取整</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">截断取整</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">转换成浮点数</td>\n</tr>\n<tr>\n<td align=\"center\">sqrt</td>\n<td align=\"center\">开平方</td>\n</tr>\n<tr>\n<td align=\"center\">cbrt</td>\n<td align=\"center\">开立方</td>\n</tr>\n<tr>\n<td align=\"center\">log</td>\n<td align=\"center\">自然对数</td>\n</tr>\n<tr>\n<td align=\"center\">log10</td>\n<td align=\"center\">常用对数</td>\n</tr>\n<tr>\n<td align=\"center\">rand48</td>\n<td align=\"center\">随机数</td>\n</tr>\n</tbody></table>\n<p>还有:acos、acosh、asin、asinh、atan、atanh、cos、cosh、erf、erfc、exp、 expm1、fabs、gamma、j0、j1、lgamma、log1p、logb、sin、sinh、tan、 tanh、y0、y1、ilogb、signgam、copysign、fmod、hypot、nextafter、jn、 yn、ldexp、scalb</p>\n<h3 id=\"变量修饰语\"><a href=\"#变量修饰语\" class=\"headerlink\" title=\"变量修饰语\"></a>变量修饰语</h3><p><strong>一般两种格式:</strong></p>\n<ul>\n<li><code>$&#123;(x)var&#125;</code> var是变量名,x是一个或多个字母,</li>\n<li><code>$&#123;var:x&#125;</code> var是变量名,x是一个或多个字母,或其他符号</li>\n</ul>\n<p><strong>注意:加了修饰语的变量依然是变量,可以当普通变量处理,可以嵌套使用,$符号后不可以有空格</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"center\">举例</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">:-</td>\n<td align=\"center\"><code>echo $&#123;var:-abc&#125;</code></td>\n<td align=\"center\">如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\"><code>echo $&#123;var-abc&#125;</code></td>\n<td align=\"center\">如果变量有值,则输出原值,如果变量不存在,则输出abc</td>\n</tr>\n<tr>\n<td align=\"center\">:&#x3D;</td>\n<td align=\"center\"><code>echo $&#123;var:=abc&#125;</code></td>\n<td align=\"center\">如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc并且赋值给var</td>\n</tr>\n<tr>\n<td align=\"center\">::&#x3D;</td>\n<td align=\"center\"><code>echo $&#123;var::=123&#125;</code></td>\n<td align=\"center\">不管有没有值，村不存在，都输出123，并且重新赋值</td>\n</tr>\n<tr>\n<td align=\"center\">:?</td>\n<td align=\"center\"><code>echo $&#123;var:?error&#125;</code></td>\n<td align=\"center\">var没有值或不存在,则直接报错,否则输出原值</td>\n</tr>\n<tr>\n<td align=\"center\">:+</td>\n<td align=\"center\"><code>echo $&#123;var:+123&#125;</code></td>\n<td align=\"center\">如果var有值,则输出123,否则输出空</td>\n</tr>\n<tr>\n<td align=\"center\">(F)</td>\n<td align=\"center\"><code>echo $&#123;(F)array&#125;</code></td>\n<td align=\"center\">把数组中的元素以换行符拼接成字符串,不加任何修饰的话则是空格拼接</td>\n</tr>\n<tr>\n<td align=\"center\">(j&#x2F;x&#x2F;)</td>\n<td align=\"center\"><code>echo $&#123;(j/-=/)array&#125;</code></td>\n<td align=\"center\">把数组中的元素以-&#x3D;两个字符连接</td>\n</tr>\n<tr>\n<td align=\"center\">(s&#x2F;x&#x2F;)</td>\n<td align=\"center\"><code>echo $&#123;(s/==/)str&#125;</code></td>\n<td align=\"center\">把字符串中的字符以&#x3D;&#x3D;两个字符为分隔符分成数组</td>\n</tr>\n<tr>\n<td align=\"center\">(t)</td>\n<td align=\"center\"><code>echo $&#123;(t)var&#125;</code></td>\n<td align=\"center\">输出变量的类型:integer float scalar array association</td>\n</tr>\n<tr>\n<td align=\"center\"><code>(P)</code></td>\n<td align=\"center\"><code>var=abc abc=123 echo $&#123;(P)var&#125;</code></td>\n<td align=\"center\">多重替换,输出123</td>\n</tr>\n<tr>\n<td align=\"center\">[#n]</td>\n<td align=\"center\"><code>echo $(([#16] 255))</code></td>\n<td align=\"center\">以n进制显示十进制整数</td>\n</tr>\n<tr>\n<td align=\"center\">n#</td>\n<td align=\"center\"><code>echo $((16#ff))</code></td>\n<td align=\"center\">显示n进制整数为十进制</td>\n</tr>\n</tbody></table>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>与bash基本一致,增加了<code>unfunction fun</code>删除某个函数的功能,还有就是规避了<code>$*</code>和<code>$@</code>的区别,zsh推荐只用<code>$*</code></p>\n<h3 id=\"替代find和ls\"><a href=\"#替代find和ls\" class=\"headerlink\" title=\"替代find和ls\"></a>替代find和ls</h3><p>需要开启扩展通配符:setopt EXTENDED_GLOB<br><strong>通配符修饰语列表</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">使用样例或补充说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;</td>\n<td align=\"center\">目录</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">F</td>\n<td align=\"center\">非空</td>\n<td align=\"center\">&#x2F;F(非空目录) &#x2F;^F(空目录)</td>\n</tr>\n<tr>\n<td align=\"center\">.</td>\n<td align=\"center\">普通文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">@</td>\n<td align=\"center\">符号链接</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;</td>\n<td align=\"center\">socket文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">p</td>\n<td align=\"center\">FIFO 文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">*</td>\n<td align=\"center\">可执行的普通文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">%</td>\n<td align=\"center\">设备文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">%b</td>\n<td align=\"center\">块设备文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">%c</td>\n<td align=\"center\">字符设备文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">r</td>\n<td align=\"center\">文件拥有着有读权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">w</td>\n<td align=\"center\">文件拥有着有写权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">x</td>\n<td align=\"center\">文件拥有着有执行权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\">文件拥有组用户有读权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">I</td>\n<td align=\"center\">文件拥有组用户有写权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">E</td>\n<td align=\"center\">文件拥有组用户有执行权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">R</td>\n<td align=\"center\">任何用户都有读权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">W</td>\n<td align=\"center\">任何用户都有写权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">X</td>\n<td align=\"center\">任何用户都有执行权限</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">s</td>\n<td align=\"center\">设置了setuid的文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">S</td>\n<td align=\"center\">设置了setgid的文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">设置了粘滞位（sticky bit）的文件</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">符合指定的权限</td>\n<td align=\"center\">f0644 f4755 f700</td>\n</tr>\n<tr>\n<td align=\"center\">e</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">大于某个数</td>\n<td align=\"center\">通常跟数字,与其他配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">指定设备号</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">l</td>\n<td align=\"center\">硬连接个数</td>\n<td align=\"center\">l-2（小于 2） l+3（大于 3）</td>\n</tr>\n<tr>\n<td align=\"center\">U</td>\n<td align=\"center\">当前用户拥有</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">G</td>\n<td align=\"center\">当前用户所在组拥有</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">u</td>\n<td align=\"center\">指定用户 id 拥有</td>\n<td align=\"center\">u1000</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td align=\"center\">指定用户组 id 拥有</td>\n<td align=\"center\">g1000</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"center\">指定文件的 atime</td>\n<td align=\"center\">访问时间,默认单位是天,可跟单位M(月)、w(周)、h(小时)、m(分钟)、s(秒)、+(指定时间之前)、-(指定时间之内)</td>\n</tr>\n<tr>\n<td align=\"center\">m</td>\n<td align=\"center\">指定文件的 mtime</td>\n<td align=\"center\">修改时间,可跟单位、+-,<code>print -l *(.mm+1)</code></td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">指定文件的 ctime</td>\n<td align=\"center\">文件状态属性修改时间,可跟单位、+-,<code>print -l *(.cm+1)</code></td>\n</tr>\n<tr>\n<td align=\"center\">L</td>\n<td align=\"center\">指定文件大小</td>\n<td align=\"center\">默认单位是字节,单位有k、m和p(512字节的块),也可以大写,<code>print -l *(.Lm-1)</code></td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td align=\"center\">取反</td>\n<td align=\"center\">&#x2F;^F</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">小于某个数</td>\n<td align=\"center\">通常跟数字,与其他配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">M</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n<tr>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n<tr>\n<td align=\"center\">N</td>\n<td align=\"center\">如果没匹配到，返回空而不报错</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">D</td>\n<td align=\"center\">包含隐藏文件（. 开头）</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">n</td>\n<td align=\"center\">按数值大小排序</td>\n<td align=\"center\">下文有说明</td>\n</tr>\n<tr>\n<td align=\"center\">o</td>\n<td align=\"center\">递增排序</td>\n<td align=\"center\">下文有说明</td>\n</tr>\n<tr>\n<td align=\"center\">O</td>\n<td align=\"center\">递减排序</td>\n<td align=\"center\">下文有说明</td>\n</tr>\n<tr>\n<td align=\"center\">[n]</td>\n<td align=\"center\">只取第 n 个文件</td>\n<td align=\"center\">.[5]</td>\n</tr>\n<tr>\n<td align=\"center\">[n1,n2]</td>\n<td align=\"center\">取第 n1 到 n2 个文件</td>\n<td align=\"center\">&#x2F;[5,10]</td>\n</tr>\n<tr>\n<td align=\"center\">:X</td>\n<td align=\"center\"></td>\n<td align=\"center\">暂无</td>\n</tr>\n</tbody></table>\n<ol>\n<li>文件排序</li>\n</ol>\n<p>可供排序的因子:n(文件名),L(大小),I(硬连接数),a(atime),m(mtime),c(ctime),d(所在目录深度,从深到浅)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 按文件名排序，同一目录下的文件和目录名会一起排，而不是先排目录再排文件</span><br><span class=\"hljs-comment\">#**/*,指当前目录和子目录</span><br><span class=\"hljs-built_in\">print</span> -l **/*(.on)<br>bb.txt<br>cc/aa.txt<br>cc/dd.txt<br>zz.txt<br><br><span class=\"hljs-comment\"># 按文件的目录深度逆序排，d 是从深往浅排，O 是逆序</span><br><span class=\"hljs-built_in\">print</span> -l **/*(.Od)<br>zz.txt<br>bb.txt<br>cc/dd.txt<br>cc/aa.txt<br><br><span class=\"hljs-comment\"># 先按文件名排序，然后再按大小排序，这样大小相同的文件依然是按文件名排的</span><br><span class=\"hljs-built_in\">print</span> -l **/*(.onoL)<br>bb.txt<br>cc/aa.txt<br>cc/dd.txt<br>cc.txt<br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>组合使用</p>\n<p> 类型和类型之间要用逗号个开,逗号前后内容互不干扰(取反^只影响到逗号之前的内容)</p>\n<p> <code>print -l *(/m-2,.Lm-3oL,@D)</code></p>\n</li>\n<li><p>批量重命名zmv</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用前需要先加载进来</span><br><span class=\"hljs-built_in\">autoload</span> -U zmv<br><br><span class=\"hljs-comment\"># 将所有 txt 文件扩展名改成 conf</span><br><span class=\"hljs-comment\"># 参数要用单引号扩起来，$1 代表第一个参数中括号中的内容</span><br> zmv <span class=\"hljs-string\">&#x27;(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$1.conf&#x27;</span><br><br><span class=\"hljs-comment\"># 如果加了 -W 参数，zmv 会自动识别文件名中需要保留的部分</span><br> zmv -W <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> <span class=\"hljs-string\">&#x27;*.conf&#x27;</span><br><br><span class=\"hljs-comment\"># 调整文件名各部分的前后顺序</span><br>zmv <span class=\"hljs-string\">&#x27;(*).(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$2.$1.txt&#x27;</span><br><span class=\"hljs-comment\"># 加 -n 预览而不实际运行</span><br>zmv -n <span class=\"hljs-string\">&#x27;(*).(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$2.$1.txt&#x27;</span><br><span class=\"hljs-built_in\">mv</span> -- a.b.txt b.a.txt<br><br><span class=\"hljs-comment\"># 0 1 2 ... 前添加 0，以便和 10 11 12 ... 宽度一致</span><br>zmv <span class=\"hljs-string\">&#x27;([0-9]).(*)&#x27;</span> <span class=\"hljs-string\">&#x27;0$1.$2&#x27;</span><br><span class=\"hljs-comment\"># 去掉开头的一个 0</span><br>zmv <span class=\"hljs-string\">&#x27;(0)(*)&#x27;</span> <span class=\"hljs-string\">&#x27;$2&#x27;</span><br><br><span class=\"hljs-comment\"># 文件整理到目录</span><br>zmv <span class=\"hljs-string\">&#x27;(*) - (*) - (*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$1/$2 - $3.txt&#x27;</span><br><br><span class=\"hljs-comment\"># 转换大小写</span><br>zmv <span class=\"hljs-string\">&#x27;(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$&#123;(U)1&#125;.txt&#x27;</span><br>zmv <span class=\"hljs-string\">&#x27;(*).txt&#x27;</span> <span class=\"hljs-string\">&#x27;$&#123;(L)1&#125;.txt&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>不展开通配符</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-function\"><span class=\"hljs-title\">calc</span></span>() &#123;<br>    <span class=\"hljs-built_in\">zmodload</span> zsh/mathfunc<br>    <span class=\"hljs-built_in\">echo</span> $(($*))<br>&#125;<br>calc 12+12<br>calc 12*12 <span class=\"hljs-comment\">#会报错</span><br><span class=\"hljs-built_in\">noglob</span> calc 12*12 <span class=\"hljs-comment\">#可以</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"local和typeset\"><a href=\"#local和typeset\" class=\"headerlink\" title=\"local和typeset\"></a>local和typeset</h3><p>local和typeset基本一样(除了不能用-f和-g这两个选项)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">强制字符串内容为小写</td>\n<td align=\"center\"><code>local -l str=abcABC</code></td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">强制字符串内容为大写</td>\n<td align=\"center\"><code>local -u str=abcABC</code></td>\n</tr>\n<tr>\n<td align=\"center\">-x</td>\n<td align=\"center\">设置为环境变量</td>\n<td align=\"center\"><code>export str=abc</code>等价于<code>local -x str=abc</code></td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">只读</td>\n<td align=\"center\"><code>local -r strl=abc</code>等价于<code>readonly str1=abc</code></td>\n</tr>\n<tr>\n<td align=\"center\">-U</td>\n<td align=\"center\">设置数组不包含重复元素</td>\n<td align=\"center\"><code>local -U array=(aa bb aa cc)</code></td>\n</tr>\n<tr>\n<td align=\"center\">-Z n</td>\n<td align=\"center\">设置整数位数</td>\n<td align=\"center\">不够用0不全,超过会被截断</td>\n</tr>\n<tr>\n<td align=\"center\">-i n</td>\n<td align=\"center\">设置整数为其他进制显示</td>\n<td align=\"center\">支持2-36</td>\n</tr>\n<tr>\n<td align=\"center\"><code>local &#123;i,j,k&#125;=123</code></td>\n<td align=\"center\">赋值多个变量为同一个值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">-T</td>\n<td align=\"center\">绑定字符串和数组</td>\n<td align=\"center\"><code>local -T DIR dir</code>,DIR为字符串,dir为数组,以冒号连接,主要用于path变量</td>\n</tr>\n<tr>\n<td align=\"center\">-p</td>\n<td align=\"center\">显示变量的定义方式</td>\n<td align=\"center\">显示脚本如何定义该变量的</td>\n</tr>\n</tbody></table>\n<h3 id=\"双引号问题\"><a href=\"#双引号问题\" class=\"headerlink\" title=\"双引号问题\"></a>双引号问题</h3><p>zsh不需要像bash那样频繁加双引号来避免错误。<br>zsh需要加双引号的场景:</p>\n<ol>\n<li>像这样的包含字符或者特殊符号的字符串 <code>&quot;aa bb \\t \\n *&quot;</code> 出现在代码中时，两边要加双引号</li>\n<li>在用<code>$()</code>调用命令时，如果希望结果按一个字符串处理，需要加上双引</li>\n<li>如果想将数组当单个字符串处理，需要加双引号，<code>array=(a b); print -l &quot;$array&quot;</code></li>\n<li>其他的原本不是单个字符串的东西，需要转成单个字符串的场景，要加双引号</li>\n</ol>\n<p>其余通常不加,其中典型场景:</p>\n<ol>\n<li>任何情况下，字符串变量的两边都不需要加双引号，无论里边的内容多么特殊，或者变量存不存在，都没有关系，如<code>$str</code></li>\n<li>如果不转换类型（比如数组转成字符串），任何变量的两边都不需要加双引号</li>\n<li><code>$1 $2 $*</code>这些参数（其实它们也都是单个字符串），都不需要加双引号，无论内容是什么，或者参数是否存在。</li>\n</ol>\n<h3 id=\"mapfile读写文件\"><a href=\"#mapfile读写文件\" class=\"headerlink\" title=\"mapfile读写文件\"></a>mapfile读写文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">zmodload</span> zsh/mapfile<br><br><span class=\"hljs-comment\"># 这样就可以创建文件并写入内容，如果文件存在则会被覆盖</span><br><span class=\"hljs-built_in\">mapfile</span>[test.txt]=<span class=\"hljs-string\">&quot;ab cd&quot;</span><br><span class=\"hljs-built_in\">cat</span> test.txt<br><span class=\"hljs-comment\">#ab cd</span><br><br><span class=\"hljs-comment\"># 判断文件是否存在</span><br>(($+mapfile[test.txt])) &amp;&amp; <span class=\"hljs-built_in\">echo</span> good<br><span class=\"hljs-comment\">#good</span><br><br><span class=\"hljs-comment\"># 读取文件</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$mapfile</span>[test.txt]<br><span class=\"hljs-comment\">#ab cd</span><br><br><span class=\"hljs-comment\"># 删除文件</span><br><span class=\"hljs-built_in\">unset</span> <span class=\"hljs-string\">&quot;mapfile[test.txt]&quot;</span><br><br><span class=\"hljs-comment\"># 遍历文件</span><br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$&#123;(k)mapfile&#125;</span>) &#123;<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-comment\">#test1.txt</span><br><span class=\"hljs-comment\">#test2.txt</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">while</span> [some condition]&#123;<br>\t<span class=\"hljs-built_in\">break</span>/continue<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">until [some condition]&#123;<br>\t<span class=\"hljs-keyword\">break</span>/<span class=\"hljs-keyword\">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#样例</span><br><span class=\"hljs-keyword\">for</span> i (aa bb cc)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br>array=(aa bb cc)<br><span class=\"hljs-keyword\">for</span> i (<span class=\"hljs-variable\">$array</span>) &#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-keyword\">for</span> ((i=<span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++))&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br><span class=\"hljs-keyword\">for</span> i (&#123;1..10&#125;)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">repeat</span> <span class=\"hljs-number\">5</span>&#123;<br>\t<span class=\"hljs-attribute\">echo</span> good<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"分支语句\"><a href=\"#分支语句\" class=\"headerlink\" title=\"分支语句\"></a>分支语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">case</span> <span class=\"hljs-variable\">$i</span> &#123;<br>\t(a)<br>\t<span class=\"hljs-built_in\">echo</span> 1<br>\t;;<br><br>\t(b)<br>\t<span class=\"hljs-built_in\">echo</span> 2<br>\t<span class=\"hljs-comment\">#继续执行下一个匹配的语句(不再进行匹配)</span><br>\t;&amp;<br><br>\t(c)<br>\t<span class=\"hljs-built_in\">echo</span> 3<br>\t<span class=\"hljs-comment\">#继续向下匹配，看是否有满足条件的分支</span><br>\t;|<br><br>\t(c)<br>\t<span class=\"hljs-built_in\">echo</span> 33<br>\t;;<br><br>\t(*)<br>\t<span class=\"hljs-built_in\">echo</span> oher<br>\t;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"用户输入选择语句\"><a href=\"#用户输入选择语句\" class=\"headerlink\" title=\"用户输入选择语句\"></a>用户输入选择语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">select</span> i (aa bb cc)&#123;<br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>必须加break,否则会一直让用户选择</p>\n<h3 id=\"异常处理语句\"><a href=\"#异常处理语句\" class=\"headerlink\" title=\"异常处理语句\"></a>异常处理语句</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>\t语句1<br>&#125; always&#123;<br>\t语句2<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>无论语句1是否出错,都执行语句2</p>\n<h3 id=\"socket模块\"><a href=\"#socket模块\" class=\"headerlink\" title=\"socket模块\"></a>socket模块</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 监听连接端=======</span><br><span class=\"hljs-comment\"># 首先要加载 socket 模块</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/socket<br><br><span class=\"hljs-built_in\">zsocket</span> -l test.sock<br>listenfd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\"># 此处阻塞等待连接</span><br><span class=\"hljs-built_in\">zsocket</span> -a <span class=\"hljs-variable\">$listenfd</span><br><span class=\"hljs-comment\"># 连接建立完成</span><br>fd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\"># 然后 $fd 就可读可写</span><br><span class=\"hljs-built_in\">cat</span> &lt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 发起连接端==========</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/socket<br><span class=\"hljs-built_in\">zsocket</span> test.sock<br>fd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-built_in\">echo</span> good &gt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 关闭监听端========</span><br><span class=\"hljs-built_in\">exec</span> &#123;listenfd&#125;&gt;&amp;-<br><span class=\"hljs-built_in\">exec</span> &#123;fd&#125;&gt;&amp;-<br><span class=\"hljs-built_in\">rm</span> test.sock<br><br><span class=\"hljs-comment\"># 关闭连接端======</span><br><span class=\"hljs-built_in\">exec</span> &#123;fd&#125;&gt;&amp;-<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"TCP模块\"><a href=\"#TCP模块\" class=\"headerlink\" title=\"TCP模块\"></a>TCP模块</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 监听连接端=======</span><br><span class=\"hljs-comment\"># 首先要加载 tcp 模块</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br><span class=\"hljs-built_in\">ztcp</span> -l 1234<br>listenfd=<span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\"># 此处阻塞等待连接</span><br><span class=\"hljs-built_in\">ztcp</span> -a <span class=\"hljs-variable\">$listenfd</span><br><span class=\"hljs-comment\"># 连接建立完成</span><br>fd=<span class=\"hljs-variable\">$REPLY</span><br><br><span class=\"hljs-comment\"># 然后 $fd 就可读可写</span><br><span class=\"hljs-built_in\">cat</span> &lt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 发起连接端===========</span><br><span class=\"hljs-comment\"># 首先要加载 tcp 模块</span><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br><span class=\"hljs-built_in\">ztcp</span> 127.0.0.1 1234<br><span class=\"hljs-comment\"># 连接建立完成</span><br>fd=<span class=\"hljs-variable\">$REPLY</span><br><br><span class=\"hljs-comment\"># 然后 $fd 就可读可写</span><br><span class=\"hljs-built_in\">echo</span> good &gt;&amp;<span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 关闭发起连接端===============</span><br><span class=\"hljs-comment\"># fd 是之前存放 fd 号的变量</span><br>% <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br><br><span class=\"hljs-comment\"># 关闭监听连接端=============</span><br>% <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$listenfd</span><br>% <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br></code></pre></td></tr></table></figure>\n<p>接受端例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/zsh</span><br><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br>(($+<span class=\"hljs-number\">1</span>)) || &#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Usage: <span class=\"hljs-variable\">$&#123;0:t&#125;</span> port&quot;</span><br>    <span class=\"hljs-built_in\">exit</span> 1<br>&#125;<br><br><span class=\"hljs-built_in\">ztcp</span> -l <span class=\"hljs-variable\">$1</span><br>listenfd=<span class=\"hljs-variable\">$REPLY</span><br><br>[[ <span class=\"hljs-variable\">$listenfd</span> == &lt;-&gt; ]] || <span class=\"hljs-built_in\">exit</span> 1<br><br><span class=\"hljs-keyword\">while</span> ((<span class=\"hljs-number\">1</span>)) &#123;<br>    <span class=\"hljs-built_in\">ztcp</span> -a <span class=\"hljs-variable\">$listenfd</span><br>    fd=<span class=\"hljs-variable\">$REPLY</span><br>    [[ <span class=\"hljs-variable\">$fd</span> == &lt;-&gt; ]] || <span class=\"hljs-built_in\">continue</span><br><br>    <span class=\"hljs-built_in\">cat</span> &lt;&amp;<span class=\"hljs-variable\">$fd</span><br>    <span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>发送端例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/zsh</span><br><br><span class=\"hljs-built_in\">zmodload</span> zsh/net/tcp<br><br>((<span class=\"hljs-variable\">$#</span> &gt;= <span class=\"hljs-number\">2</span>)) || &#123;<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Usage: <span class=\"hljs-variable\">$&#123;0:t&#125;</span> [hostname] port message&quot;</span><br>    <span class=\"hljs-built_in\">exit</span> 1<br>&#125;<br><br><span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-variable\">$1</span> == &lt;0-65535&gt; ]] &#123;<br>    <span class=\"hljs-built_in\">ztcp</span> 127.0.0.1 <span class=\"hljs-variable\">$1</span><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-built_in\">ztcp</span> <span class=\"hljs-variable\">$1</span> <span class=\"hljs-variable\">$2</span><br>    <span class=\"hljs-built_in\">shift</span><br>&#125;<br><br>fd=<span class=\"hljs-variable\">$REPLY</span><br>[[ <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$fd</span>&quot;</span> == &lt;-&gt; ]] || <span class=\"hljs-built_in\">exit</span> 1<br><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;*[2,-1]&#125;</span> &gt;&amp;<span class=\"hljs-variable\">$fd</span><br><span class=\"hljs-built_in\">ztcp</span> -c <span class=\"hljs-variable\">$fd</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"日期模块-zmodload-zsh-datetime\"><a href=\"#日期模块-zmodload-zsh-datetime\" class=\"headerlink\" title=\"日期模块:zmodload zsh&#x2F;datetime\"></a>日期模块:zmodload zsh&#x2F;datetime</h3><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>echo $EPOCHSECONDS</code></td>\n<td align=\"center\">从光标1970年到现在的秒数,等价于<code>date +%s</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>echo $EPOCHREALTIME</code></td>\n<td align=\"center\">输出高精度当前时间戳</td>\n</tr>\n<tr>\n<td align=\"center\"><code>echo $epochtime</code></td>\n<td align=\"center\">输出当前时间戳的秒和纳秒</td>\n</tr>\n<tr>\n<td align=\"center\"><code>strftime &quot;%Y-%m-%d %H:%M:%S (%u)&quot; $EPOCHSECONDS</code></td>\n<td align=\"center\">按指定格式输出</td>\n</tr>\n<tr>\n<td align=\"center\"><code>strftime -s str &quot;%Y-%m-%d %H:%M:%S (%u)&quot; $EPOCHSECONDS</code></td>\n<td align=\"center\">存到变量str中</td>\n</tr>\n<tr>\n<td align=\"center\"><code>strftime -r &quot;%Y-%m-%d %H:%M:%S (%u)&quot; &quot;2017-09-01 10:10:58 (5)&quot;</code></td>\n<td align=\"center\">上述的反操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"gdbm模块–存在文件里的哈希表\"><a href=\"#gdbm模块–存在文件里的哈希表\" class=\"headerlink\" title=\"gdbm模块–存在文件里的哈希表\"></a>gdbm模块–存在文件里的哈希表</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">% <span class=\"hljs-built_in\">zmodload</span> zsh/db/gdbm<br><br><span class=\"hljs-comment\"># 声明数据库文件对应的哈希表</span><br><span class=\"hljs-built_in\">local</span> -A sampledb<br><span class=\"hljs-comment\"># 创建数据库文件，文件名是 sample.gdbm，对应 sampledb 哈希表</span><br><span class=\"hljs-comment\"># 如果该文件已经存在，则会继续使用该文件</span><br>ztie -d db/gdbm -f sample.gdbm sampledb<br><br><span class=\"hljs-comment\"># 然后正常使用 sampledb 哈希表即可，数据会同步写入到数据库文件中</span><br>sampledb[k1]=v1<br>sampledb+=(k2 v2 k3 v3)<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;(kv)sampledb&#125;</span><br><span class=\"hljs-comment\">#k1 v1 k2 v2 k3 v3</span><br><br><span class=\"hljs-comment\"># 获取数据库文件路径</span><br>% zgdbmpath sampledb<br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$REPLY</span><br><span class=\"hljs-comment\">#/home/goreliu/sample.gdbm</span><br><br><span class=\"hljs-comment\"># 释放数据库文件</span><br>zuntie -u sampledb<br><br><br><span class=\"hljs-comment\"># 也可以用只读的方式加载数据库文件</span><br>ztie -r -d db/gdbm -f sample.gdbm sampledb<br><span class=\"hljs-comment\"># 但这样的话，需要用 zuntie -u 释放数据库文件</span><br>zuntie -u sampledb<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"sched–-计划调度命令\"><a href=\"#sched–-计划调度命令\" class=\"headerlink\" title=\"sched–&gt;计划调度命令\"></a>sched–&gt;计划调度命令</h3><p>zmodload zsh&#x2F;sched</p>\n<ul>\n<li><code>sched +5 ls</code>5秒后运行ls</li>\n<li><code>sched</code>列出已有任务</li>\n<li><code>sched -n</code>去除第n个待运行命令</li>\n</ul>\n<h3 id=\"模块简介\"><a href=\"#模块简介\" class=\"headerlink\" title=\"模块简介\"></a>模块简介</h3><p>可以用man zshmodules查看模块功能</p>\n<ul>\n<li>zsh&#x2F;system:底层文件读写</li>\n<li>zsh&#x2F;pcre:正则表达式库</li>\n<li>zsh&#x2F;stat:内部stat，取代stat</li>\n<li>zsh&#x2F;zftp:内部ftp客户端</li>\n<li>zsh&#x2F;zprof:性能追踪工具</li>\n<li>zsh&#x2F;zpty:操作pty的命令</li>\n<li>zsh&#x2F;zselect:select系统调用的封装</li>\n</ul>\n<h3 id=\"TRAPINT\"><a href=\"#TRAPINT\" class=\"headerlink\" title=\"TRAPINT\"></a>TRAPINT</h3><p>该函数名,捕获任意信号?有待研究,如下的代码竟然捕捉到SIGINT信号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/zsh</span><br><br><span class=\"hljs-comment\"># SIGINT 是 2 信号，ctrl + c 会触发</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">TRAPINT</span></span>() &#123;<br>    <span class=\"hljs-comment\"># 处理一些退出前的善后工作</span><br>    <span class=\"hljs-built_in\">sleep</span> 333<br>&#125;<br><br><span class=\"hljs-built_in\">sleep</span> 1000<br></code></pre></td></tr></table></figure>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><ol>\n<li>统一使用4个空格来缩进</li>\n<li>非特殊场景,每行代码不超过100个字符</li>\n<li>在前一行尾部加一个空格和 \\ 折行，折行后缩进一层（4 个空格）。</li>\n<li>如果缩进的是一个文本块，可以使用对齐缩进，也可以使用 4 个空格的固定缩进。</li>\n<li>如果是在 aa &amp;&amp; bb || cc、[[ ]] 或者 (( )) 中折行，&amp;&amp; || 放在下一行的行首。</li>\n<li>在缩进和对齐之外的场景，不允许出现逻辑上不必要的连续多个空格。</li>\n<li><ul>\n<li>&amp;&amp; | 等双元运算符左右要加一个空格。</li>\n</ul>\n</li>\n<li>! ~等一元运算符和作用对象之间不加空格。</li>\n<li>( ) 和 (( )) { } 内侧不加空格，[[ ]] 因为语法需要，内侧加一个空格。</li>\n<li><code>;</code>之前不加空格，之后加一个空格。</li>\n<li>定义函数时（以及在 (( )) 中调用函数时），函数名和 ( 之间不加空格。</li>\n<li>if while 等关键字和后边的内容之间加一个空格</li>\n<li>if<code>[[ ]] &#123;</code>等场景中，<code>&#123;</code>和前边的内容之间加一个空格。</li>\n<li>变量和<code>[ ]</code>之间不加空格，用<code>[ ]</code>取数组或者哈希表值时，<code>[ ]</code>内侧不加空格。</li>\n<li><code>&gt; &lt;</code>等重定向符号和文件或者文件描述符之间不加空格。</li>\n<li>非特殊场景，不允许出现超过两个连续空行。</li>\n<li>#!&#x2F;bin&#x2F;zsh 后加一个空行。</li>\n<li>if while 等语句块之后加一个空行。</li>\n<li>定义函数后加一个空行。</li>\n<li>逻辑关系不强的两行（或者两块）代码之间，根据逻辑关系强弱（自行判断），加一个或两个空行。</li>\n<li>在判断条件的场景，不使用<code>[ ]</code>，用<code>[[ ]]</code>代替。</li>\n<li>在数值计算的场景，使用<code>$(( ))</code>而不是<code>$[ ]</code>。</li>\n<li>使用数值时，两端不加引号。</li>\n<li>用<code>$var</code>取变量值时，两边不加双引号，除非需要将非字符串变量转换成字符串。</li>\n<li>在非必须场景，不需要加<code>$&#123;var&#125;</code>中的大括号。</li>\n<li>变量使用前要明确指明是局部变量（用 local 定义）还是全局变量（用 typeset -g 定义）。</li>\n<li>能用局部变量的地方全部使用局部变量（用 local 定义）。</li>\n<li>变量名中的单词可以使用下划线分隔或者驼峰风格，在不影响可读性的情况也可以使用全小写字母，但在同一个文件中要一致。</li>\n<li>字符串常量两端可以添加双引号或者单引号，但同一个文件中风格要一致。</li>\n<li>可以使用 name() 或者 function name() 定义函数，但同一个文件中风格要一致。</li>\n<li>非特殊场景，单个脚本文件不超过 1000 行。</li>\n</ol>\n<h3 id=\"bash和zsh的简明对比\"><a href=\"#bash和zsh的简明对比\" class=\"headerlink\" title=\"bash和zsh的简明对比\"></a>bash和zsh的简明对比</h3><table>\n<thead>\n<tr>\n<th align=\"center\">bash</th>\n<th align=\"center\">zsh</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&quot;$var&quot;</code></td>\n<td align=\"center\"><code>$var</code></td>\n<td align=\"center\">避免变量中有空格导致异常</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&quot;$@&quot;</code></td>\n<td align=\"center\"><code>$*</code></td>\n<td align=\"center\">避免变量中有空格导致异常</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&quot;$&#123;array[@]&#125;&quot;</code></td>\n<td align=\"center\"><code>$array</code></td>\n<td align=\"center\">取数组所有元素，@ 可改成 *</td>\n</tr>\n<tr>\n<td align=\"center\">&#96;”$</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n"},{"title":"vi及vim","date":"2019-07-18T08:53:33.000Z","subtitle":null,"index_img":"/images/vim.png","banner_img":"/images/vim.png","_content":"1.  \nvi:\n  a.命令模式替换:%s/xx/xx/gc,s代表替换,g代表一行多次匹配,c表示确认。\n  b.在每行尾部加相同内容技巧:进入列模式(ctrl+v)，按‘G’选中每一行，按‘$’延伸至行尾，再按‘A’添加内容\n2.  \nsed与awk的命令格式: command [options] script filename\n3.  \nawk默认模式为所有行，默认操作打印。\n4.  \n实心句点”.“表示当前行\n5.  \n$表示最后一行\n6.  \nctrl+g显示当前文件名\nctrl+s锁住\nctrl+q解锁\n7.  \n一般模式中，\">\"\"&lt;\"为缩进层级\n8.  \nctrl+a会把当前或之后数字加1，若要一次加10则按10ctrl+a,而ctrl+x则是减\n9.  \nguu使当前行都变成小写，gUU使当前行都变成大写，g~则反转大小写\n10.  \n一般模式下按下yt，再按你想要复制内容的后一个词，之后再在插入模式里按ctrl+r+0或ctrl+r+ctrl+p+0，就完成粘贴\n11.  \n在插入模式中按下ctrl+r+=进入计算模式完成后回车完成结果输入。\n12.  \n在插入模式中可以根据字符编码进行输入字符,汇总如下:\n\n|按键操作|用途|\n|:-:|:-:|\n|ctrl+v{123}|以十进制字符编码插入字符|\n|ctrl+v+u{1234}|以十六进制字符编码插入字符|\n|ctrl+k{char1}{char2}|插入以二合字母表示的字符|\n\n　　可以在命令模式中输入:h digraph-table，来查看二合字母\n　　一般模式中，在字符上面输入ga可查看其十进制及十六进制编码\n13.  \ngv重新选上次的高亮区\n14.  \no在可视模式中切换高亮区的活动端\n15.  \n命令模式中%代表全部行\n16.  \n可以进入行可视模式，选中对应行，然后进入命令模式进行操作\n17.  \n命令模式中t为copy命令的简写\n18.  \n在命令模式中执行普通模式下的命令可以用normal，如:\n`:%normal A;`\n就是在每行后加;\n19.  \n一般模式下按\\*可以查找当前光标下的单词\n20.  \n可以在命令模式中执行shell命令，只要在命令前加!,这只适合执行一次\n21.  \n当执行多次命令时，可以在命令模式中输入shell，要想返回vi可以在shell中输入exit\n22.  \nread,与write命令可以与shell命令结合使用,read把shell命令的标准输出读入缓冲区，write则是把缓冲区当做shell命令的标准输入\n23.  \n可以用source脚本文件执行一系列的命令\n24.  \n可以在一般模式中输入ctrl+w+v竖着分隔同一文件\n25.  \ngj、gk等是在屏幕行上的移动\n26.  \n文本对象与选择区域\n\n|文本对象|选择区域|文本对象|选择区域|\n|:-:|:-:|:-:|:-:|\n|iw|当前单词|aw|当前单词及空格|\n|iW|当前字串|aw|当前字串及空格|\n|is|当前句子|as|当前句子及空格|\n|ip|当前段落|ap|当前段落及空格|\n|ab|当前的圆括号|ib|当前圆括号的内部|\n|aB|当前的花括号|iB|当前花括号内部|\n|a]|当前的方括号|i]|当前方括号的内部|\n|a>|当前尖括号|i>|当前尖括号的内部|\n|a'|...|...|...|\n|a\"|...|...|...|\n|at|xml标签|...|...|\n\n27.  \nm{a-zA-Z},标记位置，\\`{mark}跳转到对应位置,\\`\\`上次跳转动作之前的位置,经常配合使用\n28.  \nctrl+o也可以跳转到上次的位置\n29.  \n%命令可以在一对任意括号上进行跳转\n30.  \n`\"add`指的是剪切一整行到a寄存器,`\"ap`则粘贴a寄存器里的内容\n31.  \n寄存器列表\n\n|名称|含义|\n|:-:|:-:|\n|\"\"|无名寄存器|\n|\"0|复制专用寄存器|\n|\"(a-z)|自定义寄存器|\n|\"\\_|黑洞寄存器|  \n  \n　　在插入模式下可以用ctrl+r+上寄存器名来粘贴，此时没有\"号\n32.  \n宏录制的过程，q{register}录制开始->q录制结束->@{register}执行宏动作,还可以指定次数\n33.  \n命令模式:reg {register}可以查看寄存器内容\n34.  \n要想不覆盖寄存器内容，可以q{register}，register名字必须为大写(如qa->qA)，这样就追加了，否则是覆盖重新录制,\n35.  \n一般模式下ctrl+b向前翻页\n一般模式下ctrl+f向后翻页\n36.\ndG会删除光标之后的所有内容\n37.\nH,M,L,分别是移动到屏幕行的顶,中,尾\n38.\n按键映射\n\n|递归|非递归|模式|\n|:-:|:-:|:-:|\n|:map|:noremap|normal,visual,operator-pending|\n|:nmap|:nnoremap|normal|\n|:xmap|:xnoremap|visual|\n|:cmap|:cnoremap|command-line|\n|:omap|:onoremap|operator-pending|\n|:imap|:inoremap|insert|\n39.\n在.vim/bundle/YouCompleteMe/.ycm_extra_conf.py配置c++20\n# 打造IDE\n## 单文件运行\n- 插件:skywind3000/asynctasks.vim,skywind3000/asyncrun.vim\n- 链接:[asyncrun](https://github.com/skywind3000/asyncrun.vim),[asynctasks](https://github.com/skywind3000/asynctasks.vim)\n\n|快捷键|作用|\n|:-:|:-:|\n|`F7`|编译并运行文件，这会打开一个运行shell的窗口|\n|`Ctrl+d`|关闭shell窗口|\n|`Ctrl+t`|隐藏/显示shell窗口|\n|`Ctrl+\\Ctrl+n`|把shell窗口的所有文字进入编辑模式，这样就能像操作文本一样操作该窗口(只读窗口)|\n|`Ctrl+w+\"\"`|前提先用y命令复制文本，然后进入shell窗口，按此快捷键就会粘贴|\n\n## NerdTree\n- 插件:'preservim/nerdtree'\n- 链接:[NerdTree](https://github.com/preservim/nerdtree)\n\n|快捷键|作用|\n|:-:|:-:|\n|`,nn`|打开nerdTree|\n\n## 对齐线\n- 插件:'nathanaelkane/vim-indent-guides'\n- 链接:[vim-indent-guides](https://github.com/preservim/vim-indent-guides)\n\n|快捷键|作用|\n|`,ig`|使用对齐线|\n\n## 成对元素\n- 插件:'tpope/vim-surround'\n- 链接:[vim-surround](https://github.com/tpope/vim-surround)\n\n|快捷键|作用|\n|:-:|:-:|\n|`cs\"'`|在一个有`\"`元素包围的字段上，更改`\"`为`'`|\n|`ds\"`|在一个有`\"`元素包围的字段上，删除`\"`|\n|`ysiw]`|用中括号包围一个单词|\n|`yss)]`|一行加括号|\n|`S<p class=\"important\">`|V选中一行,然后输入，会包围该行|\n\n- 左括号会有空格\n- b可以代表作括号，B代表左花括号\n\n## 快速查找文件\n- 插件:'kien/ctrlp.vim'\n- 链接:[ctrlp](https://github.com/ctrlpvim/ctrlp.vim?tab=readme-ov-file)\n\n|快捷键|作用|\n|:-:|:-:|\n|`,j`|快速查找磁盘文件|\n|`,b`|快速查找缓冲区文件|\n\n## 多行模式(有待研究)\n- 插件:'mq979/vim-visual-multi'\n- 链接:[vim-visual-multi](https://github.com/mg979/vim-visual-multi)\n\n|快捷键|作用|\n|:-:|:-:|\n|`Ctrl+Down/Up`|插入光标进入cursor mode等价于normal mode,Tab键可以切换到extend mode|\n|`Ctrl+n`|选中一个单词进入extend mode等价于visual mode,Tab键可以切换到cursor mode|\n|`Ctrl+Arrows`|选中字符|\n|`Q`|放弃当前的选中|\n\n## 注释\n- 插件:'tpope/vim-commentary'\n- 链接:[vim-commentary](https://github.com/tpope/vim-commentary)\n\n|快捷键|作用|\n|:-:|:-:|\n|`gcc`|快速注释一行|\n|`gcap`|注释一段|\n|`:7,17Commentary`|注释7,17行|\n|`:g/TODO/Commentary`|注释含有TODO行|\n\n## 快速ack(grep)\n- 插件:`mileszs/ack.vim`\n- 链接:[ack](https://github.com/mileszs/ack.vim?tab=readme-ov-file)\n- 前提:需要安装ack，他是高级版的grep\n\n## 其他\n\n|快捷键|作用|插件|\n|:-:|:-:|:-:|\n|`,sf`|列出当前文件所有函数|Plug 'Yggdroot/LeaderF', { 'do': ':LeaderfInstallCExtension' }|\n|`,o`|查看缓冲区列表|jlanzarotta/bufexplorer|\n|`,bd`|关闭当前缓冲区|jlanzarotta/bufexplorer|\n|`,ba`|关闭所有缓冲区|jlanzarotta/bufexplorer|\n|`,bl`|切换缓冲区|jlanzarotta/bufexplorer|\n|`,bh`|切换缓冲区|jlanzarotta/bufexplorer|\n|`+/_`|智能扩展选中区域|terryma/vim-expand-region|\n","source":"_posts/vi及vim.md","raw":"---\ntitle: 'vi及vim'\ndate: 2019-07-18 16:53:33\nsubtitle:\ncategories: 文本处理\ntags: 命令\nindex_img: /images/vim.png\nbanner_img: /images/vim.png\n---\n1.  \nvi:\n  a.命令模式替换:%s/xx/xx/gc,s代表替换,g代表一行多次匹配,c表示确认。\n  b.在每行尾部加相同内容技巧:进入列模式(ctrl+v)，按‘G’选中每一行，按‘$’延伸至行尾，再按‘A’添加内容\n2.  \nsed与awk的命令格式: command [options] script filename\n3.  \nawk默认模式为所有行，默认操作打印。\n4.  \n实心句点”.“表示当前行\n5.  \n$表示最后一行\n6.  \nctrl+g显示当前文件名\nctrl+s锁住\nctrl+q解锁\n7.  \n一般模式中，\">\"\"&lt;\"为缩进层级\n8.  \nctrl+a会把当前或之后数字加1，若要一次加10则按10ctrl+a,而ctrl+x则是减\n9.  \nguu使当前行都变成小写，gUU使当前行都变成大写，g~则反转大小写\n10.  \n一般模式下按下yt，再按你想要复制内容的后一个词，之后再在插入模式里按ctrl+r+0或ctrl+r+ctrl+p+0，就完成粘贴\n11.  \n在插入模式中按下ctrl+r+=进入计算模式完成后回车完成结果输入。\n12.  \n在插入模式中可以根据字符编码进行输入字符,汇总如下:\n\n|按键操作|用途|\n|:-:|:-:|\n|ctrl+v{123}|以十进制字符编码插入字符|\n|ctrl+v+u{1234}|以十六进制字符编码插入字符|\n|ctrl+k{char1}{char2}|插入以二合字母表示的字符|\n\n　　可以在命令模式中输入:h digraph-table，来查看二合字母\n　　一般模式中，在字符上面输入ga可查看其十进制及十六进制编码\n13.  \ngv重新选上次的高亮区\n14.  \no在可视模式中切换高亮区的活动端\n15.  \n命令模式中%代表全部行\n16.  \n可以进入行可视模式，选中对应行，然后进入命令模式进行操作\n17.  \n命令模式中t为copy命令的简写\n18.  \n在命令模式中执行普通模式下的命令可以用normal，如:\n`:%normal A;`\n就是在每行后加;\n19.  \n一般模式下按\\*可以查找当前光标下的单词\n20.  \n可以在命令模式中执行shell命令，只要在命令前加!,这只适合执行一次\n21.  \n当执行多次命令时，可以在命令模式中输入shell，要想返回vi可以在shell中输入exit\n22.  \nread,与write命令可以与shell命令结合使用,read把shell命令的标准输出读入缓冲区，write则是把缓冲区当做shell命令的标准输入\n23.  \n可以用source脚本文件执行一系列的命令\n24.  \n可以在一般模式中输入ctrl+w+v竖着分隔同一文件\n25.  \ngj、gk等是在屏幕行上的移动\n26.  \n文本对象与选择区域\n\n|文本对象|选择区域|文本对象|选择区域|\n|:-:|:-:|:-:|:-:|\n|iw|当前单词|aw|当前单词及空格|\n|iW|当前字串|aw|当前字串及空格|\n|is|当前句子|as|当前句子及空格|\n|ip|当前段落|ap|当前段落及空格|\n|ab|当前的圆括号|ib|当前圆括号的内部|\n|aB|当前的花括号|iB|当前花括号内部|\n|a]|当前的方括号|i]|当前方括号的内部|\n|a>|当前尖括号|i>|当前尖括号的内部|\n|a'|...|...|...|\n|a\"|...|...|...|\n|at|xml标签|...|...|\n\n27.  \nm{a-zA-Z},标记位置，\\`{mark}跳转到对应位置,\\`\\`上次跳转动作之前的位置,经常配合使用\n28.  \nctrl+o也可以跳转到上次的位置\n29.  \n%命令可以在一对任意括号上进行跳转\n30.  \n`\"add`指的是剪切一整行到a寄存器,`\"ap`则粘贴a寄存器里的内容\n31.  \n寄存器列表\n\n|名称|含义|\n|:-:|:-:|\n|\"\"|无名寄存器|\n|\"0|复制专用寄存器|\n|\"(a-z)|自定义寄存器|\n|\"\\_|黑洞寄存器|  \n  \n　　在插入模式下可以用ctrl+r+上寄存器名来粘贴，此时没有\"号\n32.  \n宏录制的过程，q{register}录制开始->q录制结束->@{register}执行宏动作,还可以指定次数\n33.  \n命令模式:reg {register}可以查看寄存器内容\n34.  \n要想不覆盖寄存器内容，可以q{register}，register名字必须为大写(如qa->qA)，这样就追加了，否则是覆盖重新录制,\n35.  \n一般模式下ctrl+b向前翻页\n一般模式下ctrl+f向后翻页\n36.\ndG会删除光标之后的所有内容\n37.\nH,M,L,分别是移动到屏幕行的顶,中,尾\n38.\n按键映射\n\n|递归|非递归|模式|\n|:-:|:-:|:-:|\n|:map|:noremap|normal,visual,operator-pending|\n|:nmap|:nnoremap|normal|\n|:xmap|:xnoremap|visual|\n|:cmap|:cnoremap|command-line|\n|:omap|:onoremap|operator-pending|\n|:imap|:inoremap|insert|\n39.\n在.vim/bundle/YouCompleteMe/.ycm_extra_conf.py配置c++20\n# 打造IDE\n## 单文件运行\n- 插件:skywind3000/asynctasks.vim,skywind3000/asyncrun.vim\n- 链接:[asyncrun](https://github.com/skywind3000/asyncrun.vim),[asynctasks](https://github.com/skywind3000/asynctasks.vim)\n\n|快捷键|作用|\n|:-:|:-:|\n|`F7`|编译并运行文件，这会打开一个运行shell的窗口|\n|`Ctrl+d`|关闭shell窗口|\n|`Ctrl+t`|隐藏/显示shell窗口|\n|`Ctrl+\\Ctrl+n`|把shell窗口的所有文字进入编辑模式，这样就能像操作文本一样操作该窗口(只读窗口)|\n|`Ctrl+w+\"\"`|前提先用y命令复制文本，然后进入shell窗口，按此快捷键就会粘贴|\n\n## NerdTree\n- 插件:'preservim/nerdtree'\n- 链接:[NerdTree](https://github.com/preservim/nerdtree)\n\n|快捷键|作用|\n|:-:|:-:|\n|`,nn`|打开nerdTree|\n\n## 对齐线\n- 插件:'nathanaelkane/vim-indent-guides'\n- 链接:[vim-indent-guides](https://github.com/preservim/vim-indent-guides)\n\n|快捷键|作用|\n|`,ig`|使用对齐线|\n\n## 成对元素\n- 插件:'tpope/vim-surround'\n- 链接:[vim-surround](https://github.com/tpope/vim-surround)\n\n|快捷键|作用|\n|:-:|:-:|\n|`cs\"'`|在一个有`\"`元素包围的字段上，更改`\"`为`'`|\n|`ds\"`|在一个有`\"`元素包围的字段上，删除`\"`|\n|`ysiw]`|用中括号包围一个单词|\n|`yss)]`|一行加括号|\n|`S<p class=\"important\">`|V选中一行,然后输入，会包围该行|\n\n- 左括号会有空格\n- b可以代表作括号，B代表左花括号\n\n## 快速查找文件\n- 插件:'kien/ctrlp.vim'\n- 链接:[ctrlp](https://github.com/ctrlpvim/ctrlp.vim?tab=readme-ov-file)\n\n|快捷键|作用|\n|:-:|:-:|\n|`,j`|快速查找磁盘文件|\n|`,b`|快速查找缓冲区文件|\n\n## 多行模式(有待研究)\n- 插件:'mq979/vim-visual-multi'\n- 链接:[vim-visual-multi](https://github.com/mg979/vim-visual-multi)\n\n|快捷键|作用|\n|:-:|:-:|\n|`Ctrl+Down/Up`|插入光标进入cursor mode等价于normal mode,Tab键可以切换到extend mode|\n|`Ctrl+n`|选中一个单词进入extend mode等价于visual mode,Tab键可以切换到cursor mode|\n|`Ctrl+Arrows`|选中字符|\n|`Q`|放弃当前的选中|\n\n## 注释\n- 插件:'tpope/vim-commentary'\n- 链接:[vim-commentary](https://github.com/tpope/vim-commentary)\n\n|快捷键|作用|\n|:-:|:-:|\n|`gcc`|快速注释一行|\n|`gcap`|注释一段|\n|`:7,17Commentary`|注释7,17行|\n|`:g/TODO/Commentary`|注释含有TODO行|\n\n## 快速ack(grep)\n- 插件:`mileszs/ack.vim`\n- 链接:[ack](https://github.com/mileszs/ack.vim?tab=readme-ov-file)\n- 前提:需要安装ack，他是高级版的grep\n\n## 其他\n\n|快捷键|作用|插件|\n|:-:|:-:|:-:|\n|`,sf`|列出当前文件所有函数|Plug 'Yggdroot/LeaderF', { 'do': ':LeaderfInstallCExtension' }|\n|`,o`|查看缓冲区列表|jlanzarotta/bufexplorer|\n|`,bd`|关闭当前缓冲区|jlanzarotta/bufexplorer|\n|`,ba`|关闭所有缓冲区|jlanzarotta/bufexplorer|\n|`,bl`|切换缓冲区|jlanzarotta/bufexplorer|\n|`,bh`|切换缓冲区|jlanzarotta/bufexplorer|\n|`+/_`|智能扩展选中区域|terryma/vim-expand-region|\n","slug":"vi及vim","published":1,"updated":"2024-07-17T19:57:45.346Z","_id":"clq1yvi78001wgwq23oocfw2u","comments":1,"layout":"post","photos":[],"content":"<ol>\n<li>vi:<br>  a.命令模式替换:%s&#x2F;xx&#x2F;xx&#x2F;gc,s代表替换,g代表一行多次匹配,c表示确认。<br>  b.在每行尾部加相同内容技巧:进入列模式(ctrl+v)，按‘G’选中每一行，按‘$’延伸至行尾，再按‘A’添加内容</li>\n<li>sed与awk的命令格式: command [options] script filename</li>\n<li>awk默认模式为所有行，默认操作打印。</li>\n<li>实心句点”.“表示当前行</li>\n<li>$表示最后一行</li>\n<li>ctrl+g显示当前文件名<br>ctrl+s锁住<br>ctrl+q解锁</li>\n<li>一般模式中，”&gt;””&lt;”为缩进层级</li>\n<li>ctrl+a会把当前或之后数字加1，若要一次加10则按10ctrl+a,而ctrl+x则是减</li>\n<li>guu使当前行都变成小写，gUU使当前行都变成大写，g~则反转大小写</li>\n<li>一般模式下按下yt，再按你想要复制内容的后一个词，之后再在插入模式里按ctrl+r+0或ctrl+r+ctrl+p+0，就完成粘贴</li>\n<li>在插入模式中按下ctrl+r+&#x3D;进入计算模式完成后回车完成结果输入。</li>\n<li>在插入模式中可以根据字符编码进行输入字符,汇总如下:</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">按键操作</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ctrl+v{123}</td>\n<td align=\"center\">以十进制字符编码插入字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+v+u{1234}</td>\n<td align=\"center\">以十六进制字符编码插入字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+k{char1}{char2}</td>\n<td align=\"center\">插入以二合字母表示的字符</td>\n</tr>\n</tbody></table>\n<p>　　可以在命令模式中输入:h digraph-table，来查看二合字母<br>　　一般模式中，在字符上面输入ga可查看其十进制及十六进制编码<br>13.<br>gv重新选上次的高亮区<br>14.<br>o在可视模式中切换高亮区的活动端<br>15.<br>命令模式中%代表全部行<br>16.<br>可以进入行可视模式，选中对应行，然后进入命令模式进行操作<br>17.<br>命令模式中t为copy命令的简写<br>18.<br>在命令模式中执行普通模式下的命令可以用normal，如:<br><code>:%normal A;</code><br>就是在每行后加;<br>19.<br>一般模式下按*可以查找当前光标下的单词<br>20.<br>可以在命令模式中执行shell命令，只要在命令前加!,这只适合执行一次<br>21.<br>当执行多次命令时，可以在命令模式中输入shell，要想返回vi可以在shell中输入exit<br>22.<br>read,与write命令可以与shell命令结合使用,read把shell命令的标准输出读入缓冲区，write则是把缓冲区当做shell命令的标准输入<br>23.<br>可以用source脚本文件执行一系列的命令<br>24.<br>可以在一般模式中输入ctrl+w+v竖着分隔同一文件<br>25.<br>gj、gk等是在屏幕行上的移动<br>26.<br>文本对象与选择区域</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文本对象</th>\n<th align=\"center\">选择区域</th>\n<th align=\"center\">文本对象</th>\n<th align=\"center\">选择区域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">iw</td>\n<td align=\"center\">当前单词</td>\n<td align=\"center\">aw</td>\n<td align=\"center\">当前单词及空格</td>\n</tr>\n<tr>\n<td align=\"center\">iW</td>\n<td align=\"center\">当前字串</td>\n<td align=\"center\">aw</td>\n<td align=\"center\">当前字串及空格</td>\n</tr>\n<tr>\n<td align=\"center\">is</td>\n<td align=\"center\">当前句子</td>\n<td align=\"center\">as</td>\n<td align=\"center\">当前句子及空格</td>\n</tr>\n<tr>\n<td align=\"center\">ip</td>\n<td align=\"center\">当前段落</td>\n<td align=\"center\">ap</td>\n<td align=\"center\">当前段落及空格</td>\n</tr>\n<tr>\n<td align=\"center\">ab</td>\n<td align=\"center\">当前的圆括号</td>\n<td align=\"center\">ib</td>\n<td align=\"center\">当前圆括号的内部</td>\n</tr>\n<tr>\n<td align=\"center\">aB</td>\n<td align=\"center\">当前的花括号</td>\n<td align=\"center\">iB</td>\n<td align=\"center\">当前花括号内部</td>\n</tr>\n<tr>\n<td align=\"center\">a]</td>\n<td align=\"center\">当前的方括号</td>\n<td align=\"center\">i]</td>\n<td align=\"center\">当前方括号的内部</td>\n</tr>\n<tr>\n<td align=\"center\">a&gt;</td>\n<td align=\"center\">当前尖括号</td>\n<td align=\"center\">i&gt;</td>\n<td align=\"center\">当前尖括号的内部</td>\n</tr>\n<tr>\n<td align=\"center\">a’</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n<tr>\n<td align=\"center\">a”</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n<tr>\n<td align=\"center\">at</td>\n<td align=\"center\">xml标签</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<ol start=\"27\">\n<li>m{a-zA-Z},标记位置，`{mark}跳转到对应位置,``上次跳转动作之前的位置,经常配合使用</li>\n<li>ctrl+o也可以跳转到上次的位置</li>\n<li>%命令可以在一对任意括号上进行跳转</li>\n<li><code>&quot;add</code>指的是剪切一整行到a寄存器,<code>&quot;ap</code>则粘贴a寄存器里的内容</li>\n<li>寄存器列表</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">“”</td>\n<td align=\"center\">无名寄存器</td>\n</tr>\n<tr>\n<td align=\"center\">“0</td>\n<td align=\"center\">复制专用寄存器</td>\n</tr>\n<tr>\n<td align=\"center\">“(a-z)</td>\n<td align=\"center\">自定义寄存器</td>\n</tr>\n<tr>\n<td align=\"center\">“_</td>\n<td align=\"center\">黑洞寄存器</td>\n</tr>\n</tbody></table>\n<p>　　在插入模式下可以用ctrl+r+上寄存器名来粘贴，此时没有”号<br>32.<br>宏录制的过程，q{register}录制开始-&gt;q录制结束-&gt;@{register}执行宏动作,还可以指定次数<br>33.<br>命令模式:reg {register}可以查看寄存器内容<br>34.<br>要想不覆盖寄存器内容，可以q{register}，register名字必须为大写(如qa-&gt;qA)，这样就追加了，否则是覆盖重新录制,<br>35.<br>一般模式下ctrl+b向前翻页<br>一般模式下ctrl+f向后翻页<br>36.<br>dG会删除光标之后的所有内容<br>37.<br>H,M,L,分别是移动到屏幕行的顶,中,尾<br>38.<br>按键映射</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">递归</th>\n<th align=\"center\">非递归</th>\n<th align=\"center\">模式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">:map</td>\n<td align=\"center\">:noremap</td>\n<td align=\"center\">normal,visual,operator-pending</td>\n</tr>\n<tr>\n<td align=\"center\">:nmap</td>\n<td align=\"center\">:nnoremap</td>\n<td align=\"center\">normal</td>\n</tr>\n<tr>\n<td align=\"center\">:xmap</td>\n<td align=\"center\">:xnoremap</td>\n<td align=\"center\">visual</td>\n</tr>\n<tr>\n<td align=\"center\">:cmap</td>\n<td align=\"center\">:cnoremap</td>\n<td align=\"center\">command-line</td>\n</tr>\n<tr>\n<td align=\"center\">:omap</td>\n<td align=\"center\">:onoremap</td>\n<td align=\"center\">operator-pending</td>\n</tr>\n<tr>\n<td align=\"center\">:imap</td>\n<td align=\"center\">:inoremap</td>\n<td align=\"center\">insert</td>\n</tr>\n<tr>\n<td align=\"center\">39.</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">在.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;.ycm_extra_conf.py配置c++20</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"打造IDE\"><a href=\"#打造IDE\" class=\"headerlink\" title=\"打造IDE\"></a>打造IDE</h1><h2 id=\"单文件运行\"><a href=\"#单文件运行\" class=\"headerlink\" title=\"单文件运行\"></a>单文件运行</h2><ul>\n<li>插件:skywind3000&#x2F;asynctasks.vim,skywind3000&#x2F;asyncrun.vim</li>\n<li>链接:<a href=\"https://github.com/skywind3000/asyncrun.vim\">asyncrun</a>,<a href=\"https://github.com/skywind3000/asynctasks.vim\">asynctasks</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>F7</code></td>\n<td align=\"center\">编译并运行文件，这会打开一个运行shell的窗口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+d</code></td>\n<td align=\"center\">关闭shell窗口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+t</code></td>\n<td align=\"center\">隐藏&#x2F;显示shell窗口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+\\Ctrl+n</code></td>\n<td align=\"center\">把shell窗口的所有文字进入编辑模式，这样就能像操作文本一样操作该窗口(只读窗口)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+w+&quot;&quot;</code></td>\n<td align=\"center\">前提先用y命令复制文本，然后进入shell窗口，按此快捷键就会粘贴</td>\n</tr>\n</tbody></table>\n<h2 id=\"NerdTree\"><a href=\"#NerdTree\" class=\"headerlink\" title=\"NerdTree\"></a>NerdTree</h2><ul>\n<li>插件:’preservim&#x2F;nerdtree’</li>\n<li>链接:<a href=\"https://github.com/preservim/nerdtree\">NerdTree</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>,nn</code></td>\n<td align=\"center\">打开nerdTree</td>\n</tr>\n</tbody></table>\n<h2 id=\"对齐线\"><a href=\"#对齐线\" class=\"headerlink\" title=\"对齐线\"></a>对齐线</h2><ul>\n<li>插件:’nathanaelkane&#x2F;vim-indent-guides’</li>\n<li>链接:<a href=\"https://github.com/preservim/vim-indent-guides\">vim-indent-guides</a></li>\n</ul>\n<p>|快捷键|作用|<br>|<code>,ig</code>|使用对齐线|</p>\n<h2 id=\"成对元素\"><a href=\"#成对元素\" class=\"headerlink\" title=\"成对元素\"></a>成对元素</h2><ul>\n<li>插件:’tpope&#x2F;vim-surround’</li>\n<li>链接:<a href=\"https://github.com/tpope/vim-surround\">vim-surround</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>cs&quot;&#39;</code></td>\n<td align=\"center\">在一个有<code>&quot;</code>元素包围的字段上，更改<code>&quot;</code>为<code>&#39;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>ds&quot;</code></td>\n<td align=\"center\">在一个有<code>&quot;</code>元素包围的字段上，删除<code>&quot;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>ysiw]</code></td>\n<td align=\"center\">用中括号包围一个单词</td>\n</tr>\n<tr>\n<td align=\"center\"><code>yss)]</code></td>\n<td align=\"center\">一行加括号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>S&lt;p class=&quot;important&quot;&gt;</code></td>\n<td align=\"center\">V选中一行,然后输入，会包围该行</td>\n</tr>\n</tbody></table>\n<ul>\n<li>左括号会有空格</li>\n<li>b可以代表作括号，B代表左花括号</li>\n</ul>\n<h2 id=\"快速查找文件\"><a href=\"#快速查找文件\" class=\"headerlink\" title=\"快速查找文件\"></a>快速查找文件</h2><ul>\n<li>插件:’kien&#x2F;ctrlp.vim’</li>\n<li>链接:<a href=\"https://github.com/ctrlpvim/ctrlp.vim?tab=readme-ov-file\">ctrlp</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>,j</code></td>\n<td align=\"center\">快速查找磁盘文件</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,b</code></td>\n<td align=\"center\">快速查找缓冲区文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"多行模式-有待研究\"><a href=\"#多行模式-有待研究\" class=\"headerlink\" title=\"多行模式(有待研究)\"></a>多行模式(有待研究)</h2><ul>\n<li>插件:’mq979&#x2F;vim-visual-multi’</li>\n<li>链接:<a href=\"https://github.com/mg979/vim-visual-multi\">vim-visual-multi</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>Ctrl+Down/Up</code></td>\n<td align=\"center\">插入光标进入cursor mode等价于normal mode,Tab键可以切换到extend mode</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+n</code></td>\n<td align=\"center\">选中一个单词进入extend mode等价于visual mode,Tab键可以切换到cursor mode</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+Arrows</code></td>\n<td align=\"center\">选中字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Q</code></td>\n<td align=\"center\">放弃当前的选中</td>\n</tr>\n</tbody></table>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li>插件:’tpope&#x2F;vim-commentary’</li>\n<li>链接:<a href=\"https://github.com/tpope/vim-commentary\">vim-commentary</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>gcc</code></td>\n<td align=\"center\">快速注释一行</td>\n</tr>\n<tr>\n<td align=\"center\"><code>gcap</code></td>\n<td align=\"center\">注释一段</td>\n</tr>\n<tr>\n<td align=\"center\"><code>:7,17Commentary</code></td>\n<td align=\"center\">注释7,17行</td>\n</tr>\n<tr>\n<td align=\"center\"><code>:g/TODO/Commentary</code></td>\n<td align=\"center\">注释含有TODO行</td>\n</tr>\n</tbody></table>\n<h2 id=\"快速ack-grep\"><a href=\"#快速ack-grep\" class=\"headerlink\" title=\"快速ack(grep)\"></a>快速ack(grep)</h2><ul>\n<li>插件:<code>mileszs/ack.vim</code></li>\n<li>链接:<a href=\"https://github.com/mileszs/ack.vim?tab=readme-ov-file\">ack</a></li>\n<li>前提:需要安装ack，他是高级版的grep</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n<th align=\"center\">插件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>,sf</code></td>\n<td align=\"center\">列出当前文件所有函数</td>\n<td align=\"center\">Plug ‘Yggdroot&#x2F;LeaderF’, { ‘do’: ‘:LeaderfInstallCExtension’ }</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,o</code></td>\n<td align=\"center\">查看缓冲区列表</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,bd</code></td>\n<td align=\"center\">关闭当前缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,ba</code></td>\n<td align=\"center\">关闭所有缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,bl</code></td>\n<td align=\"center\">切换缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,bh</code></td>\n<td align=\"center\">切换缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>+/_</code></td>\n<td align=\"center\">智能扩展选中区域</td>\n<td align=\"center\">terryma&#x2F;vim-expand-region</td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<ol>\n<li>vi:<br>  a.命令模式替换:%s&#x2F;xx&#x2F;xx&#x2F;gc,s代表替换,g代表一行多次匹配,c表示确认。<br>  b.在每行尾部加相同内容技巧:进入列模式(ctrl+v)，按‘G’选中每一行，按‘$’延伸至行尾，再按‘A’添加内容</li>\n<li>sed与awk的命令格式: command [options] script filename</li>\n<li>awk默认模式为所有行，默认操作打印。</li>\n<li>实心句点”.“表示当前行</li>\n<li>$表示最后一行</li>\n<li>ctrl+g显示当前文件名<br>ctrl+s锁住<br>ctrl+q解锁</li>\n<li>一般模式中，”&gt;””&lt;”为缩进层级</li>\n<li>ctrl+a会把当前或之后数字加1，若要一次加10则按10ctrl+a,而ctrl+x则是减</li>\n<li>guu使当前行都变成小写，gUU使当前行都变成大写，g~则反转大小写</li>\n<li>一般模式下按下yt，再按你想要复制内容的后一个词，之后再在插入模式里按ctrl+r+0或ctrl+r+ctrl+p+0，就完成粘贴</li>\n<li>在插入模式中按下ctrl+r+&#x3D;进入计算模式完成后回车完成结果输入。</li>\n<li>在插入模式中可以根据字符编码进行输入字符,汇总如下:</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">按键操作</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ctrl+v{123}</td>\n<td align=\"center\">以十进制字符编码插入字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+v+u{1234}</td>\n<td align=\"center\">以十六进制字符编码插入字符</td>\n</tr>\n<tr>\n<td align=\"center\">ctrl+k{char1}{char2}</td>\n<td align=\"center\">插入以二合字母表示的字符</td>\n</tr>\n</tbody></table>\n<p>　　可以在命令模式中输入:h digraph-table，来查看二合字母<br>　　一般模式中，在字符上面输入ga可查看其十进制及十六进制编码<br>13.<br>gv重新选上次的高亮区<br>14.<br>o在可视模式中切换高亮区的活动端<br>15.<br>命令模式中%代表全部行<br>16.<br>可以进入行可视模式，选中对应行，然后进入命令模式进行操作<br>17.<br>命令模式中t为copy命令的简写<br>18.<br>在命令模式中执行普通模式下的命令可以用normal，如:<br><code>:%normal A;</code><br>就是在每行后加;<br>19.<br>一般模式下按*可以查找当前光标下的单词<br>20.<br>可以在命令模式中执行shell命令，只要在命令前加!,这只适合执行一次<br>21.<br>当执行多次命令时，可以在命令模式中输入shell，要想返回vi可以在shell中输入exit<br>22.<br>read,与write命令可以与shell命令结合使用,read把shell命令的标准输出读入缓冲区，write则是把缓冲区当做shell命令的标准输入<br>23.<br>可以用source脚本文件执行一系列的命令<br>24.<br>可以在一般模式中输入ctrl+w+v竖着分隔同一文件<br>25.<br>gj、gk等是在屏幕行上的移动<br>26.<br>文本对象与选择区域</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文本对象</th>\n<th align=\"center\">选择区域</th>\n<th align=\"center\">文本对象</th>\n<th align=\"center\">选择区域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">iw</td>\n<td align=\"center\">当前单词</td>\n<td align=\"center\">aw</td>\n<td align=\"center\">当前单词及空格</td>\n</tr>\n<tr>\n<td align=\"center\">iW</td>\n<td align=\"center\">当前字串</td>\n<td align=\"center\">aw</td>\n<td align=\"center\">当前字串及空格</td>\n</tr>\n<tr>\n<td align=\"center\">is</td>\n<td align=\"center\">当前句子</td>\n<td align=\"center\">as</td>\n<td align=\"center\">当前句子及空格</td>\n</tr>\n<tr>\n<td align=\"center\">ip</td>\n<td align=\"center\">当前段落</td>\n<td align=\"center\">ap</td>\n<td align=\"center\">当前段落及空格</td>\n</tr>\n<tr>\n<td align=\"center\">ab</td>\n<td align=\"center\">当前的圆括号</td>\n<td align=\"center\">ib</td>\n<td align=\"center\">当前圆括号的内部</td>\n</tr>\n<tr>\n<td align=\"center\">aB</td>\n<td align=\"center\">当前的花括号</td>\n<td align=\"center\">iB</td>\n<td align=\"center\">当前花括号内部</td>\n</tr>\n<tr>\n<td align=\"center\">a]</td>\n<td align=\"center\">当前的方括号</td>\n<td align=\"center\">i]</td>\n<td align=\"center\">当前方括号的内部</td>\n</tr>\n<tr>\n<td align=\"center\">a&gt;</td>\n<td align=\"center\">当前尖括号</td>\n<td align=\"center\">i&gt;</td>\n<td align=\"center\">当前尖括号的内部</td>\n</tr>\n<tr>\n<td align=\"center\">a’</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n<tr>\n<td align=\"center\">a”</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n<tr>\n<td align=\"center\">at</td>\n<td align=\"center\">xml标签</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<ol start=\"27\">\n<li>m{a-zA-Z},标记位置，`{mark}跳转到对应位置,``上次跳转动作之前的位置,经常配合使用</li>\n<li>ctrl+o也可以跳转到上次的位置</li>\n<li>%命令可以在一对任意括号上进行跳转</li>\n<li><code>&quot;add</code>指的是剪切一整行到a寄存器,<code>&quot;ap</code>则粘贴a寄存器里的内容</li>\n<li>寄存器列表</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">“”</td>\n<td align=\"center\">无名寄存器</td>\n</tr>\n<tr>\n<td align=\"center\">“0</td>\n<td align=\"center\">复制专用寄存器</td>\n</tr>\n<tr>\n<td align=\"center\">“(a-z)</td>\n<td align=\"center\">自定义寄存器</td>\n</tr>\n<tr>\n<td align=\"center\">“_</td>\n<td align=\"center\">黑洞寄存器</td>\n</tr>\n</tbody></table>\n<p>　　在插入模式下可以用ctrl+r+上寄存器名来粘贴，此时没有”号<br>32.<br>宏录制的过程，q{register}录制开始-&gt;q录制结束-&gt;@{register}执行宏动作,还可以指定次数<br>33.<br>命令模式:reg {register}可以查看寄存器内容<br>34.<br>要想不覆盖寄存器内容，可以q{register}，register名字必须为大写(如qa-&gt;qA)，这样就追加了，否则是覆盖重新录制,<br>35.<br>一般模式下ctrl+b向前翻页<br>一般模式下ctrl+f向后翻页<br>36.<br>dG会删除光标之后的所有内容<br>37.<br>H,M,L,分别是移动到屏幕行的顶,中,尾<br>38.<br>按键映射</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">递归</th>\n<th align=\"center\">非递归</th>\n<th align=\"center\">模式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">:map</td>\n<td align=\"center\">:noremap</td>\n<td align=\"center\">normal,visual,operator-pending</td>\n</tr>\n<tr>\n<td align=\"center\">:nmap</td>\n<td align=\"center\">:nnoremap</td>\n<td align=\"center\">normal</td>\n</tr>\n<tr>\n<td align=\"center\">:xmap</td>\n<td align=\"center\">:xnoremap</td>\n<td align=\"center\">visual</td>\n</tr>\n<tr>\n<td align=\"center\">:cmap</td>\n<td align=\"center\">:cnoremap</td>\n<td align=\"center\">command-line</td>\n</tr>\n<tr>\n<td align=\"center\">:omap</td>\n<td align=\"center\">:onoremap</td>\n<td align=\"center\">operator-pending</td>\n</tr>\n<tr>\n<td align=\"center\">:imap</td>\n<td align=\"center\">:inoremap</td>\n<td align=\"center\">insert</td>\n</tr>\n<tr>\n<td align=\"center\">39.</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">在.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;.ycm_extra_conf.py配置c++20</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"打造IDE\"><a href=\"#打造IDE\" class=\"headerlink\" title=\"打造IDE\"></a>打造IDE</h1><h2 id=\"单文件运行\"><a href=\"#单文件运行\" class=\"headerlink\" title=\"单文件运行\"></a>单文件运行</h2><ul>\n<li>插件:skywind3000&#x2F;asynctasks.vim,skywind3000&#x2F;asyncrun.vim</li>\n<li>链接:<a href=\"https://github.com/skywind3000/asyncrun.vim\">asyncrun</a>,<a href=\"https://github.com/skywind3000/asynctasks.vim\">asynctasks</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>F7</code></td>\n<td align=\"center\">编译并运行文件，这会打开一个运行shell的窗口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+d</code></td>\n<td align=\"center\">关闭shell窗口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+t</code></td>\n<td align=\"center\">隐藏&#x2F;显示shell窗口</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+\\Ctrl+n</code></td>\n<td align=\"center\">把shell窗口的所有文字进入编辑模式，这样就能像操作文本一样操作该窗口(只读窗口)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+w+&quot;&quot;</code></td>\n<td align=\"center\">前提先用y命令复制文本，然后进入shell窗口，按此快捷键就会粘贴</td>\n</tr>\n</tbody></table>\n<h2 id=\"NerdTree\"><a href=\"#NerdTree\" class=\"headerlink\" title=\"NerdTree\"></a>NerdTree</h2><ul>\n<li>插件:’preservim&#x2F;nerdtree’</li>\n<li>链接:<a href=\"https://github.com/preservim/nerdtree\">NerdTree</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>,nn</code></td>\n<td align=\"center\">打开nerdTree</td>\n</tr>\n</tbody></table>\n<h2 id=\"对齐线\"><a href=\"#对齐线\" class=\"headerlink\" title=\"对齐线\"></a>对齐线</h2><ul>\n<li>插件:’nathanaelkane&#x2F;vim-indent-guides’</li>\n<li>链接:<a href=\"https://github.com/preservim/vim-indent-guides\">vim-indent-guides</a></li>\n</ul>\n<p>|快捷键|作用|<br>|<code>,ig</code>|使用对齐线|</p>\n<h2 id=\"成对元素\"><a href=\"#成对元素\" class=\"headerlink\" title=\"成对元素\"></a>成对元素</h2><ul>\n<li>插件:’tpope&#x2F;vim-surround’</li>\n<li>链接:<a href=\"https://github.com/tpope/vim-surround\">vim-surround</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>cs&quot;&#39;</code></td>\n<td align=\"center\">在一个有<code>&quot;</code>元素包围的字段上，更改<code>&quot;</code>为<code>&#39;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>ds&quot;</code></td>\n<td align=\"center\">在一个有<code>&quot;</code>元素包围的字段上，删除<code>&quot;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>ysiw]</code></td>\n<td align=\"center\">用中括号包围一个单词</td>\n</tr>\n<tr>\n<td align=\"center\"><code>yss)]</code></td>\n<td align=\"center\">一行加括号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>S&lt;p class=&quot;important&quot;&gt;</code></td>\n<td align=\"center\">V选中一行,然后输入，会包围该行</td>\n</tr>\n</tbody></table>\n<ul>\n<li>左括号会有空格</li>\n<li>b可以代表作括号，B代表左花括号</li>\n</ul>\n<h2 id=\"快速查找文件\"><a href=\"#快速查找文件\" class=\"headerlink\" title=\"快速查找文件\"></a>快速查找文件</h2><ul>\n<li>插件:’kien&#x2F;ctrlp.vim’</li>\n<li>链接:<a href=\"https://github.com/ctrlpvim/ctrlp.vim?tab=readme-ov-file\">ctrlp</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>,j</code></td>\n<td align=\"center\">快速查找磁盘文件</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,b</code></td>\n<td align=\"center\">快速查找缓冲区文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"多行模式-有待研究\"><a href=\"#多行模式-有待研究\" class=\"headerlink\" title=\"多行模式(有待研究)\"></a>多行模式(有待研究)</h2><ul>\n<li>插件:’mq979&#x2F;vim-visual-multi’</li>\n<li>链接:<a href=\"https://github.com/mg979/vim-visual-multi\">vim-visual-multi</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>Ctrl+Down/Up</code></td>\n<td align=\"center\">插入光标进入cursor mode等价于normal mode,Tab键可以切换到extend mode</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+n</code></td>\n<td align=\"center\">选中一个单词进入extend mode等价于visual mode,Tab键可以切换到cursor mode</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Ctrl+Arrows</code></td>\n<td align=\"center\">选中字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>Q</code></td>\n<td align=\"center\">放弃当前的选中</td>\n</tr>\n</tbody></table>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li>插件:’tpope&#x2F;vim-commentary’</li>\n<li>链接:<a href=\"https://github.com/tpope/vim-commentary\">vim-commentary</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>gcc</code></td>\n<td align=\"center\">快速注释一行</td>\n</tr>\n<tr>\n<td align=\"center\"><code>gcap</code></td>\n<td align=\"center\">注释一段</td>\n</tr>\n<tr>\n<td align=\"center\"><code>:7,17Commentary</code></td>\n<td align=\"center\">注释7,17行</td>\n</tr>\n<tr>\n<td align=\"center\"><code>:g/TODO/Commentary</code></td>\n<td align=\"center\">注释含有TODO行</td>\n</tr>\n</tbody></table>\n<h2 id=\"快速ack-grep\"><a href=\"#快速ack-grep\" class=\"headerlink\" title=\"快速ack(grep)\"></a>快速ack(grep)</h2><ul>\n<li>插件:<code>mileszs/ack.vim</code></li>\n<li>链接:<a href=\"https://github.com/mileszs/ack.vim?tab=readme-ov-file\">ack</a></li>\n<li>前提:需要安装ack，他是高级版的grep</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">作用</th>\n<th align=\"center\">插件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>,sf</code></td>\n<td align=\"center\">列出当前文件所有函数</td>\n<td align=\"center\">Plug ‘Yggdroot&#x2F;LeaderF’, { ‘do’: ‘:LeaderfInstallCExtension’ }</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,o</code></td>\n<td align=\"center\">查看缓冲区列表</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,bd</code></td>\n<td align=\"center\">关闭当前缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,ba</code></td>\n<td align=\"center\">关闭所有缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,bl</code></td>\n<td align=\"center\">切换缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>,bh</code></td>\n<td align=\"center\">切换缓冲区</td>\n<td align=\"center\">jlanzarotta&#x2F;bufexplorer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>+/_</code></td>\n<td align=\"center\">智能扩展选中区域</td>\n<td align=\"center\">terryma&#x2F;vim-expand-region</td>\n</tr>\n</tbody></table>\n"},{"title":"字符相关","date":"2019-07-19T06:08:18.000Z","subtitle":null,"index_img":"/images/character.png","banner_img":"/images/character.png","_content":"# cctype中的函数\nisalnum() 参数为字母或数字,返回true\nisalpha() 参数字母为字母,返回true\niscntrl() 参数为控制字符,返回true\nisdigit() 参数为数字(0～9),返回true\nisgraph() 参数为除空格外的打印字符,返回true\nislower() 参数为小写字母,返回true\nisprint() 参数为打印字符(包括空格),返回true\nispunct() 参数为标点符号,返回true\nisspace() 参数为标准空白字符,如空格,进纸,换行符,回车,制表符,返回true\nisupper() 参数为大写字母,返回true\nisxdigit() 参数为十六进制数字,即0～9,a～f或A～F,返回true\ntolower() 若是大写,返回其小写,否则返回该参数\ntoupper() 若是小写,返回其大写,否则返回该参数\n# C字符串的函数(cstring)\nstrcpy(str1,str2)  复制str2到str1\nstrncpy(str1,str2,n) 把str2的前n字符拷贝到str1\nstrcat(str1,str2)  str2连接到str1后面\nstrncat(str1,str2,n) 把str2的前n字符连接到str1\nstrcmp(str1,str2) 比较两个字符串\nstrlen(str) 计算长度不包括结束标识符\n3.  \nC字符类型与其他类型的转换\natof(str) 将字符串转换为float类型\natoi(str) 将字符串转换为int类型\nitoa(num,str,10) 将int类型转换为字符串,10代表十进制\nltoa(num,str,10) 将long类型转换为字符串,10代表十进制\nultoa(num,str,10) 将unsigned long类型转换为字符串,10代表十进制\nsprintf() 函数比上述三个更灵活,具体百度\n以下三个都是浮点型转换为字符串\nfcvt()\necvt()\ngcvt()\ncppstr.c_str() string类型转换为C类型\nC字符串可以直接赋值给string类型\n# string类型的操作(详见C++Primer P323)\nstr1.substr(pos,n) 返回一个string,包含s中从pos开始的n个字符的拷贝.pos的默认值为0,n的默认值为str1.size()-pos,即所有字符\nstr1.insert(pos,args) 在pos之前插入args指定的字符,若pos不是下标而是迭代器,则返回指向第一个插入字符的迭代器\nstr1.erase(pos,len) 删除从pos开始的len个字符.len默认至末尾\nstr1.assign(args) 将str1字符替换为指定的args的字符\nstr1.append(args) 将args追加到str1,\nstr1.replace(range,args) 删除s中范围range内的字符,替换为args指定的字符.range或者是个下标和长度,或一堆迭代器\n注:\n以上args可以是下面格式:\na.str2  字符串str2\nb.str2,pos,len 字符串str2中从pos开始的len个字\nc.cp cp指向的以空字符结尾的字符数组\nd.cp,len 从cp指向的字符数组的前len个字符\ne.n,c n个字符c\nf.b,e 迭代器的范围,不能是本身\ng.初始化列表 花括号包围的,以逗号分隔的字符列表\n而replace和insert的args形式取决于range和pos,以标号代替args.\n\n| args | replace(pos,len,args) | replace(b,e,args) | insert(pos,args) | insert(iter,args) |\n| :-: | :-: | :-: | :-: | :-: |\n| a. | y | y | y | n|\n| b. | y | n | y | n|\n| c. | y | y | y | n|\n| d. | y | y | n | n|\n| e. | y | y | y | y|\n| f. | n | y | n | y|\n| g. | n | y | n | y|\n\n　　str1.find(args) 查找str1中args第一次出现的位置\n　　str1.rfind(args) 查找str1中args最后一次出现的位置\n　　str1.find_first_of(args) 在str1查找args中任意字符第一次出现的位置\n　　str1.find_last_of(args) 在str1查找args中任意字符最后一次出现的位置\n　　str1.find_first_not_of(args) 在str1查找第一个不在args中的字符\n　　str1.find_last_not_of(args) 在str1查找最后一个不在args中的字符\n　　注:\n　　args可以是以下的格式:\n　　c,pos  从str1中位置pos开始查找字符c.pos默认为0\n　　str2,pos 从str1中位置pos开始查找字符串str2,pos默认为0\n　　cp,pos 从str1中位置pos开始查找指针cp指向的C字符串.pos默认为0\n　　cp,pos,n 从str1中查找指针cp指向的前n个字符.无默认值\n　　str1.compare(args)\n　　注:\n　　args可以是以下格式:\n　　str2 比较str1和str2\n　　pos1,n1,str2 将str1中从pos1开始的n1个字符与str2字符进行比较\n　　pos1,n1,str2,pos2,n2 将str1中从pos1开始的n1个字符与str2中从pos2开始的n2个字符串进行比较\n　　cp 与C字符串比较\n　　pos1,n1,cp ....\n　　pos1,n1,cp,n2 ......................C字符串cp指针指向的位置后的n2个字符串进行比较\n# string类型与数字的转换\nto_string(num) 数字转换成string\nstoi(s,p,b)\nstol(s,p,b)\nstoul(s,p,b)\nstoll(s,p,b)\nstoull(s,p,b)\n注:返回类型为int,long,unsigned long,long long,unsigned long long,\n   b一般表示十进制\n   p为size_t指针,用来保存s字符中第一个非数值字符的下标,默认为0,即不保存下标\nstof(s,p)\nstod(s,p)\nstold(s,p)\n注:返回类型为float,double,long double\nstd::from_chars(start,end,result,base)\n# char to string\n- `std::string(1,char_value)`\n# std::format\n提供python style的字符串构造\n## integer\n```C++\nstd::format(\"{}\", 3); // \"3\"\nstd::format(\"{:b}\", 3); // \"101\"\n```\n## float\n```C++\nstd::format(\"{:.1f}\", 3.273); // \"3.1\"\n```\n## alignment\n```C++\nstd::format(\"{:>6}\", 3.27); // \" 3.27\"\nstd::format(\"{:<6}\", 3.27); // \"3.27 \"\n```\n## reordering\n```C++\nstd::format(\"{1} - {0}\", 1, 3); // \"3 - 1\" \n```\n","source":"_posts/字符相关.md","raw":"---\ntitle: 字符相关\ndate: 2019-07-19 14:08:18\nsubtitle:\ncategories: C++\ntags: 字符\nindex_img: /images/character.png\nbanner_img: /images/character.png\n---\n# cctype中的函数\nisalnum() 参数为字母或数字,返回true\nisalpha() 参数字母为字母,返回true\niscntrl() 参数为控制字符,返回true\nisdigit() 参数为数字(0～9),返回true\nisgraph() 参数为除空格外的打印字符,返回true\nislower() 参数为小写字母,返回true\nisprint() 参数为打印字符(包括空格),返回true\nispunct() 参数为标点符号,返回true\nisspace() 参数为标准空白字符,如空格,进纸,换行符,回车,制表符,返回true\nisupper() 参数为大写字母,返回true\nisxdigit() 参数为十六进制数字,即0～9,a～f或A～F,返回true\ntolower() 若是大写,返回其小写,否则返回该参数\ntoupper() 若是小写,返回其大写,否则返回该参数\n# C字符串的函数(cstring)\nstrcpy(str1,str2)  复制str2到str1\nstrncpy(str1,str2,n) 把str2的前n字符拷贝到str1\nstrcat(str1,str2)  str2连接到str1后面\nstrncat(str1,str2,n) 把str2的前n字符连接到str1\nstrcmp(str1,str2) 比较两个字符串\nstrlen(str) 计算长度不包括结束标识符\n3.  \nC字符类型与其他类型的转换\natof(str) 将字符串转换为float类型\natoi(str) 将字符串转换为int类型\nitoa(num,str,10) 将int类型转换为字符串,10代表十进制\nltoa(num,str,10) 将long类型转换为字符串,10代表十进制\nultoa(num,str,10) 将unsigned long类型转换为字符串,10代表十进制\nsprintf() 函数比上述三个更灵活,具体百度\n以下三个都是浮点型转换为字符串\nfcvt()\necvt()\ngcvt()\ncppstr.c_str() string类型转换为C类型\nC字符串可以直接赋值给string类型\n# string类型的操作(详见C++Primer P323)\nstr1.substr(pos,n) 返回一个string,包含s中从pos开始的n个字符的拷贝.pos的默认值为0,n的默认值为str1.size()-pos,即所有字符\nstr1.insert(pos,args) 在pos之前插入args指定的字符,若pos不是下标而是迭代器,则返回指向第一个插入字符的迭代器\nstr1.erase(pos,len) 删除从pos开始的len个字符.len默认至末尾\nstr1.assign(args) 将str1字符替换为指定的args的字符\nstr1.append(args) 将args追加到str1,\nstr1.replace(range,args) 删除s中范围range内的字符,替换为args指定的字符.range或者是个下标和长度,或一堆迭代器\n注:\n以上args可以是下面格式:\na.str2  字符串str2\nb.str2,pos,len 字符串str2中从pos开始的len个字\nc.cp cp指向的以空字符结尾的字符数组\nd.cp,len 从cp指向的字符数组的前len个字符\ne.n,c n个字符c\nf.b,e 迭代器的范围,不能是本身\ng.初始化列表 花括号包围的,以逗号分隔的字符列表\n而replace和insert的args形式取决于range和pos,以标号代替args.\n\n| args | replace(pos,len,args) | replace(b,e,args) | insert(pos,args) | insert(iter,args) |\n| :-: | :-: | :-: | :-: | :-: |\n| a. | y | y | y | n|\n| b. | y | n | y | n|\n| c. | y | y | y | n|\n| d. | y | y | n | n|\n| e. | y | y | y | y|\n| f. | n | y | n | y|\n| g. | n | y | n | y|\n\n　　str1.find(args) 查找str1中args第一次出现的位置\n　　str1.rfind(args) 查找str1中args最后一次出现的位置\n　　str1.find_first_of(args) 在str1查找args中任意字符第一次出现的位置\n　　str1.find_last_of(args) 在str1查找args中任意字符最后一次出现的位置\n　　str1.find_first_not_of(args) 在str1查找第一个不在args中的字符\n　　str1.find_last_not_of(args) 在str1查找最后一个不在args中的字符\n　　注:\n　　args可以是以下的格式:\n　　c,pos  从str1中位置pos开始查找字符c.pos默认为0\n　　str2,pos 从str1中位置pos开始查找字符串str2,pos默认为0\n　　cp,pos 从str1中位置pos开始查找指针cp指向的C字符串.pos默认为0\n　　cp,pos,n 从str1中查找指针cp指向的前n个字符.无默认值\n　　str1.compare(args)\n　　注:\n　　args可以是以下格式:\n　　str2 比较str1和str2\n　　pos1,n1,str2 将str1中从pos1开始的n1个字符与str2字符进行比较\n　　pos1,n1,str2,pos2,n2 将str1中从pos1开始的n1个字符与str2中从pos2开始的n2个字符串进行比较\n　　cp 与C字符串比较\n　　pos1,n1,cp ....\n　　pos1,n1,cp,n2 ......................C字符串cp指针指向的位置后的n2个字符串进行比较\n# string类型与数字的转换\nto_string(num) 数字转换成string\nstoi(s,p,b)\nstol(s,p,b)\nstoul(s,p,b)\nstoll(s,p,b)\nstoull(s,p,b)\n注:返回类型为int,long,unsigned long,long long,unsigned long long,\n   b一般表示十进制\n   p为size_t指针,用来保存s字符中第一个非数值字符的下标,默认为0,即不保存下标\nstof(s,p)\nstod(s,p)\nstold(s,p)\n注:返回类型为float,double,long double\nstd::from_chars(start,end,result,base)\n# char to string\n- `std::string(1,char_value)`\n# std::format\n提供python style的字符串构造\n## integer\n```C++\nstd::format(\"{}\", 3); // \"3\"\nstd::format(\"{:b}\", 3); // \"101\"\n```\n## float\n```C++\nstd::format(\"{:.1f}\", 3.273); // \"3.1\"\n```\n## alignment\n```C++\nstd::format(\"{:>6}\", 3.27); // \" 3.27\"\nstd::format(\"{:<6}\", 3.27); // \"3.27 \"\n```\n## reordering\n```C++\nstd::format(\"{1} - {0}\", 1, 3); // \"3 - 1\" \n```\n","slug":"字符相关","published":1,"updated":"2024-04-05T09:40:12.042Z","_id":"clq1yvi790021gwq29djbecoa","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"cctype中的函数\"><a href=\"#cctype中的函数\" class=\"headerlink\" title=\"cctype中的函数\"></a>cctype中的函数</h1><p>isalnum() 参数为字母或数字,返回true<br>isalpha() 参数字母为字母,返回true<br>iscntrl() 参数为控制字符,返回true<br>isdigit() 参数为数字(0～9),返回true<br>isgraph() 参数为除空格外的打印字符,返回true<br>islower() 参数为小写字母,返回true<br>isprint() 参数为打印字符(包括空格),返回true<br>ispunct() 参数为标点符号,返回true<br>isspace() 参数为标准空白字符,如空格,进纸,换行符,回车,制表符,返回true<br>isupper() 参数为大写字母,返回true<br>isxdigit() 参数为十六进制数字,即0～9,a～f或A～F,返回true<br>tolower() 若是大写,返回其小写,否则返回该参数<br>toupper() 若是小写,返回其大写,否则返回该参数</p>\n<h1 id=\"C字符串的函数-cstring\"><a href=\"#C字符串的函数-cstring\" class=\"headerlink\" title=\"C字符串的函数(cstring)\"></a>C字符串的函数(cstring)</h1><p>strcpy(str1,str2)  复制str2到str1<br>strncpy(str1,str2,n) 把str2的前n字符拷贝到str1<br>strcat(str1,str2)  str2连接到str1后面<br>strncat(str1,str2,n) 把str2的前n字符连接到str1<br>strcmp(str1,str2) 比较两个字符串<br>strlen(str) 计算长度不包括结束标识符<br>3.<br>C字符类型与其他类型的转换<br>atof(str) 将字符串转换为float类型<br>atoi(str) 将字符串转换为int类型<br>itoa(num,str,10) 将int类型转换为字符串,10代表十进制<br>ltoa(num,str,10) 将long类型转换为字符串,10代表十进制<br>ultoa(num,str,10) 将unsigned long类型转换为字符串,10代表十进制<br>sprintf() 函数比上述三个更灵活,具体百度<br>以下三个都是浮点型转换为字符串<br>fcvt()<br>ecvt()<br>gcvt()<br>cppstr.c_str() string类型转换为C类型<br>C字符串可以直接赋值给string类型</p>\n<h1 id=\"string类型的操作-详见C-Primer-P323\"><a href=\"#string类型的操作-详见C-Primer-P323\" class=\"headerlink\" title=\"string类型的操作(详见C++Primer P323)\"></a>string类型的操作(详见C++Primer P323)</h1><p>str1.substr(pos,n) 返回一个string,包含s中从pos开始的n个字符的拷贝.pos的默认值为0,n的默认值为str1.size()-pos,即所有字符<br>str1.insert(pos,args) 在pos之前插入args指定的字符,若pos不是下标而是迭代器,则返回指向第一个插入字符的迭代器<br>str1.erase(pos,len) 删除从pos开始的len个字符.len默认至末尾<br>str1.assign(args) 将str1字符替换为指定的args的字符<br>str1.append(args) 将args追加到str1,<br>str1.replace(range,args) 删除s中范围range内的字符,替换为args指定的字符.range或者是个下标和长度,或一堆迭代器<br>注:<br>以上args可以是下面格式:<br>a.str2  字符串str2<br>b.str2,pos,len 字符串str2中从pos开始的len个字<br>c.cp cp指向的以空字符结尾的字符数组<br>d.cp,len 从cp指向的字符数组的前len个字符<br>e.n,c n个字符c<br>f.b,e 迭代器的范围,不能是本身<br>g.初始化列表 花括号包围的,以逗号分隔的字符列表<br>而replace和insert的args形式取决于range和pos,以标号代替args.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">args</th>\n<th align=\"center\">replace(pos,len,args)</th>\n<th align=\"center\">replace(b,e,args)</th>\n<th align=\"center\">insert(pos,args)</th>\n<th align=\"center\">insert(iter,args)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">b.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">c.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">d.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">e.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n</tr>\n<tr>\n<td align=\"center\">f.</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n</tr>\n<tr>\n<td align=\"center\">g.</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n</tr>\n</tbody></table>\n<p>　　str1.find(args) 查找str1中args第一次出现的位置<br>　　str1.rfind(args) 查找str1中args最后一次出现的位置<br>　　str1.find_first_of(args) 在str1查找args中任意字符第一次出现的位置<br>　　str1.find_last_of(args) 在str1查找args中任意字符最后一次出现的位置<br>　　str1.find_first_not_of(args) 在str1查找第一个不在args中的字符<br>　　str1.find_last_not_of(args) 在str1查找最后一个不在args中的字符<br>　　注:<br>　　args可以是以下的格式:<br>　　c,pos  从str1中位置pos开始查找字符c.pos默认为0<br>　　str2,pos 从str1中位置pos开始查找字符串str2,pos默认为0<br>　　cp,pos 从str1中位置pos开始查找指针cp指向的C字符串.pos默认为0<br>　　cp,pos,n 从str1中查找指针cp指向的前n个字符.无默认值<br>　　str1.compare(args)<br>　　注:<br>　　args可以是以下格式:<br>　　str2 比较str1和str2<br>　　pos1,n1,str2 将str1中从pos1开始的n1个字符与str2字符进行比较<br>　　pos1,n1,str2,pos2,n2 将str1中从pos1开始的n1个字符与str2中从pos2开始的n2个字符串进行比较<br>　　cp 与C字符串比较<br>　　pos1,n1,cp ….<br>　　pos1,n1,cp,n2 ………………….C字符串cp指针指向的位置后的n2个字符串进行比较</p>\n<h1 id=\"string类型与数字的转换\"><a href=\"#string类型与数字的转换\" class=\"headerlink\" title=\"string类型与数字的转换\"></a>string类型与数字的转换</h1><p>to_string(num) 数字转换成string<br>stoi(s,p,b)<br>stol(s,p,b)<br>stoul(s,p,b)<br>stoll(s,p,b)<br>stoull(s,p,b)<br>注:返回类型为int,long,unsigned long,long long,unsigned long long,<br>   b一般表示十进制<br>   p为size_t指针,用来保存s字符中第一个非数值字符的下标,默认为0,即不保存下标<br>stof(s,p)<br>stod(s,p)<br>stold(s,p)<br>注:返回类型为float,double,long double<br>std::from_chars(start,end,result,base)</p>\n<h1 id=\"char-to-string\"><a href=\"#char-to-string\" class=\"headerlink\" title=\"char to string\"></a>char to string</h1><ul>\n<li><code>std::string(1,char_value)</code></li>\n</ul>\n<h1 id=\"std-format\"><a href=\"#std-format\" class=\"headerlink\" title=\"std::format\"></a>std::format</h1><p>提供python style的字符串构造</p>\n<h2 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;&#125;&quot;</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// &quot;3&quot;</span><br>std::format(<span class=\"hljs-string\">&quot;&#123;:b&#125;&quot;</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// &quot;101&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;:.1f&#125;&quot;</span>, <span class=\"hljs-number\">3.273</span>); <span class=\"hljs-comment\">// &quot;3.1&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;:&gt;6&#125;&quot;</span>, <span class=\"hljs-number\">3.27</span>); <span class=\"hljs-comment\">// &quot; 3.27&quot;</span><br>std::format(<span class=\"hljs-string\">&quot;&#123;:&lt;6&#125;&quot;</span>, <span class=\"hljs-number\">3.27</span>); <span class=\"hljs-comment\">// &quot;3.27 &quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"reordering\"><a href=\"#reordering\" class=\"headerlink\" title=\"reordering\"></a>reordering</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;1&#125; - &#123;0&#125;&quot;</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// &quot;3 - 1&quot; </span><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"cctype中的函数\"><a href=\"#cctype中的函数\" class=\"headerlink\" title=\"cctype中的函数\"></a>cctype中的函数</h1><p>isalnum() 参数为字母或数字,返回true<br>isalpha() 参数字母为字母,返回true<br>iscntrl() 参数为控制字符,返回true<br>isdigit() 参数为数字(0～9),返回true<br>isgraph() 参数为除空格外的打印字符,返回true<br>islower() 参数为小写字母,返回true<br>isprint() 参数为打印字符(包括空格),返回true<br>ispunct() 参数为标点符号,返回true<br>isspace() 参数为标准空白字符,如空格,进纸,换行符,回车,制表符,返回true<br>isupper() 参数为大写字母,返回true<br>isxdigit() 参数为十六进制数字,即0～9,a～f或A～F,返回true<br>tolower() 若是大写,返回其小写,否则返回该参数<br>toupper() 若是小写,返回其大写,否则返回该参数</p>\n<h1 id=\"C字符串的函数-cstring\"><a href=\"#C字符串的函数-cstring\" class=\"headerlink\" title=\"C字符串的函数(cstring)\"></a>C字符串的函数(cstring)</h1><p>strcpy(str1,str2)  复制str2到str1<br>strncpy(str1,str2,n) 把str2的前n字符拷贝到str1<br>strcat(str1,str2)  str2连接到str1后面<br>strncat(str1,str2,n) 把str2的前n字符连接到str1<br>strcmp(str1,str2) 比较两个字符串<br>strlen(str) 计算长度不包括结束标识符<br>3.<br>C字符类型与其他类型的转换<br>atof(str) 将字符串转换为float类型<br>atoi(str) 将字符串转换为int类型<br>itoa(num,str,10) 将int类型转换为字符串,10代表十进制<br>ltoa(num,str,10) 将long类型转换为字符串,10代表十进制<br>ultoa(num,str,10) 将unsigned long类型转换为字符串,10代表十进制<br>sprintf() 函数比上述三个更灵活,具体百度<br>以下三个都是浮点型转换为字符串<br>fcvt()<br>ecvt()<br>gcvt()<br>cppstr.c_str() string类型转换为C类型<br>C字符串可以直接赋值给string类型</p>\n<h1 id=\"string类型的操作-详见C-Primer-P323\"><a href=\"#string类型的操作-详见C-Primer-P323\" class=\"headerlink\" title=\"string类型的操作(详见C++Primer P323)\"></a>string类型的操作(详见C++Primer P323)</h1><p>str1.substr(pos,n) 返回一个string,包含s中从pos开始的n个字符的拷贝.pos的默认值为0,n的默认值为str1.size()-pos,即所有字符<br>str1.insert(pos,args) 在pos之前插入args指定的字符,若pos不是下标而是迭代器,则返回指向第一个插入字符的迭代器<br>str1.erase(pos,len) 删除从pos开始的len个字符.len默认至末尾<br>str1.assign(args) 将str1字符替换为指定的args的字符<br>str1.append(args) 将args追加到str1,<br>str1.replace(range,args) 删除s中范围range内的字符,替换为args指定的字符.range或者是个下标和长度,或一堆迭代器<br>注:<br>以上args可以是下面格式:<br>a.str2  字符串str2<br>b.str2,pos,len 字符串str2中从pos开始的len个字<br>c.cp cp指向的以空字符结尾的字符数组<br>d.cp,len 从cp指向的字符数组的前len个字符<br>e.n,c n个字符c<br>f.b,e 迭代器的范围,不能是本身<br>g.初始化列表 花括号包围的,以逗号分隔的字符列表<br>而replace和insert的args形式取决于range和pos,以标号代替args.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">args</th>\n<th align=\"center\">replace(pos,len,args)</th>\n<th align=\"center\">replace(b,e,args)</th>\n<th align=\"center\">insert(pos,args)</th>\n<th align=\"center\">insert(iter,args)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">b.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">c.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">d.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">e.</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n<td align=\"center\">y</td>\n</tr>\n<tr>\n<td align=\"center\">f.</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n</tr>\n<tr>\n<td align=\"center\">g.</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n<td align=\"center\">n</td>\n<td align=\"center\">y</td>\n</tr>\n</tbody></table>\n<p>　　str1.find(args) 查找str1中args第一次出现的位置<br>　　str1.rfind(args) 查找str1中args最后一次出现的位置<br>　　str1.find_first_of(args) 在str1查找args中任意字符第一次出现的位置<br>　　str1.find_last_of(args) 在str1查找args中任意字符最后一次出现的位置<br>　　str1.find_first_not_of(args) 在str1查找第一个不在args中的字符<br>　　str1.find_last_not_of(args) 在str1查找最后一个不在args中的字符<br>　　注:<br>　　args可以是以下的格式:<br>　　c,pos  从str1中位置pos开始查找字符c.pos默认为0<br>　　str2,pos 从str1中位置pos开始查找字符串str2,pos默认为0<br>　　cp,pos 从str1中位置pos开始查找指针cp指向的C字符串.pos默认为0<br>　　cp,pos,n 从str1中查找指针cp指向的前n个字符.无默认值<br>　　str1.compare(args)<br>　　注:<br>　　args可以是以下格式:<br>　　str2 比较str1和str2<br>　　pos1,n1,str2 将str1中从pos1开始的n1个字符与str2字符进行比较<br>　　pos1,n1,str2,pos2,n2 将str1中从pos1开始的n1个字符与str2中从pos2开始的n2个字符串进行比较<br>　　cp 与C字符串比较<br>　　pos1,n1,cp ….<br>　　pos1,n1,cp,n2 ………………….C字符串cp指针指向的位置后的n2个字符串进行比较</p>\n<h1 id=\"string类型与数字的转换\"><a href=\"#string类型与数字的转换\" class=\"headerlink\" title=\"string类型与数字的转换\"></a>string类型与数字的转换</h1><p>to_string(num) 数字转换成string<br>stoi(s,p,b)<br>stol(s,p,b)<br>stoul(s,p,b)<br>stoll(s,p,b)<br>stoull(s,p,b)<br>注:返回类型为int,long,unsigned long,long long,unsigned long long,<br>   b一般表示十进制<br>   p为size_t指针,用来保存s字符中第一个非数值字符的下标,默认为0,即不保存下标<br>stof(s,p)<br>stod(s,p)<br>stold(s,p)<br>注:返回类型为float,double,long double<br>std::from_chars(start,end,result,base)</p>\n<h1 id=\"char-to-string\"><a href=\"#char-to-string\" class=\"headerlink\" title=\"char to string\"></a>char to string</h1><ul>\n<li><code>std::string(1,char_value)</code></li>\n</ul>\n<h1 id=\"std-format\"><a href=\"#std-format\" class=\"headerlink\" title=\"std::format\"></a>std::format</h1><p>提供python style的字符串构造</p>\n<h2 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;&#125;&quot;</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// &quot;3&quot;</span><br>std::format(<span class=\"hljs-string\">&quot;&#123;:b&#125;&quot;</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// &quot;101&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;:.1f&#125;&quot;</span>, <span class=\"hljs-number\">3.273</span>); <span class=\"hljs-comment\">// &quot;3.1&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;:&gt;6&#125;&quot;</span>, <span class=\"hljs-number\">3.27</span>); <span class=\"hljs-comment\">// &quot; 3.27&quot;</span><br>std::format(<span class=\"hljs-string\">&quot;&#123;:&lt;6&#125;&quot;</span>, <span class=\"hljs-number\">3.27</span>); <span class=\"hljs-comment\">// &quot;3.27 &quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"reordering\"><a href=\"#reordering\" class=\"headerlink\" title=\"reordering\"></a>reordering</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::format(<span class=\"hljs-string\">&quot;&#123;1&#125; - &#123;0&#125;&quot;</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// &quot;3 - 1&quot; </span><br></code></pre></td></tr></table></figure>\n"},{"title":"定时器","date":"2023-10-31T14:16:17.000Z","banner_img":"/images/timer.jpeg","index_img":"/images/timer.jpeg","_content":"\n# SIGALRM信号\n## 配合setitimer\n```C++\n#include<stdio.h>\n#include<unistd.h>\n#include<signal.h>\n#include<sys/time.h>\n\nvoid timer_isr(int sig)\n{\n\tprintf(\"timer_isr: press 'c' and enter to exit:\\n\");\n}\nint main()\n{\n\tchar c;\n\tstruct itimerval mtimer;\n\tmtimer.it_value.tv_sec = 5;\n\tmtimer.it_value.tv_usec = 0;\n\tmtimer.it_interval.tv_sec = 2;\n\tmtimer.it_interval.tv_usec = 0;\n\tsignal(SIGALRM, timer_isr);\n\tsetitimer(ITIMER_REAL, &mtimer, NULL);\n\n\twhile (1){\n\t\tc = getchar();\n\t\tif (c =='c' || c == 'C'){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/定时器.md","raw":"---\ntitle: 定时器\ndate: 2023-10-31 22:16:17\ntags:\nbanner_img: /images/timer.jpeg\nindex_img: /images/timer.jpeg\n---\n\n# SIGALRM信号\n## 配合setitimer\n```C++\n#include<stdio.h>\n#include<unistd.h>\n#include<signal.h>\n#include<sys/time.h>\n\nvoid timer_isr(int sig)\n{\n\tprintf(\"timer_isr: press 'c' and enter to exit:\\n\");\n}\nint main()\n{\n\tchar c;\n\tstruct itimerval mtimer;\n\tmtimer.it_value.tv_sec = 5;\n\tmtimer.it_value.tv_usec = 0;\n\tmtimer.it_interval.tv_sec = 2;\n\tmtimer.it_interval.tv_usec = 0;\n\tsignal(SIGALRM, timer_isr);\n\tsetitimer(ITIMER_REAL, &mtimer, NULL);\n\n\twhile (1){\n\t\tc = getchar();\n\t\tif (c =='c' || c == 'C'){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"定时器","published":1,"updated":"2023-12-20T12:01:26.873Z","_id":"clq1yvi790022gwq263t15ci1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"SIGALRM信号\"><a href=\"#SIGALRM信号\" class=\"headerlink\" title=\"SIGALRM信号\"></a>SIGALRM信号</h1><h2 id=\"配合setitimer\"><a href=\"#配合setitimer\" class=\"headerlink\" title=\"配合setitimer\"></a>配合setitimer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;signal.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;sys/time.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_isr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> sig)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;timer_isr: press &#x27;c&#x27; and enter to exit:\\n&quot;</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">char</span> c;<br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">itimerval</span> mtimer;<br>\tmtimer.it_value.tv_sec = <span class=\"hljs-number\">5</span>;<br>\tmtimer.it_value.tv_usec = <span class=\"hljs-number\">0</span>;<br>\tmtimer.it_interval.tv_sec = <span class=\"hljs-number\">2</span>;<br>\tmtimer.it_interval.tv_usec = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-built_in\">signal</span>(SIGALRM, timer_isr);<br>\t<span class=\"hljs-built_in\">setitimer</span>(ITIMER_REAL, &amp;mtimer, <span class=\"hljs-literal\">NULL</span>);<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>)&#123;<br>\t\tc = <span class=\"hljs-built_in\">getchar</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (c ==<span class=\"hljs-string\">&#x27;c&#x27;</span> || c == <span class=\"hljs-string\">&#x27;C&#x27;</span>)&#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"SIGALRM信号\"><a href=\"#SIGALRM信号\" class=\"headerlink\" title=\"SIGALRM信号\"></a>SIGALRM信号</h1><h2 id=\"配合setitimer\"><a href=\"#配合setitimer\" class=\"headerlink\" title=\"配合setitimer\"></a>配合setitimer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;signal.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;sys/time.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_isr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> sig)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;timer_isr: press &#x27;c&#x27; and enter to exit:\\n&quot;</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">char</span> c;<br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">itimerval</span> mtimer;<br>\tmtimer.it_value.tv_sec = <span class=\"hljs-number\">5</span>;<br>\tmtimer.it_value.tv_usec = <span class=\"hljs-number\">0</span>;<br>\tmtimer.it_interval.tv_sec = <span class=\"hljs-number\">2</span>;<br>\tmtimer.it_interval.tv_usec = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-built_in\">signal</span>(SIGALRM, timer_isr);<br>\t<span class=\"hljs-built_in\">setitimer</span>(ITIMER_REAL, &amp;mtimer, <span class=\"hljs-literal\">NULL</span>);<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>)&#123;<br>\t\tc = <span class=\"hljs-built_in\">getchar</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (c ==<span class=\"hljs-string\">&#x27;c&#x27;</span> || c == <span class=\"hljs-string\">&#x27;C&#x27;</span>)&#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"归档和备份命令","date":"2020-11-19T10:58:46.000Z","subtitle":null,"index_img":"/images/tar.jpg","banner_img":"/images/tar.jpg","_content":"## 压缩命令\n### gzip\n格式:`gzip [选项] [file]`,注意这不会保留原文件,默认输出为原文件加'.gz'后,同样解压缩也不会保留原压缩文件,注意只能对文件而不能对文件夹压缩,要走出这个误区\n\n|选项|说明|\n|:-:|:-:|\n|-c|把输出写入到标注输出,并保留原始文件,注意要生成压缩文件,必须重定向到一个文件,这个选项就是这么令人费解|\n|-d|解压缩,等价于gunzip|\n|-f|强制压缩,即使原始文件已经被压缩|\n|-h|显示用法信息|\n|-k|保留原文件|\n|-l|列出每个被压缩文件的压缩数据|\n|-r|若命令的一个或多个参数是目录,则递归地压缩目录中的文件|\n|-t|测试压缩文件的完整性|\n|-v|显示压缩过程的信息|\n|-[number]|设置压缩指数,[number]为1(最快,最小压缩)到9(最慢,最大压缩),默认为6|\n\n**例子:**\n`gunzip -c foo.txt.gz | less`这可以不解压直接查看内容\n\n### bzip2\nbzip2程序程序和gzip一样,但是不支持`-r`递归选项,同时它压缩率更大,速度更慢\n\n## 归档tar\n.tar为普通的tar包,.tgz为压缩过的tar包\n格式:`tar [options] [destination] [target]`\n\n|options|作用|\n|:-:|:-:|\n|c|Create创建新归档文件,存在则覆盖|\n|t|Table列表,磁带文件名列表|\n|d|磁带与文件系统的不同|\n|r|添加文件至磁带末尾|\n|u|只添加更新的文件|\n|x|extract抽取,抽取文件|\n|v|verbose冗长|\n|f|必须指定归档文件名,必须包含该选项|\n|z|gzip算法压缩|\n|j|bzip2算法压缩|\n\n`--wildcards`\n提取某个文件而不是全部(见例子)时一般不支持文件通配符,可通过--wildcards来支持,如:\n`tar xf xx.tar --wildcards 'home/me/dir-\\*/file'`\n`--file-from(-T)`\n这个选项导致tar命令从一个文件而不是命令行来读入它的路径名列表,可以是标准输入,例如:\n`find ~ -name 'file-A'| tar cf - --files-from= -| gzip >playground.tgz`\n注意上面这个例子中第一个'-'表示标准输出,第二个则是标准输入(广泛用于其他程序),上面可以不用第二个管道,直接加个z选项即可,如下:\n`find playground -name 'file-A' | tar czf playground.tgz -T -`\n#### 举例:\n`tar cvf my.tar *.[ch] makefile`不压缩创建\n`tar xvf tar_file -C destination_direectory`提取文件至指定文件夹\n`tar xf my.tar home/file`只提取归档文件某一文件(前提归档文件里必须有)\n\n## 归档和压缩二合一\n- 格式:`zip [options] [destination] [origin]`\n- 对于目录必须加-r选项,否则只是空目录,它最优化决定是否压缩文件\n- 对于中文字符无法显示：`unzip -O GB18030 XXX.zip`\n### -@选项\n用来接受从标准输入的列表,例:\n`find playground -name \"fileA\" | zip -@ file-A.zip`\n### 例子:\n`unzip -l playground.zip playground/fileA`列出指定一个文件夹\n`unzip playground.zip playground/fileA`提取指定一个文件夹\n\n## 同步rsync\n格式:`rsync [options] [source] [destination]`\nrsync会比较两者差异,最小化的复制修改以同步\n这里source和destination是下列选项之一:\n·一个本地文件或目录\n·一个远端文件或目录,以[user@]host:path的形式存在\n·一个远端rsync服务器,由rsync://[user@]host[:port]/path指定\nsource和destination至少有一个本地文件,不支持远端到远端\n### 远程同步\n#### SSH协议\nrsync默认使用ssh协议,如果想传递ssh命令的附加参数,必须使用-e选项,如:\n`rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination`\n#### rsync协议\n如果另一台服务器安装并运行了rsync守护程序,则可以用该协议(默认端口873),具体写法是服务器与目标目录间使用冒号分割:\n`rsync -av source/ 192.168.122.32::module/destination`\n上面地址中的module并不是实际路径名,而是rsync守护程序指定的一个资源名,由管理员分配。\n如果想知道rsync守护程序分配的所有module列表,可以执行下面命令:\n`rsync rsync://192.168.122.32`\n除了双冒号,也可以直接使用rsync://协议指定地址:\n`rsync -av source/ rsync://192.168.122.32/module/destination`\n#### 增量备份\n除了源目录与目标目录直接比较,rsync还支持使用基准目录,即将源目录与基准目录之间变动的部分,同步到目标目录。\n具体做法,第一次同步是全量备份,所有文件在基准目录里同步一份。以后每一次同步都是增量备份,只同步源目录与基准目录之间有变动的部分,将这部分保存在一个新的目标目录。这个新的目标目录之中,也是包含所有文件,但实际上,只有那些变动过的文件是存在于该目录,其他没有变动的文件都是指向基准目录文件的硬链接。\n--link-dest参数用来指定同步时的基准目录:\n`rsync -a --delete --link-dest /compare/path source/path /target/path`\n下面是个备份用户的主目录脚本:\n```bash\n#!/bin/bash\nset -o errexit\nset -o nounset\nset -o pipefail\n\nreadonly SOURCE_DIR=\"$(HOME)\"\nreadonly BACKUP_DIR=\"/mnt/data/backups\"\nreadonly DATETIME=\"$(date '+%Y-%m-%d_%H:%M:%S')\"\nreadonly BACKUP_PATH=\"${BACKUP_DIR}/${DATETIME}\"\nreadonly LATEST_LINK=\"${BACKUP_DIR}/latest\"\n\nmkdir -p \"${BACKUP_DIR}\"\n\nrsync -av --delete \\\n\t\"${SOURCE_DIR}/\" \\\n\t--link-dest \"${LATEST_LINK}\" \\\n\t--exclude=\".cache\" \\\n\t\"${BACKUP_PATH}\"\n\n#注意删除硬链接,只有最后为1时,才真正删除,因为i真正备份里有个指向链接,所以不会删除真正的文件\nrm -rf \"${LATEST_LINK}\"\n#注意下面是软连接,也就是说基准文件为最新的备份文件\n#我的疑惑,为啥非要用中间目录,直接比较不行吗?不是脱裤放屁吗?\nln -s \"${BACKUP_PATH}\" \"${LATEST_LINK}\"\n```\n\n|选项|含义|\n|:-:|:-:|\n|-a|不仅递归同步,还可以同步元信息(比如修改时间、权限等),软连接也会同步过去|\n|--append|参数指定文件接着上次中断的地方,继续传输|\n|--append-verify|与--append参数类似,但会对传输完成后的文件进行一次校验,如果校验失败,将重新发送整个文件|\n|-b|指定在删除或更新目标目录已经存在的文件时,将该文件更名后进行备份,默认行为是删除。更名规则是由--suffix参数指定的文件后缀名,默认是'\\~'|\n|--backup-dir|参数指定文件备份时存放的目录,比如`--backup-dir=/path/to/backups`|\n|--bwlimit|参数指定带宽限制,默认是kb/s,比如`--bwlimit=100`|\n|-c|默认情况下,rsync只检查文件的大小和最后修改日期是否发生变化,如果发生变化,就重新传输,使用这个参数以后,则通过判断文件内容的校验和,决定是否重新传输|\n|-delete|参数删除只存在与目标目录,不存在于源目标文件,即保证目标目录是源目标的镜像|\n|-e|参数指定使用SSH协议传输数据|\n|--exclude|指定排除不进行同步的文件,详细用法见下|\n|--exclude-from|参数指定一个本地文件,里面是需要排除的文件模式,每个模式一行|\n|--existing、--ignore-non-existing|参数表示不同步目标目录中不存在的文件和目录|\n|-h|略|\n|-i|参数表示输出源目录与目标目录之间文件差异详细情况|\n|--ignore-existing|参数表示只要该文件在目标目录中已经存在,就跳过去,不再同步这些文件|\n|--include|一般与--exclude结合使用,同步时要包括的文件|\n|--link-dest|参数指定增量备份的基准目录|\n|-m|指定不同步空目录|\n|--max-size|参数设置传输的最大文件的大小限制,比如不超过200kb`--max-size='200k'`|\n|--min-size|参数设置传输的最大文件的大小限制,比如不小于200kb`--min-size='200k'`|\n|-n|模拟将要执行的操作,而不真的执行,配合-v参数使用看哪些内容同步过去|\n|-P|--progress和--partial这两个参数的结合|\n|--partial|允许恢复中断中断的传输。不使用该参数时,rsync会删除传输到一般被打断的文件,使用该参数后,传输到一般的文件也会同步到目标目录,下次同步时再恢复中断的传输,一般要与--append或--append-verify配合使用|\n|--partial-dir|参数指定将传输到一半的文件保存到一个临时目录,比如`--partial-dir=rsync-partial`,一般要与--append或--append-verify配合使用|\n|--progress|表示显示进度|\n|-r|表示递归|\n|--remove-source-files|表示传输成功后,删除源文件|\n|--size-only|表示只同步大小有变化的文件,不考虑文件修改时间的的差异|\n|--suffix|参数指定文件名备份时,对文件名添加的后缀,默认是\\~|\n|-u|表示同步时跳过目标目录中修改时间更新的文件,即不同步这些有更新的时间戳文件|\n|-v,-vv,-vvv|表示输出细节,v越多越详细|\n|--version|略|\n|-z|指定同步时压缩数据|\n\n#### --exclude和--include参数示范\n```bash\nrsync -av --exclude='*.txt' source/ destination\nrsync -av --exclude '*.txt' source/ destination\nrsync -av --exclude 'file.txt' --exclude 'dir1/*' source/ destination\nrsync -av --exclude={'file1.txt','dir1/*'} source/ destination\nrsync -av --exclude-from='exclude-file.txt' source/ destination\nrsync -av --include=\"*.txt\" --exclude='*' source/ destination\n```\n","source":"_posts/归档和备份命令.md","raw":"---\ntitle: 归档和备份命令\ndate: 2020-11-19 18:58:46\nsubtitle:\ncategories:\ntags:\nindex_img: /images/tar.jpg\nbanner_img: /images/tar.jpg\n---\n## 压缩命令\n### gzip\n格式:`gzip [选项] [file]`,注意这不会保留原文件,默认输出为原文件加'.gz'后,同样解压缩也不会保留原压缩文件,注意只能对文件而不能对文件夹压缩,要走出这个误区\n\n|选项|说明|\n|:-:|:-:|\n|-c|把输出写入到标注输出,并保留原始文件,注意要生成压缩文件,必须重定向到一个文件,这个选项就是这么令人费解|\n|-d|解压缩,等价于gunzip|\n|-f|强制压缩,即使原始文件已经被压缩|\n|-h|显示用法信息|\n|-k|保留原文件|\n|-l|列出每个被压缩文件的压缩数据|\n|-r|若命令的一个或多个参数是目录,则递归地压缩目录中的文件|\n|-t|测试压缩文件的完整性|\n|-v|显示压缩过程的信息|\n|-[number]|设置压缩指数,[number]为1(最快,最小压缩)到9(最慢,最大压缩),默认为6|\n\n**例子:**\n`gunzip -c foo.txt.gz | less`这可以不解压直接查看内容\n\n### bzip2\nbzip2程序程序和gzip一样,但是不支持`-r`递归选项,同时它压缩率更大,速度更慢\n\n## 归档tar\n.tar为普通的tar包,.tgz为压缩过的tar包\n格式:`tar [options] [destination] [target]`\n\n|options|作用|\n|:-:|:-:|\n|c|Create创建新归档文件,存在则覆盖|\n|t|Table列表,磁带文件名列表|\n|d|磁带与文件系统的不同|\n|r|添加文件至磁带末尾|\n|u|只添加更新的文件|\n|x|extract抽取,抽取文件|\n|v|verbose冗长|\n|f|必须指定归档文件名,必须包含该选项|\n|z|gzip算法压缩|\n|j|bzip2算法压缩|\n\n`--wildcards`\n提取某个文件而不是全部(见例子)时一般不支持文件通配符,可通过--wildcards来支持,如:\n`tar xf xx.tar --wildcards 'home/me/dir-\\*/file'`\n`--file-from(-T)`\n这个选项导致tar命令从一个文件而不是命令行来读入它的路径名列表,可以是标准输入,例如:\n`find ~ -name 'file-A'| tar cf - --files-from= -| gzip >playground.tgz`\n注意上面这个例子中第一个'-'表示标准输出,第二个则是标准输入(广泛用于其他程序),上面可以不用第二个管道,直接加个z选项即可,如下:\n`find playground -name 'file-A' | tar czf playground.tgz -T -`\n#### 举例:\n`tar cvf my.tar *.[ch] makefile`不压缩创建\n`tar xvf tar_file -C destination_direectory`提取文件至指定文件夹\n`tar xf my.tar home/file`只提取归档文件某一文件(前提归档文件里必须有)\n\n## 归档和压缩二合一\n- 格式:`zip [options] [destination] [origin]`\n- 对于目录必须加-r选项,否则只是空目录,它最优化决定是否压缩文件\n- 对于中文字符无法显示：`unzip -O GB18030 XXX.zip`\n### -@选项\n用来接受从标准输入的列表,例:\n`find playground -name \"fileA\" | zip -@ file-A.zip`\n### 例子:\n`unzip -l playground.zip playground/fileA`列出指定一个文件夹\n`unzip playground.zip playground/fileA`提取指定一个文件夹\n\n## 同步rsync\n格式:`rsync [options] [source] [destination]`\nrsync会比较两者差异,最小化的复制修改以同步\n这里source和destination是下列选项之一:\n·一个本地文件或目录\n·一个远端文件或目录,以[user@]host:path的形式存在\n·一个远端rsync服务器,由rsync://[user@]host[:port]/path指定\nsource和destination至少有一个本地文件,不支持远端到远端\n### 远程同步\n#### SSH协议\nrsync默认使用ssh协议,如果想传递ssh命令的附加参数,必须使用-e选项,如:\n`rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination`\n#### rsync协议\n如果另一台服务器安装并运行了rsync守护程序,则可以用该协议(默认端口873),具体写法是服务器与目标目录间使用冒号分割:\n`rsync -av source/ 192.168.122.32::module/destination`\n上面地址中的module并不是实际路径名,而是rsync守护程序指定的一个资源名,由管理员分配。\n如果想知道rsync守护程序分配的所有module列表,可以执行下面命令:\n`rsync rsync://192.168.122.32`\n除了双冒号,也可以直接使用rsync://协议指定地址:\n`rsync -av source/ rsync://192.168.122.32/module/destination`\n#### 增量备份\n除了源目录与目标目录直接比较,rsync还支持使用基准目录,即将源目录与基准目录之间变动的部分,同步到目标目录。\n具体做法,第一次同步是全量备份,所有文件在基准目录里同步一份。以后每一次同步都是增量备份,只同步源目录与基准目录之间有变动的部分,将这部分保存在一个新的目标目录。这个新的目标目录之中,也是包含所有文件,但实际上,只有那些变动过的文件是存在于该目录,其他没有变动的文件都是指向基准目录文件的硬链接。\n--link-dest参数用来指定同步时的基准目录:\n`rsync -a --delete --link-dest /compare/path source/path /target/path`\n下面是个备份用户的主目录脚本:\n```bash\n#!/bin/bash\nset -o errexit\nset -o nounset\nset -o pipefail\n\nreadonly SOURCE_DIR=\"$(HOME)\"\nreadonly BACKUP_DIR=\"/mnt/data/backups\"\nreadonly DATETIME=\"$(date '+%Y-%m-%d_%H:%M:%S')\"\nreadonly BACKUP_PATH=\"${BACKUP_DIR}/${DATETIME}\"\nreadonly LATEST_LINK=\"${BACKUP_DIR}/latest\"\n\nmkdir -p \"${BACKUP_DIR}\"\n\nrsync -av --delete \\\n\t\"${SOURCE_DIR}/\" \\\n\t--link-dest \"${LATEST_LINK}\" \\\n\t--exclude=\".cache\" \\\n\t\"${BACKUP_PATH}\"\n\n#注意删除硬链接,只有最后为1时,才真正删除,因为i真正备份里有个指向链接,所以不会删除真正的文件\nrm -rf \"${LATEST_LINK}\"\n#注意下面是软连接,也就是说基准文件为最新的备份文件\n#我的疑惑,为啥非要用中间目录,直接比较不行吗?不是脱裤放屁吗?\nln -s \"${BACKUP_PATH}\" \"${LATEST_LINK}\"\n```\n\n|选项|含义|\n|:-:|:-:|\n|-a|不仅递归同步,还可以同步元信息(比如修改时间、权限等),软连接也会同步过去|\n|--append|参数指定文件接着上次中断的地方,继续传输|\n|--append-verify|与--append参数类似,但会对传输完成后的文件进行一次校验,如果校验失败,将重新发送整个文件|\n|-b|指定在删除或更新目标目录已经存在的文件时,将该文件更名后进行备份,默认行为是删除。更名规则是由--suffix参数指定的文件后缀名,默认是'\\~'|\n|--backup-dir|参数指定文件备份时存放的目录,比如`--backup-dir=/path/to/backups`|\n|--bwlimit|参数指定带宽限制,默认是kb/s,比如`--bwlimit=100`|\n|-c|默认情况下,rsync只检查文件的大小和最后修改日期是否发生变化,如果发生变化,就重新传输,使用这个参数以后,则通过判断文件内容的校验和,决定是否重新传输|\n|-delete|参数删除只存在与目标目录,不存在于源目标文件,即保证目标目录是源目标的镜像|\n|-e|参数指定使用SSH协议传输数据|\n|--exclude|指定排除不进行同步的文件,详细用法见下|\n|--exclude-from|参数指定一个本地文件,里面是需要排除的文件模式,每个模式一行|\n|--existing、--ignore-non-existing|参数表示不同步目标目录中不存在的文件和目录|\n|-h|略|\n|-i|参数表示输出源目录与目标目录之间文件差异详细情况|\n|--ignore-existing|参数表示只要该文件在目标目录中已经存在,就跳过去,不再同步这些文件|\n|--include|一般与--exclude结合使用,同步时要包括的文件|\n|--link-dest|参数指定增量备份的基准目录|\n|-m|指定不同步空目录|\n|--max-size|参数设置传输的最大文件的大小限制,比如不超过200kb`--max-size='200k'`|\n|--min-size|参数设置传输的最大文件的大小限制,比如不小于200kb`--min-size='200k'`|\n|-n|模拟将要执行的操作,而不真的执行,配合-v参数使用看哪些内容同步过去|\n|-P|--progress和--partial这两个参数的结合|\n|--partial|允许恢复中断中断的传输。不使用该参数时,rsync会删除传输到一般被打断的文件,使用该参数后,传输到一般的文件也会同步到目标目录,下次同步时再恢复中断的传输,一般要与--append或--append-verify配合使用|\n|--partial-dir|参数指定将传输到一半的文件保存到一个临时目录,比如`--partial-dir=rsync-partial`,一般要与--append或--append-verify配合使用|\n|--progress|表示显示进度|\n|-r|表示递归|\n|--remove-source-files|表示传输成功后,删除源文件|\n|--size-only|表示只同步大小有变化的文件,不考虑文件修改时间的的差异|\n|--suffix|参数指定文件名备份时,对文件名添加的后缀,默认是\\~|\n|-u|表示同步时跳过目标目录中修改时间更新的文件,即不同步这些有更新的时间戳文件|\n|-v,-vv,-vvv|表示输出细节,v越多越详细|\n|--version|略|\n|-z|指定同步时压缩数据|\n\n#### --exclude和--include参数示范\n```bash\nrsync -av --exclude='*.txt' source/ destination\nrsync -av --exclude '*.txt' source/ destination\nrsync -av --exclude 'file.txt' --exclude 'dir1/*' source/ destination\nrsync -av --exclude={'file1.txt','dir1/*'} source/ destination\nrsync -av --exclude-from='exclude-file.txt' source/ destination\nrsync -av --include=\"*.txt\" --exclude='*' source/ destination\n```\n","slug":"归档和备份命令","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi790025gwq2e1o37ie4","content":"<h2 id=\"压缩命令\"><a href=\"#压缩命令\" class=\"headerlink\" title=\"压缩命令\"></a>压缩命令</h2><h3 id=\"gzip\"><a href=\"#gzip\" class=\"headerlink\" title=\"gzip\"></a>gzip</h3><p>格式:<code>gzip [选项] [file]</code>,注意这不会保留原文件,默认输出为原文件加’.gz’后,同样解压缩也不会保留原压缩文件,注意只能对文件而不能对文件夹压缩,要走出这个误区</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">把输出写入到标注输出,并保留原始文件,注意要生成压缩文件,必须重定向到一个文件,这个选项就是这么令人费解</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">解压缩,等价于gunzip</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">强制压缩,即使原始文件已经被压缩</td>\n</tr>\n<tr>\n<td align=\"center\">-h</td>\n<td align=\"center\">显示用法信息</td>\n</tr>\n<tr>\n<td align=\"center\">-k</td>\n<td align=\"center\">保留原文件</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">列出每个被压缩文件的压缩数据</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">若命令的一个或多个参数是目录,则递归地压缩目录中的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">测试压缩文件的完整性</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">显示压缩过程的信息</td>\n</tr>\n<tr>\n<td align=\"center\">-[number]</td>\n<td align=\"center\">设置压缩指数,[number]为1(最快,最小压缩)到9(最慢,最大压缩),默认为6</td>\n</tr>\n</tbody></table>\n<p><strong>例子:</strong><br><code>gunzip -c foo.txt.gz | less</code>这可以不解压直接查看内容</p>\n<h3 id=\"bzip2\"><a href=\"#bzip2\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h3><p>bzip2程序程序和gzip一样,但是不支持<code>-r</code>递归选项,同时它压缩率更大,速度更慢</p>\n<h2 id=\"归档tar\"><a href=\"#归档tar\" class=\"headerlink\" title=\"归档tar\"></a>归档tar</h2><p>.tar为普通的tar包,.tgz为压缩过的tar包<br>格式:<code>tar [options] [destination] [target]</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">options</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">c</td>\n<td align=\"center\">Create创建新归档文件,存在则覆盖</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">Table列表,磁带文件名列表</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">磁带与文件系统的不同</td>\n</tr>\n<tr>\n<td align=\"center\">r</td>\n<td align=\"center\">添加文件至磁带末尾</td>\n</tr>\n<tr>\n<td align=\"center\">u</td>\n<td align=\"center\">只添加更新的文件</td>\n</tr>\n<tr>\n<td align=\"center\">x</td>\n<td align=\"center\">extract抽取,抽取文件</td>\n</tr>\n<tr>\n<td align=\"center\">v</td>\n<td align=\"center\">verbose冗长</td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">必须指定归档文件名,必须包含该选项</td>\n</tr>\n<tr>\n<td align=\"center\">z</td>\n<td align=\"center\">gzip算法压缩</td>\n</tr>\n<tr>\n<td align=\"center\">j</td>\n<td align=\"center\">bzip2算法压缩</td>\n</tr>\n</tbody></table>\n<p><code>--wildcards</code><br>提取某个文件而不是全部(见例子)时一般不支持文件通配符,可通过–wildcards来支持,如:<br><code>tar xf xx.tar --wildcards &#39;home/me/dir-\\*/file&#39;</code><br><code>--file-from(-T)</code><br>这个选项导致tar命令从一个文件而不是命令行来读入它的路径名列表,可以是标准输入,例如:<br><code>find ~ -name &#39;file-A&#39;| tar cf - --files-from= -| gzip &gt;playground.tgz</code><br>注意上面这个例子中第一个’-‘表示标准输出,第二个则是标准输入(广泛用于其他程序),上面可以不用第二个管道,直接加个z选项即可,如下:<br><code>find playground -name &#39;file-A&#39; | tar czf playground.tgz -T -</code></p>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例:\"></a>举例:</h4><p><code>tar cvf my.tar *.[ch] makefile</code>不压缩创建<br><code>tar xvf tar_file -C destination_direectory</code>提取文件至指定文件夹<br><code>tar xf my.tar home/file</code>只提取归档文件某一文件(前提归档文件里必须有)</p>\n<h2 id=\"归档和压缩二合一\"><a href=\"#归档和压缩二合一\" class=\"headerlink\" title=\"归档和压缩二合一\"></a>归档和压缩二合一</h2><ul>\n<li>格式:<code>zip [options] [destination] [origin]</code></li>\n<li>对于目录必须加-r选项,否则只是空目录,它最优化决定是否压缩文件</li>\n<li>对于中文字符无法显示：<code>unzip -O GB18030 XXX.zip</code></li>\n</ul>\n<h3 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"-@选项\"></a>-@选项</h3><p>用来接受从标准输入的列表,例:<br><code>find playground -name &quot;fileA&quot; | zip -@ file-A.zip</code></p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子:\"></a>例子:</h3><p><code>unzip -l playground.zip playground/fileA</code>列出指定一个文件夹<br><code>unzip playground.zip playground/fileA</code>提取指定一个文件夹</p>\n<h2 id=\"同步rsync\"><a href=\"#同步rsync\" class=\"headerlink\" title=\"同步rsync\"></a>同步rsync</h2><p>格式:<code>rsync [options] [source] [destination]</code><br>rsync会比较两者差异,最小化的复制修改以同步<br>这里source和destination是下列选项之一:<br>·一个本地文件或目录<br>·一个远端文件或目录,以[user@]host:path的形式存在<br>·一个远端rsync服务器,由rsync:&#x2F;&#x2F;[user@]host[:port]&#x2F;path指定<br>source和destination至少有一个本地文件,不支持远端到远端</p>\n<h3 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h3><h4 id=\"SSH协议\"><a href=\"#SSH协议\" class=\"headerlink\" title=\"SSH协议\"></a>SSH协议</h4><p>rsync默认使用ssh协议,如果想传递ssh命令的附加参数,必须使用-e选项,如:<br><code>rsync -av -e &#39;ssh -p 2234&#39; source/ user@remote_host:/destination</code></p>\n<h4 id=\"rsync协议\"><a href=\"#rsync协议\" class=\"headerlink\" title=\"rsync协议\"></a>rsync协议</h4><p>如果另一台服务器安装并运行了rsync守护程序,则可以用该协议(默认端口873),具体写法是服务器与目标目录间使用冒号分割:<br><code>rsync -av source/ 192.168.122.32::module/destination</code><br>上面地址中的module并不是实际路径名,而是rsync守护程序指定的一个资源名,由管理员分配。<br>如果想知道rsync守护程序分配的所有module列表,可以执行下面命令:<br><code>rsync rsync://192.168.122.32</code><br>除了双冒号,也可以直接使用rsync:&#x2F;&#x2F;协议指定地址:<br><code>rsync -av source/ rsync://192.168.122.32/module/destination</code></p>\n<h4 id=\"增量备份\"><a href=\"#增量备份\" class=\"headerlink\" title=\"增量备份\"></a>增量备份</h4><p>除了源目录与目标目录直接比较,rsync还支持使用基准目录,即将源目录与基准目录之间变动的部分,同步到目标目录。<br>具体做法,第一次同步是全量备份,所有文件在基准目录里同步一份。以后每一次同步都是增量备份,只同步源目录与基准目录之间有变动的部分,将这部分保存在一个新的目标目录。这个新的目标目录之中,也是包含所有文件,但实际上,只有那些变动过的文件是存在于该目录,其他没有变动的文件都是指向基准目录文件的硬链接。<br>–link-dest参数用来指定同步时的基准目录:<br><code>rsync -a --delete --link-dest /compare/path source/path /target/path</code><br>下面是个备份用户的主目录脚本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-built_in\">set</span> -o errexit<br><span class=\"hljs-built_in\">set</span> -o nounset<br><span class=\"hljs-built_in\">set</span> -o pipefail<br><br><span class=\"hljs-built_in\">readonly</span> SOURCE_DIR=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(HOME)</span>&quot;</span><br><span class=\"hljs-built_in\">readonly</span> BACKUP_DIR=<span class=\"hljs-string\">&quot;/mnt/data/backups&quot;</span><br><span class=\"hljs-built_in\">readonly</span> DATETIME=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(date &#x27;+%Y-%m-%d_%H:%M:%S&#x27;)</span>&quot;</span><br><span class=\"hljs-built_in\">readonly</span> BACKUP_PATH=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_DIR&#125;</span>/<span class=\"hljs-variable\">$&#123;DATETIME&#125;</span>&quot;</span><br><span class=\"hljs-built_in\">readonly</span> LATEST_LINK=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_DIR&#125;</span>/latest&quot;</span><br><br><span class=\"hljs-built_in\">mkdir</span> -p <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_DIR&#125;</span>&quot;</span><br><br>rsync -av --delete \\<br>\t<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;SOURCE_DIR&#125;</span>/&quot;</span> \\<br>\t--link-dest <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;LATEST_LINK&#125;</span>&quot;</span> \\<br>\t--exclude=<span class=\"hljs-string\">&quot;.cache&quot;</span> \\<br>\t<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_PATH&#125;</span>&quot;</span><br><br><span class=\"hljs-comment\">#注意删除硬链接,只有最后为1时,才真正删除,因为i真正备份里有个指向链接,所以不会删除真正的文件</span><br><span class=\"hljs-built_in\">rm</span> -rf <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;LATEST_LINK&#125;</span>&quot;</span><br><span class=\"hljs-comment\">#注意下面是软连接,也就是说基准文件为最新的备份文件</span><br><span class=\"hljs-comment\">#我的疑惑,为啥非要用中间目录,直接比较不行吗?不是脱裤放屁吗?</span><br><span class=\"hljs-built_in\">ln</span> -s <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_PATH&#125;</span>&quot;</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;LATEST_LINK&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">不仅递归同步,还可以同步元信息(比如修改时间、权限等),软连接也会同步过去</td>\n</tr>\n<tr>\n<td align=\"center\">–append</td>\n<td align=\"center\">参数指定文件接着上次中断的地方,继续传输</td>\n</tr>\n<tr>\n<td align=\"center\">–append-verify</td>\n<td align=\"center\">与–append参数类似,但会对传输完成后的文件进行一次校验,如果校验失败,将重新发送整个文件</td>\n</tr>\n<tr>\n<td align=\"center\">-b</td>\n<td align=\"center\">指定在删除或更新目标目录已经存在的文件时,将该文件更名后进行备份,默认行为是删除。更名规则是由–suffix参数指定的文件后缀名,默认是’~‘</td>\n</tr>\n<tr>\n<td align=\"center\">–backup-dir</td>\n<td align=\"center\">参数指定文件备份时存放的目录,比如<code>--backup-dir=/path/to/backups</code></td>\n</tr>\n<tr>\n<td align=\"center\">–bwlimit</td>\n<td align=\"center\">参数指定带宽限制,默认是kb&#x2F;s,比如<code>--bwlimit=100</code></td>\n</tr>\n<tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">默认情况下,rsync只检查文件的大小和最后修改日期是否发生变化,如果发生变化,就重新传输,使用这个参数以后,则通过判断文件内容的校验和,决定是否重新传输</td>\n</tr>\n<tr>\n<td align=\"center\">-delete</td>\n<td align=\"center\">参数删除只存在与目标目录,不存在于源目标文件,即保证目标目录是源目标的镜像</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">参数指定使用SSH协议传输数据</td>\n</tr>\n<tr>\n<td align=\"center\">–exclude</td>\n<td align=\"center\">指定排除不进行同步的文件,详细用法见下</td>\n</tr>\n<tr>\n<td align=\"center\">–exclude-from</td>\n<td align=\"center\">参数指定一个本地文件,里面是需要排除的文件模式,每个模式一行</td>\n</tr>\n<tr>\n<td align=\"center\">–existing、–ignore-non-existing</td>\n<td align=\"center\">参数表示不同步目标目录中不存在的文件和目录</td>\n</tr>\n<tr>\n<td align=\"center\">-h</td>\n<td align=\"center\">略</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">参数表示输出源目录与目标目录之间文件差异详细情况</td>\n</tr>\n<tr>\n<td align=\"center\">–ignore-existing</td>\n<td align=\"center\">参数表示只要该文件在目标目录中已经存在,就跳过去,不再同步这些文件</td>\n</tr>\n<tr>\n<td align=\"center\">–include</td>\n<td align=\"center\">一般与–exclude结合使用,同步时要包括的文件</td>\n</tr>\n<tr>\n<td align=\"center\">–link-dest</td>\n<td align=\"center\">参数指定增量备份的基准目录</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">指定不同步空目录</td>\n</tr>\n<tr>\n<td align=\"center\">–max-size</td>\n<td align=\"center\">参数设置传输的最大文件的大小限制,比如不超过200kb<code>--max-size=&#39;200k&#39;</code></td>\n</tr>\n<tr>\n<td align=\"center\">–min-size</td>\n<td align=\"center\">参数设置传输的最大文件的大小限制,比如不小于200kb<code>--min-size=&#39;200k&#39;</code></td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">模拟将要执行的操作,而不真的执行,配合-v参数使用看哪些内容同步过去</td>\n</tr>\n<tr>\n<td align=\"center\">-P</td>\n<td align=\"center\">–progress和–partial这两个参数的结合</td>\n</tr>\n<tr>\n<td align=\"center\">–partial</td>\n<td align=\"center\">允许恢复中断中断的传输。不使用该参数时,rsync会删除传输到一般被打断的文件,使用该参数后,传输到一般的文件也会同步到目标目录,下次同步时再恢复中断的传输,一般要与–append或–append-verify配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">–partial-dir</td>\n<td align=\"center\">参数指定将传输到一半的文件保存到一个临时目录,比如<code>--partial-dir=rsync-partial</code>,一般要与–append或–append-verify配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">–progress</td>\n<td align=\"center\">表示显示进度</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">表示递归</td>\n</tr>\n<tr>\n<td align=\"center\">–remove-source-files</td>\n<td align=\"center\">表示传输成功后,删除源文件</td>\n</tr>\n<tr>\n<td align=\"center\">–size-only</td>\n<td align=\"center\">表示只同步大小有变化的文件,不考虑文件修改时间的的差异</td>\n</tr>\n<tr>\n<td align=\"center\">–suffix</td>\n<td align=\"center\">参数指定文件名备份时,对文件名添加的后缀,默认是~</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">表示同步时跳过目标目录中修改时间更新的文件,即不同步这些有更新的时间戳文件</td>\n</tr>\n<tr>\n<td align=\"center\">-v,-vv,-vvv</td>\n<td align=\"center\">表示输出细节,v越多越详细</td>\n</tr>\n<tr>\n<td align=\"center\">–version</td>\n<td align=\"center\">略</td>\n</tr>\n<tr>\n<td align=\"center\">-z</td>\n<td align=\"center\">指定同步时压缩数据</td>\n</tr>\n</tbody></table>\n<h4 id=\"–exclude和–include参数示范\"><a href=\"#–exclude和–include参数示范\" class=\"headerlink\" title=\"–exclude和–include参数示范\"></a>–exclude和–include参数示范</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">rsync -av --exclude=<span class=\"hljs-string\">&#x27;*.txt&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude <span class=\"hljs-string\">&#x27;file.txt&#x27;</span> --exclude <span class=\"hljs-string\">&#x27;dir1/*&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude=&#123;<span class=\"hljs-string\">&#x27;file1.txt&#x27;</span>,<span class=\"hljs-string\">&#x27;dir1/*&#x27;</span>&#125; <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude-from=<span class=\"hljs-string\">&#x27;exclude-file.txt&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --include=<span class=\"hljs-string\">&quot;*.txt&quot;</span> --exclude=<span class=\"hljs-string\">&#x27;*&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"压缩命令\"><a href=\"#压缩命令\" class=\"headerlink\" title=\"压缩命令\"></a>压缩命令</h2><h3 id=\"gzip\"><a href=\"#gzip\" class=\"headerlink\" title=\"gzip\"></a>gzip</h3><p>格式:<code>gzip [选项] [file]</code>,注意这不会保留原文件,默认输出为原文件加’.gz’后,同样解压缩也不会保留原压缩文件,注意只能对文件而不能对文件夹压缩,要走出这个误区</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">把输出写入到标注输出,并保留原始文件,注意要生成压缩文件,必须重定向到一个文件,这个选项就是这么令人费解</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">解压缩,等价于gunzip</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">强制压缩,即使原始文件已经被压缩</td>\n</tr>\n<tr>\n<td align=\"center\">-h</td>\n<td align=\"center\">显示用法信息</td>\n</tr>\n<tr>\n<td align=\"center\">-k</td>\n<td align=\"center\">保留原文件</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">列出每个被压缩文件的压缩数据</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">若命令的一个或多个参数是目录,则递归地压缩目录中的文件</td>\n</tr>\n<tr>\n<td align=\"center\">-t</td>\n<td align=\"center\">测试压缩文件的完整性</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">显示压缩过程的信息</td>\n</tr>\n<tr>\n<td align=\"center\">-[number]</td>\n<td align=\"center\">设置压缩指数,[number]为1(最快,最小压缩)到9(最慢,最大压缩),默认为6</td>\n</tr>\n</tbody></table>\n<p><strong>例子:</strong><br><code>gunzip -c foo.txt.gz | less</code>这可以不解压直接查看内容</p>\n<h3 id=\"bzip2\"><a href=\"#bzip2\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h3><p>bzip2程序程序和gzip一样,但是不支持<code>-r</code>递归选项,同时它压缩率更大,速度更慢</p>\n<h2 id=\"归档tar\"><a href=\"#归档tar\" class=\"headerlink\" title=\"归档tar\"></a>归档tar</h2><p>.tar为普通的tar包,.tgz为压缩过的tar包<br>格式:<code>tar [options] [destination] [target]</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">options</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">c</td>\n<td align=\"center\">Create创建新归档文件,存在则覆盖</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">Table列表,磁带文件名列表</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">磁带与文件系统的不同</td>\n</tr>\n<tr>\n<td align=\"center\">r</td>\n<td align=\"center\">添加文件至磁带末尾</td>\n</tr>\n<tr>\n<td align=\"center\">u</td>\n<td align=\"center\">只添加更新的文件</td>\n</tr>\n<tr>\n<td align=\"center\">x</td>\n<td align=\"center\">extract抽取,抽取文件</td>\n</tr>\n<tr>\n<td align=\"center\">v</td>\n<td align=\"center\">verbose冗长</td>\n</tr>\n<tr>\n<td align=\"center\">f</td>\n<td align=\"center\">必须指定归档文件名,必须包含该选项</td>\n</tr>\n<tr>\n<td align=\"center\">z</td>\n<td align=\"center\">gzip算法压缩</td>\n</tr>\n<tr>\n<td align=\"center\">j</td>\n<td align=\"center\">bzip2算法压缩</td>\n</tr>\n</tbody></table>\n<p><code>--wildcards</code><br>提取某个文件而不是全部(见例子)时一般不支持文件通配符,可通过–wildcards来支持,如:<br><code>tar xf xx.tar --wildcards &#39;home/me/dir-\\*/file&#39;</code><br><code>--file-from(-T)</code><br>这个选项导致tar命令从一个文件而不是命令行来读入它的路径名列表,可以是标准输入,例如:<br><code>find ~ -name &#39;file-A&#39;| tar cf - --files-from= -| gzip &gt;playground.tgz</code><br>注意上面这个例子中第一个’-‘表示标准输出,第二个则是标准输入(广泛用于其他程序),上面可以不用第二个管道,直接加个z选项即可,如下:<br><code>find playground -name &#39;file-A&#39; | tar czf playground.tgz -T -</code></p>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例:\"></a>举例:</h4><p><code>tar cvf my.tar *.[ch] makefile</code>不压缩创建<br><code>tar xvf tar_file -C destination_direectory</code>提取文件至指定文件夹<br><code>tar xf my.tar home/file</code>只提取归档文件某一文件(前提归档文件里必须有)</p>\n<h2 id=\"归档和压缩二合一\"><a href=\"#归档和压缩二合一\" class=\"headerlink\" title=\"归档和压缩二合一\"></a>归档和压缩二合一</h2><ul>\n<li>格式:<code>zip [options] [destination] [origin]</code></li>\n<li>对于目录必须加-r选项,否则只是空目录,它最优化决定是否压缩文件</li>\n<li>对于中文字符无法显示：<code>unzip -O GB18030 XXX.zip</code></li>\n</ul>\n<h3 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"-@选项\"></a>-@选项</h3><p>用来接受从标准输入的列表,例:<br><code>find playground -name &quot;fileA&quot; | zip -@ file-A.zip</code></p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子:\"></a>例子:</h3><p><code>unzip -l playground.zip playground/fileA</code>列出指定一个文件夹<br><code>unzip playground.zip playground/fileA</code>提取指定一个文件夹</p>\n<h2 id=\"同步rsync\"><a href=\"#同步rsync\" class=\"headerlink\" title=\"同步rsync\"></a>同步rsync</h2><p>格式:<code>rsync [options] [source] [destination]</code><br>rsync会比较两者差异,最小化的复制修改以同步<br>这里source和destination是下列选项之一:<br>·一个本地文件或目录<br>·一个远端文件或目录,以[user@]host:path的形式存在<br>·一个远端rsync服务器,由rsync:&#x2F;&#x2F;[user@]host[:port]&#x2F;path指定<br>source和destination至少有一个本地文件,不支持远端到远端</p>\n<h3 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h3><h4 id=\"SSH协议\"><a href=\"#SSH协议\" class=\"headerlink\" title=\"SSH协议\"></a>SSH协议</h4><p>rsync默认使用ssh协议,如果想传递ssh命令的附加参数,必须使用-e选项,如:<br><code>rsync -av -e &#39;ssh -p 2234&#39; source/ user@remote_host:/destination</code></p>\n<h4 id=\"rsync协议\"><a href=\"#rsync协议\" class=\"headerlink\" title=\"rsync协议\"></a>rsync协议</h4><p>如果另一台服务器安装并运行了rsync守护程序,则可以用该协议(默认端口873),具体写法是服务器与目标目录间使用冒号分割:<br><code>rsync -av source/ 192.168.122.32::module/destination</code><br>上面地址中的module并不是实际路径名,而是rsync守护程序指定的一个资源名,由管理员分配。<br>如果想知道rsync守护程序分配的所有module列表,可以执行下面命令:<br><code>rsync rsync://192.168.122.32</code><br>除了双冒号,也可以直接使用rsync:&#x2F;&#x2F;协议指定地址:<br><code>rsync -av source/ rsync://192.168.122.32/module/destination</code></p>\n<h4 id=\"增量备份\"><a href=\"#增量备份\" class=\"headerlink\" title=\"增量备份\"></a>增量备份</h4><p>除了源目录与目标目录直接比较,rsync还支持使用基准目录,即将源目录与基准目录之间变动的部分,同步到目标目录。<br>具体做法,第一次同步是全量备份,所有文件在基准目录里同步一份。以后每一次同步都是增量备份,只同步源目录与基准目录之间有变动的部分,将这部分保存在一个新的目标目录。这个新的目标目录之中,也是包含所有文件,但实际上,只有那些变动过的文件是存在于该目录,其他没有变动的文件都是指向基准目录文件的硬链接。<br>–link-dest参数用来指定同步时的基准目录:<br><code>rsync -a --delete --link-dest /compare/path source/path /target/path</code><br>下面是个备份用户的主目录脚本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-built_in\">set</span> -o errexit<br><span class=\"hljs-built_in\">set</span> -o nounset<br><span class=\"hljs-built_in\">set</span> -o pipefail<br><br><span class=\"hljs-built_in\">readonly</span> SOURCE_DIR=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(HOME)</span>&quot;</span><br><span class=\"hljs-built_in\">readonly</span> BACKUP_DIR=<span class=\"hljs-string\">&quot;/mnt/data/backups&quot;</span><br><span class=\"hljs-built_in\">readonly</span> DATETIME=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(date &#x27;+%Y-%m-%d_%H:%M:%S&#x27;)</span>&quot;</span><br><span class=\"hljs-built_in\">readonly</span> BACKUP_PATH=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_DIR&#125;</span>/<span class=\"hljs-variable\">$&#123;DATETIME&#125;</span>&quot;</span><br><span class=\"hljs-built_in\">readonly</span> LATEST_LINK=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_DIR&#125;</span>/latest&quot;</span><br><br><span class=\"hljs-built_in\">mkdir</span> -p <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_DIR&#125;</span>&quot;</span><br><br>rsync -av --delete \\<br>\t<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;SOURCE_DIR&#125;</span>/&quot;</span> \\<br>\t--link-dest <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;LATEST_LINK&#125;</span>&quot;</span> \\<br>\t--exclude=<span class=\"hljs-string\">&quot;.cache&quot;</span> \\<br>\t<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_PATH&#125;</span>&quot;</span><br><br><span class=\"hljs-comment\">#注意删除硬链接,只有最后为1时,才真正删除,因为i真正备份里有个指向链接,所以不会删除真正的文件</span><br><span class=\"hljs-built_in\">rm</span> -rf <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;LATEST_LINK&#125;</span>&quot;</span><br><span class=\"hljs-comment\">#注意下面是软连接,也就是说基准文件为最新的备份文件</span><br><span class=\"hljs-comment\">#我的疑惑,为啥非要用中间目录,直接比较不行吗?不是脱裤放屁吗?</span><br><span class=\"hljs-built_in\">ln</span> -s <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;BACKUP_PATH&#125;</span>&quot;</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;LATEST_LINK&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">不仅递归同步,还可以同步元信息(比如修改时间、权限等),软连接也会同步过去</td>\n</tr>\n<tr>\n<td align=\"center\">–append</td>\n<td align=\"center\">参数指定文件接着上次中断的地方,继续传输</td>\n</tr>\n<tr>\n<td align=\"center\">–append-verify</td>\n<td align=\"center\">与–append参数类似,但会对传输完成后的文件进行一次校验,如果校验失败,将重新发送整个文件</td>\n</tr>\n<tr>\n<td align=\"center\">-b</td>\n<td align=\"center\">指定在删除或更新目标目录已经存在的文件时,将该文件更名后进行备份,默认行为是删除。更名规则是由–suffix参数指定的文件后缀名,默认是’~‘</td>\n</tr>\n<tr>\n<td align=\"center\">–backup-dir</td>\n<td align=\"center\">参数指定文件备份时存放的目录,比如<code>--backup-dir=/path/to/backups</code></td>\n</tr>\n<tr>\n<td align=\"center\">–bwlimit</td>\n<td align=\"center\">参数指定带宽限制,默认是kb&#x2F;s,比如<code>--bwlimit=100</code></td>\n</tr>\n<tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">默认情况下,rsync只检查文件的大小和最后修改日期是否发生变化,如果发生变化,就重新传输,使用这个参数以后,则通过判断文件内容的校验和,决定是否重新传输</td>\n</tr>\n<tr>\n<td align=\"center\">-delete</td>\n<td align=\"center\">参数删除只存在与目标目录,不存在于源目标文件,即保证目标目录是源目标的镜像</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">参数指定使用SSH协议传输数据</td>\n</tr>\n<tr>\n<td align=\"center\">–exclude</td>\n<td align=\"center\">指定排除不进行同步的文件,详细用法见下</td>\n</tr>\n<tr>\n<td align=\"center\">–exclude-from</td>\n<td align=\"center\">参数指定一个本地文件,里面是需要排除的文件模式,每个模式一行</td>\n</tr>\n<tr>\n<td align=\"center\">–existing、–ignore-non-existing</td>\n<td align=\"center\">参数表示不同步目标目录中不存在的文件和目录</td>\n</tr>\n<tr>\n<td align=\"center\">-h</td>\n<td align=\"center\">略</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">参数表示输出源目录与目标目录之间文件差异详细情况</td>\n</tr>\n<tr>\n<td align=\"center\">–ignore-existing</td>\n<td align=\"center\">参数表示只要该文件在目标目录中已经存在,就跳过去,不再同步这些文件</td>\n</tr>\n<tr>\n<td align=\"center\">–include</td>\n<td align=\"center\">一般与–exclude结合使用,同步时要包括的文件</td>\n</tr>\n<tr>\n<td align=\"center\">–link-dest</td>\n<td align=\"center\">参数指定增量备份的基准目录</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"center\">指定不同步空目录</td>\n</tr>\n<tr>\n<td align=\"center\">–max-size</td>\n<td align=\"center\">参数设置传输的最大文件的大小限制,比如不超过200kb<code>--max-size=&#39;200k&#39;</code></td>\n</tr>\n<tr>\n<td align=\"center\">–min-size</td>\n<td align=\"center\">参数设置传输的最大文件的大小限制,比如不小于200kb<code>--min-size=&#39;200k&#39;</code></td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">模拟将要执行的操作,而不真的执行,配合-v参数使用看哪些内容同步过去</td>\n</tr>\n<tr>\n<td align=\"center\">-P</td>\n<td align=\"center\">–progress和–partial这两个参数的结合</td>\n</tr>\n<tr>\n<td align=\"center\">–partial</td>\n<td align=\"center\">允许恢复中断中断的传输。不使用该参数时,rsync会删除传输到一般被打断的文件,使用该参数后,传输到一般的文件也会同步到目标目录,下次同步时再恢复中断的传输,一般要与–append或–append-verify配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">–partial-dir</td>\n<td align=\"center\">参数指定将传输到一半的文件保存到一个临时目录,比如<code>--partial-dir=rsync-partial</code>,一般要与–append或–append-verify配合使用</td>\n</tr>\n<tr>\n<td align=\"center\">–progress</td>\n<td align=\"center\">表示显示进度</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">表示递归</td>\n</tr>\n<tr>\n<td align=\"center\">–remove-source-files</td>\n<td align=\"center\">表示传输成功后,删除源文件</td>\n</tr>\n<tr>\n<td align=\"center\">–size-only</td>\n<td align=\"center\">表示只同步大小有变化的文件,不考虑文件修改时间的的差异</td>\n</tr>\n<tr>\n<td align=\"center\">–suffix</td>\n<td align=\"center\">参数指定文件名备份时,对文件名添加的后缀,默认是~</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">表示同步时跳过目标目录中修改时间更新的文件,即不同步这些有更新的时间戳文件</td>\n</tr>\n<tr>\n<td align=\"center\">-v,-vv,-vvv</td>\n<td align=\"center\">表示输出细节,v越多越详细</td>\n</tr>\n<tr>\n<td align=\"center\">–version</td>\n<td align=\"center\">略</td>\n</tr>\n<tr>\n<td align=\"center\">-z</td>\n<td align=\"center\">指定同步时压缩数据</td>\n</tr>\n</tbody></table>\n<h4 id=\"–exclude和–include参数示范\"><a href=\"#–exclude和–include参数示范\" class=\"headerlink\" title=\"–exclude和–include参数示范\"></a>–exclude和–include参数示范</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">rsync -av --exclude=<span class=\"hljs-string\">&#x27;*.txt&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude <span class=\"hljs-string\">&#x27;file.txt&#x27;</span> --exclude <span class=\"hljs-string\">&#x27;dir1/*&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude=&#123;<span class=\"hljs-string\">&#x27;file1.txt&#x27;</span>,<span class=\"hljs-string\">&#x27;dir1/*&#x27;</span>&#125; <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --exclude-from=<span class=\"hljs-string\">&#x27;exclude-file.txt&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br>rsync -av --include=<span class=\"hljs-string\">&quot;*.txt&quot;</span> --exclude=<span class=\"hljs-string\">&#x27;*&#x27;</span> <span class=\"hljs-built_in\">source</span>/ destination<br></code></pre></td></tr></table></figure>\n"},{"title":"文件系统与存储","date":"2021-10-21T13:06:28.000Z","subtitle":null,"index_img":"/images/filesystem.jpg","banner_img":"/images/filesystem.jpg","_content":"原始磁盘->创建分区(划分磁盘)->在各个分区上创建文件系统->挂载文件系统\n### 创建分区->fdisk和cfdisk\ncfdisk更加界面友好一点\n* 查看当前系统所有设备`fdisk -l`\n* 对某个设备进行分区`fdisk [设备名]`或`cfdisk [设备名]`,注意设备名后面不加数字,加数字的都是该设备上的某分区,如:**/dev/sda是设备,/dev/sda1则是已分好的分区**,(之后进入工具,有关知识待实践)\n\n### 创建文件系统->mkfs.*\n目前流行的系统有:ext4(mkfs.ext4),zfs(mkfs.zfs),btrfs(mkfs.btrfs)\n`mkfs.* [分区名]`分区名有数字,这会格式化分区后建文件系统\n\n### 挂载文件系统->mount\n`mount -t [ext4、zfs、btrfs] [设备名] [目录]`把已经建好文件系统的分区挂载到指定目录\n\n### 文件系统的检查与修复->fsck\nfsck检查文件系统时,文件系统必须未挂载,fsck使用/etc/fstab文件自动检查文件系统类型,如果/etc/fstab里没有该文件系统分区的信息,需要加-t选项指明文件系统类型,如下:\n`fsck -t ext4 /dev/sdb1`\n\n## 逻辑卷\n逻辑卷可以把不同物理设备上的分区,结合起来,动态增加文件系统大小:下面是类比\n物理卷(实质上是各个原始分区)->卷组(多个物理卷)->逻辑卷(在卷组基础上加上逻辑关联,新成整体)。\n物理设备->某个原始分区->文件系统。\nLinux系统将一个逻辑卷视为一个物理分区,格式化一个文件系统后可以挂载\n\n### pvcreate转化物理分区为物理卷\n`sudo pvcreate /dev/sdb1`这实际只是标记该分区为一个物理卷\n`sudo pvdisplay /dev/sdb1`显示物理卷的详细信息\n\n### vgcreate创建卷组\n`sudo vgcreate Vol1 /dev/sdb1 /dev/sdx`将两个物理卷创建到一个卷组\n`sudo vgdisplay Vol1`查看卷组信息\n\n### lvcreate创建逻辑卷\n`sudo lvcreate -l 100%FREE -n lvtest Vol1`在卷组上创建逻辑卷,-l制定多少可用的卷组空间,以百分比表示,-L选项以字节为单位,-n制定逻辑卷的名字,更多选项看man(有待研究)\n`sudo lvdisplay Vol1`查看逻辑卷\n\n### 创建文件系统\n`sudo mkfs.ext4 /dev/Vol1/lvtest`创建文件系统\n`sudo mount /dev/Vol1/lvtest /mnt`挂载\n注意:路径中同时指明了卷组名和逻辑卷名\n\n### 修改逻辑卷(待建)\n* vgchange 激活和禁用卷组\n* vgremove 删除卷组\n* vgextend 将物理卷加到卷组中\n* vgreduce 从卷组中删除物理卷\n* lvextend 增加逻辑卷的大小\n* lvreduce 减小逻辑卷的大小\n\n## 一些tips\n\n### windows下U盘只读不可写问题\na.`df -h`查找挂载点\nb.`sudo umount 位置`卸载U盘而不拔掉\nc.`sudo dosfsck -v -a 文件系统分区(如:/dev/sdb1)`修复故障\nd.`sudo mount 文件系统 挂载点`重新挂载\n\n### 自动挂载磁盘:\n　a.`fdisk -l`查看可挂载磁盘\n　b.`df -h`查看已挂载的磁盘\n　c.`blkid`获取目标磁盘的uuid和属性\n　d.`vi /etc/fstab`添加开机mount,格式:UUID=xx /home/nanbert/disk ext4 defaults 1 1 \n\n### 从现有文件创建映像文件\n`genisoimage -o cd-rom.iso -R -J ~/cd-rom-files`\n\n### CD-ROM\n清除一张CD-ROM\n`wodim dev=/dev/cdrw blank=fast`\n写入一个映像文件进CD-ROM\n`wodim dev=/dev/cdrw image.iso`\n\n### 挂载某个镜像\n`sudo mount xx.iso -o loop /mnt`\n","source":"_posts/文件系统与存储.md","raw":"---\ntitle: 文件系统与存储\ndate: 2021-10-21 21:06:28\nsubtitle:\ncategories:\ntags:\nindex_img: /images/filesystem.jpg\nbanner_img: /images/filesystem.jpg\n---\n原始磁盘->创建分区(划分磁盘)->在各个分区上创建文件系统->挂载文件系统\n### 创建分区->fdisk和cfdisk\ncfdisk更加界面友好一点\n* 查看当前系统所有设备`fdisk -l`\n* 对某个设备进行分区`fdisk [设备名]`或`cfdisk [设备名]`,注意设备名后面不加数字,加数字的都是该设备上的某分区,如:**/dev/sda是设备,/dev/sda1则是已分好的分区**,(之后进入工具,有关知识待实践)\n\n### 创建文件系统->mkfs.*\n目前流行的系统有:ext4(mkfs.ext4),zfs(mkfs.zfs),btrfs(mkfs.btrfs)\n`mkfs.* [分区名]`分区名有数字,这会格式化分区后建文件系统\n\n### 挂载文件系统->mount\n`mount -t [ext4、zfs、btrfs] [设备名] [目录]`把已经建好文件系统的分区挂载到指定目录\n\n### 文件系统的检查与修复->fsck\nfsck检查文件系统时,文件系统必须未挂载,fsck使用/etc/fstab文件自动检查文件系统类型,如果/etc/fstab里没有该文件系统分区的信息,需要加-t选项指明文件系统类型,如下:\n`fsck -t ext4 /dev/sdb1`\n\n## 逻辑卷\n逻辑卷可以把不同物理设备上的分区,结合起来,动态增加文件系统大小:下面是类比\n物理卷(实质上是各个原始分区)->卷组(多个物理卷)->逻辑卷(在卷组基础上加上逻辑关联,新成整体)。\n物理设备->某个原始分区->文件系统。\nLinux系统将一个逻辑卷视为一个物理分区,格式化一个文件系统后可以挂载\n\n### pvcreate转化物理分区为物理卷\n`sudo pvcreate /dev/sdb1`这实际只是标记该分区为一个物理卷\n`sudo pvdisplay /dev/sdb1`显示物理卷的详细信息\n\n### vgcreate创建卷组\n`sudo vgcreate Vol1 /dev/sdb1 /dev/sdx`将两个物理卷创建到一个卷组\n`sudo vgdisplay Vol1`查看卷组信息\n\n### lvcreate创建逻辑卷\n`sudo lvcreate -l 100%FREE -n lvtest Vol1`在卷组上创建逻辑卷,-l制定多少可用的卷组空间,以百分比表示,-L选项以字节为单位,-n制定逻辑卷的名字,更多选项看man(有待研究)\n`sudo lvdisplay Vol1`查看逻辑卷\n\n### 创建文件系统\n`sudo mkfs.ext4 /dev/Vol1/lvtest`创建文件系统\n`sudo mount /dev/Vol1/lvtest /mnt`挂载\n注意:路径中同时指明了卷组名和逻辑卷名\n\n### 修改逻辑卷(待建)\n* vgchange 激活和禁用卷组\n* vgremove 删除卷组\n* vgextend 将物理卷加到卷组中\n* vgreduce 从卷组中删除物理卷\n* lvextend 增加逻辑卷的大小\n* lvreduce 减小逻辑卷的大小\n\n## 一些tips\n\n### windows下U盘只读不可写问题\na.`df -h`查找挂载点\nb.`sudo umount 位置`卸载U盘而不拔掉\nc.`sudo dosfsck -v -a 文件系统分区(如:/dev/sdb1)`修复故障\nd.`sudo mount 文件系统 挂载点`重新挂载\n\n### 自动挂载磁盘:\n　a.`fdisk -l`查看可挂载磁盘\n　b.`df -h`查看已挂载的磁盘\n　c.`blkid`获取目标磁盘的uuid和属性\n　d.`vi /etc/fstab`添加开机mount,格式:UUID=xx /home/nanbert/disk ext4 defaults 1 1 \n\n### 从现有文件创建映像文件\n`genisoimage -o cd-rom.iso -R -J ~/cd-rom-files`\n\n### CD-ROM\n清除一张CD-ROM\n`wodim dev=/dev/cdrw blank=fast`\n写入一个映像文件进CD-ROM\n`wodim dev=/dev/cdrw image.iso`\n\n### 挂载某个镜像\n`sudo mount xx.iso -o loop /mnt`\n","slug":"文件系统与存储","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi7a0029gwq27mhifnwj","content":"<p>原始磁盘-&gt;创建分区(划分磁盘)-&gt;在各个分区上创建文件系统-&gt;挂载文件系统</p>\n<h3 id=\"创建分区-fdisk和cfdisk\"><a href=\"#创建分区-fdisk和cfdisk\" class=\"headerlink\" title=\"创建分区-&gt;fdisk和cfdisk\"></a>创建分区-&gt;fdisk和cfdisk</h3><p>cfdisk更加界面友好一点</p>\n<ul>\n<li>查看当前系统所有设备<code>fdisk -l</code></li>\n<li>对某个设备进行分区<code>fdisk [设备名]</code>或<code>cfdisk [设备名]</code>,注意设备名后面不加数字,加数字的都是该设备上的某分区,如:<strong>&#x2F;dev&#x2F;sda是设备,&#x2F;dev&#x2F;sda1则是已分好的分区</strong>,(之后进入工具,有关知识待实践)</li>\n</ul>\n<h3 id=\"创建文件系统-mkfs\"><a href=\"#创建文件系统-mkfs\" class=\"headerlink\" title=\"创建文件系统-&gt;mkfs.*\"></a>创建文件系统-&gt;mkfs.*</h3><p>目前流行的系统有:ext4(mkfs.ext4),zfs(mkfs.zfs),btrfs(mkfs.btrfs)<br><code>mkfs.* [分区名]</code>分区名有数字,这会格式化分区后建文件系统</p>\n<h3 id=\"挂载文件系统-mount\"><a href=\"#挂载文件系统-mount\" class=\"headerlink\" title=\"挂载文件系统-&gt;mount\"></a>挂载文件系统-&gt;mount</h3><p><code>mount -t [ext4、zfs、btrfs] [设备名] [目录]</code>把已经建好文件系统的分区挂载到指定目录</p>\n<h3 id=\"文件系统的检查与修复-fsck\"><a href=\"#文件系统的检查与修复-fsck\" class=\"headerlink\" title=\"文件系统的检查与修复-&gt;fsck\"></a>文件系统的检查与修复-&gt;fsck</h3><p>fsck检查文件系统时,文件系统必须未挂载,fsck使用&#x2F;etc&#x2F;fstab文件自动检查文件系统类型,如果&#x2F;etc&#x2F;fstab里没有该文件系统分区的信息,需要加-t选项指明文件系统类型,如下:<br><code>fsck -t ext4 /dev/sdb1</code></p>\n<h2 id=\"逻辑卷\"><a href=\"#逻辑卷\" class=\"headerlink\" title=\"逻辑卷\"></a>逻辑卷</h2><p>逻辑卷可以把不同物理设备上的分区,结合起来,动态增加文件系统大小:下面是类比<br>物理卷(实质上是各个原始分区)-&gt;卷组(多个物理卷)-&gt;逻辑卷(在卷组基础上加上逻辑关联,新成整体)。<br>物理设备-&gt;某个原始分区-&gt;文件系统。<br>Linux系统将一个逻辑卷视为一个物理分区,格式化一个文件系统后可以挂载</p>\n<h3 id=\"pvcreate转化物理分区为物理卷\"><a href=\"#pvcreate转化物理分区为物理卷\" class=\"headerlink\" title=\"pvcreate转化物理分区为物理卷\"></a>pvcreate转化物理分区为物理卷</h3><p><code>sudo pvcreate /dev/sdb1</code>这实际只是标记该分区为一个物理卷<br><code>sudo pvdisplay /dev/sdb1</code>显示物理卷的详细信息</p>\n<h3 id=\"vgcreate创建卷组\"><a href=\"#vgcreate创建卷组\" class=\"headerlink\" title=\"vgcreate创建卷组\"></a>vgcreate创建卷组</h3><p><code>sudo vgcreate Vol1 /dev/sdb1 /dev/sdx</code>将两个物理卷创建到一个卷组<br><code>sudo vgdisplay Vol1</code>查看卷组信息</p>\n<h3 id=\"lvcreate创建逻辑卷\"><a href=\"#lvcreate创建逻辑卷\" class=\"headerlink\" title=\"lvcreate创建逻辑卷\"></a>lvcreate创建逻辑卷</h3><p><code>sudo lvcreate -l 100%FREE -n lvtest Vol1</code>在卷组上创建逻辑卷,-l制定多少可用的卷组空间,以百分比表示,-L选项以字节为单位,-n制定逻辑卷的名字,更多选项看man(有待研究)<br><code>sudo lvdisplay Vol1</code>查看逻辑卷</p>\n<h3 id=\"创建文件系统\"><a href=\"#创建文件系统\" class=\"headerlink\" title=\"创建文件系统\"></a>创建文件系统</h3><p><code>sudo mkfs.ext4 /dev/Vol1/lvtest</code>创建文件系统<br><code>sudo mount /dev/Vol1/lvtest /mnt</code>挂载<br>注意:路径中同时指明了卷组名和逻辑卷名</p>\n<h3 id=\"修改逻辑卷-待建\"><a href=\"#修改逻辑卷-待建\" class=\"headerlink\" title=\"修改逻辑卷(待建)\"></a>修改逻辑卷(待建)</h3><ul>\n<li>vgchange 激活和禁用卷组</li>\n<li>vgremove 删除卷组</li>\n<li>vgextend 将物理卷加到卷组中</li>\n<li>vgreduce 从卷组中删除物理卷</li>\n<li>lvextend 增加逻辑卷的大小</li>\n<li>lvreduce 减小逻辑卷的大小</li>\n</ul>\n<h2 id=\"一些tips\"><a href=\"#一些tips\" class=\"headerlink\" title=\"一些tips\"></a>一些tips</h2><h3 id=\"windows下U盘只读不可写问题\"><a href=\"#windows下U盘只读不可写问题\" class=\"headerlink\" title=\"windows下U盘只读不可写问题\"></a>windows下U盘只读不可写问题</h3><p>a.<code>df -h</code>查找挂载点<br>b.<code>sudo umount 位置</code>卸载U盘而不拔掉<br>c.<code>sudo dosfsck -v -a 文件系统分区(如:/dev/sdb1)</code>修复故障<br>d.<code>sudo mount 文件系统 挂载点</code>重新挂载</p>\n<h3 id=\"自动挂载磁盘\"><a href=\"#自动挂载磁盘\" class=\"headerlink\" title=\"自动挂载磁盘:\"></a>自动挂载磁盘:</h3><p>　a.<code>fdisk -l</code>查看可挂载磁盘<br>　b.<code>df -h</code>查看已挂载的磁盘<br>　c.<code>blkid</code>获取目标磁盘的uuid和属性<br>　d.<code>vi /etc/fstab</code>添加开机mount,格式:UUID&#x3D;xx &#x2F;home&#x2F;nanbert&#x2F;disk ext4 defaults 1 1 </p>\n<h3 id=\"从现有文件创建映像文件\"><a href=\"#从现有文件创建映像文件\" class=\"headerlink\" title=\"从现有文件创建映像文件\"></a>从现有文件创建映像文件</h3><p><code>genisoimage -o cd-rom.iso -R -J ~/cd-rom-files</code></p>\n<h3 id=\"CD-ROM\"><a href=\"#CD-ROM\" class=\"headerlink\" title=\"CD-ROM\"></a>CD-ROM</h3><p>清除一张CD-ROM<br><code>wodim dev=/dev/cdrw blank=fast</code><br>写入一个映像文件进CD-ROM<br><code>wodim dev=/dev/cdrw image.iso</code></p>\n<h3 id=\"挂载某个镜像\"><a href=\"#挂载某个镜像\" class=\"headerlink\" title=\"挂载某个镜像\"></a>挂载某个镜像</h3><p><code>sudo mount xx.iso -o loop /mnt</code></p>\n","excerpt":"","more":"<p>原始磁盘-&gt;创建分区(划分磁盘)-&gt;在各个分区上创建文件系统-&gt;挂载文件系统</p>\n<h3 id=\"创建分区-fdisk和cfdisk\"><a href=\"#创建分区-fdisk和cfdisk\" class=\"headerlink\" title=\"创建分区-&gt;fdisk和cfdisk\"></a>创建分区-&gt;fdisk和cfdisk</h3><p>cfdisk更加界面友好一点</p>\n<ul>\n<li>查看当前系统所有设备<code>fdisk -l</code></li>\n<li>对某个设备进行分区<code>fdisk [设备名]</code>或<code>cfdisk [设备名]</code>,注意设备名后面不加数字,加数字的都是该设备上的某分区,如:<strong>&#x2F;dev&#x2F;sda是设备,&#x2F;dev&#x2F;sda1则是已分好的分区</strong>,(之后进入工具,有关知识待实践)</li>\n</ul>\n<h3 id=\"创建文件系统-mkfs\"><a href=\"#创建文件系统-mkfs\" class=\"headerlink\" title=\"创建文件系统-&gt;mkfs.*\"></a>创建文件系统-&gt;mkfs.*</h3><p>目前流行的系统有:ext4(mkfs.ext4),zfs(mkfs.zfs),btrfs(mkfs.btrfs)<br><code>mkfs.* [分区名]</code>分区名有数字,这会格式化分区后建文件系统</p>\n<h3 id=\"挂载文件系统-mount\"><a href=\"#挂载文件系统-mount\" class=\"headerlink\" title=\"挂载文件系统-&gt;mount\"></a>挂载文件系统-&gt;mount</h3><p><code>mount -t [ext4、zfs、btrfs] [设备名] [目录]</code>把已经建好文件系统的分区挂载到指定目录</p>\n<h3 id=\"文件系统的检查与修复-fsck\"><a href=\"#文件系统的检查与修复-fsck\" class=\"headerlink\" title=\"文件系统的检查与修复-&gt;fsck\"></a>文件系统的检查与修复-&gt;fsck</h3><p>fsck检查文件系统时,文件系统必须未挂载,fsck使用&#x2F;etc&#x2F;fstab文件自动检查文件系统类型,如果&#x2F;etc&#x2F;fstab里没有该文件系统分区的信息,需要加-t选项指明文件系统类型,如下:<br><code>fsck -t ext4 /dev/sdb1</code></p>\n<h2 id=\"逻辑卷\"><a href=\"#逻辑卷\" class=\"headerlink\" title=\"逻辑卷\"></a>逻辑卷</h2><p>逻辑卷可以把不同物理设备上的分区,结合起来,动态增加文件系统大小:下面是类比<br>物理卷(实质上是各个原始分区)-&gt;卷组(多个物理卷)-&gt;逻辑卷(在卷组基础上加上逻辑关联,新成整体)。<br>物理设备-&gt;某个原始分区-&gt;文件系统。<br>Linux系统将一个逻辑卷视为一个物理分区,格式化一个文件系统后可以挂载</p>\n<h3 id=\"pvcreate转化物理分区为物理卷\"><a href=\"#pvcreate转化物理分区为物理卷\" class=\"headerlink\" title=\"pvcreate转化物理分区为物理卷\"></a>pvcreate转化物理分区为物理卷</h3><p><code>sudo pvcreate /dev/sdb1</code>这实际只是标记该分区为一个物理卷<br><code>sudo pvdisplay /dev/sdb1</code>显示物理卷的详细信息</p>\n<h3 id=\"vgcreate创建卷组\"><a href=\"#vgcreate创建卷组\" class=\"headerlink\" title=\"vgcreate创建卷组\"></a>vgcreate创建卷组</h3><p><code>sudo vgcreate Vol1 /dev/sdb1 /dev/sdx</code>将两个物理卷创建到一个卷组<br><code>sudo vgdisplay Vol1</code>查看卷组信息</p>\n<h3 id=\"lvcreate创建逻辑卷\"><a href=\"#lvcreate创建逻辑卷\" class=\"headerlink\" title=\"lvcreate创建逻辑卷\"></a>lvcreate创建逻辑卷</h3><p><code>sudo lvcreate -l 100%FREE -n lvtest Vol1</code>在卷组上创建逻辑卷,-l制定多少可用的卷组空间,以百分比表示,-L选项以字节为单位,-n制定逻辑卷的名字,更多选项看man(有待研究)<br><code>sudo lvdisplay Vol1</code>查看逻辑卷</p>\n<h3 id=\"创建文件系统\"><a href=\"#创建文件系统\" class=\"headerlink\" title=\"创建文件系统\"></a>创建文件系统</h3><p><code>sudo mkfs.ext4 /dev/Vol1/lvtest</code>创建文件系统<br><code>sudo mount /dev/Vol1/lvtest /mnt</code>挂载<br>注意:路径中同时指明了卷组名和逻辑卷名</p>\n<h3 id=\"修改逻辑卷-待建\"><a href=\"#修改逻辑卷-待建\" class=\"headerlink\" title=\"修改逻辑卷(待建)\"></a>修改逻辑卷(待建)</h3><ul>\n<li>vgchange 激活和禁用卷组</li>\n<li>vgremove 删除卷组</li>\n<li>vgextend 将物理卷加到卷组中</li>\n<li>vgreduce 从卷组中删除物理卷</li>\n<li>lvextend 增加逻辑卷的大小</li>\n<li>lvreduce 减小逻辑卷的大小</li>\n</ul>\n<h2 id=\"一些tips\"><a href=\"#一些tips\" class=\"headerlink\" title=\"一些tips\"></a>一些tips</h2><h3 id=\"windows下U盘只读不可写问题\"><a href=\"#windows下U盘只读不可写问题\" class=\"headerlink\" title=\"windows下U盘只读不可写问题\"></a>windows下U盘只读不可写问题</h3><p>a.<code>df -h</code>查找挂载点<br>b.<code>sudo umount 位置</code>卸载U盘而不拔掉<br>c.<code>sudo dosfsck -v -a 文件系统分区(如:/dev/sdb1)</code>修复故障<br>d.<code>sudo mount 文件系统 挂载点</code>重新挂载</p>\n<h3 id=\"自动挂载磁盘\"><a href=\"#自动挂载磁盘\" class=\"headerlink\" title=\"自动挂载磁盘:\"></a>自动挂载磁盘:</h3><p>　a.<code>fdisk -l</code>查看可挂载磁盘<br>　b.<code>df -h</code>查看已挂载的磁盘<br>　c.<code>blkid</code>获取目标磁盘的uuid和属性<br>　d.<code>vi /etc/fstab</code>添加开机mount,格式:UUID&#x3D;xx &#x2F;home&#x2F;nanbert&#x2F;disk ext4 defaults 1 1 </p>\n<h3 id=\"从现有文件创建映像文件\"><a href=\"#从现有文件创建映像文件\" class=\"headerlink\" title=\"从现有文件创建映像文件\"></a>从现有文件创建映像文件</h3><p><code>genisoimage -o cd-rom.iso -R -J ~/cd-rom-files</code></p>\n<h3 id=\"CD-ROM\"><a href=\"#CD-ROM\" class=\"headerlink\" title=\"CD-ROM\"></a>CD-ROM</h3><p>清除一张CD-ROM<br><code>wodim dev=/dev/cdrw blank=fast</code><br>写入一个映像文件进CD-ROM<br><code>wodim dev=/dev/cdrw image.iso</code></p>\n<h3 id=\"挂载某个镜像\"><a href=\"#挂载某个镜像\" class=\"headerlink\" title=\"挂载某个镜像\"></a>挂载某个镜像</h3><p><code>sudo mount xx.iso -o loop /mnt</code></p>\n"},{"title":"文本处理瑞士军刀--小而强悍","date":"2020-11-21T09:50:14.000Z","subtitle":null,"index_img":"/images/knifes.jpg","banner_img":"/images/knifes.jpg","_content":"<font size=4>**1.cat命令**</font>\n\n|选项|说明|\n|:-:|:-:|\n|-A|用$表示每行的结尾,^I表示tab空格字符(是个判别空格和tab的方法)|\n|-n|显示行号|\n|-s|对于连续空行,只保留一行|\n\n**cat用例**\n`cat << END`接下来直到END之间的内容\n`cat > foo.txt`快捷新建foo.txt并输入内容,以ctrl-D结束\n`cat <<< filename`打印filename这个单词\n<font size=4>**2.sort命令**</font>\n\n|选项|说明|\n|:-:|:-:|\n|-b|忽略开头的空白字符,从第一个非空白字符进行排序|\n|-f|让排序忽略大小写|\n|-n|基于字符串的数值来排序,而不是字母值|\n|-r|降序排序|\n|-k [field1],[field2]|举例`-k 4,5`,根据[4,5]间的字符段对行进行排序,如果没有5,则只是根据第四个字符段进行行排序,字符段的分隔符默认为空,可以由-t来指定|\n|-t [char]|定义域分割字符,默认为空格或制表|\n|-u|去除比较相等的行,即便行内容不相等,如果比较结果相等(如只从第二个字符比较)改行也会被去除,|\n\n**-key选项的魅力**\n`sort -k 1,1 -k 2n foo.txt`先按第一个字段按字符串排序,如果第一字段相等,再2n表示第二个字段用数值排序,n和sort选项一样表示数值排序,同样还可以指定b(忽略开头的空格),r(逆向排序)\n考虑系列文本字段,如何以日期的格式降序排序呢\n```\n10/30/2008\n11/25/2008\n06/19/2008\n```\n\n简单用如下命令:\n`sort -k 1.7nbr -k 1.1nbr -k 1.4nbr xx.txt`表示先从第一个字段第7个字符开始进行排序,如果相等,再比较第一个字符开始的第一个字段开始排序,再者第四个字符开始排序\n**sort用例**\n`sort > foo.txt`同cat一样只不过对你输入的内容进行排序,也是ctrl-d结束\n`sort file1.txt file2.txt file3.txt > final_sorted.txt`对多个文件进行排序\n<font size=4>**3.unique命令**</font>\nunique命令只能删除排好序的行,即是它只判断连续相等的行\n\n|选项|说明|\n|:-:|:-:|\n|-e|输出所有重复行,并且每行开头显示重复次数|\n|-d|只输所有出重复行|\n|-f [n]|忽略每行开头的n个字段,字段之间由空格分割(不支持自定义)|\n|-i|忽略大小写|\n|-s [n]|跳过每行开头的n个字符|\n|-u|只输出独有的文本,默认选项|\n\n<font size=4>**4.cut命令**</font>\ncut 程序被用来从文本行 抽取文本，并把其输出到标准输出。能够接受多个文件参数或标准输入\n\n|选项|说明|\n|:-:|:-:|\n|-b [num_list]|从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分隔开的数值区间组成|\n|-c [num_list]|从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分割开的数值区间组成|\n|-f [num_list]|从文本行中抽取一个或多个由num_list定义的字段。这个列表可能包括一个或多个字段,或由逗号分割开的字段区间|\n|-d [delim_char]|指定字段分隔符,默认情况下,由单个tab字符分隔开|\n|--complement|抽取整个文本行，除了那些由-c或-f选项指定的文本|\n\n选项中各个list列表格式如下:\nN     从第1个开始数的第N个字节、字符或域\nN-    从第N个开始到所在行结束的所有字符、字节或域\nN-M   从第N个开始到第M个之间(包括第M个)的所有字符、字节或域\n-M    从第1个开始到第M个之间(包括第M个)的所有字符、字节或域\n<font size=4>**4.paste命令**</font>\n格式:`paste [file1] [file2]`,在file1每行后添加file2中对应行内容,默认使用制表符分割两个文件的内容,可以用-d选项指定分割符\n<font size=4>**5.join命令**</font>\n与paste类似,但是它对文件有一个要求,每个文件对应行,都有相同的字段(默认为空白分割符),效果如下图:\n\n|A文本|B文本|结果|\n|John 20|John man|John 20 man|\n|May 15|May woman|May 15 woman|\n|Mike 33|Mike man|Mike 33 man|\n\n各种设置有待研究\n<font size=4>**6.comm命令**</font>\ncomm比较两个文本文件,会产生三列输出,第一列包含第一个文件独有的文本行,第二列包含第二个文本行独有的,第三列,两个文本共有的,-n选项会隐藏第n列的内容,n只有三个数字选择1,2,3\n<font size=4>**7.diff命令**</font>\n格式:`diff <options> [old file] [new file]`\ndiff默认输出如何使第一个文件变成第二个文件\n常用选项-c,-u选项\n<font size=4>**8.patch命令**</font>\npatch程序被用来把更改应用到文本文件中。它接受从diff程序的输出,并且通常被用来把较老的文件转变为较新的文件,注意不一定要指定文件名,因为diff信息中已经有了文件信息\n## 9.tr命令\n选项:`tr [选项] [set1] [set2]`\ntr用来更改字符(只能从标准输出中接受数据),把一个字母换成另一个字母\nset1,set2是下列选项之一:\n1.一个枚举列表,例如:ABSCKAL\n2.一个字符域:A-Z,a-z\n3.POSIX字符类:[:upper:]\n<font color=#FF0000>注意:</font>set1和set2字符集长度相同,一对一,但是,也有多对一,把所有符合字符换成同一个字符\n**tr例子**\n1.`tr -d '\\r' dos_file > unix_file`把dos_file的换行符删除\n2.`echo \"aabbbbccc\" | tr -s ab`挤压重复字符,这个结果为\"abccc\"\n但如果是`echo \"abcabcabc\" | tr -s ab`结果不变\n3.`seq 1 2 9 | paste -sd,`paste的神奇用法\n\n\n\n","source":"_posts/文本处理瑞士军刀-小而强悍.md","raw":"---\ntitle: 文本处理瑞士军刀--小而强悍\ndate: 2020-11-21 17:50:14\nsubtitle:\ncategories:\ntags:\nindex_img: /images/knifes.jpg\nbanner_img: /images/knifes.jpg\n---\n<font size=4>**1.cat命令**</font>\n\n|选项|说明|\n|:-:|:-:|\n|-A|用$表示每行的结尾,^I表示tab空格字符(是个判别空格和tab的方法)|\n|-n|显示行号|\n|-s|对于连续空行,只保留一行|\n\n**cat用例**\n`cat << END`接下来直到END之间的内容\n`cat > foo.txt`快捷新建foo.txt并输入内容,以ctrl-D结束\n`cat <<< filename`打印filename这个单词\n<font size=4>**2.sort命令**</font>\n\n|选项|说明|\n|:-:|:-:|\n|-b|忽略开头的空白字符,从第一个非空白字符进行排序|\n|-f|让排序忽略大小写|\n|-n|基于字符串的数值来排序,而不是字母值|\n|-r|降序排序|\n|-k [field1],[field2]|举例`-k 4,5`,根据[4,5]间的字符段对行进行排序,如果没有5,则只是根据第四个字符段进行行排序,字符段的分隔符默认为空,可以由-t来指定|\n|-t [char]|定义域分割字符,默认为空格或制表|\n|-u|去除比较相等的行,即便行内容不相等,如果比较结果相等(如只从第二个字符比较)改行也会被去除,|\n\n**-key选项的魅力**\n`sort -k 1,1 -k 2n foo.txt`先按第一个字段按字符串排序,如果第一字段相等,再2n表示第二个字段用数值排序,n和sort选项一样表示数值排序,同样还可以指定b(忽略开头的空格),r(逆向排序)\n考虑系列文本字段,如何以日期的格式降序排序呢\n```\n10/30/2008\n11/25/2008\n06/19/2008\n```\n\n简单用如下命令:\n`sort -k 1.7nbr -k 1.1nbr -k 1.4nbr xx.txt`表示先从第一个字段第7个字符开始进行排序,如果相等,再比较第一个字符开始的第一个字段开始排序,再者第四个字符开始排序\n**sort用例**\n`sort > foo.txt`同cat一样只不过对你输入的内容进行排序,也是ctrl-d结束\n`sort file1.txt file2.txt file3.txt > final_sorted.txt`对多个文件进行排序\n<font size=4>**3.unique命令**</font>\nunique命令只能删除排好序的行,即是它只判断连续相等的行\n\n|选项|说明|\n|:-:|:-:|\n|-e|输出所有重复行,并且每行开头显示重复次数|\n|-d|只输所有出重复行|\n|-f [n]|忽略每行开头的n个字段,字段之间由空格分割(不支持自定义)|\n|-i|忽略大小写|\n|-s [n]|跳过每行开头的n个字符|\n|-u|只输出独有的文本,默认选项|\n\n<font size=4>**4.cut命令**</font>\ncut 程序被用来从文本行 抽取文本，并把其输出到标准输出。能够接受多个文件参数或标准输入\n\n|选项|说明|\n|:-:|:-:|\n|-b [num_list]|从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分隔开的数值区间组成|\n|-c [num_list]|从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分割开的数值区间组成|\n|-f [num_list]|从文本行中抽取一个或多个由num_list定义的字段。这个列表可能包括一个或多个字段,或由逗号分割开的字段区间|\n|-d [delim_char]|指定字段分隔符,默认情况下,由单个tab字符分隔开|\n|--complement|抽取整个文本行，除了那些由-c或-f选项指定的文本|\n\n选项中各个list列表格式如下:\nN     从第1个开始数的第N个字节、字符或域\nN-    从第N个开始到所在行结束的所有字符、字节或域\nN-M   从第N个开始到第M个之间(包括第M个)的所有字符、字节或域\n-M    从第1个开始到第M个之间(包括第M个)的所有字符、字节或域\n<font size=4>**4.paste命令**</font>\n格式:`paste [file1] [file2]`,在file1每行后添加file2中对应行内容,默认使用制表符分割两个文件的内容,可以用-d选项指定分割符\n<font size=4>**5.join命令**</font>\n与paste类似,但是它对文件有一个要求,每个文件对应行,都有相同的字段(默认为空白分割符),效果如下图:\n\n|A文本|B文本|结果|\n|John 20|John man|John 20 man|\n|May 15|May woman|May 15 woman|\n|Mike 33|Mike man|Mike 33 man|\n\n各种设置有待研究\n<font size=4>**6.comm命令**</font>\ncomm比较两个文本文件,会产生三列输出,第一列包含第一个文件独有的文本行,第二列包含第二个文本行独有的,第三列,两个文本共有的,-n选项会隐藏第n列的内容,n只有三个数字选择1,2,3\n<font size=4>**7.diff命令**</font>\n格式:`diff <options> [old file] [new file]`\ndiff默认输出如何使第一个文件变成第二个文件\n常用选项-c,-u选项\n<font size=4>**8.patch命令**</font>\npatch程序被用来把更改应用到文本文件中。它接受从diff程序的输出,并且通常被用来把较老的文件转变为较新的文件,注意不一定要指定文件名,因为diff信息中已经有了文件信息\n## 9.tr命令\n选项:`tr [选项] [set1] [set2]`\ntr用来更改字符(只能从标准输出中接受数据),把一个字母换成另一个字母\nset1,set2是下列选项之一:\n1.一个枚举列表,例如:ABSCKAL\n2.一个字符域:A-Z,a-z\n3.POSIX字符类:[:upper:]\n<font color=#FF0000>注意:</font>set1和set2字符集长度相同,一对一,但是,也有多对一,把所有符合字符换成同一个字符\n**tr例子**\n1.`tr -d '\\r' dos_file > unix_file`把dos_file的换行符删除\n2.`echo \"aabbbbccc\" | tr -s ab`挤压重复字符,这个结果为\"abccc\"\n但如果是`echo \"abcabcabc\" | tr -s ab`结果不变\n3.`seq 1 2 9 | paste -sd,`paste的神奇用法\n\n\n\n","slug":"文本处理瑞士军刀-小而强悍","published":1,"updated":"2024-04-28T19:41:43.627Z","_id":"clq1yvi7a002bgwq2di87egq2","comments":1,"layout":"post","photos":[],"content":"<p><font size=4><strong>1.cat命令</strong></font></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-A</td>\n<td align=\"center\">用$表示每行的结尾,^I表示tab空格字符(是个判别空格和tab的方法)</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">显示行号</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">对于连续空行,只保留一行</td>\n</tr>\n</tbody></table>\n<p><strong>cat用例</strong><br><code>cat &lt;&lt; END</code>接下来直到END之间的内容<br><code>cat &gt; foo.txt</code>快捷新建foo.txt并输入内容,以ctrl-D结束<br><code>cat &lt;&lt;&lt; filename</code>打印filename这个单词<br><font size=4><strong>2.sort命令</strong></font></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b</td>\n<td align=\"center\">忽略开头的空白字符,从第一个非空白字符进行排序</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">让排序忽略大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">基于字符串的数值来排序,而不是字母值</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">降序排序</td>\n</tr>\n<tr>\n<td align=\"center\">-k [field1],[field2]</td>\n<td align=\"center\">举例<code>-k 4,5</code>,根据[4,5]间的字符段对行进行排序,如果没有5,则只是根据第四个字符段进行行排序,字符段的分隔符默认为空,可以由-t来指定</td>\n</tr>\n<tr>\n<td align=\"center\">-t [char]</td>\n<td align=\"center\">定义域分割字符,默认为空格或制表</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">去除比较相等的行,即便行内容不相等,如果比较结果相等(如只从第二个字符比较)改行也会被去除,</td>\n</tr>\n</tbody></table>\n<p><strong>-key选项的魅力</strong><br><code>sort -k 1,1 -k 2n foo.txt</code>先按第一个字段按字符串排序,如果第一字段相等,再2n表示第二个字段用数值排序,n和sort选项一样表示数值排序,同样还可以指定b(忽略开头的空格),r(逆向排序)<br>考虑系列文本字段,如何以日期的格式降序排序呢</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">10</span>/<span class=\"hljs-number\">30</span>/<span class=\"hljs-number\">2008</span><br><span class=\"hljs-attribute\">11</span>/<span class=\"hljs-number\">25</span>/<span class=\"hljs-number\">2008</span><br><span class=\"hljs-attribute\">06</span>/<span class=\"hljs-number\">19</span>/<span class=\"hljs-number\">2008</span><br></code></pre></td></tr></table></figure>\n\n<p>简单用如下命令:<br><code>sort -k 1.7nbr -k 1.1nbr -k 1.4nbr xx.txt</code>表示先从第一个字段第7个字符开始进行排序,如果相等,再比较第一个字符开始的第一个字段开始排序,再者第四个字符开始排序<br><strong>sort用例</strong><br><code>sort &gt; foo.txt</code>同cat一样只不过对你输入的内容进行排序,也是ctrl-d结束<br><code>sort file1.txt file2.txt file3.txt &gt; final_sorted.txt</code>对多个文件进行排序<br><font size=4><strong>3.unique命令</strong></font><br>unique命令只能删除排好序的行,即是它只判断连续相等的行</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">输出所有重复行,并且每行开头显示重复次数</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">只输所有出重复行</td>\n</tr>\n<tr>\n<td align=\"center\">-f [n]</td>\n<td align=\"center\">忽略每行开头的n个字段,字段之间由空格分割(不支持自定义)</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">忽略大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-s [n]</td>\n<td align=\"center\">跳过每行开头的n个字符</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">只输出独有的文本,默认选项</td>\n</tr>\n</tbody></table>\n<p><font size=4><strong>4.cut命令</strong></font><br>cut 程序被用来从文本行 抽取文本，并把其输出到标准输出。能够接受多个文件参数或标准输入</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b [num_list]</td>\n<td align=\"center\">从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分隔开的数值区间组成</td>\n</tr>\n<tr>\n<td align=\"center\">-c [num_list]</td>\n<td align=\"center\">从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分割开的数值区间组成</td>\n</tr>\n<tr>\n<td align=\"center\">-f [num_list]</td>\n<td align=\"center\">从文本行中抽取一个或多个由num_list定义的字段。这个列表可能包括一个或多个字段,或由逗号分割开的字段区间</td>\n</tr>\n<tr>\n<td align=\"center\">-d [delim_char]</td>\n<td align=\"center\">指定字段分隔符,默认情况下,由单个tab字符分隔开</td>\n</tr>\n<tr>\n<td align=\"center\">–complement</td>\n<td align=\"center\">抽取整个文本行，除了那些由-c或-f选项指定的文本</td>\n</tr>\n</tbody></table>\n<p>选项中各个list列表格式如下:<br>N     从第1个开始数的第N个字节、字符或域<br>N-    从第N个开始到所在行结束的所有字符、字节或域<br>N-M   从第N个开始到第M个之间(包括第M个)的所有字符、字节或域<br>-M    从第1个开始到第M个之间(包括第M个)的所有字符、字节或域<br><font size=4><strong>4.paste命令</strong></font><br>格式:<code>paste [file1] [file2]</code>,在file1每行后添加file2中对应行内容,默认使用制表符分割两个文件的内容,可以用-d选项指定分割符<br><font size=4><strong>5.join命令</strong></font><br>与paste类似,但是它对文件有一个要求,每个文件对应行,都有相同的字段(默认为空白分割符),效果如下图:</p>\n<p>|A文本|B文本|结果|<br>|John 20|John man|John 20 man|<br>|May 15|May woman|May 15 woman|<br>|Mike 33|Mike man|Mike 33 man|</p>\n<p>各种设置有待研究<br><font size=4><strong>6.comm命令</strong></font><br>comm比较两个文本文件,会产生三列输出,第一列包含第一个文件独有的文本行,第二列包含第二个文本行独有的,第三列,两个文本共有的,-n选项会隐藏第n列的内容,n只有三个数字选择1,2,3<br><font size=4><strong>7.diff命令</strong></font><br>格式:<code>diff &lt;options&gt; [old file] [new file]</code><br>diff默认输出如何使第一个文件变成第二个文件<br>常用选项-c,-u选项<br><font size=4><strong>8.patch命令</strong></font><br>patch程序被用来把更改应用到文本文件中。它接受从diff程序的输出,并且通常被用来把较老的文件转变为较新的文件,注意不一定要指定文件名,因为diff信息中已经有了文件信息</p>\n<h2 id=\"9-tr命令\"><a href=\"#9-tr命令\" class=\"headerlink\" title=\"9.tr命令\"></a>9.tr命令</h2><p>选项:<code>tr [选项] [set1] [set2]</code><br>tr用来更改字符(只能从标准输出中接受数据),把一个字母换成另一个字母<br>set1,set2是下列选项之一:<br>1.一个枚举列表,例如:ABSCKAL<br>2.一个字符域:A-Z,a-z<br>3.POSIX字符类:[:upper:]<br><font color=#FF0000>注意:</font>set1和set2字符集长度相同,一对一,但是,也有多对一,把所有符合字符换成同一个字符<br><strong>tr例子</strong><br>1.<code>tr -d &#39;\\r&#39; dos_file &gt; unix_file</code>把dos_file的换行符删除<br>2.<code>echo &quot;aabbbbccc&quot; | tr -s ab</code>挤压重复字符,这个结果为”abccc”<br>但如果是<code>echo &quot;abcabcabc&quot; | tr -s ab</code>结果不变<br>3.<code>seq 1 2 9 | paste -sd,</code>paste的神奇用法</p>\n","excerpt":"","more":"<p><font size=4><strong>1.cat命令</strong></font></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-A</td>\n<td align=\"center\">用$表示每行的结尾,^I表示tab空格字符(是个判别空格和tab的方法)</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">显示行号</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">对于连续空行,只保留一行</td>\n</tr>\n</tbody></table>\n<p><strong>cat用例</strong><br><code>cat &lt;&lt; END</code>接下来直到END之间的内容<br><code>cat &gt; foo.txt</code>快捷新建foo.txt并输入内容,以ctrl-D结束<br><code>cat &lt;&lt;&lt; filename</code>打印filename这个单词<br><font size=4><strong>2.sort命令</strong></font></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b</td>\n<td align=\"center\">忽略开头的空白字符,从第一个非空白字符进行排序</td>\n</tr>\n<tr>\n<td align=\"center\">-f</td>\n<td align=\"center\">让排序忽略大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">基于字符串的数值来排序,而不是字母值</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">降序排序</td>\n</tr>\n<tr>\n<td align=\"center\">-k [field1],[field2]</td>\n<td align=\"center\">举例<code>-k 4,5</code>,根据[4,5]间的字符段对行进行排序,如果没有5,则只是根据第四个字符段进行行排序,字符段的分隔符默认为空,可以由-t来指定</td>\n</tr>\n<tr>\n<td align=\"center\">-t [char]</td>\n<td align=\"center\">定义域分割字符,默认为空格或制表</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">去除比较相等的行,即便行内容不相等,如果比较结果相等(如只从第二个字符比较)改行也会被去除,</td>\n</tr>\n</tbody></table>\n<p><strong>-key选项的魅力</strong><br><code>sort -k 1,1 -k 2n foo.txt</code>先按第一个字段按字符串排序,如果第一字段相等,再2n表示第二个字段用数值排序,n和sort选项一样表示数值排序,同样还可以指定b(忽略开头的空格),r(逆向排序)<br>考虑系列文本字段,如何以日期的格式降序排序呢</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">10</span>/<span class=\"hljs-number\">30</span>/<span class=\"hljs-number\">2008</span><br><span class=\"hljs-attribute\">11</span>/<span class=\"hljs-number\">25</span>/<span class=\"hljs-number\">2008</span><br><span class=\"hljs-attribute\">06</span>/<span class=\"hljs-number\">19</span>/<span class=\"hljs-number\">2008</span><br></code></pre></td></tr></table></figure>\n\n<p>简单用如下命令:<br><code>sort -k 1.7nbr -k 1.1nbr -k 1.4nbr xx.txt</code>表示先从第一个字段第7个字符开始进行排序,如果相等,再比较第一个字符开始的第一个字段开始排序,再者第四个字符开始排序<br><strong>sort用例</strong><br><code>sort &gt; foo.txt</code>同cat一样只不过对你输入的内容进行排序,也是ctrl-d结束<br><code>sort file1.txt file2.txt file3.txt &gt; final_sorted.txt</code>对多个文件进行排序<br><font size=4><strong>3.unique命令</strong></font><br>unique命令只能删除排好序的行,即是它只判断连续相等的行</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">输出所有重复行,并且每行开头显示重复次数</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">只输所有出重复行</td>\n</tr>\n<tr>\n<td align=\"center\">-f [n]</td>\n<td align=\"center\">忽略每行开头的n个字段,字段之间由空格分割(不支持自定义)</td>\n</tr>\n<tr>\n<td align=\"center\">-i</td>\n<td align=\"center\">忽略大小写</td>\n</tr>\n<tr>\n<td align=\"center\">-s [n]</td>\n<td align=\"center\">跳过每行开头的n个字符</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">只输出独有的文本,默认选项</td>\n</tr>\n</tbody></table>\n<p><font size=4><strong>4.cut命令</strong></font><br>cut 程序被用来从文本行 抽取文本，并把其输出到标准输出。能够接受多个文件参数或标准输入</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-b [num_list]</td>\n<td align=\"center\">从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分隔开的数值区间组成</td>\n</tr>\n<tr>\n<td align=\"center\">-c [num_list]</td>\n<td align=\"center\">从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分割开的数值区间组成</td>\n</tr>\n<tr>\n<td align=\"center\">-f [num_list]</td>\n<td align=\"center\">从文本行中抽取一个或多个由num_list定义的字段。这个列表可能包括一个或多个字段,或由逗号分割开的字段区间</td>\n</tr>\n<tr>\n<td align=\"center\">-d [delim_char]</td>\n<td align=\"center\">指定字段分隔符,默认情况下,由单个tab字符分隔开</td>\n</tr>\n<tr>\n<td align=\"center\">–complement</td>\n<td align=\"center\">抽取整个文本行，除了那些由-c或-f选项指定的文本</td>\n</tr>\n</tbody></table>\n<p>选项中各个list列表格式如下:<br>N     从第1个开始数的第N个字节、字符或域<br>N-    从第N个开始到所在行结束的所有字符、字节或域<br>N-M   从第N个开始到第M个之间(包括第M个)的所有字符、字节或域<br>-M    从第1个开始到第M个之间(包括第M个)的所有字符、字节或域<br><font size=4><strong>4.paste命令</strong></font><br>格式:<code>paste [file1] [file2]</code>,在file1每行后添加file2中对应行内容,默认使用制表符分割两个文件的内容,可以用-d选项指定分割符<br><font size=4><strong>5.join命令</strong></font><br>与paste类似,但是它对文件有一个要求,每个文件对应行,都有相同的字段(默认为空白分割符),效果如下图:</p>\n<p>|A文本|B文本|结果|<br>|John 20|John man|John 20 man|<br>|May 15|May woman|May 15 woman|<br>|Mike 33|Mike man|Mike 33 man|</p>\n<p>各种设置有待研究<br><font size=4><strong>6.comm命令</strong></font><br>comm比较两个文本文件,会产生三列输出,第一列包含第一个文件独有的文本行,第二列包含第二个文本行独有的,第三列,两个文本共有的,-n选项会隐藏第n列的内容,n只有三个数字选择1,2,3<br><font size=4><strong>7.diff命令</strong></font><br>格式:<code>diff &lt;options&gt; [old file] [new file]</code><br>diff默认输出如何使第一个文件变成第二个文件<br>常用选项-c,-u选项<br><font size=4><strong>8.patch命令</strong></font><br>patch程序被用来把更改应用到文本文件中。它接受从diff程序的输出,并且通常被用来把较老的文件转变为较新的文件,注意不一定要指定文件名,因为diff信息中已经有了文件信息</p>\n<h2 id=\"9-tr命令\"><a href=\"#9-tr命令\" class=\"headerlink\" title=\"9.tr命令\"></a>9.tr命令</h2><p>选项:<code>tr [选项] [set1] [set2]</code><br>tr用来更改字符(只能从标准输出中接受数据),把一个字母换成另一个字母<br>set1,set2是下列选项之一:<br>1.一个枚举列表,例如:ABSCKAL<br>2.一个字符域:A-Z,a-z<br>3.POSIX字符类:[:upper:]<br><font color=#FF0000>注意:</font>set1和set2字符集长度相同,一对一,但是,也有多对一,把所有符合字符换成同一个字符<br><strong>tr例子</strong><br>1.<code>tr -d &#39;\\r&#39; dos_file &gt; unix_file</code>把dos_file的换行符删除<br>2.<code>echo &quot;aabbbbccc&quot; | tr -s ab</code>挤压重复字符,这个结果为”abccc”<br>但如果是<code>echo &quot;abcabcabc&quot; | tr -s ab</code>结果不变<br>3.<code>seq 1 2 9 | paste -sd,</code>paste的神奇用法</p>\n"},{"title":"文本处理瑞士军刀-扩展","date":"2022-03-22T08:41:44.000Z","subtitle":null,"index_img":"/images/extend.jpg","banner_img":"/images/extend.jpg","_content":"## csvkit\n### 安装\n`pip install csvkit`\n### csvlook\n使csv看起来更加人性化\n\n|选项|含义|\n|:-:|:-:|\n|-H|csvlook默认第一行为头，该选项取消该默认，认为无头|\n|-I|不区分类型，不为数字的可读性加逗号等等|\n\n### in2csv\n转换xlsx为csv,默认为第一个表单\n\n|选项|含义|\n|:-:|:-:|\n|--names|打印所有表单名|\n|--sheet [name]|转换指定的表单名|\n\n### csvgrep\ncsv的抓取\n\n|选项|含义|\n|:-:|:-:|\n|--columns [column]|指定某一列名|\n|--regex [regex]|指定正则|\n\n### sql2csv\n把数据库中的内容转换成csv\n\n|选项|含义|\n|:-:|:-:|\n|--db [URL]|数据库的URL|\n|--query|输入SQL语句|\n### csvsql\n应用sql语句到csv,主要使用SQLite的语法\n### csvjoin\n整合多个csv\n### csvstat\n分析csv的命令\n\n|选项|含义|\n|:-:|:-:|\n|--freq|每个值出现的频率|\n|--len|不知道啥玩意|\n|--max|每列最大值|\n|--min|每列最小值|\n|--mean|每列平均数|\n|--median|每列中位数|\n|--nulls|每列是否含null|\n|--stdev|每列标准差|\n|--sum|每列和|\n|--unique|统计每一列不同的值|\n#### 例子\n`seq 5 | header -a val | csvsql --query \"SELECT SUM(val) AS sum FROM stdin\"`\n### csvcut\n\n|选项|含义|\n|:-:|:-:|\n|-c|指定想要的列名,也可以指定数字，表示第几列，从1开始,以逗号分隔|\n|-C|剔除某些列名，和-c相反|\n\n## jq\nlinux发行版直接安装，使json格式可读性更好\n## sample-stream\n### 安装\n`pip install sample-stream`\n### 命令\n这是一个处理流的命令\n|选项|含义|\n|:-:|:-:|\n|-s|10s后关闭该流|\n\n## rush\n一个小仓库https://github.com/jeroenjanssens/rush，用来画图\n### 安装\n1) 安装R语言\n`sudo pacman -S r`\n2) 进入R命令端\n`sudo R`\n3) 安装remote包\n`install.packages(\"remotes\")`\n4) 安装rush包,该步骤我运行两次才成功，要花费大量编译时间\n`remotes::install_github(\"jeroenjanssens/rush\")`\n## pup\nhtml可读性提升工具\n\n## moreutils\n是一个工具集\n### 安装\n`sudo pacman -S moreutils`\n### ts\n在没一行前面加上当前时间戳\n## 文本转换\n- json2csv:https://github.com/jehiah/json2csv\n- xml2json:pacman官方库有两个版本\n","source":"_posts/文本处理瑞士军刀-扩展.md","raw":"---\ntitle: 文本处理瑞士军刀-扩展\ndate: 2022-03-22 16:41:44\nsubtitle:\ncategories:\ntags:\nindex_img: /images/extend.jpg\nbanner_img: /images/extend.jpg\n---\n## csvkit\n### 安装\n`pip install csvkit`\n### csvlook\n使csv看起来更加人性化\n\n|选项|含义|\n|:-:|:-:|\n|-H|csvlook默认第一行为头，该选项取消该默认，认为无头|\n|-I|不区分类型，不为数字的可读性加逗号等等|\n\n### in2csv\n转换xlsx为csv,默认为第一个表单\n\n|选项|含义|\n|:-:|:-:|\n|--names|打印所有表单名|\n|--sheet [name]|转换指定的表单名|\n\n### csvgrep\ncsv的抓取\n\n|选项|含义|\n|:-:|:-:|\n|--columns [column]|指定某一列名|\n|--regex [regex]|指定正则|\n\n### sql2csv\n把数据库中的内容转换成csv\n\n|选项|含义|\n|:-:|:-:|\n|--db [URL]|数据库的URL|\n|--query|输入SQL语句|\n### csvsql\n应用sql语句到csv,主要使用SQLite的语法\n### csvjoin\n整合多个csv\n### csvstat\n分析csv的命令\n\n|选项|含义|\n|:-:|:-:|\n|--freq|每个值出现的频率|\n|--len|不知道啥玩意|\n|--max|每列最大值|\n|--min|每列最小值|\n|--mean|每列平均数|\n|--median|每列中位数|\n|--nulls|每列是否含null|\n|--stdev|每列标准差|\n|--sum|每列和|\n|--unique|统计每一列不同的值|\n#### 例子\n`seq 5 | header -a val | csvsql --query \"SELECT SUM(val) AS sum FROM stdin\"`\n### csvcut\n\n|选项|含义|\n|:-:|:-:|\n|-c|指定想要的列名,也可以指定数字，表示第几列，从1开始,以逗号分隔|\n|-C|剔除某些列名，和-c相反|\n\n## jq\nlinux发行版直接安装，使json格式可读性更好\n## sample-stream\n### 安装\n`pip install sample-stream`\n### 命令\n这是一个处理流的命令\n|选项|含义|\n|:-:|:-:|\n|-s|10s后关闭该流|\n\n## rush\n一个小仓库https://github.com/jeroenjanssens/rush，用来画图\n### 安装\n1) 安装R语言\n`sudo pacman -S r`\n2) 进入R命令端\n`sudo R`\n3) 安装remote包\n`install.packages(\"remotes\")`\n4) 安装rush包,该步骤我运行两次才成功，要花费大量编译时间\n`remotes::install_github(\"jeroenjanssens/rush\")`\n## pup\nhtml可读性提升工具\n\n## moreutils\n是一个工具集\n### 安装\n`sudo pacman -S moreutils`\n### ts\n在没一行前面加上当前时间戳\n## 文本转换\n- json2csv:https://github.com/jehiah/json2csv\n- xml2json:pacman官方库有两个版本\n","slug":"文本处理瑞士军刀-扩展","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi7a002cgwq2fxcs7h00","content":"<h2 id=\"csvkit\"><a href=\"#csvkit\" class=\"headerlink\" title=\"csvkit\"></a>csvkit</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>pip install csvkit</code></p>\n<h3 id=\"csvlook\"><a href=\"#csvlook\" class=\"headerlink\" title=\"csvlook\"></a>csvlook</h3><p>使csv看起来更加人性化</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-H</td>\n<td align=\"center\">csvlook默认第一行为头，该选项取消该默认，认为无头</td>\n</tr>\n<tr>\n<td align=\"center\">-I</td>\n<td align=\"center\">不区分类型，不为数字的可读性加逗号等等</td>\n</tr>\n</tbody></table>\n<h3 id=\"in2csv\"><a href=\"#in2csv\" class=\"headerlink\" title=\"in2csv\"></a>in2csv</h3><p>转换xlsx为csv,默认为第一个表单</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–names</td>\n<td align=\"center\">打印所有表单名</td>\n</tr>\n<tr>\n<td align=\"center\">–sheet [name]</td>\n<td align=\"center\">转换指定的表单名</td>\n</tr>\n</tbody></table>\n<h3 id=\"csvgrep\"><a href=\"#csvgrep\" class=\"headerlink\" title=\"csvgrep\"></a>csvgrep</h3><p>csv的抓取</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–columns [column]</td>\n<td align=\"center\">指定某一列名</td>\n</tr>\n<tr>\n<td align=\"center\">–regex [regex]</td>\n<td align=\"center\">指定正则</td>\n</tr>\n</tbody></table>\n<h3 id=\"sql2csv\"><a href=\"#sql2csv\" class=\"headerlink\" title=\"sql2csv\"></a>sql2csv</h3><p>把数据库中的内容转换成csv</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–db [URL]</td>\n<td align=\"center\">数据库的URL</td>\n</tr>\n<tr>\n<td align=\"center\">–query</td>\n<td align=\"center\">输入SQL语句</td>\n</tr>\n</tbody></table>\n<h3 id=\"csvsql\"><a href=\"#csvsql\" class=\"headerlink\" title=\"csvsql\"></a>csvsql</h3><p>应用sql语句到csv,主要使用SQLite的语法</p>\n<h3 id=\"csvjoin\"><a href=\"#csvjoin\" class=\"headerlink\" title=\"csvjoin\"></a>csvjoin</h3><p>整合多个csv</p>\n<h3 id=\"csvstat\"><a href=\"#csvstat\" class=\"headerlink\" title=\"csvstat\"></a>csvstat</h3><p>分析csv的命令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–freq</td>\n<td align=\"center\">每个值出现的频率</td>\n</tr>\n<tr>\n<td align=\"center\">–len</td>\n<td align=\"center\">不知道啥玩意</td>\n</tr>\n<tr>\n<td align=\"center\">–max</td>\n<td align=\"center\">每列最大值</td>\n</tr>\n<tr>\n<td align=\"center\">–min</td>\n<td align=\"center\">每列最小值</td>\n</tr>\n<tr>\n<td align=\"center\">–mean</td>\n<td align=\"center\">每列平均数</td>\n</tr>\n<tr>\n<td align=\"center\">–median</td>\n<td align=\"center\">每列中位数</td>\n</tr>\n<tr>\n<td align=\"center\">–nulls</td>\n<td align=\"center\">每列是否含null</td>\n</tr>\n<tr>\n<td align=\"center\">–stdev</td>\n<td align=\"center\">每列标准差</td>\n</tr>\n<tr>\n<td align=\"center\">–sum</td>\n<td align=\"center\">每列和</td>\n</tr>\n<tr>\n<td align=\"center\">–unique</td>\n<td align=\"center\">统计每一列不同的值</td>\n</tr>\n</tbody></table>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><p><code>seq 5 | header -a val | csvsql --query &quot;SELECT SUM(val) AS sum FROM stdin&quot;</code></p>\n<h3 id=\"csvcut\"><a href=\"#csvcut\" class=\"headerlink\" title=\"csvcut\"></a>csvcut</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">指定想要的列名,也可以指定数字，表示第几列，从1开始,以逗号分隔</td>\n</tr>\n<tr>\n<td align=\"center\">-C</td>\n<td align=\"center\">剔除某些列名，和-c相反</td>\n</tr>\n</tbody></table>\n<h2 id=\"jq\"><a href=\"#jq\" class=\"headerlink\" title=\"jq\"></a>jq</h2><p>linux发行版直接安装，使json格式可读性更好</p>\n<h2 id=\"sample-stream\"><a href=\"#sample-stream\" class=\"headerlink\" title=\"sample-stream\"></a>sample-stream</h2><h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>pip install sample-stream</code></p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>这是一个处理流的命令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">10s后关闭该流</td>\n</tr>\n</tbody></table>\n<h2 id=\"rush\"><a href=\"#rush\" class=\"headerlink\" title=\"rush\"></a>rush</h2><p>一个小仓库<a href=\"https://github.com/jeroenjanssens/rush%EF%BC%8C%E7%94%A8%E6%9D%A5%E7%94%BB%E5%9B%BE\">https://github.com/jeroenjanssens/rush，用来画图</a></p>\n<h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ol>\n<li>安装R语言<br><code>sudo pacman -S r</code></li>\n<li>进入R命令端<br><code>sudo R</code></li>\n<li>安装remote包<br><code>install.packages(&quot;remotes&quot;)</code></li>\n<li>安装rush包,该步骤我运行两次才成功，要花费大量编译时间<br><code>remotes::install_github(&quot;jeroenjanssens/rush&quot;)</code></li>\n</ol>\n<h2 id=\"pup\"><a href=\"#pup\" class=\"headerlink\" title=\"pup\"></a>pup</h2><p>html可读性提升工具</p>\n<h2 id=\"moreutils\"><a href=\"#moreutils\" class=\"headerlink\" title=\"moreutils\"></a>moreutils</h2><p>是一个工具集</p>\n<h3 id=\"安装-3\"><a href=\"#安装-3\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>sudo pacman -S moreutils</code></p>\n<h3 id=\"ts\"><a href=\"#ts\" class=\"headerlink\" title=\"ts\"></a>ts</h3><p>在没一行前面加上当前时间戳</p>\n<h2 id=\"文本转换\"><a href=\"#文本转换\" class=\"headerlink\" title=\"文本转换\"></a>文本转换</h2><ul>\n<li>json2csv:<a href=\"https://github.com/jehiah/json2csv\">https://github.com/jehiah/json2csv</a></li>\n<li>xml2json:pacman官方库有两个版本</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"csvkit\"><a href=\"#csvkit\" class=\"headerlink\" title=\"csvkit\"></a>csvkit</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>pip install csvkit</code></p>\n<h3 id=\"csvlook\"><a href=\"#csvlook\" class=\"headerlink\" title=\"csvlook\"></a>csvlook</h3><p>使csv看起来更加人性化</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-H</td>\n<td align=\"center\">csvlook默认第一行为头，该选项取消该默认，认为无头</td>\n</tr>\n<tr>\n<td align=\"center\">-I</td>\n<td align=\"center\">不区分类型，不为数字的可读性加逗号等等</td>\n</tr>\n</tbody></table>\n<h3 id=\"in2csv\"><a href=\"#in2csv\" class=\"headerlink\" title=\"in2csv\"></a>in2csv</h3><p>转换xlsx为csv,默认为第一个表单</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–names</td>\n<td align=\"center\">打印所有表单名</td>\n</tr>\n<tr>\n<td align=\"center\">–sheet [name]</td>\n<td align=\"center\">转换指定的表单名</td>\n</tr>\n</tbody></table>\n<h3 id=\"csvgrep\"><a href=\"#csvgrep\" class=\"headerlink\" title=\"csvgrep\"></a>csvgrep</h3><p>csv的抓取</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–columns [column]</td>\n<td align=\"center\">指定某一列名</td>\n</tr>\n<tr>\n<td align=\"center\">–regex [regex]</td>\n<td align=\"center\">指定正则</td>\n</tr>\n</tbody></table>\n<h3 id=\"sql2csv\"><a href=\"#sql2csv\" class=\"headerlink\" title=\"sql2csv\"></a>sql2csv</h3><p>把数据库中的内容转换成csv</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–db [URL]</td>\n<td align=\"center\">数据库的URL</td>\n</tr>\n<tr>\n<td align=\"center\">–query</td>\n<td align=\"center\">输入SQL语句</td>\n</tr>\n</tbody></table>\n<h3 id=\"csvsql\"><a href=\"#csvsql\" class=\"headerlink\" title=\"csvsql\"></a>csvsql</h3><p>应用sql语句到csv,主要使用SQLite的语法</p>\n<h3 id=\"csvjoin\"><a href=\"#csvjoin\" class=\"headerlink\" title=\"csvjoin\"></a>csvjoin</h3><p>整合多个csv</p>\n<h3 id=\"csvstat\"><a href=\"#csvstat\" class=\"headerlink\" title=\"csvstat\"></a>csvstat</h3><p>分析csv的命令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">–freq</td>\n<td align=\"center\">每个值出现的频率</td>\n</tr>\n<tr>\n<td align=\"center\">–len</td>\n<td align=\"center\">不知道啥玩意</td>\n</tr>\n<tr>\n<td align=\"center\">–max</td>\n<td align=\"center\">每列最大值</td>\n</tr>\n<tr>\n<td align=\"center\">–min</td>\n<td align=\"center\">每列最小值</td>\n</tr>\n<tr>\n<td align=\"center\">–mean</td>\n<td align=\"center\">每列平均数</td>\n</tr>\n<tr>\n<td align=\"center\">–median</td>\n<td align=\"center\">每列中位数</td>\n</tr>\n<tr>\n<td align=\"center\">–nulls</td>\n<td align=\"center\">每列是否含null</td>\n</tr>\n<tr>\n<td align=\"center\">–stdev</td>\n<td align=\"center\">每列标准差</td>\n</tr>\n<tr>\n<td align=\"center\">–sum</td>\n<td align=\"center\">每列和</td>\n</tr>\n<tr>\n<td align=\"center\">–unique</td>\n<td align=\"center\">统计每一列不同的值</td>\n</tr>\n</tbody></table>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><p><code>seq 5 | header -a val | csvsql --query &quot;SELECT SUM(val) AS sum FROM stdin&quot;</code></p>\n<h3 id=\"csvcut\"><a href=\"#csvcut\" class=\"headerlink\" title=\"csvcut\"></a>csvcut</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-c</td>\n<td align=\"center\">指定想要的列名,也可以指定数字，表示第几列，从1开始,以逗号分隔</td>\n</tr>\n<tr>\n<td align=\"center\">-C</td>\n<td align=\"center\">剔除某些列名，和-c相反</td>\n</tr>\n</tbody></table>\n<h2 id=\"jq\"><a href=\"#jq\" class=\"headerlink\" title=\"jq\"></a>jq</h2><p>linux发行版直接安装，使json格式可读性更好</p>\n<h2 id=\"sample-stream\"><a href=\"#sample-stream\" class=\"headerlink\" title=\"sample-stream\"></a>sample-stream</h2><h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>pip install sample-stream</code></p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>这是一个处理流的命令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">10s后关闭该流</td>\n</tr>\n</tbody></table>\n<h2 id=\"rush\"><a href=\"#rush\" class=\"headerlink\" title=\"rush\"></a>rush</h2><p>一个小仓库<a href=\"https://github.com/jeroenjanssens/rush%EF%BC%8C%E7%94%A8%E6%9D%A5%E7%94%BB%E5%9B%BE\">https://github.com/jeroenjanssens/rush，用来画图</a></p>\n<h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ol>\n<li>安装R语言<br><code>sudo pacman -S r</code></li>\n<li>进入R命令端<br><code>sudo R</code></li>\n<li>安装remote包<br><code>install.packages(&quot;remotes&quot;)</code></li>\n<li>安装rush包,该步骤我运行两次才成功，要花费大量编译时间<br><code>remotes::install_github(&quot;jeroenjanssens/rush&quot;)</code></li>\n</ol>\n<h2 id=\"pup\"><a href=\"#pup\" class=\"headerlink\" title=\"pup\"></a>pup</h2><p>html可读性提升工具</p>\n<h2 id=\"moreutils\"><a href=\"#moreutils\" class=\"headerlink\" title=\"moreutils\"></a>moreutils</h2><p>是一个工具集</p>\n<h3 id=\"安装-3\"><a href=\"#安装-3\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>sudo pacman -S moreutils</code></p>\n<h3 id=\"ts\"><a href=\"#ts\" class=\"headerlink\" title=\"ts\"></a>ts</h3><p>在没一行前面加上当前时间戳</p>\n<h2 id=\"文本转换\"><a href=\"#文本转换\" class=\"headerlink\" title=\"文本转换\"></a>文本转换</h2><ul>\n<li>json2csv:<a href=\"https://github.com/jehiah/json2csv\">https://github.com/jehiah/json2csv</a></li>\n<li>xml2json:pacman官方库有两个版本</li>\n</ul>\n"},{"title":"计算机原理","date":"2020-08-04T00:15:20.000Z","subtitle":null,"index_img":"/images/computer_bin.jpg","banner_img":"/images/computer_bin.jpg","_content":"1.位运算相关\n```\na&(b|c)=(a&b)|(a&c)\na|(b&c)=(a|b)&(a|c)\na^a=0 a^(a+1)=1(a为偶数)\na=n&(n-1)(移除n最后一个1)\ndiff=(n&(n-1))^n=n&(-n) (获取最后一个1)\n(n^(-1))+1=-n(有符号数取反加一为其相反数)\n(var^(var>>31))-(var>>31) (32位取绝对值)\n```\n2.位移运算\n左移:<<,丢弃高位,低位补0\n逻辑右移:>>,左端补0(c语言,对于无符号数,为逻辑右移)\n算术右移:>>,左端补最高有效位的值(c语言,对于有符号数,为算术右移)\n3.无符号与有符号的转换\na.C语言两者之间的转换，保持位模式不变,只是改变解码规则,最高位的解释由负到正,除了最高位的解释变化，其余位不变，设那些的权重和为k。\n所以有符号补码的解释为-2^(w-1)+k,而无符号解释为2^(w-1)+k,w表示位数,所以两者相差2^w, 对于位模式(只考虑负数,即超过有符号表示范围的正数)相同的有以下结论:\n无符号数=有符号负数+2^w\n有符号负数=无符号数-2^w\n有符号负数的绝对值+无符号数=2^w\nb.无符号与有符号比较,c语言会都转换无符号\n4.数字位的扩展\na.低位无符号向高位转换时,只要简单把多出来的位置为0\nb.低位有符号向高位有符号扩展时,为保持表示的数值不变,多出的位与原来符号位保持一致,很好想,0好说,多出来的位为0即保持数不变,1的话即是负数，多出的位都置为1,记住2^w-2^(w-1)=2^(w-1),这样多出来的权重和就是没多出位之前最高的负权重(用脑子一想就知道了)\nc.低位有符号向高位无符号扩展时,C语言是这样处理,先进行低位有符号到高位有符号扩展,即b,在进行有符号到无符号的同位转换,即3中的方法\n5.截断位\n截断都是直接去除多出的位,C中不支持这种转换,但这就是溢出的本质\na.截断后表示无符号,低位表示的数=高位数mod2^(低位数),很好想,去除的位数权重和肯定是2^(低位数)的倍数,低位表示的数肯定小于2^(低位数)(因为,低位表示的数最大值为2^(低位数)-1)\nb.截断后表示有符号,比较弱智的想法是,先转无符号,在此基础上进行无符号到有符号的转换.\n6.无符号相加溢出\n若0<=x,y<2^w,则x+y在[0,2^(w+1)-2]之间,x+y若大于等于2^w,则会被截断,表现为x+y-2^w。很容易想不做说明,同时也很容易得出,如果判断是否溢出,当且仅当得数小于其中任意一个加数。(因为溢出的话,x+y-2^w-x=y-2^w,肯定小于0)\n7.有符号相加\n向上溢出和6相同,向下溢出,则表现为x+y+2^w。书上的太难啃,我是这么想的,接它一位,并且表示没借之前的最小负数,应该是最高前两位为1,其余为0,而没借之前无法表示多出来的值为(-x-y-2^(w-1)),再以无符号来看,所以借出来之后,表示溢出的应有负数对应的无符号值为2^w+2^(w-1)-(-x-y-2^(w-1)),该数补码值即是表示不出来的负数,该高位无符号值化简为x+y+2^(w+1),由于x+y处于[-2^w,-2^w-1)之间,所以x+y+2^(w+1)的最小值为2^w,所以补出来的那一位始终为1,所以截断时要减去个2^w,最终结果就是x+y+2^(w+1)-2^(w)=x+y+2^(w)这个值,我知道我第二次看可能看不懂,以此纪念我思考的过程,和拙劣的表达\n补码检测上溢出:x,y都大于0,但它们的和小于等于0即发生溢出\n补码检测下溢出:x,y都小于0,但他们的和大于等于0即发生溢出\n<font color=#FF0000>其实本质上，溢出后表示的值,就是,借给它一个高位后,正确表达时,再按5的方法截断的值</font>\n8.整数相乘\n若补码整数x0,y0,与它们位模式相同的无符号整数为x1,y1,(x0\\*y0)与(x1\\*y1)的结果，无论有没有被截断，它们的位模式是相同的(还要缕一缕)\n9.乘以2的幂\nx\\*2^k,就等价于x\\<\\<k,对于不是2的幂的也可以转换如:x\\*14=x\\*(2^3+2^2+2)=(x<<3)+(x<<2)+(x<<1)\n10.除以2的幂\n无符号除以就是向右逻辑移位(与乘法相反嘛,聪明的你肯定想到了),而补码除以就是向右算术移位,同时当结果为负数,要保证舍入到0(简单来说就是无论正负,都去掉小数点,因为直接移位,会使结果原离远点),还需要做点修正,x/2^k=(x+(1\\<\\<k)-1)\\>\\>k(本质上,利用了如下的属性x/y)\nC中补码的除法会进行如下:\n`(x<0 ? x+(1<<k)-1 :x)>>k`来计算x/2^k\n3.trick\na.-1用补码表示为全1位\nb.0用补码表示为全0位\nc.非负数x,-x的w位补码表示就是2^w-x,而反码则是[111...1]-x,（这两个表达式都当成无符号来进行位表示。反码也可以这么理解2^w-1-x）\nd.一个位模式的补码,就是两者相加刚好溢出的那个码值,无符号数x(假设为w位),它的补码可以通过计算2^w-x(不包括0)得出,而有符号数x的补码即是它的相反数(不包括所能表示的最小值),其实从位角度来看对每一位取反加1(本质上就是这么算的),也可以这么看,以最右边的位为1的为界,它左边的(不包括它本身)都取反\n\n2.取模的算式\n```\n(a+b) mod P = [(a mod P)+(b mod P)]mod P\n(a*b) mod P = [(a mod P)*(b mod P)]mod P\n```\n","source":"_posts/计算机原理.md","raw":"---\ntitle: 计算机原理\ndate: 2020-08-04 08:15:20\nsubtitle:\ncategories:\ntags:\nindex_img: /images/computer_bin.jpg\nbanner_img: /images/computer_bin.jpg\n---\n1.位运算相关\n```\na&(b|c)=(a&b)|(a&c)\na|(b&c)=(a|b)&(a|c)\na^a=0 a^(a+1)=1(a为偶数)\na=n&(n-1)(移除n最后一个1)\ndiff=(n&(n-1))^n=n&(-n) (获取最后一个1)\n(n^(-1))+1=-n(有符号数取反加一为其相反数)\n(var^(var>>31))-(var>>31) (32位取绝对值)\n```\n2.位移运算\n左移:<<,丢弃高位,低位补0\n逻辑右移:>>,左端补0(c语言,对于无符号数,为逻辑右移)\n算术右移:>>,左端补最高有效位的值(c语言,对于有符号数,为算术右移)\n3.无符号与有符号的转换\na.C语言两者之间的转换，保持位模式不变,只是改变解码规则,最高位的解释由负到正,除了最高位的解释变化，其余位不变，设那些的权重和为k。\n所以有符号补码的解释为-2^(w-1)+k,而无符号解释为2^(w-1)+k,w表示位数,所以两者相差2^w, 对于位模式(只考虑负数,即超过有符号表示范围的正数)相同的有以下结论:\n无符号数=有符号负数+2^w\n有符号负数=无符号数-2^w\n有符号负数的绝对值+无符号数=2^w\nb.无符号与有符号比较,c语言会都转换无符号\n4.数字位的扩展\na.低位无符号向高位转换时,只要简单把多出来的位置为0\nb.低位有符号向高位有符号扩展时,为保持表示的数值不变,多出的位与原来符号位保持一致,很好想,0好说,多出来的位为0即保持数不变,1的话即是负数，多出的位都置为1,记住2^w-2^(w-1)=2^(w-1),这样多出来的权重和就是没多出位之前最高的负权重(用脑子一想就知道了)\nc.低位有符号向高位无符号扩展时,C语言是这样处理,先进行低位有符号到高位有符号扩展,即b,在进行有符号到无符号的同位转换,即3中的方法\n5.截断位\n截断都是直接去除多出的位,C中不支持这种转换,但这就是溢出的本质\na.截断后表示无符号,低位表示的数=高位数mod2^(低位数),很好想,去除的位数权重和肯定是2^(低位数)的倍数,低位表示的数肯定小于2^(低位数)(因为,低位表示的数最大值为2^(低位数)-1)\nb.截断后表示有符号,比较弱智的想法是,先转无符号,在此基础上进行无符号到有符号的转换.\n6.无符号相加溢出\n若0<=x,y<2^w,则x+y在[0,2^(w+1)-2]之间,x+y若大于等于2^w,则会被截断,表现为x+y-2^w。很容易想不做说明,同时也很容易得出,如果判断是否溢出,当且仅当得数小于其中任意一个加数。(因为溢出的话,x+y-2^w-x=y-2^w,肯定小于0)\n7.有符号相加\n向上溢出和6相同,向下溢出,则表现为x+y+2^w。书上的太难啃,我是这么想的,接它一位,并且表示没借之前的最小负数,应该是最高前两位为1,其余为0,而没借之前无法表示多出来的值为(-x-y-2^(w-1)),再以无符号来看,所以借出来之后,表示溢出的应有负数对应的无符号值为2^w+2^(w-1)-(-x-y-2^(w-1)),该数补码值即是表示不出来的负数,该高位无符号值化简为x+y+2^(w+1),由于x+y处于[-2^w,-2^w-1)之间,所以x+y+2^(w+1)的最小值为2^w,所以补出来的那一位始终为1,所以截断时要减去个2^w,最终结果就是x+y+2^(w+1)-2^(w)=x+y+2^(w)这个值,我知道我第二次看可能看不懂,以此纪念我思考的过程,和拙劣的表达\n补码检测上溢出:x,y都大于0,但它们的和小于等于0即发生溢出\n补码检测下溢出:x,y都小于0,但他们的和大于等于0即发生溢出\n<font color=#FF0000>其实本质上，溢出后表示的值,就是,借给它一个高位后,正确表达时,再按5的方法截断的值</font>\n8.整数相乘\n若补码整数x0,y0,与它们位模式相同的无符号整数为x1,y1,(x0\\*y0)与(x1\\*y1)的结果，无论有没有被截断，它们的位模式是相同的(还要缕一缕)\n9.乘以2的幂\nx\\*2^k,就等价于x\\<\\<k,对于不是2的幂的也可以转换如:x\\*14=x\\*(2^3+2^2+2)=(x<<3)+(x<<2)+(x<<1)\n10.除以2的幂\n无符号除以就是向右逻辑移位(与乘法相反嘛,聪明的你肯定想到了),而补码除以就是向右算术移位,同时当结果为负数,要保证舍入到0(简单来说就是无论正负,都去掉小数点,因为直接移位,会使结果原离远点),还需要做点修正,x/2^k=(x+(1\\<\\<k)-1)\\>\\>k(本质上,利用了如下的属性x/y)\nC中补码的除法会进行如下:\n`(x<0 ? x+(1<<k)-1 :x)>>k`来计算x/2^k\n3.trick\na.-1用补码表示为全1位\nb.0用补码表示为全0位\nc.非负数x,-x的w位补码表示就是2^w-x,而反码则是[111...1]-x,（这两个表达式都当成无符号来进行位表示。反码也可以这么理解2^w-1-x）\nd.一个位模式的补码,就是两者相加刚好溢出的那个码值,无符号数x(假设为w位),它的补码可以通过计算2^w-x(不包括0)得出,而有符号数x的补码即是它的相反数(不包括所能表示的最小值),其实从位角度来看对每一位取反加1(本质上就是这么算的),也可以这么看,以最右边的位为1的为界,它左边的(不包括它本身)都取反\n\n2.取模的算式\n```\n(a+b) mod P = [(a mod P)+(b mod P)]mod P\n(a*b) mod P = [(a mod P)*(b mod P)]mod P\n```\n","slug":"计算机原理","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi7b002egwq24rq9125c","content":"<p>1.位运算相关</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">a&amp;(b|c)=(a&amp;b)|(a&amp;c)<br>a|(b&amp;c)=(a|b)&amp;(a|c)<br>a^a=<span class=\"hljs-number\">0</span> a^(a+<span class=\"hljs-number\">1</span>)=<span class=\"hljs-number\">1</span>(a为偶数)<br>a=<span class=\"hljs-built_in\">n</span>&amp;(<span class=\"hljs-built_in\">n</span>-<span class=\"hljs-number\">1</span>)(移除<span class=\"hljs-built_in\">n</span>最后一个<span class=\"hljs-number\">1</span>)<br>diff=(<span class=\"hljs-built_in\">n</span>&amp;(<span class=\"hljs-built_in\">n</span>-<span class=\"hljs-number\">1</span>))^<span class=\"hljs-built_in\">n</span>=<span class=\"hljs-built_in\">n</span>&amp;(-<span class=\"hljs-built_in\">n</span>) (获取最后一个<span class=\"hljs-number\">1</span>)<br>(<span class=\"hljs-built_in\">n</span>^(-<span class=\"hljs-number\">1</span>))+<span class=\"hljs-number\">1</span>=-<span class=\"hljs-built_in\">n</span>(<span class=\"hljs-comment\">有符号数取反加一为其相反数</span>)<br>(<span class=\"hljs-built_in\">var</span>^(<span class=\"hljs-built_in\">var</span>&gt;&gt;<span class=\"hljs-number\">31</span>))-(<span class=\"hljs-built_in\">var</span>&gt;&gt;<span class=\"hljs-number\">31</span>) (<span class=\"hljs-number\">32</span>位取绝对值)<br></code></pre></td></tr></table></figure>\n<p>2.位移运算<br>左移:&lt;&lt;,丢弃高位,低位补0<br>逻辑右移:&gt;&gt;,左端补0(c语言,对于无符号数,为逻辑右移)<br>算术右移:&gt;&gt;,左端补最高有效位的值(c语言,对于有符号数,为算术右移)<br>3.无符号与有符号的转换<br>a.C语言两者之间的转换，保持位模式不变,只是改变解码规则,最高位的解释由负到正,除了最高位的解释变化，其余位不变，设那些的权重和为k。<br>所以有符号补码的解释为-2^(w-1)+k,而无符号解释为2^(w-1)+k,w表示位数,所以两者相差2^w, 对于位模式(只考虑负数,即超过有符号表示范围的正数)相同的有以下结论:<br>无符号数&#x3D;有符号负数+2^w<br>有符号负数&#x3D;无符号数-2^w<br>有符号负数的绝对值+无符号数&#x3D;2^w<br>b.无符号与有符号比较,c语言会都转换无符号<br>4.数字位的扩展<br>a.低位无符号向高位转换时,只要简单把多出来的位置为0<br>b.低位有符号向高位有符号扩展时,为保持表示的数值不变,多出的位与原来符号位保持一致,很好想,0好说,多出来的位为0即保持数不变,1的话即是负数，多出的位都置为1,记住2^w-2^(w-1)&#x3D;2^(w-1),这样多出来的权重和就是没多出位之前最高的负权重(用脑子一想就知道了)<br>c.低位有符号向高位无符号扩展时,C语言是这样处理,先进行低位有符号到高位有符号扩展,即b,在进行有符号到无符号的同位转换,即3中的方法<br>5.截断位<br>截断都是直接去除多出的位,C中不支持这种转换,但这就是溢出的本质<br>a.截断后表示无符号,低位表示的数&#x3D;高位数mod2^(低位数),很好想,去除的位数权重和肯定是2^(低位数)的倍数,低位表示的数肯定小于2^(低位数)(因为,低位表示的数最大值为2^(低位数)-1)<br>b.截断后表示有符号,比较弱智的想法是,先转无符号,在此基础上进行无符号到有符号的转换.<br>6.无符号相加溢出<br>若0&lt;&#x3D;x,y&lt;2^w,则x+y在[0,2^(w+1)-2]之间,x+y若大于等于2^w,则会被截断,表现为x+y-2^w。很容易想不做说明,同时也很容易得出,如果判断是否溢出,当且仅当得数小于其中任意一个加数。(因为溢出的话,x+y-2^w-x&#x3D;y-2^w,肯定小于0)<br>7.有符号相加<br>向上溢出和6相同,向下溢出,则表现为x+y+2^w。书上的太难啃,我是这么想的,接它一位,并且表示没借之前的最小负数,应该是最高前两位为1,其余为0,而没借之前无法表示多出来的值为(-x-y-2^(w-1)),再以无符号来看,所以借出来之后,表示溢出的应有负数对应的无符号值为2^w+2^(w-1)-(-x-y-2^(w-1)),该数补码值即是表示不出来的负数,该高位无符号值化简为x+y+2^(w+1),由于x+y处于[-2^w,-2^w-1)之间,所以x+y+2^(w+1)的最小值为2^w,所以补出来的那一位始终为1,所以截断时要减去个2^w,最终结果就是x+y+2^(w+1)-2^(w)&#x3D;x+y+2^(w)这个值,我知道我第二次看可能看不懂,以此纪念我思考的过程,和拙劣的表达<br>补码检测上溢出:x,y都大于0,但它们的和小于等于0即发生溢出<br>补码检测下溢出:x,y都小于0,但他们的和大于等于0即发生溢出<br><font color=#FF0000>其实本质上，溢出后表示的值,就是,借给它一个高位后,正确表达时,再按5的方法截断的值</font><br>8.整数相乘<br>若补码整数x0,y0,与它们位模式相同的无符号整数为x1,y1,(x0*y0)与(x1*y1)的结果，无论有没有被截断，它们的位模式是相同的(还要缕一缕)<br>9.乘以2的幂<br>x*2^k,就等价于x&lt;&lt;k,对于不是2的幂的也可以转换如:x*14&#x3D;x*(2^3+2^2+2)&#x3D;(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)<br>10.除以2的幂<br>无符号除以就是向右逻辑移位(与乘法相反嘛,聪明的你肯定想到了),而补码除以就是向右算术移位,同时当结果为负数,要保证舍入到0(简单来说就是无论正负,都去掉小数点,因为直接移位,会使结果原离远点),还需要做点修正,x&#x2F;2^k&#x3D;(x+(1&lt;&lt;k)-1)&gt;&gt;k(本质上,利用了如下的属性x&#x2F;y)<br>C中补码的除法会进行如下:<br><code>(x&lt;0 ? x+(1&lt;&lt;k)-1 :x)&gt;&gt;k</code>来计算x&#x2F;2^k<br>3.trick<br>a.-1用补码表示为全1位<br>b.0用补码表示为全0位<br>c.非负数x,-x的w位补码表示就是2^w-x,而反码则是[111…1]-x,（这两个表达式都当成无符号来进行位表示。反码也可以这么理解2^w-1-x）<br>d.一个位模式的补码,就是两者相加刚好溢出的那个码值,无符号数x(假设为w位),它的补码可以通过计算2^w-x(不包括0)得出,而有符号数x的补码即是它的相反数(不包括所能表示的最小值),其实从位角度来看对每一位取反加1(本质上就是这么算的),也可以这么看,以最右边的位为1的为界,它左边的(不包括它本身)都取反</p>\n<p>2.取模的算式</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">(<span class=\"hljs-keyword\">a</span>+b) <span class=\"hljs-keyword\">mod</span> P = [(<span class=\"hljs-keyword\">a</span> <span class=\"hljs-keyword\">mod</span> P)+(b <span class=\"hljs-keyword\">mod</span> P)]<span class=\"hljs-keyword\">mod</span> P<br>(<span class=\"hljs-keyword\">a</span>*b) <span class=\"hljs-keyword\">mod</span> P = [(<span class=\"hljs-keyword\">a</span> <span class=\"hljs-keyword\">mod</span> P)*(b <span class=\"hljs-keyword\">mod</span> P)]<span class=\"hljs-keyword\">mod</span> P<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>1.位运算相关</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">a&amp;(b|c)=(a&amp;b)|(a&amp;c)<br>a|(b&amp;c)=(a|b)&amp;(a|c)<br>a^a=<span class=\"hljs-number\">0</span> a^(a+<span class=\"hljs-number\">1</span>)=<span class=\"hljs-number\">1</span>(a为偶数)<br>a=<span class=\"hljs-built_in\">n</span>&amp;(<span class=\"hljs-built_in\">n</span>-<span class=\"hljs-number\">1</span>)(移除<span class=\"hljs-built_in\">n</span>最后一个<span class=\"hljs-number\">1</span>)<br>diff=(<span class=\"hljs-built_in\">n</span>&amp;(<span class=\"hljs-built_in\">n</span>-<span class=\"hljs-number\">1</span>))^<span class=\"hljs-built_in\">n</span>=<span class=\"hljs-built_in\">n</span>&amp;(-<span class=\"hljs-built_in\">n</span>) (获取最后一个<span class=\"hljs-number\">1</span>)<br>(<span class=\"hljs-built_in\">n</span>^(-<span class=\"hljs-number\">1</span>))+<span class=\"hljs-number\">1</span>=-<span class=\"hljs-built_in\">n</span>(<span class=\"hljs-comment\">有符号数取反加一为其相反数</span>)<br>(<span class=\"hljs-built_in\">var</span>^(<span class=\"hljs-built_in\">var</span>&gt;&gt;<span class=\"hljs-number\">31</span>))-(<span class=\"hljs-built_in\">var</span>&gt;&gt;<span class=\"hljs-number\">31</span>) (<span class=\"hljs-number\">32</span>位取绝对值)<br></code></pre></td></tr></table></figure>\n<p>2.位移运算<br>左移:&lt;&lt;,丢弃高位,低位补0<br>逻辑右移:&gt;&gt;,左端补0(c语言,对于无符号数,为逻辑右移)<br>算术右移:&gt;&gt;,左端补最高有效位的值(c语言,对于有符号数,为算术右移)<br>3.无符号与有符号的转换<br>a.C语言两者之间的转换，保持位模式不变,只是改变解码规则,最高位的解释由负到正,除了最高位的解释变化，其余位不变，设那些的权重和为k。<br>所以有符号补码的解释为-2^(w-1)+k,而无符号解释为2^(w-1)+k,w表示位数,所以两者相差2^w, 对于位模式(只考虑负数,即超过有符号表示范围的正数)相同的有以下结论:<br>无符号数&#x3D;有符号负数+2^w<br>有符号负数&#x3D;无符号数-2^w<br>有符号负数的绝对值+无符号数&#x3D;2^w<br>b.无符号与有符号比较,c语言会都转换无符号<br>4.数字位的扩展<br>a.低位无符号向高位转换时,只要简单把多出来的位置为0<br>b.低位有符号向高位有符号扩展时,为保持表示的数值不变,多出的位与原来符号位保持一致,很好想,0好说,多出来的位为0即保持数不变,1的话即是负数，多出的位都置为1,记住2^w-2^(w-1)&#x3D;2^(w-1),这样多出来的权重和就是没多出位之前最高的负权重(用脑子一想就知道了)<br>c.低位有符号向高位无符号扩展时,C语言是这样处理,先进行低位有符号到高位有符号扩展,即b,在进行有符号到无符号的同位转换,即3中的方法<br>5.截断位<br>截断都是直接去除多出的位,C中不支持这种转换,但这就是溢出的本质<br>a.截断后表示无符号,低位表示的数&#x3D;高位数mod2^(低位数),很好想,去除的位数权重和肯定是2^(低位数)的倍数,低位表示的数肯定小于2^(低位数)(因为,低位表示的数最大值为2^(低位数)-1)<br>b.截断后表示有符号,比较弱智的想法是,先转无符号,在此基础上进行无符号到有符号的转换.<br>6.无符号相加溢出<br>若0&lt;&#x3D;x,y&lt;2^w,则x+y在[0,2^(w+1)-2]之间,x+y若大于等于2^w,则会被截断,表现为x+y-2^w。很容易想不做说明,同时也很容易得出,如果判断是否溢出,当且仅当得数小于其中任意一个加数。(因为溢出的话,x+y-2^w-x&#x3D;y-2^w,肯定小于0)<br>7.有符号相加<br>向上溢出和6相同,向下溢出,则表现为x+y+2^w。书上的太难啃,我是这么想的,接它一位,并且表示没借之前的最小负数,应该是最高前两位为1,其余为0,而没借之前无法表示多出来的值为(-x-y-2^(w-1)),再以无符号来看,所以借出来之后,表示溢出的应有负数对应的无符号值为2^w+2^(w-1)-(-x-y-2^(w-1)),该数补码值即是表示不出来的负数,该高位无符号值化简为x+y+2^(w+1),由于x+y处于[-2^w,-2^w-1)之间,所以x+y+2^(w+1)的最小值为2^w,所以补出来的那一位始终为1,所以截断时要减去个2^w,最终结果就是x+y+2^(w+1)-2^(w)&#x3D;x+y+2^(w)这个值,我知道我第二次看可能看不懂,以此纪念我思考的过程,和拙劣的表达<br>补码检测上溢出:x,y都大于0,但它们的和小于等于0即发生溢出<br>补码检测下溢出:x,y都小于0,但他们的和大于等于0即发生溢出<br><font color=#FF0000>其实本质上，溢出后表示的值,就是,借给它一个高位后,正确表达时,再按5的方法截断的值</font><br>8.整数相乘<br>若补码整数x0,y0,与它们位模式相同的无符号整数为x1,y1,(x0*y0)与(x1*y1)的结果，无论有没有被截断，它们的位模式是相同的(还要缕一缕)<br>9.乘以2的幂<br>x*2^k,就等价于x&lt;&lt;k,对于不是2的幂的也可以转换如:x*14&#x3D;x*(2^3+2^2+2)&#x3D;(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)<br>10.除以2的幂<br>无符号除以就是向右逻辑移位(与乘法相反嘛,聪明的你肯定想到了),而补码除以就是向右算术移位,同时当结果为负数,要保证舍入到0(简单来说就是无论正负,都去掉小数点,因为直接移位,会使结果原离远点),还需要做点修正,x&#x2F;2^k&#x3D;(x+(1&lt;&lt;k)-1)&gt;&gt;k(本质上,利用了如下的属性x&#x2F;y)<br>C中补码的除法会进行如下:<br><code>(x&lt;0 ? x+(1&lt;&lt;k)-1 :x)&gt;&gt;k</code>来计算x&#x2F;2^k<br>3.trick<br>a.-1用补码表示为全1位<br>b.0用补码表示为全0位<br>c.非负数x,-x的w位补码表示就是2^w-x,而反码则是[111…1]-x,（这两个表达式都当成无符号来进行位表示。反码也可以这么理解2^w-1-x）<br>d.一个位模式的补码,就是两者相加刚好溢出的那个码值,无符号数x(假设为w位),它的补码可以通过计算2^w-x(不包括0)得出,而有符号数x的补码即是它的相反数(不包括所能表示的最小值),其实从位角度来看对每一位取反加1(本质上就是这么算的),也可以这么看,以最右边的位为1的为界,它左边的(不包括它本身)都取反</p>\n<p>2.取模的算式</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">(<span class=\"hljs-keyword\">a</span>+b) <span class=\"hljs-keyword\">mod</span> P = [(<span class=\"hljs-keyword\">a</span> <span class=\"hljs-keyword\">mod</span> P)+(b <span class=\"hljs-keyword\">mod</span> P)]<span class=\"hljs-keyword\">mod</span> P<br>(<span class=\"hljs-keyword\">a</span>*b) <span class=\"hljs-keyword\">mod</span> P = [(<span class=\"hljs-keyword\">a</span> <span class=\"hljs-keyword\">mod</span> P)*(b <span class=\"hljs-keyword\">mod</span> P)]<span class=\"hljs-keyword\">mod</span> P<br></code></pre></td></tr></table></figure>\n"},{"title":"计算机网络基础","date":"2022-10-02T07:01:35.000Z","subtitle":null,"index_img":"/images/network.png","banner_img":"/images/network.png","_content":"\n# 接入网\n- 定义: 将端系统物理连接到**边缘路由器**的网络，**边缘路由器**就是端系统到任何其他远程端系统的路径上的第一台路由器\n## 家庭接入\n### 数字用户线(DSL)\n![](/images/dsl.png)\n- 涉及概念：DSL调制解调器，数字用户线接入复用器（DSLAM）\n### 电缆英特网接入\n![](/images/CIA.png)\n- 涉及概念：电缆调制解调器端接系统(CMTS),混合光纤同轴（HFC）系统\n### 光纤到户（FTTH）\n- 涉及概念：光纤网络端接器（ONT）,光纤线路端接器（OLT）\n## 企业(/家庭)接入\n### 以太网（LAN局域网的一种）\n![](/images/LAN.png)\n### wifi(无线局域网wlan)\n![](/images/wireless.png)\n## 广域接入\n2G,3G,4G...,LTE\n# 物理媒介\n![双绞铜线](/images/tp.png)\n![同轴电缆](/images/cable.png)\n![光纤](/images/fiber.png)\n陆地/卫星无线电通道\n# 网络核心\n## 电路交换（过时）\n- 涉及概念：频分复用(FDM)、时分复用(TDM)\n## 分组交换\n端到端交换**报文(message)**,需要将报文划分较小的数据块，称之为**分组(packet)**，每个分组由**比特**衡量大小\n### 时延\n![](/images/delay.png)\n- 处理时延：检查分组首部和决定该分组导向何处所需要的时间，由路由处理及选择有关,<=微秒量级\n- 排队时延：一个特定分组的排队时延取决于先期到达的正在排队的分组数量,毫秒量级-微秒量级\n- 传输时延：一个分组的所有比特到达后才可以传输，一个L比特的分组在速率为R的链路上的传输时延是L/R，与路由之间的距离无关，毫秒-微妙\n- 传播时延：从链路的起点到某路由器传播所需要的时间是传播时延，与距离相关：d/s，s解近光速，毫秒级别\n### 排队时延和丢包\n- 流量强度：La/R,a为分组/秒，表示分组到达队列的平均速率,流量强度必须小于1,否则队列无限增长，时延趋向无限大，但实际中容量有限，此时会导致丢包\n### 吞吐量\n![](/images/througput.png)\n取决于链路中的最小传输速率，及公共链路中其他干扰流量,忽略干扰流量就是min(R1,R2,R3...)\n## 网络安全\n### 病毒和蠕虫\n### 拒绝服务攻击-DoS\n- 弱点攻击：向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文\n- 带宽洪泛：攻击者向目标主机发送大量的分组，使链路拥塞\n- 连接洪泛：在目标主机中创建大量半开或全开TCP连接\n### 嗅探分组wireshark\n### ip哄骗\n## 网络层模型\n![](/images/layer.png)\n- message:报文\n- segment:报文段\n- datagram:数据报\n- frame:帧\n","source":"_posts/计算机网络基础.md","raw":"---\ntitle: 计算机网络基础\ndate: 2022-10-02 15:01:35\nsubtitle:\ncategories:\ntags:\nindex_img: /images/network.png\nbanner_img: /images/network.png\n---\n\n# 接入网\n- 定义: 将端系统物理连接到**边缘路由器**的网络，**边缘路由器**就是端系统到任何其他远程端系统的路径上的第一台路由器\n## 家庭接入\n### 数字用户线(DSL)\n![](/images/dsl.png)\n- 涉及概念：DSL调制解调器，数字用户线接入复用器（DSLAM）\n### 电缆英特网接入\n![](/images/CIA.png)\n- 涉及概念：电缆调制解调器端接系统(CMTS),混合光纤同轴（HFC）系统\n### 光纤到户（FTTH）\n- 涉及概念：光纤网络端接器（ONT）,光纤线路端接器（OLT）\n## 企业(/家庭)接入\n### 以太网（LAN局域网的一种）\n![](/images/LAN.png)\n### wifi(无线局域网wlan)\n![](/images/wireless.png)\n## 广域接入\n2G,3G,4G...,LTE\n# 物理媒介\n![双绞铜线](/images/tp.png)\n![同轴电缆](/images/cable.png)\n![光纤](/images/fiber.png)\n陆地/卫星无线电通道\n# 网络核心\n## 电路交换（过时）\n- 涉及概念：频分复用(FDM)、时分复用(TDM)\n## 分组交换\n端到端交换**报文(message)**,需要将报文划分较小的数据块，称之为**分组(packet)**，每个分组由**比特**衡量大小\n### 时延\n![](/images/delay.png)\n- 处理时延：检查分组首部和决定该分组导向何处所需要的时间，由路由处理及选择有关,<=微秒量级\n- 排队时延：一个特定分组的排队时延取决于先期到达的正在排队的分组数量,毫秒量级-微秒量级\n- 传输时延：一个分组的所有比特到达后才可以传输，一个L比特的分组在速率为R的链路上的传输时延是L/R，与路由之间的距离无关，毫秒-微妙\n- 传播时延：从链路的起点到某路由器传播所需要的时间是传播时延，与距离相关：d/s，s解近光速，毫秒级别\n### 排队时延和丢包\n- 流量强度：La/R,a为分组/秒，表示分组到达队列的平均速率,流量强度必须小于1,否则队列无限增长，时延趋向无限大，但实际中容量有限，此时会导致丢包\n### 吞吐量\n![](/images/througput.png)\n取决于链路中的最小传输速率，及公共链路中其他干扰流量,忽略干扰流量就是min(R1,R2,R3...)\n## 网络安全\n### 病毒和蠕虫\n### 拒绝服务攻击-DoS\n- 弱点攻击：向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文\n- 带宽洪泛：攻击者向目标主机发送大量的分组，使链路拥塞\n- 连接洪泛：在目标主机中创建大量半开或全开TCP连接\n### 嗅探分组wireshark\n### ip哄骗\n## 网络层模型\n![](/images/layer.png)\n- message:报文\n- segment:报文段\n- datagram:数据报\n- frame:帧\n","slug":"计算机网络基础","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi7b002fgwq2dxzt9ddj","content":"<h1 id=\"接入网\"><a href=\"#接入网\" class=\"headerlink\" title=\"接入网\"></a>接入网</h1><ul>\n<li>定义: 将端系统物理连接到<strong>边缘路由器</strong>的网络，<strong>边缘路由器</strong>就是端系统到任何其他远程端系统的路径上的第一台路由器</li>\n</ul>\n<h2 id=\"家庭接入\"><a href=\"#家庭接入\" class=\"headerlink\" title=\"家庭接入\"></a>家庭接入</h2><h3 id=\"数字用户线-DSL\"><a href=\"#数字用户线-DSL\" class=\"headerlink\" title=\"数字用户线(DSL)\"></a>数字用户线(DSL)</h3><p><img src=\"/images/dsl.png\"></p>\n<ul>\n<li>涉及概念：DSL调制解调器，数字用户线接入复用器（DSLAM）</li>\n</ul>\n<h3 id=\"电缆英特网接入\"><a href=\"#电缆英特网接入\" class=\"headerlink\" title=\"电缆英特网接入\"></a>电缆英特网接入</h3><p><img src=\"/images/CIA.png\"></p>\n<ul>\n<li>涉及概念：电缆调制解调器端接系统(CMTS),混合光纤同轴（HFC）系统</li>\n</ul>\n<h3 id=\"光纤到户（FTTH）\"><a href=\"#光纤到户（FTTH）\" class=\"headerlink\" title=\"光纤到户（FTTH）\"></a>光纤到户（FTTH）</h3><ul>\n<li>涉及概念：光纤网络端接器（ONT）,光纤线路端接器（OLT）</li>\n</ul>\n<h2 id=\"企业-家庭-接入\"><a href=\"#企业-家庭-接入\" class=\"headerlink\" title=\"企业(&#x2F;家庭)接入\"></a>企业(&#x2F;家庭)接入</h2><h3 id=\"以太网（LAN局域网的一种）\"><a href=\"#以太网（LAN局域网的一种）\" class=\"headerlink\" title=\"以太网（LAN局域网的一种）\"></a>以太网（LAN局域网的一种）</h3><p><img src=\"/images/LAN.png\"></p>\n<h3 id=\"wifi-无线局域网wlan\"><a href=\"#wifi-无线局域网wlan\" class=\"headerlink\" title=\"wifi(无线局域网wlan)\"></a>wifi(无线局域网wlan)</h3><p><img src=\"/images/wireless.png\"></p>\n<h2 id=\"广域接入\"><a href=\"#广域接入\" class=\"headerlink\" title=\"广域接入\"></a>广域接入</h2><p>2G,3G,4G…,LTE</p>\n<h1 id=\"物理媒介\"><a href=\"#物理媒介\" class=\"headerlink\" title=\"物理媒介\"></a>物理媒介</h1><p><img src=\"/images/tp.png\" alt=\"双绞铜线\"><br><img src=\"/images/cable.png\" alt=\"同轴电缆\"><br><img src=\"/images/fiber.png\" alt=\"光纤\"><br>陆地&#x2F;卫星无线电通道</p>\n<h1 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h1><h2 id=\"电路交换（过时）\"><a href=\"#电路交换（过时）\" class=\"headerlink\" title=\"电路交换（过时）\"></a>电路交换（过时）</h2><ul>\n<li>涉及概念：频分复用(FDM)、时分复用(TDM)</li>\n</ul>\n<h2 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h2><p>端到端交换<strong>报文(message)</strong>,需要将报文划分较小的数据块，称之为<strong>分组(packet)<strong>，每个分组由</strong>比特</strong>衡量大小</p>\n<h3 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h3><p><img src=\"/images/delay.png\"></p>\n<ul>\n<li>处理时延：检查分组首部和决定该分组导向何处所需要的时间，由路由处理及选择有关,&lt;&#x3D;微秒量级</li>\n<li>排队时延：一个特定分组的排队时延取决于先期到达的正在排队的分组数量,毫秒量级-微秒量级</li>\n<li>传输时延：一个分组的所有比特到达后才可以传输，一个L比特的分组在速率为R的链路上的传输时延是L&#x2F;R，与路由之间的距离无关，毫秒-微妙</li>\n<li>传播时延：从链路的起点到某路由器传播所需要的时间是传播时延，与距离相关：d&#x2F;s，s解近光速，毫秒级别</li>\n</ul>\n<h3 id=\"排队时延和丢包\"><a href=\"#排队时延和丢包\" class=\"headerlink\" title=\"排队时延和丢包\"></a>排队时延和丢包</h3><ul>\n<li>流量强度：La&#x2F;R,a为分组&#x2F;秒，表示分组到达队列的平均速率,流量强度必须小于1,否则队列无限增长，时延趋向无限大，但实际中容量有限，此时会导致丢包</li>\n</ul>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p><img src=\"/images/througput.png\"><br>取决于链路中的最小传输速率，及公共链路中其他干扰流量,忽略干扰流量就是min(R1,R2,R3…)</p>\n<h2 id=\"网络安全\"><a href=\"#网络安全\" class=\"headerlink\" title=\"网络安全\"></a>网络安全</h2><h3 id=\"病毒和蠕虫\"><a href=\"#病毒和蠕虫\" class=\"headerlink\" title=\"病毒和蠕虫\"></a>病毒和蠕虫</h3><h3 id=\"拒绝服务攻击-DoS\"><a href=\"#拒绝服务攻击-DoS\" class=\"headerlink\" title=\"拒绝服务攻击-DoS\"></a>拒绝服务攻击-DoS</h3><ul>\n<li>弱点攻击：向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文</li>\n<li>带宽洪泛：攻击者向目标主机发送大量的分组，使链路拥塞</li>\n<li>连接洪泛：在目标主机中创建大量半开或全开TCP连接</li>\n</ul>\n<h3 id=\"嗅探分组wireshark\"><a href=\"#嗅探分组wireshark\" class=\"headerlink\" title=\"嗅探分组wireshark\"></a>嗅探分组wireshark</h3><h3 id=\"ip哄骗\"><a href=\"#ip哄骗\" class=\"headerlink\" title=\"ip哄骗\"></a>ip哄骗</h3><h2 id=\"网络层模型\"><a href=\"#网络层模型\" class=\"headerlink\" title=\"网络层模型\"></a>网络层模型</h2><p><img src=\"/images/layer.png\"></p>\n<ul>\n<li>message:报文</li>\n<li>segment:报文段</li>\n<li>datagram:数据报</li>\n<li>frame:帧</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"接入网\"><a href=\"#接入网\" class=\"headerlink\" title=\"接入网\"></a>接入网</h1><ul>\n<li>定义: 将端系统物理连接到<strong>边缘路由器</strong>的网络，<strong>边缘路由器</strong>就是端系统到任何其他远程端系统的路径上的第一台路由器</li>\n</ul>\n<h2 id=\"家庭接入\"><a href=\"#家庭接入\" class=\"headerlink\" title=\"家庭接入\"></a>家庭接入</h2><h3 id=\"数字用户线-DSL\"><a href=\"#数字用户线-DSL\" class=\"headerlink\" title=\"数字用户线(DSL)\"></a>数字用户线(DSL)</h3><p><img src=\"/images/dsl.png\"></p>\n<ul>\n<li>涉及概念：DSL调制解调器，数字用户线接入复用器（DSLAM）</li>\n</ul>\n<h3 id=\"电缆英特网接入\"><a href=\"#电缆英特网接入\" class=\"headerlink\" title=\"电缆英特网接入\"></a>电缆英特网接入</h3><p><img src=\"/images/CIA.png\"></p>\n<ul>\n<li>涉及概念：电缆调制解调器端接系统(CMTS),混合光纤同轴（HFC）系统</li>\n</ul>\n<h3 id=\"光纤到户（FTTH）\"><a href=\"#光纤到户（FTTH）\" class=\"headerlink\" title=\"光纤到户（FTTH）\"></a>光纤到户（FTTH）</h3><ul>\n<li>涉及概念：光纤网络端接器（ONT）,光纤线路端接器（OLT）</li>\n</ul>\n<h2 id=\"企业-家庭-接入\"><a href=\"#企业-家庭-接入\" class=\"headerlink\" title=\"企业(&#x2F;家庭)接入\"></a>企业(&#x2F;家庭)接入</h2><h3 id=\"以太网（LAN局域网的一种）\"><a href=\"#以太网（LAN局域网的一种）\" class=\"headerlink\" title=\"以太网（LAN局域网的一种）\"></a>以太网（LAN局域网的一种）</h3><p><img src=\"/images/LAN.png\"></p>\n<h3 id=\"wifi-无线局域网wlan\"><a href=\"#wifi-无线局域网wlan\" class=\"headerlink\" title=\"wifi(无线局域网wlan)\"></a>wifi(无线局域网wlan)</h3><p><img src=\"/images/wireless.png\"></p>\n<h2 id=\"广域接入\"><a href=\"#广域接入\" class=\"headerlink\" title=\"广域接入\"></a>广域接入</h2><p>2G,3G,4G…,LTE</p>\n<h1 id=\"物理媒介\"><a href=\"#物理媒介\" class=\"headerlink\" title=\"物理媒介\"></a>物理媒介</h1><p><img src=\"/images/tp.png\" alt=\"双绞铜线\"><br><img src=\"/images/cable.png\" alt=\"同轴电缆\"><br><img src=\"/images/fiber.png\" alt=\"光纤\"><br>陆地&#x2F;卫星无线电通道</p>\n<h1 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h1><h2 id=\"电路交换（过时）\"><a href=\"#电路交换（过时）\" class=\"headerlink\" title=\"电路交换（过时）\"></a>电路交换（过时）</h2><ul>\n<li>涉及概念：频分复用(FDM)、时分复用(TDM)</li>\n</ul>\n<h2 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h2><p>端到端交换<strong>报文(message)</strong>,需要将报文划分较小的数据块，称之为<strong>分组(packet)<strong>，每个分组由</strong>比特</strong>衡量大小</p>\n<h3 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h3><p><img src=\"/images/delay.png\"></p>\n<ul>\n<li>处理时延：检查分组首部和决定该分组导向何处所需要的时间，由路由处理及选择有关,&lt;&#x3D;微秒量级</li>\n<li>排队时延：一个特定分组的排队时延取决于先期到达的正在排队的分组数量,毫秒量级-微秒量级</li>\n<li>传输时延：一个分组的所有比特到达后才可以传输，一个L比特的分组在速率为R的链路上的传输时延是L&#x2F;R，与路由之间的距离无关，毫秒-微妙</li>\n<li>传播时延：从链路的起点到某路由器传播所需要的时间是传播时延，与距离相关：d&#x2F;s，s解近光速，毫秒级别</li>\n</ul>\n<h3 id=\"排队时延和丢包\"><a href=\"#排队时延和丢包\" class=\"headerlink\" title=\"排队时延和丢包\"></a>排队时延和丢包</h3><ul>\n<li>流量强度：La&#x2F;R,a为分组&#x2F;秒，表示分组到达队列的平均速率,流量强度必须小于1,否则队列无限增长，时延趋向无限大，但实际中容量有限，此时会导致丢包</li>\n</ul>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p><img src=\"/images/througput.png\"><br>取决于链路中的最小传输速率，及公共链路中其他干扰流量,忽略干扰流量就是min(R1,R2,R3…)</p>\n<h2 id=\"网络安全\"><a href=\"#网络安全\" class=\"headerlink\" title=\"网络安全\"></a>网络安全</h2><h3 id=\"病毒和蠕虫\"><a href=\"#病毒和蠕虫\" class=\"headerlink\" title=\"病毒和蠕虫\"></a>病毒和蠕虫</h3><h3 id=\"拒绝服务攻击-DoS\"><a href=\"#拒绝服务攻击-DoS\" class=\"headerlink\" title=\"拒绝服务攻击-DoS\"></a>拒绝服务攻击-DoS</h3><ul>\n<li>弱点攻击：向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文</li>\n<li>带宽洪泛：攻击者向目标主机发送大量的分组，使链路拥塞</li>\n<li>连接洪泛：在目标主机中创建大量半开或全开TCP连接</li>\n</ul>\n<h3 id=\"嗅探分组wireshark\"><a href=\"#嗅探分组wireshark\" class=\"headerlink\" title=\"嗅探分组wireshark\"></a>嗅探分组wireshark</h3><h3 id=\"ip哄骗\"><a href=\"#ip哄骗\" class=\"headerlink\" title=\"ip哄骗\"></a>ip哄骗</h3><h2 id=\"网络层模型\"><a href=\"#网络层模型\" class=\"headerlink\" title=\"网络层模型\"></a>网络层模型</h2><p><img src=\"/images/layer.png\"></p>\n<ul>\n<li>message:报文</li>\n<li>segment:报文段</li>\n<li>datagram:数据报</li>\n<li>frame:帧</li>\n</ul>\n"},{"title":"设计模式_工厂模式","date":"2023-06-24T01:24:39.000Z","subtitle":null,"index_img":"/images/factoryPattern.png","banner_img":"/images/factoryPattern.png","_content":"\n# 简单工厂\n![](/images/simpleFactory.png)\n# 工厂方法\n- 定义： 一个创建对象的接口，但让子类决定哪个类要实力化。工厂方法让一个类延迟实例化到子类\n![](/images/factoryMethodNormal.png)\n![](/images/factoryMethodExp.png)\n## 依赖倒置\n- 定义：依赖抽象，不依赖具体类\n- 精髓：低层组件依赖于更高层的抽象\n- 原则：\n  - 变量不应该持有到具体类的引用\n  - 类不应该派生自具体类\n  - 方法不应该覆盖其任何基类的已实现方法\n# 抽象工厂\n- 定义：提供一个接口，用于创建相关或依赖对象的家族，而不必指定它们具体类\n![](/images/abstractFactory.png)\n# 要点\n- 所有工厂都封装对象的创建\n- 工厂方法靠继承：对象创建被委托给子类，子类实现工厂方法来创建对象\n- 抽象工厂靠对象组合：对象创建在工厂接口暴露的方法中实现\n- 所有工厂模式都通过减少应用对具体类的依赖，促进松耦合\n- 工厂方法的意图，是允许一个类延迟实例化到其子类\n- 抽象工厂的意图，是创建相关对象家族，不必依赖具体类\n- 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n","source":"_posts/设计模式-工厂模式.md","raw":"---\ntitle: 设计模式_工厂模式\ndate: 2023-06-24 09:24:39\nsubtitle:\ncategories:\ntags:\nindex_img: /images/factoryPattern.png\nbanner_img: /images/factoryPattern.png\n---\n\n# 简单工厂\n![](/images/simpleFactory.png)\n# 工厂方法\n- 定义： 一个创建对象的接口，但让子类决定哪个类要实力化。工厂方法让一个类延迟实例化到子类\n![](/images/factoryMethodNormal.png)\n![](/images/factoryMethodExp.png)\n## 依赖倒置\n- 定义：依赖抽象，不依赖具体类\n- 精髓：低层组件依赖于更高层的抽象\n- 原则：\n  - 变量不应该持有到具体类的引用\n  - 类不应该派生自具体类\n  - 方法不应该覆盖其任何基类的已实现方法\n# 抽象工厂\n- 定义：提供一个接口，用于创建相关或依赖对象的家族，而不必指定它们具体类\n![](/images/abstractFactory.png)\n# 要点\n- 所有工厂都封装对象的创建\n- 工厂方法靠继承：对象创建被委托给子类，子类实现工厂方法来创建对象\n- 抽象工厂靠对象组合：对象创建在工厂接口暴露的方法中实现\n- 所有工厂模式都通过减少应用对具体类的依赖，促进松耦合\n- 工厂方法的意图，是允许一个类延迟实例化到其子类\n- 抽象工厂的意图，是创建相关对象家族，不必依赖具体类\n- 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n","slug":"设计模式-工厂模式","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi7b002ggwq270jh7s1b","content":"<h1 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h1><p><img src=\"/images/simpleFactory.png\"></p>\n<h1 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h1><ul>\n<li>定义： 一个创建对象的接口，但让子类决定哪个类要实力化。工厂方法让一个类延迟实例化到子类<br><img src=\"/images/factoryMethodNormal.png\"><br><img src=\"/images/factoryMethodExp.png\"></li>\n</ul>\n<h2 id=\"依赖倒置\"><a href=\"#依赖倒置\" class=\"headerlink\" title=\"依赖倒置\"></a>依赖倒置</h2><ul>\n<li>定义：依赖抽象，不依赖具体类</li>\n<li>精髓：低层组件依赖于更高层的抽象</li>\n<li>原则：<ul>\n<li>变量不应该持有到具体类的引用</li>\n<li>类不应该派生自具体类</li>\n<li>方法不应该覆盖其任何基类的已实现方法</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h1><ul>\n<li>定义：提供一个接口，用于创建相关或依赖对象的家族，而不必指定它们具体类<br><img src=\"/images/abstractFactory.png\"></li>\n</ul>\n<h1 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h1><ul>\n<li>所有工厂都封装对象的创建</li>\n<li>工厂方法靠继承：对象创建被委托给子类，子类实现工厂方法来创建对象</li>\n<li>抽象工厂靠对象组合：对象创建在工厂接口暴露的方法中实现</li>\n<li>所有工厂模式都通过减少应用对具体类的依赖，促进松耦合</li>\n<li>工厂方法的意图，是允许一个类延迟实例化到其子类</li>\n<li>抽象工厂的意图，是创建相关对象家族，不必依赖具体类</li>\n<li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h1><p><img src=\"/images/simpleFactory.png\"></p>\n<h1 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h1><ul>\n<li>定义： 一个创建对象的接口，但让子类决定哪个类要实力化。工厂方法让一个类延迟实例化到子类<br><img src=\"/images/factoryMethodNormal.png\"><br><img src=\"/images/factoryMethodExp.png\"></li>\n</ul>\n<h2 id=\"依赖倒置\"><a href=\"#依赖倒置\" class=\"headerlink\" title=\"依赖倒置\"></a>依赖倒置</h2><ul>\n<li>定义：依赖抽象，不依赖具体类</li>\n<li>精髓：低层组件依赖于更高层的抽象</li>\n<li>原则：<ul>\n<li>变量不应该持有到具体类的引用</li>\n<li>类不应该派生自具体类</li>\n<li>方法不应该覆盖其任何基类的已实现方法</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h1><ul>\n<li>定义：提供一个接口，用于创建相关或依赖对象的家族，而不必指定它们具体类<br><img src=\"/images/abstractFactory.png\"></li>\n</ul>\n<h1 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h1><ul>\n<li>所有工厂都封装对象的创建</li>\n<li>工厂方法靠继承：对象创建被委托给子类，子类实现工厂方法来创建对象</li>\n<li>抽象工厂靠对象组合：对象创建在工厂接口暴露的方法中实现</li>\n<li>所有工厂模式都通过减少应用对具体类的依赖，促进松耦合</li>\n<li>工厂方法的意图，是允许一个类延迟实例化到其子类</li>\n<li>抽象工厂的意图，是创建相关对象家族，不必依赖具体类</li>\n<li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li>\n</ul>\n"},{"title":"设计模式_装饰者模式","date":"2023-06-26T02:44:20.000Z","banner_img":"/images/decorator_cover.jpg","index_img":"/images/decorator_cover.jpg","_content":"\n# 开放-关闭原则\n类应该对扩展开放，但对修改关闭\n# 类图\n![](/images/decorator.jpg)\n# 要点\n- 继承是扩展形式之一，但未必是达到弹性设计的最佳方式\n- 组合和委托经常可以用来在运行时添加新行为\n- 装饰者模式提供了子类化扩展行为的替代品\n- 装饰者模式涉及一群装饰者类，这些类用来包装具体组件\n- 装饰者类反映了他们所装饰的组件类型\n- 装饰者通过在对组件的方法调用之前或之后添加功能改变组件的行为\n- 可以用任意数目的装饰者来包裹一个组件\n- 装饰者一般对组件的客户是透明的，除非客户依赖于组件的具体类型\n- 装饰者或导致设计中出现许多小对象，过度使用会让代码复杂\n","source":"_posts/设计模式-装饰者模式.md","raw":"---\ntitle: 设计模式_装饰者模式\ndate: 2023-06-26 10:44:20\ntags:\nbanner_img: /images/decorator_cover.jpg\nindex_img: /images/decorator_cover.jpg\n---\n\n# 开放-关闭原则\n类应该对扩展开放，但对修改关闭\n# 类图\n![](/images/decorator.jpg)\n# 要点\n- 继承是扩展形式之一，但未必是达到弹性设计的最佳方式\n- 组合和委托经常可以用来在运行时添加新行为\n- 装饰者模式提供了子类化扩展行为的替代品\n- 装饰者模式涉及一群装饰者类，这些类用来包装具体组件\n- 装饰者类反映了他们所装饰的组件类型\n- 装饰者通过在对组件的方法调用之前或之后添加功能改变组件的行为\n- 可以用任意数目的装饰者来包裹一个组件\n- 装饰者一般对组件的客户是透明的，除非客户依赖于组件的具体类型\n- 装饰者或导致设计中出现许多小对象，过度使用会让代码复杂\n","slug":"设计模式-装饰者模式","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi7c002igwq216erakj6","content":"<h1 id=\"开放-关闭原则\"><a href=\"#开放-关闭原则\" class=\"headerlink\" title=\"开放-关闭原则\"></a>开放-关闭原则</h1><p>类应该对扩展开放，但对修改关闭</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p><img src=\"/images/decorator.jpg\"></p>\n<h1 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h1><ul>\n<li>继承是扩展形式之一，但未必是达到弹性设计的最佳方式</li>\n<li>组合和委托经常可以用来在运行时添加新行为</li>\n<li>装饰者模式提供了子类化扩展行为的替代品</li>\n<li>装饰者模式涉及一群装饰者类，这些类用来包装具体组件</li>\n<li>装饰者类反映了他们所装饰的组件类型</li>\n<li>装饰者通过在对组件的方法调用之前或之后添加功能改变组件的行为</li>\n<li>可以用任意数目的装饰者来包裹一个组件</li>\n<li>装饰者一般对组件的客户是透明的，除非客户依赖于组件的具体类型</li>\n<li>装饰者或导致设计中出现许多小对象，过度使用会让代码复杂</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"开放-关闭原则\"><a href=\"#开放-关闭原则\" class=\"headerlink\" title=\"开放-关闭原则\"></a>开放-关闭原则</h1><p>类应该对扩展开放，但对修改关闭</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p><img src=\"/images/decorator.jpg\"></p>\n<h1 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h1><ul>\n<li>继承是扩展形式之一，但未必是达到弹性设计的最佳方式</li>\n<li>组合和委托经常可以用来在运行时添加新行为</li>\n<li>装饰者模式提供了子类化扩展行为的替代品</li>\n<li>装饰者模式涉及一群装饰者类，这些类用来包装具体组件</li>\n<li>装饰者类反映了他们所装饰的组件类型</li>\n<li>装饰者通过在对组件的方法调用之前或之后添加功能改变组件的行为</li>\n<li>可以用任意数目的装饰者来包裹一个组件</li>\n<li>装饰者一般对组件的客户是透明的，除非客户依赖于组件的具体类型</li>\n<li>装饰者或导致设计中出现许多小对象，过度使用会让代码复杂</li>\n</ul>\n"},{"title":"设计模式_观察者模式","date":"2023-07-08T01:52:57.000Z","index_img":"/images/observer.jpeg","banner_img":"/images/observer.jpeg","_content":"\n# 概述\n观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新\n\n# 类图\n![](/images/observer_normal.png)\n![](/images/observer_exp.png)\n# 松耦合设计\n尽量做到交互对象之间的松耦合，这允许我们建造能够应对变化的，有弹性的OO系统，因为对象之间的依赖降到最低\n\n# 订阅模式\n订阅模式是个更复杂的模式，常常用在中间件，注意与之区别\n\n# 要点\n- 观察者模式定义对象之间的一对多关系\n- 主题使用通用接口更新观察者\n- 任何具体类型的观察者都可以参与该模式，只要它们实现观察者接口\n- 观察者是松耦合的，除了知道它们实现观察者接口之外，主题对它们的事情不知\n- 使用该模式时，可以从主题推或拉数据\n- 观察者模式在MVC中经常用到\n","source":"_posts/设计模式-观察者模式.md","raw":"---\ntitle: 设计模式_观察者模式\ndate: 2023-07-08 09:52:57\ntags:\nindex_img: /images/observer.jpeg\nbanner_img: /images/observer.jpeg\n---\n\n# 概述\n观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新\n\n# 类图\n![](/images/observer_normal.png)\n![](/images/observer_exp.png)\n# 松耦合设计\n尽量做到交互对象之间的松耦合，这允许我们建造能够应对变化的，有弹性的OO系统，因为对象之间的依赖降到最低\n\n# 订阅模式\n订阅模式是个更复杂的模式，常常用在中间件，注意与之区别\n\n# 要点\n- 观察者模式定义对象之间的一对多关系\n- 主题使用通用接口更新观察者\n- 任何具体类型的观察者都可以参与该模式，只要它们实现观察者接口\n- 观察者是松耦合的，除了知道它们实现观察者接口之外，主题对它们的事情不知\n- 使用该模式时，可以从主题推或拉数据\n- 观察者模式在MVC中经常用到\n","slug":"设计模式-观察者模式","published":1,"updated":"2023-12-12T06:48:06.678Z","_id":"clq1yvi7c002jgwq232p5dz6g","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p><img src=\"/images/observer_normal.png\"><br><img src=\"/images/observer_exp.png\"></p>\n<h1 id=\"松耦合设计\"><a href=\"#松耦合设计\" class=\"headerlink\" title=\"松耦合设计\"></a>松耦合设计</h1><p>尽量做到交互对象之间的松耦合，这允许我们建造能够应对变化的，有弹性的OO系统，因为对象之间的依赖降到最低</p>\n<h1 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h1><p>订阅模式是个更复杂的模式，常常用在中间件，注意与之区别</p>\n<h1 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h1><ul>\n<li>观察者模式定义对象之间的一对多关系</li>\n<li>主题使用通用接口更新观察者</li>\n<li>任何具体类型的观察者都可以参与该模式，只要它们实现观察者接口</li>\n<li>观察者是松耦合的，除了知道它们实现观察者接口之外，主题对它们的事情不知</li>\n<li>使用该模式时，可以从主题推或拉数据</li>\n<li>观察者模式在MVC中经常用到</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p><img src=\"/images/observer_normal.png\"><br><img src=\"/images/observer_exp.png\"></p>\n<h1 id=\"松耦合设计\"><a href=\"#松耦合设计\" class=\"headerlink\" title=\"松耦合设计\"></a>松耦合设计</h1><p>尽量做到交互对象之间的松耦合，这允许我们建造能够应对变化的，有弹性的OO系统，因为对象之间的依赖降到最低</p>\n<h1 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h1><p>订阅模式是个更复杂的模式，常常用在中间件，注意与之区别</p>\n<h1 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h1><ul>\n<li>观察者模式定义对象之间的一对多关系</li>\n<li>主题使用通用接口更新观察者</li>\n<li>任何具体类型的观察者都可以参与该模式，只要它们实现观察者接口</li>\n<li>观察者是松耦合的，除了知道它们实现观察者接口之外，主题对它们的事情不知</li>\n<li>使用该模式时，可以从主题推或拉数据</li>\n<li>观察者模式在MVC中经常用到</li>\n</ul>\n"},{"title":"输入输出流","date":"2021-03-11T09:33:06.000Z","subtitle":null,"index_img":"/images/stream.jpg","banner_img":"/images/stream.jpg","_content":"1.操纵符\n\n|操纵符|含义|\n|:-:|:-:|\n|boolalpha|将true和false输出为字符串|\n|\\*noboolalpha|将true和false输出为1,0|\n|showbase|对整型值输出表示进制的前缀|\n|\\*noshowbase|不生成表示进制的前缀|\n|showpoint|对浮点值总是显示小数点|\n|\\*noshowpoint|只有当浮点值包含小数部分时,显示小数点|\n|showpos|对非负数显示+|\n|\\*noshowpos|对非负数不显示+|\n|uppercase|在十六进制中打印0X,在科学计数法中打印E|\n|\\*uppercase|在十六进制中打印0x,在科学计数法中打印e|\n|\\*dec|整型值显示为十进制|\n|hex|整型值显示为十六进制|\n|oct|整型值显示为十进制|\n|left|左对齐,在值的右侧添加填充字符|\n|right|右对齐,在值的左侧添加填充字符|\n|internal|左对齐符号,右对齐值,在值和符号之间添加填充字符|\n|fixed|浮点值显示为定点十进制|\n|scientific|浮点值显示为科学计数法|\n|hexfloat|浮点值显示为十六进制(c++11)|\n|defaultfloat|重置浮点值显示为十进制(c++11)|\n|unitbuf|每次输出操作后都刷新缓冲区|\n|\\*nounitbuf|恢复正常的缓冲区刷新方式|\n|\\*skipws|输入运算符跳过空白符|\n|noskipws|输入运算符不跳过空白符|\n|flush|刷新ostream缓冲区|\n|ends|插入空字符,然后刷新ostream缓冲区|\n|endl|插入换行符,然后刷新ostream缓冲区|\n|setprecision([int])|在iomanip,接受一个int值,来设置精度,见详解|\n|setfill([char])|在iomanip,用一个字符填充空白|\n|setw([int])|在iomanip,指定值的最小宽度,注意它只影响接下来的那个值|\n|setbase([int])|在iomanip,将整数输出为某进制|\n\n2.流对象的成员函数\n\n|成员函数|含义|\n|:-:|:-:|\n|precision()|返回当前精度值|\n|precision(int)|将精度设置为此值,返回旧精度|\n|is.get(ch)|从istream is读取下一个字节存入字符ch。返回is|\n|os.put(ch)|将字符ch输出到ostream os。返回os|\n|is.get()|将is的下个字节作为int返回,不返回char的原因是可以多存个结尾符,与cstdio里的EOF做比较|\n|is.putback(ch)|将字符ch放回is。返回is|\n|is.unget()|将is向后移动一个字节。返回is|\n|is.peek()|将下个字节作为int返回。但不从流中删除|\n|is.get(sink,size,delim)|从is中读取最多size字节,并保存在字符数组中,字符数组的起始地址由sink给出。读取过程知道遇到字符delim或读取了size个字节或遇到文件尾。如果遇到delim，将其留在输入流中，不读取出来存入sink|\n|is.getline(sink,size,delim)|与接受三个参数的类似，但会丢弃delim|\n|is.read(sink,size)|读取最多size个字节，存入字符数组sink中，返回is|\n|is.gcount()|返回上一个未格式化读取操作从is读取的字节数|\n|os.write(source,size)|将字符数组source中的size个字节写入os，返回os|\n|is.ignore(size,delim)|读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾|\n\n3.流的随机访问(只支持fstream,sstream)\n\n|函数|含义|\n|:-:|:-:|\n|tellg()|返回输入流中标记的当前位置|\n|tellp()|返回输出流中标记的当前位置|\n|seekg()|在一个输入流中将标记重定位到给定的绝对地址。pos通常是tellg的返回值|\n|seekp()|在一个输出流中将标记重定位到给定的绝对地址。pos通常是tellp的返回值|\n|seekg(off,from)|在一个输入流中将标记定位到from之前(off为负的时候)或之后off个字符。from是下列的值:beg(流开始位置)，cur(当前位置)，end(结尾位置)|\n|seekp(off,from)|(输出流同上)|\n\n4.getline()函数\ngetlint([istream],[string])从输入流中读取一行，并舍弃换行符，赋值给string\n5.流的状态位\n\n|状态成员(类型为strm::iostate)|成员函数|函数意义|\n|:-:|:-:|:-:|\n|badbit|s.bad()|strm:badbit用来指出流已经奔溃。若流s的badbit置位，成员函数返回true，这个一般由系统造成，一般这个流就废了|\n|failbit|s.fail()|strm::failbit用来指出一个IO操作失败。若s的failbit置位，成员函数返回true,流还可以修正继续使用|\n|eofbit|s.eof()|strm::eofbit用来指出流到达结尾。若s的eofbit置位，成员函数返回true|\n|goodbit|s.good()|strm::goodbit用来指出流未处于错误状态。若上述三个被置位任何一个，成员函数返回true|\n||s.clear()|所有条件状态复位，流状态设置为有效，返回void|\n||s.clear(flags)|根据给定的flags标志位，进行条件置位，如：`cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit)`只对failbit和badbit复位，其余保持不变|\n||s.rdstate()|返回流当前状态，类型为strm::iostate|\n\n6.流之间的关联\n一般情况下cin和cerr被关联到cout,所以cin操纵之后，都会刷新cout的缓冲区\ncin.tie()会返回关联的输出流的指针\ncin.tie([\\*os])关联流到该指针\n每个流最多关联到一个输出流，但多个流可以同时关联到同一个输出流。\nistream可以关联ostream的对象，ostream也可以关联到ostream的对象，也可以关联到一个空指针。\n7.文件模式\n\n|文件模式|含义|\n|in|以读方式打开|\n|out|以写方式打开|\n|app|每次写操作前均定位到文件末尾|\n|ate|打开文件后立刻定位到文件末尾|\n|trunc|截断文件|\n|binary|以二进制方式进行IO|\n\n文件模式指定之间以‘|’分割，并有如下限制:\n-只可以对ofstream或fstream对象设定out模式\n-只可以对ifstream或fstream对象设定in模式\n-只有当out模式设定时才可以设定trunc模式\n-只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出模式打开\n-默认情况下，即使我们没有指定trunc,out模式打开的文件也会被截断，或者同时指定app模式或者in模式\n-ate和binary可以用于任何文件流对象，可以与其他模式任意组合\n4.精度\n默认情况下,精度会控制打印的数字的总数。打印时,<font color=#FF0000>浮点值按当前精度舍入而非截断</font>,在执行scientific,fixed或hexfloat后,精度值控制的是小数点后面的数字位数\n\n1.scanf与printf\n格式:`scanf(\"format_specifier\",&val)`与`printf(\"format_specifier\",&val)`\n例子:\n```C++\nchar ch;\ndouble d;\nscanf(\"%c %lf\",&ch,&d);\nprintf(\"%c %lf\",ch,d);\n```\n|:-:|:-:|:-:|\n|类型|格式|大小|\n|int|%d|32bit|\n|long|%ld|64bit|\n|char|%c|16bit|\n|float|%f|32bit|\n|double|%lf|64bit|\n2.float与double固定小数点后的位数输出\n```C++\nfloat a=8.333291;\nprintf(\"%.03f\",a);//小数点后面保留3位\ncout.precision(3);\ncout<<fixed<<endl;//保留3位\n\n```\n3.进制转换\n十六进制 `cout<<hex;`\n十进制 `cout<<dec`;\n八进制 `cout<<oct`;\n","source":"_posts/输入输出流.md","raw":"---\ntitle: 输入输出流\ndate: 2021-03-11 17:33:06\nsubtitle:\ncategories:\ntags:\nindex_img: /images/stream.jpg\nbanner_img: /images/stream.jpg\n---\n1.操纵符\n\n|操纵符|含义|\n|:-:|:-:|\n|boolalpha|将true和false输出为字符串|\n|\\*noboolalpha|将true和false输出为1,0|\n|showbase|对整型值输出表示进制的前缀|\n|\\*noshowbase|不生成表示进制的前缀|\n|showpoint|对浮点值总是显示小数点|\n|\\*noshowpoint|只有当浮点值包含小数部分时,显示小数点|\n|showpos|对非负数显示+|\n|\\*noshowpos|对非负数不显示+|\n|uppercase|在十六进制中打印0X,在科学计数法中打印E|\n|\\*uppercase|在十六进制中打印0x,在科学计数法中打印e|\n|\\*dec|整型值显示为十进制|\n|hex|整型值显示为十六进制|\n|oct|整型值显示为十进制|\n|left|左对齐,在值的右侧添加填充字符|\n|right|右对齐,在值的左侧添加填充字符|\n|internal|左对齐符号,右对齐值,在值和符号之间添加填充字符|\n|fixed|浮点值显示为定点十进制|\n|scientific|浮点值显示为科学计数法|\n|hexfloat|浮点值显示为十六进制(c++11)|\n|defaultfloat|重置浮点值显示为十进制(c++11)|\n|unitbuf|每次输出操作后都刷新缓冲区|\n|\\*nounitbuf|恢复正常的缓冲区刷新方式|\n|\\*skipws|输入运算符跳过空白符|\n|noskipws|输入运算符不跳过空白符|\n|flush|刷新ostream缓冲区|\n|ends|插入空字符,然后刷新ostream缓冲区|\n|endl|插入换行符,然后刷新ostream缓冲区|\n|setprecision([int])|在iomanip,接受一个int值,来设置精度,见详解|\n|setfill([char])|在iomanip,用一个字符填充空白|\n|setw([int])|在iomanip,指定值的最小宽度,注意它只影响接下来的那个值|\n|setbase([int])|在iomanip,将整数输出为某进制|\n\n2.流对象的成员函数\n\n|成员函数|含义|\n|:-:|:-:|\n|precision()|返回当前精度值|\n|precision(int)|将精度设置为此值,返回旧精度|\n|is.get(ch)|从istream is读取下一个字节存入字符ch。返回is|\n|os.put(ch)|将字符ch输出到ostream os。返回os|\n|is.get()|将is的下个字节作为int返回,不返回char的原因是可以多存个结尾符,与cstdio里的EOF做比较|\n|is.putback(ch)|将字符ch放回is。返回is|\n|is.unget()|将is向后移动一个字节。返回is|\n|is.peek()|将下个字节作为int返回。但不从流中删除|\n|is.get(sink,size,delim)|从is中读取最多size字节,并保存在字符数组中,字符数组的起始地址由sink给出。读取过程知道遇到字符delim或读取了size个字节或遇到文件尾。如果遇到delim，将其留在输入流中，不读取出来存入sink|\n|is.getline(sink,size,delim)|与接受三个参数的类似，但会丢弃delim|\n|is.read(sink,size)|读取最多size个字节，存入字符数组sink中，返回is|\n|is.gcount()|返回上一个未格式化读取操作从is读取的字节数|\n|os.write(source,size)|将字符数组source中的size个字节写入os，返回os|\n|is.ignore(size,delim)|读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾|\n\n3.流的随机访问(只支持fstream,sstream)\n\n|函数|含义|\n|:-:|:-:|\n|tellg()|返回输入流中标记的当前位置|\n|tellp()|返回输出流中标记的当前位置|\n|seekg()|在一个输入流中将标记重定位到给定的绝对地址。pos通常是tellg的返回值|\n|seekp()|在一个输出流中将标记重定位到给定的绝对地址。pos通常是tellp的返回值|\n|seekg(off,from)|在一个输入流中将标记定位到from之前(off为负的时候)或之后off个字符。from是下列的值:beg(流开始位置)，cur(当前位置)，end(结尾位置)|\n|seekp(off,from)|(输出流同上)|\n\n4.getline()函数\ngetlint([istream],[string])从输入流中读取一行，并舍弃换行符，赋值给string\n5.流的状态位\n\n|状态成员(类型为strm::iostate)|成员函数|函数意义|\n|:-:|:-:|:-:|\n|badbit|s.bad()|strm:badbit用来指出流已经奔溃。若流s的badbit置位，成员函数返回true，这个一般由系统造成，一般这个流就废了|\n|failbit|s.fail()|strm::failbit用来指出一个IO操作失败。若s的failbit置位，成员函数返回true,流还可以修正继续使用|\n|eofbit|s.eof()|strm::eofbit用来指出流到达结尾。若s的eofbit置位，成员函数返回true|\n|goodbit|s.good()|strm::goodbit用来指出流未处于错误状态。若上述三个被置位任何一个，成员函数返回true|\n||s.clear()|所有条件状态复位，流状态设置为有效，返回void|\n||s.clear(flags)|根据给定的flags标志位，进行条件置位，如：`cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit)`只对failbit和badbit复位，其余保持不变|\n||s.rdstate()|返回流当前状态，类型为strm::iostate|\n\n6.流之间的关联\n一般情况下cin和cerr被关联到cout,所以cin操纵之后，都会刷新cout的缓冲区\ncin.tie()会返回关联的输出流的指针\ncin.tie([\\*os])关联流到该指针\n每个流最多关联到一个输出流，但多个流可以同时关联到同一个输出流。\nistream可以关联ostream的对象，ostream也可以关联到ostream的对象，也可以关联到一个空指针。\n7.文件模式\n\n|文件模式|含义|\n|in|以读方式打开|\n|out|以写方式打开|\n|app|每次写操作前均定位到文件末尾|\n|ate|打开文件后立刻定位到文件末尾|\n|trunc|截断文件|\n|binary|以二进制方式进行IO|\n\n文件模式指定之间以‘|’分割，并有如下限制:\n-只可以对ofstream或fstream对象设定out模式\n-只可以对ifstream或fstream对象设定in模式\n-只有当out模式设定时才可以设定trunc模式\n-只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出模式打开\n-默认情况下，即使我们没有指定trunc,out模式打开的文件也会被截断，或者同时指定app模式或者in模式\n-ate和binary可以用于任何文件流对象，可以与其他模式任意组合\n4.精度\n默认情况下,精度会控制打印的数字的总数。打印时,<font color=#FF0000>浮点值按当前精度舍入而非截断</font>,在执行scientific,fixed或hexfloat后,精度值控制的是小数点后面的数字位数\n\n1.scanf与printf\n格式:`scanf(\"format_specifier\",&val)`与`printf(\"format_specifier\",&val)`\n例子:\n```C++\nchar ch;\ndouble d;\nscanf(\"%c %lf\",&ch,&d);\nprintf(\"%c %lf\",ch,d);\n```\n|:-:|:-:|:-:|\n|类型|格式|大小|\n|int|%d|32bit|\n|long|%ld|64bit|\n|char|%c|16bit|\n|float|%f|32bit|\n|double|%lf|64bit|\n2.float与double固定小数点后的位数输出\n```C++\nfloat a=8.333291;\nprintf(\"%.03f\",a);//小数点后面保留3位\ncout.precision(3);\ncout<<fixed<<endl;//保留3位\n\n```\n3.进制转换\n十六进制 `cout<<hex;`\n十进制 `cout<<dec`;\n八进制 `cout<<oct`;\n","slug":"输入输出流","published":1,"updated":"2023-12-12T06:29:01.371Z","comments":1,"layout":"post","photos":[],"_id":"clq1yvi7c002lgwq27qqlgpxg","content":"<p>1.操纵符</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操纵符</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">boolalpha</td>\n<td align=\"center\">将true和false输出为字符串</td>\n</tr>\n<tr>\n<td align=\"center\">*noboolalpha</td>\n<td align=\"center\">将true和false输出为1,0</td>\n</tr>\n<tr>\n<td align=\"center\">showbase</td>\n<td align=\"center\">对整型值输出表示进制的前缀</td>\n</tr>\n<tr>\n<td align=\"center\">*noshowbase</td>\n<td align=\"center\">不生成表示进制的前缀</td>\n</tr>\n<tr>\n<td align=\"center\">showpoint</td>\n<td align=\"center\">对浮点值总是显示小数点</td>\n</tr>\n<tr>\n<td align=\"center\">*noshowpoint</td>\n<td align=\"center\">只有当浮点值包含小数部分时,显示小数点</td>\n</tr>\n<tr>\n<td align=\"center\">showpos</td>\n<td align=\"center\">对非负数显示+</td>\n</tr>\n<tr>\n<td align=\"center\">*noshowpos</td>\n<td align=\"center\">对非负数不显示+</td>\n</tr>\n<tr>\n<td align=\"center\">uppercase</td>\n<td align=\"center\">在十六进制中打印0X,在科学计数法中打印E</td>\n</tr>\n<tr>\n<td align=\"center\">*uppercase</td>\n<td align=\"center\">在十六进制中打印0x,在科学计数法中打印e</td>\n</tr>\n<tr>\n<td align=\"center\">*dec</td>\n<td align=\"center\">整型值显示为十进制</td>\n</tr>\n<tr>\n<td align=\"center\">hex</td>\n<td align=\"center\">整型值显示为十六进制</td>\n</tr>\n<tr>\n<td align=\"center\">oct</td>\n<td align=\"center\">整型值显示为十进制</td>\n</tr>\n<tr>\n<td align=\"center\">left</td>\n<td align=\"center\">左对齐,在值的右侧添加填充字符</td>\n</tr>\n<tr>\n<td align=\"center\">right</td>\n<td align=\"center\">右对齐,在值的左侧添加填充字符</td>\n</tr>\n<tr>\n<td align=\"center\">internal</td>\n<td align=\"center\">左对齐符号,右对齐值,在值和符号之间添加填充字符</td>\n</tr>\n<tr>\n<td align=\"center\">fixed</td>\n<td align=\"center\">浮点值显示为定点十进制</td>\n</tr>\n<tr>\n<td align=\"center\">scientific</td>\n<td align=\"center\">浮点值显示为科学计数法</td>\n</tr>\n<tr>\n<td align=\"center\">hexfloat</td>\n<td align=\"center\">浮点值显示为十六进制(c++11)</td>\n</tr>\n<tr>\n<td align=\"center\">defaultfloat</td>\n<td align=\"center\">重置浮点值显示为十进制(c++11)</td>\n</tr>\n<tr>\n<td align=\"center\">unitbuf</td>\n<td align=\"center\">每次输出操作后都刷新缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">*nounitbuf</td>\n<td align=\"center\">恢复正常的缓冲区刷新方式</td>\n</tr>\n<tr>\n<td align=\"center\">*skipws</td>\n<td align=\"center\">输入运算符跳过空白符</td>\n</tr>\n<tr>\n<td align=\"center\">noskipws</td>\n<td align=\"center\">输入运算符不跳过空白符</td>\n</tr>\n<tr>\n<td align=\"center\">flush</td>\n<td align=\"center\">刷新ostream缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">ends</td>\n<td align=\"center\">插入空字符,然后刷新ostream缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">endl</td>\n<td align=\"center\">插入换行符,然后刷新ostream缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">setprecision([int])</td>\n<td align=\"center\">在iomanip,接受一个int值,来设置精度,见详解</td>\n</tr>\n<tr>\n<td align=\"center\">setfill([char])</td>\n<td align=\"center\">在iomanip,用一个字符填充空白</td>\n</tr>\n<tr>\n<td align=\"center\">setw([int])</td>\n<td align=\"center\">在iomanip,指定值的最小宽度,注意它只影响接下来的那个值</td>\n</tr>\n<tr>\n<td align=\"center\">setbase([int])</td>\n<td align=\"center\">在iomanip,将整数输出为某进制</td>\n</tr>\n</tbody></table>\n<p>2.流对象的成员函数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">成员函数</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">precision()</td>\n<td align=\"center\">返回当前精度值</td>\n</tr>\n<tr>\n<td align=\"center\">precision(int)</td>\n<td align=\"center\">将精度设置为此值,返回旧精度</td>\n</tr>\n<tr>\n<td align=\"center\">is.get(ch)</td>\n<td align=\"center\">从istream is读取下一个字节存入字符ch。返回is</td>\n</tr>\n<tr>\n<td align=\"center\">os.put(ch)</td>\n<td align=\"center\">将字符ch输出到ostream os。返回os</td>\n</tr>\n<tr>\n<td align=\"center\">is.get()</td>\n<td align=\"center\">将is的下个字节作为int返回,不返回char的原因是可以多存个结尾符,与cstdio里的EOF做比较</td>\n</tr>\n<tr>\n<td align=\"center\">is.putback(ch)</td>\n<td align=\"center\">将字符ch放回is。返回is</td>\n</tr>\n<tr>\n<td align=\"center\">is.unget()</td>\n<td align=\"center\">将is向后移动一个字节。返回is</td>\n</tr>\n<tr>\n<td align=\"center\">is.peek()</td>\n<td align=\"center\">将下个字节作为int返回。但不从流中删除</td>\n</tr>\n<tr>\n<td align=\"center\">is.get(sink,size,delim)</td>\n<td align=\"center\">从is中读取最多size字节,并保存在字符数组中,字符数组的起始地址由sink给出。读取过程知道遇到字符delim或读取了size个字节或遇到文件尾。如果遇到delim，将其留在输入流中，不读取出来存入sink</td>\n</tr>\n<tr>\n<td align=\"center\">is.getline(sink,size,delim)</td>\n<td align=\"center\">与接受三个参数的类似，但会丢弃delim</td>\n</tr>\n<tr>\n<td align=\"center\">is.read(sink,size)</td>\n<td align=\"center\">读取最多size个字节，存入字符数组sink中，返回is</td>\n</tr>\n<tr>\n<td align=\"center\">is.gcount()</td>\n<td align=\"center\">返回上一个未格式化读取操作从is读取的字节数</td>\n</tr>\n<tr>\n<td align=\"center\">os.write(source,size)</td>\n<td align=\"center\">将字符数组source中的size个字节写入os，返回os</td>\n</tr>\n<tr>\n<td align=\"center\">is.ignore(size,delim)</td>\n<td align=\"center\">读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾</td>\n</tr>\n</tbody></table>\n<p>3.流的随机访问(只支持fstream,sstream)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">tellg()</td>\n<td align=\"center\">返回输入流中标记的当前位置</td>\n</tr>\n<tr>\n<td align=\"center\">tellp()</td>\n<td align=\"center\">返回输出流中标记的当前位置</td>\n</tr>\n<tr>\n<td align=\"center\">seekg()</td>\n<td align=\"center\">在一个输入流中将标记重定位到给定的绝对地址。pos通常是tellg的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">seekp()</td>\n<td align=\"center\">在一个输出流中将标记重定位到给定的绝对地址。pos通常是tellp的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">seekg(off,from)</td>\n<td align=\"center\">在一个输入流中将标记定位到from之前(off为负的时候)或之后off个字符。from是下列的值:beg(流开始位置)，cur(当前位置)，end(结尾位置)</td>\n</tr>\n<tr>\n<td align=\"center\">seekp(off,from)</td>\n<td align=\"center\">(输出流同上)</td>\n</tr>\n</tbody></table>\n<p>4.getline()函数<br>getlint([istream],[string])从输入流中读取一行，并舍弃换行符，赋值给string<br>5.流的状态位</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">状态成员(类型为strm::iostate)</th>\n<th align=\"center\">成员函数</th>\n<th align=\"center\">函数意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">badbit</td>\n<td align=\"center\">s.bad()</td>\n<td align=\"center\">strm:badbit用来指出流已经奔溃。若流s的badbit置位，成员函数返回true，这个一般由系统造成，一般这个流就废了</td>\n</tr>\n<tr>\n<td align=\"center\">failbit</td>\n<td align=\"center\">s.fail()</td>\n<td align=\"center\">strm::failbit用来指出一个IO操作失败。若s的failbit置位，成员函数返回true,流还可以修正继续使用</td>\n</tr>\n<tr>\n<td align=\"center\">eofbit</td>\n<td align=\"center\">s.eof()</td>\n<td align=\"center\">strm::eofbit用来指出流到达结尾。若s的eofbit置位，成员函数返回true</td>\n</tr>\n<tr>\n<td align=\"center\">goodbit</td>\n<td align=\"center\">s.good()</td>\n<td align=\"center\">strm::goodbit用来指出流未处于错误状态。若上述三个被置位任何一个，成员函数返回true</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">s.clear()</td>\n<td align=\"center\">所有条件状态复位，流状态设置为有效，返回void</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">s.clear(flags)</td>\n<td align=\"center\">根据给定的flags标志位，进行条件置位，如：<code>cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit)</code>只对failbit和badbit复位，其余保持不变</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">s.rdstate()</td>\n<td align=\"center\">返回流当前状态，类型为strm::iostate</td>\n</tr>\n</tbody></table>\n<p>6.流之间的关联<br>一般情况下cin和cerr被关联到cout,所以cin操纵之后，都会刷新cout的缓冲区<br>cin.tie()会返回关联的输出流的指针<br>cin.tie([*os])关联流到该指针<br>每个流最多关联到一个输出流，但多个流可以同时关联到同一个输出流。<br>istream可以关联ostream的对象，ostream也可以关联到ostream的对象，也可以关联到一个空指针。<br>7.文件模式</p>\n<p>|文件模式|含义|<br>|in|以读方式打开|<br>|out|以写方式打开|<br>|app|每次写操作前均定位到文件末尾|<br>|ate|打开文件后立刻定位到文件末尾|<br>|trunc|截断文件|<br>|binary|以二进制方式进行IO|</p>\n<p>文件模式指定之间以‘|’分割，并有如下限制:<br>-只可以对ofstream或fstream对象设定out模式<br>-只可以对ifstream或fstream对象设定in模式<br>-只有当out模式设定时才可以设定trunc模式<br>-只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出模式打开<br>-默认情况下，即使我们没有指定trunc,out模式打开的文件也会被截断，或者同时指定app模式或者in模式<br>-ate和binary可以用于任何文件流对象，可以与其他模式任意组合<br>4.精度<br>默认情况下,精度会控制打印的数字的总数。打印时,<font color=#FF0000>浮点值按当前精度舍入而非截断</font>,在执行scientific,fixed或hexfloat后,精度值控制的是小数点后面的数字位数</p>\n<p>1.scanf与printf<br>格式:<code>scanf(&quot;format_specifier&quot;,&amp;val)</code>与<code>printf(&quot;format_specifier&quot;,&amp;val)</code><br>例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">char</span> ch;<br><span class=\"hljs-type\">double</span> d;<br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%c %lf&quot;</span>,&amp;ch,&amp;d);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%c %lf&quot;</span>,ch,d);<br></code></pre></td></tr></table></figure>\n<p>|:-:|:-:|:-:|<br>|类型|格式|大小|<br>|int|%d|32bit|<br>|long|%ld|64bit|<br>|char|%c|16bit|<br>|float|%f|32bit|<br>|double|%lf|64bit|<br>2.float与double固定小数点后的位数输出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> a=<span class=\"hljs-number\">8.333291</span>;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%.03f&quot;</span>,a);<span class=\"hljs-comment\">//小数点后面保留3位</span><br>cout.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">3</span>);<br>cout&lt;&lt;fixed&lt;&lt;endl;<span class=\"hljs-comment\">//保留3位</span><br><br></code></pre></td></tr></table></figure>\n<p>3.进制转换<br>十六进制 <code>cout&lt;&lt;hex;</code><br>十进制 <code>cout&lt;&lt;dec</code>;<br>八进制 <code>cout&lt;&lt;oct</code>;</p>\n","excerpt":"","more":"<p>1.操纵符</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操纵符</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">boolalpha</td>\n<td align=\"center\">将true和false输出为字符串</td>\n</tr>\n<tr>\n<td align=\"center\">*noboolalpha</td>\n<td align=\"center\">将true和false输出为1,0</td>\n</tr>\n<tr>\n<td align=\"center\">showbase</td>\n<td align=\"center\">对整型值输出表示进制的前缀</td>\n</tr>\n<tr>\n<td align=\"center\">*noshowbase</td>\n<td align=\"center\">不生成表示进制的前缀</td>\n</tr>\n<tr>\n<td align=\"center\">showpoint</td>\n<td align=\"center\">对浮点值总是显示小数点</td>\n</tr>\n<tr>\n<td align=\"center\">*noshowpoint</td>\n<td align=\"center\">只有当浮点值包含小数部分时,显示小数点</td>\n</tr>\n<tr>\n<td align=\"center\">showpos</td>\n<td align=\"center\">对非负数显示+</td>\n</tr>\n<tr>\n<td align=\"center\">*noshowpos</td>\n<td align=\"center\">对非负数不显示+</td>\n</tr>\n<tr>\n<td align=\"center\">uppercase</td>\n<td align=\"center\">在十六进制中打印0X,在科学计数法中打印E</td>\n</tr>\n<tr>\n<td align=\"center\">*uppercase</td>\n<td align=\"center\">在十六进制中打印0x,在科学计数法中打印e</td>\n</tr>\n<tr>\n<td align=\"center\">*dec</td>\n<td align=\"center\">整型值显示为十进制</td>\n</tr>\n<tr>\n<td align=\"center\">hex</td>\n<td align=\"center\">整型值显示为十六进制</td>\n</tr>\n<tr>\n<td align=\"center\">oct</td>\n<td align=\"center\">整型值显示为十进制</td>\n</tr>\n<tr>\n<td align=\"center\">left</td>\n<td align=\"center\">左对齐,在值的右侧添加填充字符</td>\n</tr>\n<tr>\n<td align=\"center\">right</td>\n<td align=\"center\">右对齐,在值的左侧添加填充字符</td>\n</tr>\n<tr>\n<td align=\"center\">internal</td>\n<td align=\"center\">左对齐符号,右对齐值,在值和符号之间添加填充字符</td>\n</tr>\n<tr>\n<td align=\"center\">fixed</td>\n<td align=\"center\">浮点值显示为定点十进制</td>\n</tr>\n<tr>\n<td align=\"center\">scientific</td>\n<td align=\"center\">浮点值显示为科学计数法</td>\n</tr>\n<tr>\n<td align=\"center\">hexfloat</td>\n<td align=\"center\">浮点值显示为十六进制(c++11)</td>\n</tr>\n<tr>\n<td align=\"center\">defaultfloat</td>\n<td align=\"center\">重置浮点值显示为十进制(c++11)</td>\n</tr>\n<tr>\n<td align=\"center\">unitbuf</td>\n<td align=\"center\">每次输出操作后都刷新缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">*nounitbuf</td>\n<td align=\"center\">恢复正常的缓冲区刷新方式</td>\n</tr>\n<tr>\n<td align=\"center\">*skipws</td>\n<td align=\"center\">输入运算符跳过空白符</td>\n</tr>\n<tr>\n<td align=\"center\">noskipws</td>\n<td align=\"center\">输入运算符不跳过空白符</td>\n</tr>\n<tr>\n<td align=\"center\">flush</td>\n<td align=\"center\">刷新ostream缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">ends</td>\n<td align=\"center\">插入空字符,然后刷新ostream缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">endl</td>\n<td align=\"center\">插入换行符,然后刷新ostream缓冲区</td>\n</tr>\n<tr>\n<td align=\"center\">setprecision([int])</td>\n<td align=\"center\">在iomanip,接受一个int值,来设置精度,见详解</td>\n</tr>\n<tr>\n<td align=\"center\">setfill([char])</td>\n<td align=\"center\">在iomanip,用一个字符填充空白</td>\n</tr>\n<tr>\n<td align=\"center\">setw([int])</td>\n<td align=\"center\">在iomanip,指定值的最小宽度,注意它只影响接下来的那个值</td>\n</tr>\n<tr>\n<td align=\"center\">setbase([int])</td>\n<td align=\"center\">在iomanip,将整数输出为某进制</td>\n</tr>\n</tbody></table>\n<p>2.流对象的成员函数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">成员函数</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">precision()</td>\n<td align=\"center\">返回当前精度值</td>\n</tr>\n<tr>\n<td align=\"center\">precision(int)</td>\n<td align=\"center\">将精度设置为此值,返回旧精度</td>\n</tr>\n<tr>\n<td align=\"center\">is.get(ch)</td>\n<td align=\"center\">从istream is读取下一个字节存入字符ch。返回is</td>\n</tr>\n<tr>\n<td align=\"center\">os.put(ch)</td>\n<td align=\"center\">将字符ch输出到ostream os。返回os</td>\n</tr>\n<tr>\n<td align=\"center\">is.get()</td>\n<td align=\"center\">将is的下个字节作为int返回,不返回char的原因是可以多存个结尾符,与cstdio里的EOF做比较</td>\n</tr>\n<tr>\n<td align=\"center\">is.putback(ch)</td>\n<td align=\"center\">将字符ch放回is。返回is</td>\n</tr>\n<tr>\n<td align=\"center\">is.unget()</td>\n<td align=\"center\">将is向后移动一个字节。返回is</td>\n</tr>\n<tr>\n<td align=\"center\">is.peek()</td>\n<td align=\"center\">将下个字节作为int返回。但不从流中删除</td>\n</tr>\n<tr>\n<td align=\"center\">is.get(sink,size,delim)</td>\n<td align=\"center\">从is中读取最多size字节,并保存在字符数组中,字符数组的起始地址由sink给出。读取过程知道遇到字符delim或读取了size个字节或遇到文件尾。如果遇到delim，将其留在输入流中，不读取出来存入sink</td>\n</tr>\n<tr>\n<td align=\"center\">is.getline(sink,size,delim)</td>\n<td align=\"center\">与接受三个参数的类似，但会丢弃delim</td>\n</tr>\n<tr>\n<td align=\"center\">is.read(sink,size)</td>\n<td align=\"center\">读取最多size个字节，存入字符数组sink中，返回is</td>\n</tr>\n<tr>\n<td align=\"center\">is.gcount()</td>\n<td align=\"center\">返回上一个未格式化读取操作从is读取的字节数</td>\n</tr>\n<tr>\n<td align=\"center\">os.write(source,size)</td>\n<td align=\"center\">将字符数组source中的size个字节写入os，返回os</td>\n</tr>\n<tr>\n<td align=\"center\">is.ignore(size,delim)</td>\n<td align=\"center\">读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾</td>\n</tr>\n</tbody></table>\n<p>3.流的随机访问(只支持fstream,sstream)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">tellg()</td>\n<td align=\"center\">返回输入流中标记的当前位置</td>\n</tr>\n<tr>\n<td align=\"center\">tellp()</td>\n<td align=\"center\">返回输出流中标记的当前位置</td>\n</tr>\n<tr>\n<td align=\"center\">seekg()</td>\n<td align=\"center\">在一个输入流中将标记重定位到给定的绝对地址。pos通常是tellg的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">seekp()</td>\n<td align=\"center\">在一个输出流中将标记重定位到给定的绝对地址。pos通常是tellp的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">seekg(off,from)</td>\n<td align=\"center\">在一个输入流中将标记定位到from之前(off为负的时候)或之后off个字符。from是下列的值:beg(流开始位置)，cur(当前位置)，end(结尾位置)</td>\n</tr>\n<tr>\n<td align=\"center\">seekp(off,from)</td>\n<td align=\"center\">(输出流同上)</td>\n</tr>\n</tbody></table>\n<p>4.getline()函数<br>getlint([istream],[string])从输入流中读取一行，并舍弃换行符，赋值给string<br>5.流的状态位</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">状态成员(类型为strm::iostate)</th>\n<th align=\"center\">成员函数</th>\n<th align=\"center\">函数意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">badbit</td>\n<td align=\"center\">s.bad()</td>\n<td align=\"center\">strm:badbit用来指出流已经奔溃。若流s的badbit置位，成员函数返回true，这个一般由系统造成，一般这个流就废了</td>\n</tr>\n<tr>\n<td align=\"center\">failbit</td>\n<td align=\"center\">s.fail()</td>\n<td align=\"center\">strm::failbit用来指出一个IO操作失败。若s的failbit置位，成员函数返回true,流还可以修正继续使用</td>\n</tr>\n<tr>\n<td align=\"center\">eofbit</td>\n<td align=\"center\">s.eof()</td>\n<td align=\"center\">strm::eofbit用来指出流到达结尾。若s的eofbit置位，成员函数返回true</td>\n</tr>\n<tr>\n<td align=\"center\">goodbit</td>\n<td align=\"center\">s.good()</td>\n<td align=\"center\">strm::goodbit用来指出流未处于错误状态。若上述三个被置位任何一个，成员函数返回true</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">s.clear()</td>\n<td align=\"center\">所有条件状态复位，流状态设置为有效，返回void</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">s.clear(flags)</td>\n<td align=\"center\">根据给定的flags标志位，进行条件置位，如：<code>cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit)</code>只对failbit和badbit复位，其余保持不变</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">s.rdstate()</td>\n<td align=\"center\">返回流当前状态，类型为strm::iostate</td>\n</tr>\n</tbody></table>\n<p>6.流之间的关联<br>一般情况下cin和cerr被关联到cout,所以cin操纵之后，都会刷新cout的缓冲区<br>cin.tie()会返回关联的输出流的指针<br>cin.tie([*os])关联流到该指针<br>每个流最多关联到一个输出流，但多个流可以同时关联到同一个输出流。<br>istream可以关联ostream的对象，ostream也可以关联到ostream的对象，也可以关联到一个空指针。<br>7.文件模式</p>\n<p>|文件模式|含义|<br>|in|以读方式打开|<br>|out|以写方式打开|<br>|app|每次写操作前均定位到文件末尾|<br>|ate|打开文件后立刻定位到文件末尾|<br>|trunc|截断文件|<br>|binary|以二进制方式进行IO|</p>\n<p>文件模式指定之间以‘|’分割，并有如下限制:<br>-只可以对ofstream或fstream对象设定out模式<br>-只可以对ifstream或fstream对象设定in模式<br>-只有当out模式设定时才可以设定trunc模式<br>-只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出模式打开<br>-默认情况下，即使我们没有指定trunc,out模式打开的文件也会被截断，或者同时指定app模式或者in模式<br>-ate和binary可以用于任何文件流对象，可以与其他模式任意组合<br>4.精度<br>默认情况下,精度会控制打印的数字的总数。打印时,<font color=#FF0000>浮点值按当前精度舍入而非截断</font>,在执行scientific,fixed或hexfloat后,精度值控制的是小数点后面的数字位数</p>\n<p>1.scanf与printf<br>格式:<code>scanf(&quot;format_specifier&quot;,&amp;val)</code>与<code>printf(&quot;format_specifier&quot;,&amp;val)</code><br>例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">char</span> ch;<br><span class=\"hljs-type\">double</span> d;<br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%c %lf&quot;</span>,&amp;ch,&amp;d);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%c %lf&quot;</span>,ch,d);<br></code></pre></td></tr></table></figure>\n<p>|:-:|:-:|:-:|<br>|类型|格式|大小|<br>|int|%d|32bit|<br>|long|%ld|64bit|<br>|char|%c|16bit|<br>|float|%f|32bit|<br>|double|%lf|64bit|<br>2.float与double固定小数点后的位数输出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> a=<span class=\"hljs-number\">8.333291</span>;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%.03f&quot;</span>,a);<span class=\"hljs-comment\">//小数点后面保留3位</span><br>cout.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">3</span>);<br>cout&lt;&lt;fixed&lt;&lt;endl;<span class=\"hljs-comment\">//保留3位</span><br><br></code></pre></td></tr></table></figure>\n<p>3.进制转换<br>十六进制 <code>cout&lt;&lt;hex;</code><br>十进制 <code>cout&lt;&lt;dec</code>;<br>八进制 <code>cout&lt;&lt;oct</code>;</p>\n"},{"title":"进程与线程","date":"2023-09-03T07:21:11.000Z","banner_img":"/images/processThread.png","index_img":"/images/processThread.png","_content":"# 7进程环境\n## main函数的启动\n当内核执行c程序时，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址（连接器指定）,启动例程从内核取得命令行参数和环境变量值，然后调用main函数\n## 进程终止\n### 8种终止方式\n1. 从main返回\n2. 调用exit\n3. 调用_exit或_Exit\n4. 最后一个线程从其启动例程返回\n5. 最后一个线程调用pthread_exit\n异常终止:\n6. 调用abort\n7. 接到一个信号\n8. 最后一个线程对取消请求做出响应\n### atexit函数\n```C\n#include <stdlib.h>\nint atexit(void (*func)(void));\n// 登记成功返回0\n```\n终止处理函数，一个进程可以登记最多32个函数\n![](/images/exit.png)\n## 内存空间分布\n![](/images/memory_struct.png)\n磁盘上的可执行文件并不存放bss内容，内核在程序开始运行前将它们都设为0。磁盘可执行文件只存取text和初始化段\n`size /path/bin`可查看某执行文件的各个段的长度\n## 共享库\ngcc默认使用共享库，可使用-static阻止使用共享库\n## 内存分配函数\n- malloc: 分配指定字节数的存储区。初始值不确定\n- calloc: 为指定数量指定长度的对象分配存储空间,初始化为0\n- realloc: 增加或减少以前分配区的长度。增加时新增区的初始值不确定\n它们都是调用sbrk的系统调用，sbrk可扩充或缩小进程的存储空间，但是大多数的malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配\n这三个函数都有debug版本，进行附加检错，通过设置环境变量支持\n**alloca**函数分配的空间在栈上\n## 环境变量\n全局变量environ(char**)，指向环境表，一般不对它进行直接操作\n![](/images/environ.png)\n- `char* getenv(const char* name)`\n- `int putenv(char *str)`str是类似`name = value`, 会直接将该值的地址放到环境表中,所以str不能是栈上的\n- `int setenv(const char *name, const char* value, int rewrite)` rewrite为0,则不删除现有定义\n- `int unsetenv(const char* name)`\n环境表和环境字符串通常位于进程空间的顶部，所以如果增加环境变量或值字符串变长，系统会调用malloc在堆上分配空间\n## setjmp和longjmp函数间的跳转\n```C\n#include <setjmp.h>\nint setjmp(jmp_buf env)//若直接调用，返回0；若从longjmp返回，则非0\nvoid longjmp(jmp_Buf env, int val)\n```\n在函数之间的跳转，会舍弃中间的帧，无法确保变量的值，在同一个系统中，要想获得可靠的值，则要加上volatile关键字，这并不能保证(p218仔细看把)\n## getrlimit和setrlimit资源限制函数\n(todo,目前感觉用处不大)\n# 进程控制\n## 进程标识\n- 进程0：调度进程，也叫交换进程，内核的一部分，不执行任何磁盘上的程序\n- 进程1：init进程，自举过程结束，由内核调用，永不会终止，以超级用户特权运行的普通用户进程\n## fork\nfork完文件表项如下图\n![](/images/fd.png)\n## 僵尸进程和孤儿进程\n- 僵尸进程：子进程终止，父进程未wait回收其资源\n- 孤儿进程：子进程未结束，父进程终止了，此时，成为孤儿进程，之后由内核的进程1托管成为父进程\n## exec\n用磁盘上的一个新程序替换当前进程的正文段、数据段、堆和栈\n## wait函数\nwait函数会回收子进程的结束状态，但有些wait函数是只读，这可以再次wait，读取其状态\n## setuid\nset-user-id就是ls -l权限中的s权限\n![](/images/uid.png)\n## system\n该函数其实调用了fork->exec->waitpid函数，有设置用户id的程序最后不用该函数，可能使得system执行的程序权限提升，正确做法fork前设置适当的有效用户id\n## 设置priority函数\nnice、getpriority、setpriority\n## 进程会计--pacct命令\n## 进程时间--times\n\n## 条件变量-线程同步\n**在wait时，会解锁,唤醒时会加锁**\n","source":"_posts/进程与线程.md","raw":"---\ntitle: 进程与线程\ndate: 2023-09-03 15:21:11\ntags:\nbanner_img: /images/processThread.png\nindex_img: /images/processThread.png\n---\n# 7进程环境\n## main函数的启动\n当内核执行c程序时，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址（连接器指定）,启动例程从内核取得命令行参数和环境变量值，然后调用main函数\n## 进程终止\n### 8种终止方式\n1. 从main返回\n2. 调用exit\n3. 调用_exit或_Exit\n4. 最后一个线程从其启动例程返回\n5. 最后一个线程调用pthread_exit\n异常终止:\n6. 调用abort\n7. 接到一个信号\n8. 最后一个线程对取消请求做出响应\n### atexit函数\n```C\n#include <stdlib.h>\nint atexit(void (*func)(void));\n// 登记成功返回0\n```\n终止处理函数，一个进程可以登记最多32个函数\n![](/images/exit.png)\n## 内存空间分布\n![](/images/memory_struct.png)\n磁盘上的可执行文件并不存放bss内容，内核在程序开始运行前将它们都设为0。磁盘可执行文件只存取text和初始化段\n`size /path/bin`可查看某执行文件的各个段的长度\n## 共享库\ngcc默认使用共享库，可使用-static阻止使用共享库\n## 内存分配函数\n- malloc: 分配指定字节数的存储区。初始值不确定\n- calloc: 为指定数量指定长度的对象分配存储空间,初始化为0\n- realloc: 增加或减少以前分配区的长度。增加时新增区的初始值不确定\n它们都是调用sbrk的系统调用，sbrk可扩充或缩小进程的存储空间，但是大多数的malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配\n这三个函数都有debug版本，进行附加检错，通过设置环境变量支持\n**alloca**函数分配的空间在栈上\n## 环境变量\n全局变量environ(char**)，指向环境表，一般不对它进行直接操作\n![](/images/environ.png)\n- `char* getenv(const char* name)`\n- `int putenv(char *str)`str是类似`name = value`, 会直接将该值的地址放到环境表中,所以str不能是栈上的\n- `int setenv(const char *name, const char* value, int rewrite)` rewrite为0,则不删除现有定义\n- `int unsetenv(const char* name)`\n环境表和环境字符串通常位于进程空间的顶部，所以如果增加环境变量或值字符串变长，系统会调用malloc在堆上分配空间\n## setjmp和longjmp函数间的跳转\n```C\n#include <setjmp.h>\nint setjmp(jmp_buf env)//若直接调用，返回0；若从longjmp返回，则非0\nvoid longjmp(jmp_Buf env, int val)\n```\n在函数之间的跳转，会舍弃中间的帧，无法确保变量的值，在同一个系统中，要想获得可靠的值，则要加上volatile关键字，这并不能保证(p218仔细看把)\n## getrlimit和setrlimit资源限制函数\n(todo,目前感觉用处不大)\n# 进程控制\n## 进程标识\n- 进程0：调度进程，也叫交换进程，内核的一部分，不执行任何磁盘上的程序\n- 进程1：init进程，自举过程结束，由内核调用，永不会终止，以超级用户特权运行的普通用户进程\n## fork\nfork完文件表项如下图\n![](/images/fd.png)\n## 僵尸进程和孤儿进程\n- 僵尸进程：子进程终止，父进程未wait回收其资源\n- 孤儿进程：子进程未结束，父进程终止了，此时，成为孤儿进程，之后由内核的进程1托管成为父进程\n## exec\n用磁盘上的一个新程序替换当前进程的正文段、数据段、堆和栈\n## wait函数\nwait函数会回收子进程的结束状态，但有些wait函数是只读，这可以再次wait，读取其状态\n## setuid\nset-user-id就是ls -l权限中的s权限\n![](/images/uid.png)\n## system\n该函数其实调用了fork->exec->waitpid函数，有设置用户id的程序最后不用该函数，可能使得system执行的程序权限提升，正确做法fork前设置适当的有效用户id\n## 设置priority函数\nnice、getpriority、setpriority\n## 进程会计--pacct命令\n## 进程时间--times\n\n## 条件变量-线程同步\n**在wait时，会解锁,唤醒时会加锁**\n","slug":"进程与线程","published":1,"updated":"2024-03-18T20:19:51.515Z","_id":"clq1yvi7d002mgwq2byl00qfn","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"7进程环境\"><a href=\"#7进程环境\" class=\"headerlink\" title=\"7进程环境\"></a>7进程环境</h1><h2 id=\"main函数的启动\"><a href=\"#main函数的启动\" class=\"headerlink\" title=\"main函数的启动\"></a>main函数的启动</h2><p>当内核执行c程序时，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址（连接器指定）,启动例程从内核取得命令行参数和环境变量值，然后调用main函数</p>\n<h2 id=\"进程终止\"><a href=\"#进程终止\" class=\"headerlink\" title=\"进程终止\"></a>进程终止</h2><h3 id=\"8种终止方式\"><a href=\"#8种终止方式\" class=\"headerlink\" title=\"8种终止方式\"></a>8种终止方式</h3><ol>\n<li>从main返回</li>\n<li>调用exit</li>\n<li>调用_exit或_Exit</li>\n<li>最后一个线程从其启动例程返回</li>\n<li>最后一个线程调用pthread_exit<br>异常终止:</li>\n<li>调用abort</li>\n<li>接到一个信号</li>\n<li>最后一个线程对取消请求做出响应</li>\n</ol>\n<h3 id=\"atexit函数\"><a href=\"#atexit函数\" class=\"headerlink\" title=\"atexit函数\"></a>atexit函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">atexit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> (*func)(<span class=\"hljs-type\">void</span>))</span>;<br><span class=\"hljs-comment\">// 登记成功返回0</span><br></code></pre></td></tr></table></figure>\n<p>终止处理函数，一个进程可以登记最多32个函数<br><img src=\"/images/exit.png\"></p>\n<h2 id=\"内存空间分布\"><a href=\"#内存空间分布\" class=\"headerlink\" title=\"内存空间分布\"></a>内存空间分布</h2><p><img src=\"/images/memory_struct.png\"><br>磁盘上的可执行文件并不存放bss内容，内核在程序开始运行前将它们都设为0。磁盘可执行文件只存取text和初始化段<br><code>size /path/bin</code>可查看某执行文件的各个段的长度</p>\n<h2 id=\"共享库\"><a href=\"#共享库\" class=\"headerlink\" title=\"共享库\"></a>共享库</h2><p>gcc默认使用共享库，可使用-static阻止使用共享库</p>\n<h2 id=\"内存分配函数\"><a href=\"#内存分配函数\" class=\"headerlink\" title=\"内存分配函数\"></a>内存分配函数</h2><ul>\n<li>malloc: 分配指定字节数的存储区。初始值不确定</li>\n<li>calloc: 为指定数量指定长度的对象分配存储空间,初始化为0</li>\n<li>realloc: 增加或减少以前分配区的长度。增加时新增区的初始值不确定<br>它们都是调用sbrk的系统调用，sbrk可扩充或缩小进程的存储空间，但是大多数的malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配<br>这三个函数都有debug版本，进行附加检错，通过设置环境变量支持<br><strong>alloca</strong>函数分配的空间在栈上</li>\n</ul>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>全局变量environ(char**)，指向环境表，一般不对它进行直接操作<br><img src=\"/images/environ.png\"></p>\n<ul>\n<li><code>char* getenv(const char* name)</code></li>\n<li><code>int putenv(char *str)</code>str是类似<code>name = value</code>, 会直接将该值的地址放到环境表中,所以str不能是栈上的</li>\n<li><code>int setenv(const char *name, const char* value, int rewrite)</code> rewrite为0,则不删除现有定义</li>\n<li><code>int unsetenv(const char* name)</code><br>环境表和环境字符串通常位于进程空间的顶部，所以如果增加环境变量或值字符串变长，系统会调用malloc在堆上分配空间</li>\n</ul>\n<h2 id=\"setjmp和longjmp函数间的跳转\"><a href=\"#setjmp和longjmp函数间的跳转\" class=\"headerlink\" title=\"setjmp和longjmp函数间的跳转\"></a>setjmp和longjmp函数间的跳转</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;setjmp.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">setjmp</span><span class=\"hljs-params\">(jmp_buf env)</span><span class=\"hljs-comment\">//若直接调用，返回0；若从longjmp返回，则非0</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">longjmp</span><span class=\"hljs-params\">(jmp_Buf env, <span class=\"hljs-type\">int</span> val)</span><br></code></pre></td></tr></table></figure>\n<p>在函数之间的跳转，会舍弃中间的帧，无法确保变量的值，在同一个系统中，要想获得可靠的值，则要加上volatile关键字，这并不能保证(p218仔细看把)</p>\n<h2 id=\"getrlimit和setrlimit资源限制函数\"><a href=\"#getrlimit和setrlimit资源限制函数\" class=\"headerlink\" title=\"getrlimit和setrlimit资源限制函数\"></a>getrlimit和setrlimit资源限制函数</h2><p>(todo,目前感觉用处不大)</p>\n<h1 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h1><h2 id=\"进程标识\"><a href=\"#进程标识\" class=\"headerlink\" title=\"进程标识\"></a>进程标识</h2><ul>\n<li>进程0：调度进程，也叫交换进程，内核的一部分，不执行任何磁盘上的程序</li>\n<li>进程1：init进程，自举过程结束，由内核调用，永不会终止，以超级用户特权运行的普通用户进程</li>\n</ul>\n<h2 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h2><p>fork完文件表项如下图<br><img src=\"/images/fd.png\"></p>\n<h2 id=\"僵尸进程和孤儿进程\"><a href=\"#僵尸进程和孤儿进程\" class=\"headerlink\" title=\"僵尸进程和孤儿进程\"></a>僵尸进程和孤儿进程</h2><ul>\n<li>僵尸进程：子进程终止，父进程未wait回收其资源</li>\n<li>孤儿进程：子进程未结束，父进程终止了，此时，成为孤儿进程，之后由内核的进程1托管成为父进程</li>\n</ul>\n<h2 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h2><p>用磁盘上的一个新程序替换当前进程的正文段、数据段、堆和栈</p>\n<h2 id=\"wait函数\"><a href=\"#wait函数\" class=\"headerlink\" title=\"wait函数\"></a>wait函数</h2><p>wait函数会回收子进程的结束状态，但有些wait函数是只读，这可以再次wait，读取其状态</p>\n<h2 id=\"setuid\"><a href=\"#setuid\" class=\"headerlink\" title=\"setuid\"></a>setuid</h2><p>set-user-id就是ls -l权限中的s权限<br><img src=\"/images/uid.png\"></p>\n<h2 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h2><p>该函数其实调用了fork-&gt;exec-&gt;waitpid函数，有设置用户id的程序最后不用该函数，可能使得system执行的程序权限提升，正确做法fork前设置适当的有效用户id</p>\n<h2 id=\"设置priority函数\"><a href=\"#设置priority函数\" class=\"headerlink\" title=\"设置priority函数\"></a>设置priority函数</h2><p>nice、getpriority、setpriority</p>\n<h2 id=\"进程会计–pacct命令\"><a href=\"#进程会计–pacct命令\" class=\"headerlink\" title=\"进程会计–pacct命令\"></a>进程会计–pacct命令</h2><h2 id=\"进程时间–times\"><a href=\"#进程时间–times\" class=\"headerlink\" title=\"进程时间–times\"></a>进程时间–times</h2><h2 id=\"条件变量-线程同步\"><a href=\"#条件变量-线程同步\" class=\"headerlink\" title=\"条件变量-线程同步\"></a>条件变量-线程同步</h2><p><strong>在wait时，会解锁,唤醒时会加锁</strong></p>\n","excerpt":"","more":"<h1 id=\"7进程环境\"><a href=\"#7进程环境\" class=\"headerlink\" title=\"7进程环境\"></a>7进程环境</h1><h2 id=\"main函数的启动\"><a href=\"#main函数的启动\" class=\"headerlink\" title=\"main函数的启动\"></a>main函数的启动</h2><p>当内核执行c程序时，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址（连接器指定）,启动例程从内核取得命令行参数和环境变量值，然后调用main函数</p>\n<h2 id=\"进程终止\"><a href=\"#进程终止\" class=\"headerlink\" title=\"进程终止\"></a>进程终止</h2><h3 id=\"8种终止方式\"><a href=\"#8种终止方式\" class=\"headerlink\" title=\"8种终止方式\"></a>8种终止方式</h3><ol>\n<li>从main返回</li>\n<li>调用exit</li>\n<li>调用_exit或_Exit</li>\n<li>最后一个线程从其启动例程返回</li>\n<li>最后一个线程调用pthread_exit<br>异常终止:</li>\n<li>调用abort</li>\n<li>接到一个信号</li>\n<li>最后一个线程对取消请求做出响应</li>\n</ol>\n<h3 id=\"atexit函数\"><a href=\"#atexit函数\" class=\"headerlink\" title=\"atexit函数\"></a>atexit函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">atexit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> (*func)(<span class=\"hljs-type\">void</span>))</span>;<br><span class=\"hljs-comment\">// 登记成功返回0</span><br></code></pre></td></tr></table></figure>\n<p>终止处理函数，一个进程可以登记最多32个函数<br><img src=\"/images/exit.png\"></p>\n<h2 id=\"内存空间分布\"><a href=\"#内存空间分布\" class=\"headerlink\" title=\"内存空间分布\"></a>内存空间分布</h2><p><img src=\"/images/memory_struct.png\"><br>磁盘上的可执行文件并不存放bss内容，内核在程序开始运行前将它们都设为0。磁盘可执行文件只存取text和初始化段<br><code>size /path/bin</code>可查看某执行文件的各个段的长度</p>\n<h2 id=\"共享库\"><a href=\"#共享库\" class=\"headerlink\" title=\"共享库\"></a>共享库</h2><p>gcc默认使用共享库，可使用-static阻止使用共享库</p>\n<h2 id=\"内存分配函数\"><a href=\"#内存分配函数\" class=\"headerlink\" title=\"内存分配函数\"></a>内存分配函数</h2><ul>\n<li>malloc: 分配指定字节数的存储区。初始值不确定</li>\n<li>calloc: 为指定数量指定长度的对象分配存储空间,初始化为0</li>\n<li>realloc: 增加或减少以前分配区的长度。增加时新增区的初始值不确定<br>它们都是调用sbrk的系统调用，sbrk可扩充或缩小进程的存储空间，但是大多数的malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配<br>这三个函数都有debug版本，进行附加检错，通过设置环境变量支持<br><strong>alloca</strong>函数分配的空间在栈上</li>\n</ul>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>全局变量environ(char**)，指向环境表，一般不对它进行直接操作<br><img src=\"/images/environ.png\"></p>\n<ul>\n<li><code>char* getenv(const char* name)</code></li>\n<li><code>int putenv(char *str)</code>str是类似<code>name = value</code>, 会直接将该值的地址放到环境表中,所以str不能是栈上的</li>\n<li><code>int setenv(const char *name, const char* value, int rewrite)</code> rewrite为0,则不删除现有定义</li>\n<li><code>int unsetenv(const char* name)</code><br>环境表和环境字符串通常位于进程空间的顶部，所以如果增加环境变量或值字符串变长，系统会调用malloc在堆上分配空间</li>\n</ul>\n<h2 id=\"setjmp和longjmp函数间的跳转\"><a href=\"#setjmp和longjmp函数间的跳转\" class=\"headerlink\" title=\"setjmp和longjmp函数间的跳转\"></a>setjmp和longjmp函数间的跳转</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;setjmp.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">setjmp</span><span class=\"hljs-params\">(jmp_buf env)</span><span class=\"hljs-comment\">//若直接调用，返回0；若从longjmp返回，则非0</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">longjmp</span><span class=\"hljs-params\">(jmp_Buf env, <span class=\"hljs-type\">int</span> val)</span><br></code></pre></td></tr></table></figure>\n<p>在函数之间的跳转，会舍弃中间的帧，无法确保变量的值，在同一个系统中，要想获得可靠的值，则要加上volatile关键字，这并不能保证(p218仔细看把)</p>\n<h2 id=\"getrlimit和setrlimit资源限制函数\"><a href=\"#getrlimit和setrlimit资源限制函数\" class=\"headerlink\" title=\"getrlimit和setrlimit资源限制函数\"></a>getrlimit和setrlimit资源限制函数</h2><p>(todo,目前感觉用处不大)</p>\n<h1 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h1><h2 id=\"进程标识\"><a href=\"#进程标识\" class=\"headerlink\" title=\"进程标识\"></a>进程标识</h2><ul>\n<li>进程0：调度进程，也叫交换进程，内核的一部分，不执行任何磁盘上的程序</li>\n<li>进程1：init进程，自举过程结束，由内核调用，永不会终止，以超级用户特权运行的普通用户进程</li>\n</ul>\n<h2 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h2><p>fork完文件表项如下图<br><img src=\"/images/fd.png\"></p>\n<h2 id=\"僵尸进程和孤儿进程\"><a href=\"#僵尸进程和孤儿进程\" class=\"headerlink\" title=\"僵尸进程和孤儿进程\"></a>僵尸进程和孤儿进程</h2><ul>\n<li>僵尸进程：子进程终止，父进程未wait回收其资源</li>\n<li>孤儿进程：子进程未结束，父进程终止了，此时，成为孤儿进程，之后由内核的进程1托管成为父进程</li>\n</ul>\n<h2 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h2><p>用磁盘上的一个新程序替换当前进程的正文段、数据段、堆和栈</p>\n<h2 id=\"wait函数\"><a href=\"#wait函数\" class=\"headerlink\" title=\"wait函数\"></a>wait函数</h2><p>wait函数会回收子进程的结束状态，但有些wait函数是只读，这可以再次wait，读取其状态</p>\n<h2 id=\"setuid\"><a href=\"#setuid\" class=\"headerlink\" title=\"setuid\"></a>setuid</h2><p>set-user-id就是ls -l权限中的s权限<br><img src=\"/images/uid.png\"></p>\n<h2 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h2><p>该函数其实调用了fork-&gt;exec-&gt;waitpid函数，有设置用户id的程序最后不用该函数，可能使得system执行的程序权限提升，正确做法fork前设置适当的有效用户id</p>\n<h2 id=\"设置priority函数\"><a href=\"#设置priority函数\" class=\"headerlink\" title=\"设置priority函数\"></a>设置priority函数</h2><p>nice、getpriority、setpriority</p>\n<h2 id=\"进程会计–pacct命令\"><a href=\"#进程会计–pacct命令\" class=\"headerlink\" title=\"进程会计–pacct命令\"></a>进程会计–pacct命令</h2><h2 id=\"进程时间–times\"><a href=\"#进程时间–times\" class=\"headerlink\" title=\"进程时间–times\"></a>进程时间–times</h2><h2 id=\"条件变量-线程同步\"><a href=\"#条件变量-线程同步\" class=\"headerlink\" title=\"条件变量-线程同步\"></a>条件变量-线程同步</h2><p><strong>在wait时，会解锁,唤醒时会加锁</strong></p>\n"},{"title":"python基础","date":"2024-01-09T19:48:23.000Z","index_img":"/images/python_basic.png","banner_img":"/images/python_basic.png","_content":"\n# 函数\n## 默认参数\npython不支持重载，但是支持默认参数\n```python\ndef add(a=0, b=0, c=0):\n    return a+b+c\nadd(1,2)\nadd(1,2,3)\nadd(c=50,a=2, b= 2)\n```\n## 可变参数\n```python\ndef add(*args):\n    total = 0\n    for val in args:\n        total+=val\n    return total\n```\n# 模块\n- python中每个文件就代表一个模块,模块名即为文件名\n- `__name__`是python中一个隐含的变量，它代表了模块的名字，只有被Python解释器直接执行的模块的名字才是`__main__`\n# 作用域\n```python\ndef foo():\n    b = 'hello'\n    # Python中可以在函数内部再定义函数\n    def bar():\n        c = True\n        print(a)//全局变量\n        print(b)//嵌套变量\n        print(c)//局部变量\n    bar()\n    # print(c)  # NameError: name 'c' is not defined\nif __name__ == '__main__':\n    a = 100 # 不属于任何函数，即为全局变量\n    # print(b)  # NameError: name 'b' is not defined\n    foo()\n```\n- 除上述的全局作用域、嵌套作用域、局部作用域外，还存在内置作用域，如input,print,int等\n- 查一个变量会按局部作用域、嵌套作用域、全局作用域、内置作用域来找\n## global和nonlocal\n- global一般用在函数中指示该变量来自全局，如果全局中没有,那么就会定义一个，并置于全局中\n- nonlocal则指示变量处于嵌套作用域中\n# 闭包\n- 闭包可以使一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以用它的值\n# pip\n## matplotlib依赖路径\n- numpy->contourpy->cycler->fonttools->kiwisolver->packaging->pillow->pyparsing->six->python_dateutil->matplotlib\n# 字符串\n- 支持`*`号，重复字符串\n- 三个单引号或双引号，可以支持折行\n- `s1 = r'\\n\\hello''`,不会转义\n## 相关函数\n\n|用法|说明|\n|:-:|:-:|\n|len(str1)|计算字符串长度|\n|str1.capitalize()|获得字符串首字母大写的拷贝|\n|str1.title()|获得每个单词首字母大写的拷贝|\n|str1.upper()|获得字符串变大写的拷贝|\n|str1.find('a')|查找子串的位置，如果没有返回-1|\n|str1.index('a')|查找子串的位置，如果没有抛出异常|\n|str1.startswith('he')|是否以指定的字符串开头|\n|str1.endswith('he')|是否以指定的字符串结尾|\n|str1.center(50, '\\*')|以指定宽度居中并在两侧填充指定字符|\n|str1.rjust(50, '\\*')|以指定宽度靠右放置|\n|str1.ljust(50, '\\*')|以指定宽度靠左放置|\n|str1.isdigit()|检查字符串是否只由数字组成|\n|str1.isalpha()|检查字符串是否只由字母组成|\n|str1.isalnum()|检查字符串是否由字母和数字组成|\n|str1.strip()|去除左右两侧空格的拷贝|\n|str1.lstrip()|去除左两侧空格的拷贝|\n|str1.rstrip()|去除右两侧空格的拷贝|\n\n# print\n```python\na, b = 5, 10\nprint('%d * %d = %d' % (a, b, a * b))\n```\n\n```python\na, b = 5, 10\nprint('{0} * {1} = {2}'.format(a, b, a * b))\n```\n\n```python\na, b = 5, 10\nprint(f'{a} * {b} = {a * b}')\n```\n\n# list\n- 定义：`t = []`\n- 转换元组：`tuple1 = tuple(list1)`\n## 同时遍历元素和下标\n```python\nfor index, elem in enumerate(list1):\n    print(index, elem)\n```\n## 函数相关\n\n|例子|说明|\n|:-:|:-:|\n|list1.append(ele)|在末尾增加一个元素|\n|list1.insert(1, 400)|在下标为1的元素前加个元素|\n|list1.extend(list2)|合并两个列表，等价于list1+=list2|\n|list1.remove(value)|去除列表中第一个为value的元素,如果列表中没该元素则抛出异常|\n|list1.pop(index1)|去除下标为index1的元素，默认为末尾元素|\n|list1.clear()|清空列表|\n|list1.reverse()|倒转元素|\n|list1.sort(reverse=True)|列表本身排序|\n|sorted(list1, reverse=True)|返回列表逆排序的拷贝|\n\n## 切片\n- `fruits[::-1]`: 获得倒转元素列表的拷贝\n- `fruits[:]`: 获得列表的拷贝\n\n# 生成式和生成器\n- 生成式：`f = [x+y for x in 'ABCDE' for y in '1234567']`,耗费空间更多\n- 生成器：`f = (x ** 2 for x in range(1,1000))`,不占用额外空间，但是取元素时会内部计算\n\n# 元组\n- 定义：`t = ('ss', 'gg')`\n- 转换列表：`list1 = list(tuple1)`\n- 相比列表的优势:tuple不可变，时空上都优于列表\n\n# 集合\n- 定义：`set1 = set()`,`set2 = set((1,2,3,4,3,2))`,`set3=set(range(1,10))`\n- set里的元素是排好序的\n## 相关函数\n\n|例子|说明|\n|:-:|:-:|\n|set1.add(value)|增加一个元素|\n|set2.update([11,12])|增加一个列表的元素|\n|set2.remove(12)|去除值12元素，没有会抛出异常|\n|set2.discard(12)|同remove但不会抛出异常|\n|set1.pop()|删除末尾元素|\n|set1.issuperset(set2)|set2是否包含set1|\n|set1.issubset(set2)|set1是否包含set2|\n\n![](/images/python_set.png)\n\n# 字典\n## 定义\n- `scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82}`\n- `items1 = dict(one=1, two=2, three=3, four=4)`\n- `items2 = dict(zip(['a', 'b', 'c'], '123'))`\n- `items3 = {num: num ** 2 for num in range(1, 10)}`\n## 函数相关\n\n|例子|说明|\n|:-:|:-:|\n|scores.update(冷面=67, 方启鹤=85)|增加两组元素|\n|scores.get('xx',60)|get方法也是通过键获取对应的值,如果不存在返回60|\n|scores.popitem()|去除末尾元素|\n|scores.pop('xx', 10)|去除键为xx的元素,如果没有返回10|\n|scores.clear()|清空|\n\n# 类\n## 类的定义\n```python\nclass Student(object):\n    # __init__是一个特殊方法用于在创建对象时进行初始化操作\n    # 通过这个方法我们可以为学生对象绑定name和age两个属性\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def study(self, course_name):\n        print('%s正在学习%s.' % (self.name, course_name))\n    # PEP 8要求标识符的名字用全小写多个单词用下划线连接\n    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)\n    def watch_movie(self):\n        if self.age < 18:\n            print('%s只能观看《熊出没》.' % self.name)\n        else:\n            print('%s正在观看岛国爱情大电影.' % self.name)\n```\n## 访问可见性\n- 在属性或方法前加两个下划线`__`，则是私有的，可以加`_Test`前缀强制访问，例如`a.__bar()`不可以访问，`a._Test__bar()`即可访问\n- 可以通过装饰器property设置setter和getter\n```python\nclass Person(object):\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n    # 访问器 - getter方法\n    @property\n    def name(self):\n        return self._name\n    # 访问器 - getter方法\n    @property\n    def age(self):\n        return self._age\n    # 修改器 - setter方法\n    @age.setter\n    def age(self, age):\n        self._age = age\n    def play(self):\n        if self._age <= 16:\n            print('%s正在玩飞行棋.' % self._name)\n        else:\n            print('%s正在玩斗地主.' % self._name)\ndef main():\n    person = Person('王大锤', 12)\n    person.play()\n    person.age = 22\n    person.play()\n    # person.name = '白元芳'  # AttributeError: can't set attribute\nif __name__ == '__main__':\n    main()\n```\n## __slots__\n果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用\n```python\nclass Person(object):\n    # 限定Person对象只能绑定_name, _age和_gender属性\n    __slots__ = ('_name', '_age', '_gender')\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n    @property\n    def name(self):\n        return self._name\n    @property\n    def age(self):\n        return self._age\n    @age.setter\n    def age(self, age):\n        self._age = age\n    def play(self):\n        if self._age <= 16:\n            print('%s正在玩飞行棋.' % self._name)\n        else:\n            print('%s正在玩斗地主.' % self._name)\ndef main():\n    person = Person('王大锤', 22)\n    person.play()\n    person._gender = '男'\n    # AttributeError: 'Person' object has no attribute '_is_gay'\n    # person._is_gay = True\n```\n## 静态方法\n```python\n\nclass Triangle(object):\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n    @staticmethod\n    def is_valid(a, b, c):\n        return a + b > c and b + c > a and a + c > b\n\nif Triangle.is_valid(a, b, c):\n```\n## 类方法\n```python\nfrom time import time, localtime, sleep\nclass Clock(object):\n    \"\"\"数字时钟\"\"\"\n    def __init__(self, hour=0, minute=0, second=0):\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n    @classmethod\n    def now(cls):\n        ctime = localtime(time())\n        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)\nclock = Clock.now()\n```\n## 虚类\n```python\nfrom abc import ABCMeta, abstractmethod\nclass Pet(object, metaclass=ABCMeta):\n    \"\"\"宠物\"\"\"\n    def __init__(self, nickname):\n        self._nickname = nickname\n    @abstractmethod\n    def make_voice(self):\n        \"\"\"发出声音\"\"\"\n        pass\n```\n\n# sys\n- sys.getsizeof(var1): 打印变量的空间\n\n# yield\n\n# tips\n- `__doc__`：xx.__doc__,会打印xx函数或方法的说明\n","source":"_posts/python基础.md","raw":"---\ntitle: python基础\ndate: 2024-01-10 03:48:23\ntags:\nindex_img: /images/python_basic.png\nbanner_img: /images/python_basic.png\n---\n\n# 函数\n## 默认参数\npython不支持重载，但是支持默认参数\n```python\ndef add(a=0, b=0, c=0):\n    return a+b+c\nadd(1,2)\nadd(1,2,3)\nadd(c=50,a=2, b= 2)\n```\n## 可变参数\n```python\ndef add(*args):\n    total = 0\n    for val in args:\n        total+=val\n    return total\n```\n# 模块\n- python中每个文件就代表一个模块,模块名即为文件名\n- `__name__`是python中一个隐含的变量，它代表了模块的名字，只有被Python解释器直接执行的模块的名字才是`__main__`\n# 作用域\n```python\ndef foo():\n    b = 'hello'\n    # Python中可以在函数内部再定义函数\n    def bar():\n        c = True\n        print(a)//全局变量\n        print(b)//嵌套变量\n        print(c)//局部变量\n    bar()\n    # print(c)  # NameError: name 'c' is not defined\nif __name__ == '__main__':\n    a = 100 # 不属于任何函数，即为全局变量\n    # print(b)  # NameError: name 'b' is not defined\n    foo()\n```\n- 除上述的全局作用域、嵌套作用域、局部作用域外，还存在内置作用域，如input,print,int等\n- 查一个变量会按局部作用域、嵌套作用域、全局作用域、内置作用域来找\n## global和nonlocal\n- global一般用在函数中指示该变量来自全局，如果全局中没有,那么就会定义一个，并置于全局中\n- nonlocal则指示变量处于嵌套作用域中\n# 闭包\n- 闭包可以使一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以用它的值\n# pip\n## matplotlib依赖路径\n- numpy->contourpy->cycler->fonttools->kiwisolver->packaging->pillow->pyparsing->six->python_dateutil->matplotlib\n# 字符串\n- 支持`*`号，重复字符串\n- 三个单引号或双引号，可以支持折行\n- `s1 = r'\\n\\hello''`,不会转义\n## 相关函数\n\n|用法|说明|\n|:-:|:-:|\n|len(str1)|计算字符串长度|\n|str1.capitalize()|获得字符串首字母大写的拷贝|\n|str1.title()|获得每个单词首字母大写的拷贝|\n|str1.upper()|获得字符串变大写的拷贝|\n|str1.find('a')|查找子串的位置，如果没有返回-1|\n|str1.index('a')|查找子串的位置，如果没有抛出异常|\n|str1.startswith('he')|是否以指定的字符串开头|\n|str1.endswith('he')|是否以指定的字符串结尾|\n|str1.center(50, '\\*')|以指定宽度居中并在两侧填充指定字符|\n|str1.rjust(50, '\\*')|以指定宽度靠右放置|\n|str1.ljust(50, '\\*')|以指定宽度靠左放置|\n|str1.isdigit()|检查字符串是否只由数字组成|\n|str1.isalpha()|检查字符串是否只由字母组成|\n|str1.isalnum()|检查字符串是否由字母和数字组成|\n|str1.strip()|去除左右两侧空格的拷贝|\n|str1.lstrip()|去除左两侧空格的拷贝|\n|str1.rstrip()|去除右两侧空格的拷贝|\n\n# print\n```python\na, b = 5, 10\nprint('%d * %d = %d' % (a, b, a * b))\n```\n\n```python\na, b = 5, 10\nprint('{0} * {1} = {2}'.format(a, b, a * b))\n```\n\n```python\na, b = 5, 10\nprint(f'{a} * {b} = {a * b}')\n```\n\n# list\n- 定义：`t = []`\n- 转换元组：`tuple1 = tuple(list1)`\n## 同时遍历元素和下标\n```python\nfor index, elem in enumerate(list1):\n    print(index, elem)\n```\n## 函数相关\n\n|例子|说明|\n|:-:|:-:|\n|list1.append(ele)|在末尾增加一个元素|\n|list1.insert(1, 400)|在下标为1的元素前加个元素|\n|list1.extend(list2)|合并两个列表，等价于list1+=list2|\n|list1.remove(value)|去除列表中第一个为value的元素,如果列表中没该元素则抛出异常|\n|list1.pop(index1)|去除下标为index1的元素，默认为末尾元素|\n|list1.clear()|清空列表|\n|list1.reverse()|倒转元素|\n|list1.sort(reverse=True)|列表本身排序|\n|sorted(list1, reverse=True)|返回列表逆排序的拷贝|\n\n## 切片\n- `fruits[::-1]`: 获得倒转元素列表的拷贝\n- `fruits[:]`: 获得列表的拷贝\n\n# 生成式和生成器\n- 生成式：`f = [x+y for x in 'ABCDE' for y in '1234567']`,耗费空间更多\n- 生成器：`f = (x ** 2 for x in range(1,1000))`,不占用额外空间，但是取元素时会内部计算\n\n# 元组\n- 定义：`t = ('ss', 'gg')`\n- 转换列表：`list1 = list(tuple1)`\n- 相比列表的优势:tuple不可变，时空上都优于列表\n\n# 集合\n- 定义：`set1 = set()`,`set2 = set((1,2,3,4,3,2))`,`set3=set(range(1,10))`\n- set里的元素是排好序的\n## 相关函数\n\n|例子|说明|\n|:-:|:-:|\n|set1.add(value)|增加一个元素|\n|set2.update([11,12])|增加一个列表的元素|\n|set2.remove(12)|去除值12元素，没有会抛出异常|\n|set2.discard(12)|同remove但不会抛出异常|\n|set1.pop()|删除末尾元素|\n|set1.issuperset(set2)|set2是否包含set1|\n|set1.issubset(set2)|set1是否包含set2|\n\n![](/images/python_set.png)\n\n# 字典\n## 定义\n- `scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82}`\n- `items1 = dict(one=1, two=2, three=3, four=4)`\n- `items2 = dict(zip(['a', 'b', 'c'], '123'))`\n- `items3 = {num: num ** 2 for num in range(1, 10)}`\n## 函数相关\n\n|例子|说明|\n|:-:|:-:|\n|scores.update(冷面=67, 方启鹤=85)|增加两组元素|\n|scores.get('xx',60)|get方法也是通过键获取对应的值,如果不存在返回60|\n|scores.popitem()|去除末尾元素|\n|scores.pop('xx', 10)|去除键为xx的元素,如果没有返回10|\n|scores.clear()|清空|\n\n# 类\n## 类的定义\n```python\nclass Student(object):\n    # __init__是一个特殊方法用于在创建对象时进行初始化操作\n    # 通过这个方法我们可以为学生对象绑定name和age两个属性\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def study(self, course_name):\n        print('%s正在学习%s.' % (self.name, course_name))\n    # PEP 8要求标识符的名字用全小写多个单词用下划线连接\n    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)\n    def watch_movie(self):\n        if self.age < 18:\n            print('%s只能观看《熊出没》.' % self.name)\n        else:\n            print('%s正在观看岛国爱情大电影.' % self.name)\n```\n## 访问可见性\n- 在属性或方法前加两个下划线`__`，则是私有的，可以加`_Test`前缀强制访问，例如`a.__bar()`不可以访问，`a._Test__bar()`即可访问\n- 可以通过装饰器property设置setter和getter\n```python\nclass Person(object):\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n    # 访问器 - getter方法\n    @property\n    def name(self):\n        return self._name\n    # 访问器 - getter方法\n    @property\n    def age(self):\n        return self._age\n    # 修改器 - setter方法\n    @age.setter\n    def age(self, age):\n        self._age = age\n    def play(self):\n        if self._age <= 16:\n            print('%s正在玩飞行棋.' % self._name)\n        else:\n            print('%s正在玩斗地主.' % self._name)\ndef main():\n    person = Person('王大锤', 12)\n    person.play()\n    person.age = 22\n    person.play()\n    # person.name = '白元芳'  # AttributeError: can't set attribute\nif __name__ == '__main__':\n    main()\n```\n## __slots__\n果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用\n```python\nclass Person(object):\n    # 限定Person对象只能绑定_name, _age和_gender属性\n    __slots__ = ('_name', '_age', '_gender')\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n    @property\n    def name(self):\n        return self._name\n    @property\n    def age(self):\n        return self._age\n    @age.setter\n    def age(self, age):\n        self._age = age\n    def play(self):\n        if self._age <= 16:\n            print('%s正在玩飞行棋.' % self._name)\n        else:\n            print('%s正在玩斗地主.' % self._name)\ndef main():\n    person = Person('王大锤', 22)\n    person.play()\n    person._gender = '男'\n    # AttributeError: 'Person' object has no attribute '_is_gay'\n    # person._is_gay = True\n```\n## 静态方法\n```python\n\nclass Triangle(object):\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n    @staticmethod\n    def is_valid(a, b, c):\n        return a + b > c and b + c > a and a + c > b\n\nif Triangle.is_valid(a, b, c):\n```\n## 类方法\n```python\nfrom time import time, localtime, sleep\nclass Clock(object):\n    \"\"\"数字时钟\"\"\"\n    def __init__(self, hour=0, minute=0, second=0):\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n    @classmethod\n    def now(cls):\n        ctime = localtime(time())\n        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)\nclock = Clock.now()\n```\n## 虚类\n```python\nfrom abc import ABCMeta, abstractmethod\nclass Pet(object, metaclass=ABCMeta):\n    \"\"\"宠物\"\"\"\n    def __init__(self, nickname):\n        self._nickname = nickname\n    @abstractmethod\n    def make_voice(self):\n        \"\"\"发出声音\"\"\"\n        pass\n```\n\n# sys\n- sys.getsizeof(var1): 打印变量的空间\n\n# yield\n\n# tips\n- `__doc__`：xx.__doc__,会打印xx函数或方法的说明\n","slug":"python基础","published":1,"updated":"2024-01-18T20:42:27.513Z","_id":"clr6shu6j000006q2djdo2mvh","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>python不支持重载，但是支持默认参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a=<span class=\"hljs-number\">0</span>, b=<span class=\"hljs-number\">0</span>, c=<span class=\"hljs-number\">0</span></span>):<br>    <span class=\"hljs-keyword\">return</span> a+b+c<br>add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)<br>add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>)<br>add(c=<span class=\"hljs-number\">50</span>,a=<span class=\"hljs-number\">2</span>, b= <span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">*args</span>):<br>    total = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> val <span class=\"hljs-keyword\">in</span> args:<br>        total+=val<br>    <span class=\"hljs-keyword\">return</span> total<br></code></pre></td></tr></table></figure>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><ul>\n<li>python中每个文件就代表一个模块,模块名即为文件名</li>\n<li><code>__name__</code>是python中一个隐含的变量，它代表了模块的名字，只有被Python解释器直接执行的模块的名字才是<code>__main__</code></li>\n</ul>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">foo</span>():<br>    b = <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>    <span class=\"hljs-comment\"># Python中可以在函数内部再定义函数</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bar</span>():<br>        c = <span class=\"hljs-literal\">True</span><br>        <span class=\"hljs-built_in\">print</span>(a)//全局变量<br>        <span class=\"hljs-built_in\">print</span>(b)//嵌套变量<br>        <span class=\"hljs-built_in\">print</span>(c)//局部变量<br>    bar()<br>    <span class=\"hljs-comment\"># print(c)  # NameError: name &#x27;c&#x27; is not defined</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    a = <span class=\"hljs-number\">100</span> <span class=\"hljs-comment\"># 不属于任何函数，即为全局变量</span><br>    <span class=\"hljs-comment\"># print(b)  # NameError: name &#x27;b&#x27; is not defined</span><br>    foo()<br></code></pre></td></tr></table></figure>\n<ul>\n<li>除上述的全局作用域、嵌套作用域、局部作用域外，还存在内置作用域，如input,print,int等</li>\n<li>查一个变量会按局部作用域、嵌套作用域、全局作用域、内置作用域来找</li>\n</ul>\n<h2 id=\"global和nonlocal\"><a href=\"#global和nonlocal\" class=\"headerlink\" title=\"global和nonlocal\"></a>global和nonlocal</h2><ul>\n<li>global一般用在函数中指示该变量来自全局，如果全局中没有,那么就会定义一个，并置于全局中</li>\n<li>nonlocal则指示变量处于嵌套作用域中</li>\n</ul>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><ul>\n<li>闭包可以使一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以用它的值</li>\n</ul>\n<h1 id=\"pip\"><a href=\"#pip\" class=\"headerlink\" title=\"pip\"></a>pip</h1><h2 id=\"matplotlib依赖路径\"><a href=\"#matplotlib依赖路径\" class=\"headerlink\" title=\"matplotlib依赖路径\"></a>matplotlib依赖路径</h2><ul>\n<li>numpy-&gt;contourpy-&gt;cycler-&gt;fonttools-&gt;kiwisolver-&gt;packaging-&gt;pillow-&gt;pyparsing-&gt;six-&gt;python_dateutil-&gt;matplotlib</li>\n</ul>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><ul>\n<li>支持<code>*</code>号，重复字符串</li>\n<li>三个单引号或双引号，可以支持折行</li>\n<li><code>s1 = r&#39;\\n\\hello&#39;&#39;</code>,不会转义</li>\n</ul>\n<h2 id=\"相关函数\"><a href=\"#相关函数\" class=\"headerlink\" title=\"相关函数\"></a>相关函数</h2><table>\n<thead>\n<tr>\n<th align=\"center\">用法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">len(str1)</td>\n<td align=\"center\">计算字符串长度</td>\n</tr>\n<tr>\n<td align=\"center\">str1.capitalize()</td>\n<td align=\"center\">获得字符串首字母大写的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.title()</td>\n<td align=\"center\">获得每个单词首字母大写的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.upper()</td>\n<td align=\"center\">获得字符串变大写的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.find(‘a’)</td>\n<td align=\"center\">查找子串的位置，如果没有返回-1</td>\n</tr>\n<tr>\n<td align=\"center\">str1.index(‘a’)</td>\n<td align=\"center\">查找子串的位置，如果没有抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">str1.startswith(‘he’)</td>\n<td align=\"center\">是否以指定的字符串开头</td>\n</tr>\n<tr>\n<td align=\"center\">str1.endswith(‘he’)</td>\n<td align=\"center\">是否以指定的字符串结尾</td>\n</tr>\n<tr>\n<td align=\"center\">str1.center(50, ‘*‘)</td>\n<td align=\"center\">以指定宽度居中并在两侧填充指定字符</td>\n</tr>\n<tr>\n<td align=\"center\">str1.rjust(50, ‘*‘)</td>\n<td align=\"center\">以指定宽度靠右放置</td>\n</tr>\n<tr>\n<td align=\"center\">str1.ljust(50, ‘*‘)</td>\n<td align=\"center\">以指定宽度靠左放置</td>\n</tr>\n<tr>\n<td align=\"center\">str1.isdigit()</td>\n<td align=\"center\">检查字符串是否只由数字组成</td>\n</tr>\n<tr>\n<td align=\"center\">str1.isalpha()</td>\n<td align=\"center\">检查字符串是否只由字母组成</td>\n</tr>\n<tr>\n<td align=\"center\">str1.isalnum()</td>\n<td align=\"center\">检查字符串是否由字母和数字组成</td>\n</tr>\n<tr>\n<td align=\"center\">str1.strip()</td>\n<td align=\"center\">去除左右两侧空格的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.lstrip()</td>\n<td align=\"center\">去除左两侧空格的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.rstrip()</td>\n<td align=\"center\">去除右两侧空格的拷贝</td>\n</tr>\n</tbody></table>\n<h1 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a, b = <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%d * %d = %d&#x27;</span> % (a, b, a * b))<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a, b = <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&#x27;</span>.<span class=\"hljs-built_in\">format</span>(a, b, a * b))<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a, b = <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&#x27;<span class=\"hljs-subst\">&#123;a&#125;</span> * <span class=\"hljs-subst\">&#123;b&#125;</span> = <span class=\"hljs-subst\">&#123;a * b&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h1><ul>\n<li>定义：<code>t = []</code></li>\n<li>转换元组：<code>tuple1 = tuple(list1)</code></li>\n</ul>\n<h2 id=\"同时遍历元素和下标\"><a href=\"#同时遍历元素和下标\" class=\"headerlink\" title=\"同时遍历元素和下标\"></a>同时遍历元素和下标</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> index, elem <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(list1):<br>    <span class=\"hljs-built_in\">print</span>(index, elem)<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数相关\"><a href=\"#函数相关\" class=\"headerlink\" title=\"函数相关\"></a>函数相关</h2><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">list1.append(ele)</td>\n<td align=\"center\">在末尾增加一个元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.insert(1, 400)</td>\n<td align=\"center\">在下标为1的元素前加个元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.extend(list2)</td>\n<td align=\"center\">合并两个列表，等价于list1+&#x3D;list2</td>\n</tr>\n<tr>\n<td align=\"center\">list1.remove(value)</td>\n<td align=\"center\">去除列表中第一个为value的元素,如果列表中没该元素则抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">list1.pop(index1)</td>\n<td align=\"center\">去除下标为index1的元素，默认为末尾元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.clear()</td>\n<td align=\"center\">清空列表</td>\n</tr>\n<tr>\n<td align=\"center\">list1.reverse()</td>\n<td align=\"center\">倒转元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.sort(reverse&#x3D;True)</td>\n<td align=\"center\">列表本身排序</td>\n</tr>\n<tr>\n<td align=\"center\">sorted(list1, reverse&#x3D;True)</td>\n<td align=\"center\">返回列表逆排序的拷贝</td>\n</tr>\n</tbody></table>\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><ul>\n<li><code>fruits[::-1]</code>: 获得倒转元素列表的拷贝</li>\n<li><code>fruits[:]</code>: 获得列表的拷贝</li>\n</ul>\n<h1 id=\"生成式和生成器\"><a href=\"#生成式和生成器\" class=\"headerlink\" title=\"生成式和生成器\"></a>生成式和生成器</h1><ul>\n<li>生成式：<code>f = [x+y for x in &#39;ABCDE&#39; for y in &#39;1234567&#39;]</code>,耗费空间更多</li>\n<li>生成器：<code>f = (x ** 2 for x in range(1,1000))</code>,不占用额外空间，但是取元素时会内部计算</li>\n</ul>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><ul>\n<li>定义：<code>t = (&#39;ss&#39;, &#39;gg&#39;)</code></li>\n<li>转换列表：<code>list1 = list(tuple1)</code></li>\n<li>相比列表的优势:tuple不可变，时空上都优于列表</li>\n</ul>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><ul>\n<li>定义：<code>set1 = set()</code>,<code>set2 = set((1,2,3,4,3,2))</code>,<code>set3=set(range(1,10))</code></li>\n<li>set里的元素是排好序的</li>\n</ul>\n<h2 id=\"相关函数-1\"><a href=\"#相关函数-1\" class=\"headerlink\" title=\"相关函数\"></a>相关函数</h2><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">set1.add(value)</td>\n<td align=\"center\">增加一个元素</td>\n</tr>\n<tr>\n<td align=\"center\">set2.update([11,12])</td>\n<td align=\"center\">增加一个列表的元素</td>\n</tr>\n<tr>\n<td align=\"center\">set2.remove(12)</td>\n<td align=\"center\">去除值12元素，没有会抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">set2.discard(12)</td>\n<td align=\"center\">同remove但不会抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">set1.pop()</td>\n<td align=\"center\">删除末尾元素</td>\n</tr>\n<tr>\n<td align=\"center\">set1.issuperset(set2)</td>\n<td align=\"center\">set2是否包含set1</td>\n</tr>\n<tr>\n<td align=\"center\">set1.issubset(set2)</td>\n<td align=\"center\">set1是否包含set2</td>\n</tr>\n</tbody></table>\n<p><img src=\"/images/python_set.png\"></p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li><code>scores = &#123;&#39;骆昊&#39;: 95, &#39;白元芳&#39;: 78, &#39;狄仁杰&#39;: 82&#125;</code></li>\n<li><code>items1 = dict(one=1, two=2, three=3, four=4)</code></li>\n<li><code>items2 = dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;123&#39;))</code></li>\n<li><code>items3 = &#123;num: num ** 2 for num in range(1, 10)&#125;</code></li>\n</ul>\n<h2 id=\"函数相关-1\"><a href=\"#函数相关-1\" class=\"headerlink\" title=\"函数相关\"></a>函数相关</h2><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">scores.update(冷面&#x3D;67, 方启鹤&#x3D;85)</td>\n<td align=\"center\">增加两组元素</td>\n</tr>\n<tr>\n<td align=\"center\">scores.get(‘xx’,60)</td>\n<td align=\"center\">get方法也是通过键获取对应的值,如果不存在返回60</td>\n</tr>\n<tr>\n<td align=\"center\">scores.popitem()</td>\n<td align=\"center\">去除末尾元素</td>\n</tr>\n<tr>\n<td align=\"center\">scores.pop(‘xx’, 10)</td>\n<td align=\"center\">去除键为xx的元素,如果没有返回10</td>\n</tr>\n<tr>\n<td align=\"center\">scores.clear()</td>\n<td align=\"center\">清空</td>\n</tr>\n</tbody></table>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-comment\"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span><br>    <span class=\"hljs-comment\"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">study</span>(<span class=\"hljs-params\">self, course_name</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在学习%s.&#x27;</span> % (self.name, course_name))<br>    <span class=\"hljs-comment\"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span><br>    <span class=\"hljs-comment\"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">watch_movie</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> self.age &lt; <span class=\"hljs-number\">18</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s只能观看《熊出没》.&#x27;</span> % self.name)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在观看岛国爱情大电影.&#x27;</span> % self.name)<br></code></pre></td></tr></table></figure>\n<h2 id=\"访问可见性\"><a href=\"#访问可见性\" class=\"headerlink\" title=\"访问可见性\"></a>访问可见性</h2><ul>\n<li>在属性或方法前加两个下划线<code>__</code>，则是私有的，可以加<code>_Test</code>前缀强制访问，例如<code>a.__bar()</code>不可以访问，<code>a._Test__bar()</code>即可访问</li>\n<li>可以通过装饰器property设置setter和getter<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>):<br>        self._name = name<br>        self._age = age<br>    <span class=\"hljs-comment\"># 访问器 - getter方法</span><br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">name</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._name<br>    <span class=\"hljs-comment\"># 访问器 - getter方法</span><br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._age<br>    <span class=\"hljs-comment\"># 修改器 - setter方法</span><br><span class=\"hljs-meta\">    @age.setter</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self, age</span>):<br>        self._age = age<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">play</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> self._age &lt;= <span class=\"hljs-number\">16</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    person = Person(<span class=\"hljs-string\">&#x27;王大锤&#x27;</span>, <span class=\"hljs-number\">12</span>)<br>    person.play()<br>    person.age = <span class=\"hljs-number\">22</span><br>    person.play()<br>    <span class=\"hljs-comment\"># person.name = &#x27;白元芳&#x27;  # AttributeError: can&#x27;t set attribute</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"slots\"><a href=\"#slots\" class=\"headerlink\" title=\"slots\"></a><strong>slots</strong></h2><p>果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-comment\"># 限定Person对象只能绑定_name, _age和_gender属性</span><br>    __slots__ = (<span class=\"hljs-string\">&#x27;_name&#x27;</span>, <span class=\"hljs-string\">&#x27;_age&#x27;</span>, <span class=\"hljs-string\">&#x27;_gender&#x27;</span>)<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>):<br>        self._name = name<br>        self._age = age<br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">name</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._name<br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._age<br><span class=\"hljs-meta\">    @age.setter</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self, age</span>):<br>        self._age = age<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">play</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> self._age &lt;= <span class=\"hljs-number\">16</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    person = Person(<span class=\"hljs-string\">&#x27;王大锤&#x27;</span>, <span class=\"hljs-number\">22</span>)<br>    person.play()<br>    person._gender = <span class=\"hljs-string\">&#x27;男&#x27;</span><br>    <span class=\"hljs-comment\"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;_is_gay&#x27;</span><br>    <span class=\"hljs-comment\"># person._is_gay = True</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Triangle</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, a, b, c</span>):<br>        self._a = a<br>        self._b = b<br>        self._c = c<br><span class=\"hljs-meta\">    @staticmethod</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">is_valid</span>(<span class=\"hljs-params\">a, b, c</span>):<br>        <span class=\"hljs-keyword\">return</span> a + b &gt; c <span class=\"hljs-keyword\">and</span> b + c &gt; a <span class=\"hljs-keyword\">and</span> a + c &gt; b<br><br><span class=\"hljs-keyword\">if</span> Triangle.is_valid(a, b, c):<br></code></pre></td></tr></table></figure>\n<h2 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> time <span class=\"hljs-keyword\">import</span> time, localtime, sleep<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clock</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;数字时钟&quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, hour=<span class=\"hljs-number\">0</span>, minute=<span class=\"hljs-number\">0</span>, second=<span class=\"hljs-number\">0</span></span>):<br>        self._hour = hour<br>        self._minute = minute<br>        self._second = second<br><span class=\"hljs-meta\">    @classmethod</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">now</span>(<span class=\"hljs-params\">cls</span>):<br>        ctime = localtime(time())<br>        <span class=\"hljs-keyword\">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)<br>clock = Clock.now()<br></code></pre></td></tr></table></figure>\n<h2 id=\"虚类\"><a href=\"#虚类\" class=\"headerlink\" title=\"虚类\"></a>虚类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> abc <span class=\"hljs-keyword\">import</span> ABCMeta, abstractmethod<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pet</span>(<span class=\"hljs-built_in\">object</span>, metaclass=ABCMeta):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;宠物&quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, nickname</span>):<br>        self._nickname = nickname<br><span class=\"hljs-meta\">    @abstractmethod</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">make_voice</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;发出声音&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"sys\"><a href=\"#sys\" class=\"headerlink\" title=\"sys\"></a>sys</h1><ul>\n<li>sys.getsizeof(var1): 打印变量的空间</li>\n</ul>\n<h1 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h1><h1 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h1><ul>\n<li><code>__doc__</code>：xx.<strong>doc</strong>,会打印xx函数或方法的说明</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>python不支持重载，但是支持默认参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a=<span class=\"hljs-number\">0</span>, b=<span class=\"hljs-number\">0</span>, c=<span class=\"hljs-number\">0</span></span>):<br>    <span class=\"hljs-keyword\">return</span> a+b+c<br>add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)<br>add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>)<br>add(c=<span class=\"hljs-number\">50</span>,a=<span class=\"hljs-number\">2</span>, b= <span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">*args</span>):<br>    total = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> val <span class=\"hljs-keyword\">in</span> args:<br>        total+=val<br>    <span class=\"hljs-keyword\">return</span> total<br></code></pre></td></tr></table></figure>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><ul>\n<li>python中每个文件就代表一个模块,模块名即为文件名</li>\n<li><code>__name__</code>是python中一个隐含的变量，它代表了模块的名字，只有被Python解释器直接执行的模块的名字才是<code>__main__</code></li>\n</ul>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">foo</span>():<br>    b = <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>    <span class=\"hljs-comment\"># Python中可以在函数内部再定义函数</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bar</span>():<br>        c = <span class=\"hljs-literal\">True</span><br>        <span class=\"hljs-built_in\">print</span>(a)//全局变量<br>        <span class=\"hljs-built_in\">print</span>(b)//嵌套变量<br>        <span class=\"hljs-built_in\">print</span>(c)//局部变量<br>    bar()<br>    <span class=\"hljs-comment\"># print(c)  # NameError: name &#x27;c&#x27; is not defined</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    a = <span class=\"hljs-number\">100</span> <span class=\"hljs-comment\"># 不属于任何函数，即为全局变量</span><br>    <span class=\"hljs-comment\"># print(b)  # NameError: name &#x27;b&#x27; is not defined</span><br>    foo()<br></code></pre></td></tr></table></figure>\n<ul>\n<li>除上述的全局作用域、嵌套作用域、局部作用域外，还存在内置作用域，如input,print,int等</li>\n<li>查一个变量会按局部作用域、嵌套作用域、全局作用域、内置作用域来找</li>\n</ul>\n<h2 id=\"global和nonlocal\"><a href=\"#global和nonlocal\" class=\"headerlink\" title=\"global和nonlocal\"></a>global和nonlocal</h2><ul>\n<li>global一般用在函数中指示该变量来自全局，如果全局中没有,那么就会定义一个，并置于全局中</li>\n<li>nonlocal则指示变量处于嵌套作用域中</li>\n</ul>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><ul>\n<li>闭包可以使一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以用它的值</li>\n</ul>\n<h1 id=\"pip\"><a href=\"#pip\" class=\"headerlink\" title=\"pip\"></a>pip</h1><h2 id=\"matplotlib依赖路径\"><a href=\"#matplotlib依赖路径\" class=\"headerlink\" title=\"matplotlib依赖路径\"></a>matplotlib依赖路径</h2><ul>\n<li>numpy-&gt;contourpy-&gt;cycler-&gt;fonttools-&gt;kiwisolver-&gt;packaging-&gt;pillow-&gt;pyparsing-&gt;six-&gt;python_dateutil-&gt;matplotlib</li>\n</ul>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><ul>\n<li>支持<code>*</code>号，重复字符串</li>\n<li>三个单引号或双引号，可以支持折行</li>\n<li><code>s1 = r&#39;\\n\\hello&#39;&#39;</code>,不会转义</li>\n</ul>\n<h2 id=\"相关函数\"><a href=\"#相关函数\" class=\"headerlink\" title=\"相关函数\"></a>相关函数</h2><table>\n<thead>\n<tr>\n<th align=\"center\">用法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">len(str1)</td>\n<td align=\"center\">计算字符串长度</td>\n</tr>\n<tr>\n<td align=\"center\">str1.capitalize()</td>\n<td align=\"center\">获得字符串首字母大写的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.title()</td>\n<td align=\"center\">获得每个单词首字母大写的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.upper()</td>\n<td align=\"center\">获得字符串变大写的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.find(‘a’)</td>\n<td align=\"center\">查找子串的位置，如果没有返回-1</td>\n</tr>\n<tr>\n<td align=\"center\">str1.index(‘a’)</td>\n<td align=\"center\">查找子串的位置，如果没有抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">str1.startswith(‘he’)</td>\n<td align=\"center\">是否以指定的字符串开头</td>\n</tr>\n<tr>\n<td align=\"center\">str1.endswith(‘he’)</td>\n<td align=\"center\">是否以指定的字符串结尾</td>\n</tr>\n<tr>\n<td align=\"center\">str1.center(50, ‘*‘)</td>\n<td align=\"center\">以指定宽度居中并在两侧填充指定字符</td>\n</tr>\n<tr>\n<td align=\"center\">str1.rjust(50, ‘*‘)</td>\n<td align=\"center\">以指定宽度靠右放置</td>\n</tr>\n<tr>\n<td align=\"center\">str1.ljust(50, ‘*‘)</td>\n<td align=\"center\">以指定宽度靠左放置</td>\n</tr>\n<tr>\n<td align=\"center\">str1.isdigit()</td>\n<td align=\"center\">检查字符串是否只由数字组成</td>\n</tr>\n<tr>\n<td align=\"center\">str1.isalpha()</td>\n<td align=\"center\">检查字符串是否只由字母组成</td>\n</tr>\n<tr>\n<td align=\"center\">str1.isalnum()</td>\n<td align=\"center\">检查字符串是否由字母和数字组成</td>\n</tr>\n<tr>\n<td align=\"center\">str1.strip()</td>\n<td align=\"center\">去除左右两侧空格的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.lstrip()</td>\n<td align=\"center\">去除左两侧空格的拷贝</td>\n</tr>\n<tr>\n<td align=\"center\">str1.rstrip()</td>\n<td align=\"center\">去除右两侧空格的拷贝</td>\n</tr>\n</tbody></table>\n<h1 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a, b = <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%d * %d = %d&#x27;</span> % (a, b, a * b))<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a, b = <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&#x27;</span>.<span class=\"hljs-built_in\">format</span>(a, b, a * b))<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a, b = <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&#x27;<span class=\"hljs-subst\">&#123;a&#125;</span> * <span class=\"hljs-subst\">&#123;b&#125;</span> = <span class=\"hljs-subst\">&#123;a * b&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h1><ul>\n<li>定义：<code>t = []</code></li>\n<li>转换元组：<code>tuple1 = tuple(list1)</code></li>\n</ul>\n<h2 id=\"同时遍历元素和下标\"><a href=\"#同时遍历元素和下标\" class=\"headerlink\" title=\"同时遍历元素和下标\"></a>同时遍历元素和下标</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> index, elem <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(list1):<br>    <span class=\"hljs-built_in\">print</span>(index, elem)<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数相关\"><a href=\"#函数相关\" class=\"headerlink\" title=\"函数相关\"></a>函数相关</h2><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">list1.append(ele)</td>\n<td align=\"center\">在末尾增加一个元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.insert(1, 400)</td>\n<td align=\"center\">在下标为1的元素前加个元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.extend(list2)</td>\n<td align=\"center\">合并两个列表，等价于list1+&#x3D;list2</td>\n</tr>\n<tr>\n<td align=\"center\">list1.remove(value)</td>\n<td align=\"center\">去除列表中第一个为value的元素,如果列表中没该元素则抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">list1.pop(index1)</td>\n<td align=\"center\">去除下标为index1的元素，默认为末尾元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.clear()</td>\n<td align=\"center\">清空列表</td>\n</tr>\n<tr>\n<td align=\"center\">list1.reverse()</td>\n<td align=\"center\">倒转元素</td>\n</tr>\n<tr>\n<td align=\"center\">list1.sort(reverse&#x3D;True)</td>\n<td align=\"center\">列表本身排序</td>\n</tr>\n<tr>\n<td align=\"center\">sorted(list1, reverse&#x3D;True)</td>\n<td align=\"center\">返回列表逆排序的拷贝</td>\n</tr>\n</tbody></table>\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><ul>\n<li><code>fruits[::-1]</code>: 获得倒转元素列表的拷贝</li>\n<li><code>fruits[:]</code>: 获得列表的拷贝</li>\n</ul>\n<h1 id=\"生成式和生成器\"><a href=\"#生成式和生成器\" class=\"headerlink\" title=\"生成式和生成器\"></a>生成式和生成器</h1><ul>\n<li>生成式：<code>f = [x+y for x in &#39;ABCDE&#39; for y in &#39;1234567&#39;]</code>,耗费空间更多</li>\n<li>生成器：<code>f = (x ** 2 for x in range(1,1000))</code>,不占用额外空间，但是取元素时会内部计算</li>\n</ul>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><ul>\n<li>定义：<code>t = (&#39;ss&#39;, &#39;gg&#39;)</code></li>\n<li>转换列表：<code>list1 = list(tuple1)</code></li>\n<li>相比列表的优势:tuple不可变，时空上都优于列表</li>\n</ul>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><ul>\n<li>定义：<code>set1 = set()</code>,<code>set2 = set((1,2,3,4,3,2))</code>,<code>set3=set(range(1,10))</code></li>\n<li>set里的元素是排好序的</li>\n</ul>\n<h2 id=\"相关函数-1\"><a href=\"#相关函数-1\" class=\"headerlink\" title=\"相关函数\"></a>相关函数</h2><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">set1.add(value)</td>\n<td align=\"center\">增加一个元素</td>\n</tr>\n<tr>\n<td align=\"center\">set2.update([11,12])</td>\n<td align=\"center\">增加一个列表的元素</td>\n</tr>\n<tr>\n<td align=\"center\">set2.remove(12)</td>\n<td align=\"center\">去除值12元素，没有会抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">set2.discard(12)</td>\n<td align=\"center\">同remove但不会抛出异常</td>\n</tr>\n<tr>\n<td align=\"center\">set1.pop()</td>\n<td align=\"center\">删除末尾元素</td>\n</tr>\n<tr>\n<td align=\"center\">set1.issuperset(set2)</td>\n<td align=\"center\">set2是否包含set1</td>\n</tr>\n<tr>\n<td align=\"center\">set1.issubset(set2)</td>\n<td align=\"center\">set1是否包含set2</td>\n</tr>\n</tbody></table>\n<p><img src=\"/images/python_set.png\"></p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li><code>scores = &#123;&#39;骆昊&#39;: 95, &#39;白元芳&#39;: 78, &#39;狄仁杰&#39;: 82&#125;</code></li>\n<li><code>items1 = dict(one=1, two=2, three=3, four=4)</code></li>\n<li><code>items2 = dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;123&#39;))</code></li>\n<li><code>items3 = &#123;num: num ** 2 for num in range(1, 10)&#125;</code></li>\n</ul>\n<h2 id=\"函数相关-1\"><a href=\"#函数相关-1\" class=\"headerlink\" title=\"函数相关\"></a>函数相关</h2><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">scores.update(冷面&#x3D;67, 方启鹤&#x3D;85)</td>\n<td align=\"center\">增加两组元素</td>\n</tr>\n<tr>\n<td align=\"center\">scores.get(‘xx’,60)</td>\n<td align=\"center\">get方法也是通过键获取对应的值,如果不存在返回60</td>\n</tr>\n<tr>\n<td align=\"center\">scores.popitem()</td>\n<td align=\"center\">去除末尾元素</td>\n</tr>\n<tr>\n<td align=\"center\">scores.pop(‘xx’, 10)</td>\n<td align=\"center\">去除键为xx的元素,如果没有返回10</td>\n</tr>\n<tr>\n<td align=\"center\">scores.clear()</td>\n<td align=\"center\">清空</td>\n</tr>\n</tbody></table>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-comment\"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span><br>    <span class=\"hljs-comment\"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">study</span>(<span class=\"hljs-params\">self, course_name</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在学习%s.&#x27;</span> % (self.name, course_name))<br>    <span class=\"hljs-comment\"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span><br>    <span class=\"hljs-comment\"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">watch_movie</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> self.age &lt; <span class=\"hljs-number\">18</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s只能观看《熊出没》.&#x27;</span> % self.name)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在观看岛国爱情大电影.&#x27;</span> % self.name)<br></code></pre></td></tr></table></figure>\n<h2 id=\"访问可见性\"><a href=\"#访问可见性\" class=\"headerlink\" title=\"访问可见性\"></a>访问可见性</h2><ul>\n<li>在属性或方法前加两个下划线<code>__</code>，则是私有的，可以加<code>_Test</code>前缀强制访问，例如<code>a.__bar()</code>不可以访问，<code>a._Test__bar()</code>即可访问</li>\n<li>可以通过装饰器property设置setter和getter<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>):<br>        self._name = name<br>        self._age = age<br>    <span class=\"hljs-comment\"># 访问器 - getter方法</span><br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">name</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._name<br>    <span class=\"hljs-comment\"># 访问器 - getter方法</span><br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._age<br>    <span class=\"hljs-comment\"># 修改器 - setter方法</span><br><span class=\"hljs-meta\">    @age.setter</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self, age</span>):<br>        self._age = age<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">play</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> self._age &lt;= <span class=\"hljs-number\">16</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    person = Person(<span class=\"hljs-string\">&#x27;王大锤&#x27;</span>, <span class=\"hljs-number\">12</span>)<br>    person.play()<br>    person.age = <span class=\"hljs-number\">22</span><br>    person.play()<br>    <span class=\"hljs-comment\"># person.name = &#x27;白元芳&#x27;  # AttributeError: can&#x27;t set attribute</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"slots\"><a href=\"#slots\" class=\"headerlink\" title=\"slots\"></a><strong>slots</strong></h2><p>果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-comment\"># 限定Person对象只能绑定_name, _age和_gender属性</span><br>    __slots__ = (<span class=\"hljs-string\">&#x27;_name&#x27;</span>, <span class=\"hljs-string\">&#x27;_age&#x27;</span>, <span class=\"hljs-string\">&#x27;_gender&#x27;</span>)<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>):<br>        self._name = name<br>        self._age = age<br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">name</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._name<br><span class=\"hljs-meta\">    @property</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> self._age<br><span class=\"hljs-meta\">    @age.setter</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">self, age</span>):<br>        self._age = age<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">play</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> self._age &lt;= <span class=\"hljs-number\">16</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    person = Person(<span class=\"hljs-string\">&#x27;王大锤&#x27;</span>, <span class=\"hljs-number\">22</span>)<br>    person.play()<br>    person._gender = <span class=\"hljs-string\">&#x27;男&#x27;</span><br>    <span class=\"hljs-comment\"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;_is_gay&#x27;</span><br>    <span class=\"hljs-comment\"># person._is_gay = True</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Triangle</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, a, b, c</span>):<br>        self._a = a<br>        self._b = b<br>        self._c = c<br><span class=\"hljs-meta\">    @staticmethod</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">is_valid</span>(<span class=\"hljs-params\">a, b, c</span>):<br>        <span class=\"hljs-keyword\">return</span> a + b &gt; c <span class=\"hljs-keyword\">and</span> b + c &gt; a <span class=\"hljs-keyword\">and</span> a + c &gt; b<br><br><span class=\"hljs-keyword\">if</span> Triangle.is_valid(a, b, c):<br></code></pre></td></tr></table></figure>\n<h2 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> time <span class=\"hljs-keyword\">import</span> time, localtime, sleep<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clock</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;数字时钟&quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, hour=<span class=\"hljs-number\">0</span>, minute=<span class=\"hljs-number\">0</span>, second=<span class=\"hljs-number\">0</span></span>):<br>        self._hour = hour<br>        self._minute = minute<br>        self._second = second<br><span class=\"hljs-meta\">    @classmethod</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">now</span>(<span class=\"hljs-params\">cls</span>):<br>        ctime = localtime(time())<br>        <span class=\"hljs-keyword\">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)<br>clock = Clock.now()<br></code></pre></td></tr></table></figure>\n<h2 id=\"虚类\"><a href=\"#虚类\" class=\"headerlink\" title=\"虚类\"></a>虚类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> abc <span class=\"hljs-keyword\">import</span> ABCMeta, abstractmethod<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pet</span>(<span class=\"hljs-built_in\">object</span>, metaclass=ABCMeta):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;宠物&quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, nickname</span>):<br>        self._nickname = nickname<br><span class=\"hljs-meta\">    @abstractmethod</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">make_voice</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;发出声音&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"sys\"><a href=\"#sys\" class=\"headerlink\" title=\"sys\"></a>sys</h1><ul>\n<li>sys.getsizeof(var1): 打印变量的空间</li>\n</ul>\n<h1 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h1><h1 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h1><ul>\n<li><code>__doc__</code>：xx.<strong>doc</strong>,会打印xx函数或方法的说明</li>\n</ul>\n"},{"title":"C++_Template","date":"2024-03-23T19:59:20.000Z","index_img":"/images/template.jpg","banner_img":"/images/template.jpg","_content":"\n# Class Template-Deduction Guide\n## iterator\n```C++\n# include <type_traits> // std::remove_reference_t\n# include <vector> // std::vector\ntemplate<typename T>\nstruct Container {\ntemplate<typename Iter>\nContainer(Iter beg, Iter end) {}\n};\ntemplate<typename Iter>\nContainer(Iter b, Iter e) -> // deduction guide\nContainer<typename std::iterator_traits<Iter>::value_type>;\nstd::vector v{1, 2, 3};\nContainer c{v.begin(), v.end()}; // construct 'Container<int>'\n```\n## string\n```C++\ntemplate<typename T>\nstruct MyString {\nMyString(T) {}\n};\n// constructor class instantiation\nMyString(char const*) -> MyString<std::string>; // deduction guide\nMyString s{\"abc\"}; // construct 'MyString<std::string>'\n```\n# 类与成员函数\n有两种方式：\n- Generic class + generic function\n- Full class specialization + generic/full specialization function\n```C++\ntemplate<typename T, typename R>\nstruct A {\n    template<typename X, typename Y>\n    void f();\n};\ntemplate<typename T, typename R>\ntemplate<typename X, typename Y>\nvoid A<T, R>::f() {}\n// ok, A<T, R> and f<X, Y> are not specialized\ntemplate<>\ntemplate<typename X, typename Y>\nvoid A<int, int>::f() {}\n// ok, A<int, int> is full specialized\n// ok, f<X, Y> is not specialized\ntemplate<>\ntemplate<>\nvoid A<int, int>::f<int, int>() {}\n// ok, A<int, int> and f<int, int> are full specialized\ntemplate<typename T>\ntemplate<typename X, typename Y>\nvoid A<T, int>::f() {}\n// error A<T, int> is partially specialized\n// (A<T, int> class must be defined before)\ntemplate<typename T, typename R>\ntemplate<typename X>\nvoid A<T, R>::f<int, X>() {}\n// error function members cannot be partially specialized\ntemplate<typename T, typename R>\ntemplate<>\nvoid A<T, R>::f<int, int>() {}\n// error function members of a non-specialized class cannot be specialized\n// (requires a binding to a specific template instantiation at compile-time)\n```\n# enable_if\n## 原理\n```C++\ntemplate<bool Condition, typename T = void>\nstruct enable_if {\n// \"type\" is not defined if \"Condition == false\"\n};\ntemplate<typename T>\nstruct enable_if<true, T> {\n    using type = T;\n};\n```\n## array/pointer\n```C++\n# include <type_traits>\ntemplate<typename T, int Size>\nvoid f(T (&array)[Size]) {} // (1)\n//template<typename T, int Size>\n//void f(T* array) {} // (2)\ntemplate<typename T>\nstd::enable_if_t<std::is_pointer_v<T>>\nf(T ptr) {} // (3)\nint array[3];\nf(array); // It is not possible to call (1) if (2) is present\n// The reason is that 'array' decays to a pointer\n// Now with (3), the code calls (1)\n```\n## 检查类是否含有某个成员\n```C++\nstruct A {\nstatic int x;\nint y;\nusing type = int;\n};\nstruct B {};\n\n# include <type_traits>\ntemplate<typename T, typename = void>\nstruct has_x : std::false_type {};\ntemplate<typename T>\nstruct has_x<T, decltype((void) T::x)> : std::true_type {};\ntemplate<typename T, typename = void>\nstruct has_y : std::false_type {};\ntemplate<typename T>\nstruct has_y<T, decltype((void) std::declval<T>().y)> : std::true_type {};\nhas_x< A >::value; // returns true\nhas_x< B >::value; // returns false\nhas_y< A >::value; // returns true\nhas_y< B >::value; // returns false\n```\n## 判断是否定义某个类型\n```C++\ntemplate<typename...>\nusing void_t = void; // included in C++17 <utility>\ntemplate<typename T, typename = void>\nstruct has_type : std::false_type {};\ntemplate<typename T>\nstruct has_type<T,\nstd::void_t<typename T::type> > : std::true_type {};\nhas_type< A >::value; // returns true\nhas_type< B >::value; // returns false\n```\n## 判断是否支持流操作\n```C++\ntemplate<typename T>\nusing EnableP = decltype( std::declval<std::ostream&>() <<\nstd::declval<T>() );\ntemplate<typename T, typename = void>\nstruct is_stream_supported : std::false_type {};\ntemplate<typename T>\nstruct is_stream_supported<T, EnableP<T>> : std::true_type {};\nstruct A {};\nis_stream_supported<int>::value; // returns true\nis_stream_supported<A>::value; // returns false\n```\n# 模板参数类型\n- integral type\n- enum, enum class\n- floating-point type(c++20)\n- auto placeholder(c++ 17)\n- class literals and concepts(c++20)\n- typename一般类型\n- function\n- reference/pointer to global static function or object\n- pointer to member type\n- nullptr(c++14)\n## array/pointer\n```c++\ntemplate<int* ptr> // pointer\nvoid g() {\ncout << ptr[0];\n}\ntemplate<int (&array)[3]> // reference\nvoid f() {\ncout << array[0];\n}\nint array[] = {2, 3, 4}; // global\nint main() {\nf<array>(); // print 2\ng<array>(); // print 2\n}\n```\n## class member\n```c++\nstruct A {\nint x = 5;\nint y[3] = {4, 2, 3};\n};\ntemplate<int A::*x> // pointer to\nvoid h1() {} // member type\ntemplate<int (A::*y)[3]> // pointer to\nvoid h2() {} // member type\nint main() {\nh1<&A::x>();\nh2<&A::y>();\n}\n```\n## function type\n```c++\ntemplate<int (*F)(int, int)> // <-- signature of \"f\"\nint apply1(int a, int b) {\nreturn F(a, b);\n}\nint f(int a, int b) { return a + b; }\nint g(int a, int b) { return a * b; }\ntemplate<decltype(f) F> // alternative syntax\nint apply2(int a, int b) {\nreturn F(a, b);\n}\nint main() {\napply1<f>(2, 3); // return 5\napply2<g>(2, 3); // return 6\n}\n```\n# type_traits\n- `#include<type_traits>`\n- std::is_integral<T>::value 等价于 std::is_integral_v<T>\n\n|函数|说明|\n|:-:|:-:|\n|is_integral|checks for an integral type(bool,char,unsigned char,short,int,long,etc)|\n|is_floating_point|checks for a floating-point type(float,double)|\n|is_arithmetic|checks for a integral or floating-point type|\n|is_signed|checks for a signed type|\n|is_unsigned|checks for an unsigned type|\n|is_enum|checks for an enumerator type(enum,enum class)|\n|is_void|checks for(void)|\n|is_pointer|checks for a pointer(`T*`)|\n|is_null_pointer||\n|is_reference|checks for a reference(T&)|\n|is_array|checks for an array(`T (&)[N]`)|\n|is_function||\n|is_class|checks for a class type(struct class)|\n|is_abstract|checks for a class with at least one pure virtual function|\n|is_polymorphic|checks for a class with at least one virtual function|\n|is_const||\n|is_same<T,R>|checks if T and R are the same type|\n|is_base_of<T,R>|checks if T is base of R|\n|is_convertible<T,R>|checks if T can be converted to R|\n\n- using U = typename std::make_unsigned<int>::type 等价于 std::make_unsigned_t<T>;\n\n|函数|说明|\n|:-:|:-:|\n|make_signed|make a signed type|\n|make_unsigned|makes an unsigned type|\n|remove_pointer|remove pointer(`T*->T`)|\n|add_pointer|add pointer(`T->T*`)|\n|remove_reference|remove reference(`T*->T`)|\n|add_lvalue_reference|add reference(T->T&)|\n|remove_const|remove const|\n|add_const|add const|\n|common_type<T,R>|(see the example)|\n|conditional<pred,T,R>|returns T if pred is true,R otherwise|\n|decay<T>|returns the same type as a function parameter passed by-value|\n\n```C++\n# include <type_traits>\ntemplate<typename T, typename R>\nstd::common_type_t<R, T> // <-- return type\nadd(T a, R b) {\nreturn a + b;\n}\n// we can also use decltype to derive the result type\nusing result_t = decltype(add(3, 4.0f));\nresult_t x = add(3, 4.0f);\n```\n\n- 如果 T 是一个引用类型（如 int&），std::decay<T>::type 就是 int。\n- 如果 T 是一个数组类型（如 int[5]），std::decay<T>::type 就是 int*。\n- 如果 T 是一个函数类型，std::decay<T>::type 就是相应的函数指针类型。\n- 如果 T 是一个 cv-qualified 类型（如 const int 或 volatile int），std::decay<T>::type 就是没有这些限定符的 int。\n\n# Variadic Template\n- 可以用`sizeof...(args)`得出个数\n```C++\n// BASE CASE\ntemplate<typename T, typename R>\nauto add(T a, R b) {\nreturn a + b;\n}\n// RECURSIVE CASE\ntemplate<typename T, typename... TArgs> // Variadic typename\nauto add(T a, TArgs... args) { // Typename expansion\nreturn a + add(args...); // Arguments expansion\n}\nadd(2, 3.0); // 5\nadd(2, 3.0, 4); // 9\nadd(2, 3.0, 4, 5); // 14\n// add(2); // compile error the base case accepts only two arguments\n```\n## 存到数组\n```C++\ntemplate<typename... TArgs>\nvoid f(TArgs... args) {\nconstexpr int Size = sizeof...(args);\nint array[] = {args...};\nfor (auto x : array)\ncout << x << \" \";\n}\nf(1, 2, 3); // print \"1 2 3\"\nf(1, 2, 3, 4); // print \"1 2 3 4\"\n```\n## Folding Expression\n- Example1\n```C++\ntemplate<typename... Args>\nauto add_unary(Args... args) { // Unary folding\nreturn (... + args); // unfold: 1 + 2.0f + 3ull\n}\ntemplate<typename... Args>\nauto add_binary(Args... args) { // Binary folding\nreturn (1 + ... + args); // unfold: 1 + 1 + 2.0f + 3ull\n}\nadd_unary(1, 2.0f, 3ll); // returns 6.0f (float)\nadd_binary(1, 2.0f, 3ll); // returns 7.0f (float) \n```\n- Example2\n```C++\ntemplate<typename T>\nT square(T value) { return value * value; }\ntemplate<typename... TArgs>\nauto add_square(TArgs... args) {\nreturn (square(args) + ...); // square() is applied to each\n} // variadic argument\nadd_square(2, 2, 3.0f); // returns 17.0f\n```\n## 获取函数的形参个数\n```C++\ntemplate <typename T>\nstruct GetArity;\n// generic function pointer\ntemplate<typename R, typename... Args>\nstruct GetArity<R(*)(Args...)> {\nstatic constexpr int value = sizeof...(Args);\n};\n// generic function reference\ntemplate<typename R, typename... Args>\nstruct GetArity<R(&)(Args...)> {\nstatic constexpr int value = sizeof...(Args);\n};\n// generic function object\ntemplate<typename R, typename... Args>\nstruct GetArity<R(Args...)> {\nstatic constexpr int value = sizeof...(Args);\n}; \nvoid f(int, char, double) {}\nint main() {\n// function object\nGetArity<decltype(f)>::value;\nauto& g = f;\n// function reference\nGetArity<decltype(g)>::value;\n// function reference\nGetArity<decltype((f))>::value;\nauto* h = f;\n// function pointer\nGetArity<decltype(h)>::value;\n}\n```\n## 获得lamda或operator()的参数个数\n```C++\ntemplate <typename T>\nstruct GetArity;\ntemplate<typename R, typename C, typename... Args>\nstruct GetArity<R(C::*)(Args...)> { // class member\nstatic constexpr int value = sizeof...(Args);\n};\ntemplate<typename R, typename C, typename... Args>\nstruct GetArity<R(C::*)(Args...) const> { // \"const\" class member\nstatic constexpr int value = sizeof...(Args);\n};\nstruct A {\nvoid operator()(char, char) {}\nvoid operator()(char, char) const {}\n};\nGetArity<A>::value; // call GetArity<R(C::*)(Args...)>\nGetArity<const A>::value; // call GetArity<R(C::*)(Args...) const>\n```\n# Concepts和requires(c++20)\n## concepts语法\n```C++\n[template arguments]\nconcept [name] = [compile-time boolean expression];\n```\n## concepts例子\n```C++\ntemplate<typename T>\nconcept Arithmetic = std::is_arithmetic_v<T>;\ntemplate<Arithmetic T>\nT add(T valueA, T valueB) {\nreturn valueA + valueB;\n}\n```\n## requires clause语法\n```C++\nrequires [compile-time boolean expression or Concept]\n```\n### concept example\n```C++\ntemplate<typename T>\nrequires Arithmetic<T>\nT add(T valueA, T valueB) {\nreturn valueA + valueB;\n}\n```\n### bool expression example\n```C++\ntemplate<typename T>\nT add(T valueA, T valueB) requires (sizeof(T) == 4) {\nreturn valueA + valueB;\n}\n```\n## requires expression语法\nA requires expression is a compile-time expression of type bool that defines the\nconstraints on template arguments\n```C++\nrequires [(arguments)] {\n[SFINAE contrain]; // or\nrequires [predicate];\n} -> bool\n```\n### example\n```C++\ntemplate<typename T>\nconcept MyConcept = requires (T a, T b) { // First case: SFINAE constrains\na + b; // Req. 1 - support add operator\na[0]; // Req. 2 - support subscript operator\na.x; // Req. 3 - has \"x\" data member\na.f(); // Req. 4 - has \"f\" function member\ntypename T::type; // Req. 5 - has \"type\" field\n};\n# include <concept>\ntemplate<typename T>\nconcept MyConcept2 = requires (T a, T b) {\n{*a + 1} -> std::convertible_to<float>; // Req. 6 - can be deferred and the sum\n// with an integer is convertible\n// to float\n{a * a} -> std::same_as<int>; // Req. 7 - \"a * a\" must be valid and\n// the result type is \"int\"\n};\n```\n## requires Clause + Expression\n```C++\ntemplate<typename T>\nvoid f(T a) requires requires { T::value; }\n// clause -> SFINAE followed by\n// expression -> bool (zero args)\n{}\n\ntemplate<typename T>\nT increment(T a) requires requires (T x) { x + 1; }\n// clause -> SFINAE followed by\n// expression -> bool (one arg)\n{\nreturn a + 1;\n}\n```\n\n# Examples\n## 利用特例化判断类型是否一致\n```C++\ntemplate<typename T, typename R> // GENERIC template declaration\nstruct is_same {\nstatic constexpr bool value = false;\n};\ntemplate<typename T>\nstruct is_same<T, T> { // PARTIAL template specialization\nstatic constexpr bool value = true;\n};\ncout << is_same< int, char>::value; // print false, generic template\ncout << is_same<float, float>::value; // print true, partial template\n```\n## 利用特例化判断const指针\n```C++\n# include <type_traits>\n// std::true type and std::false type contain a field \"value\"\n// set to true or false respectively\ntemplate<typename T>\nstruct is_const_pointer : std::false_type {}; // GENERIC template declaration\ntemplate<typename R> // PARTIAL specialization\nstruct is_const_pointer<const R*> : std::true_type {};\ncout << is_const_pointer<int*>::value; // print false, generic template\ncout << is_const_pointer<const int*>::value; // print true, partial template\ncout << is_const_pointer<int* const>::value; // print false, generic template\n```\n","source":"_posts/C-Template.md","raw":"---\ntitle: C++_Template\ndate: 2024-03-24 03:59:20\ntags:\nindex_img: /images/template.jpg\nbanner_img: /images/template.jpg\n---\n\n# Class Template-Deduction Guide\n## iterator\n```C++\n# include <type_traits> // std::remove_reference_t\n# include <vector> // std::vector\ntemplate<typename T>\nstruct Container {\ntemplate<typename Iter>\nContainer(Iter beg, Iter end) {}\n};\ntemplate<typename Iter>\nContainer(Iter b, Iter e) -> // deduction guide\nContainer<typename std::iterator_traits<Iter>::value_type>;\nstd::vector v{1, 2, 3};\nContainer c{v.begin(), v.end()}; // construct 'Container<int>'\n```\n## string\n```C++\ntemplate<typename T>\nstruct MyString {\nMyString(T) {}\n};\n// constructor class instantiation\nMyString(char const*) -> MyString<std::string>; // deduction guide\nMyString s{\"abc\"}; // construct 'MyString<std::string>'\n```\n# 类与成员函数\n有两种方式：\n- Generic class + generic function\n- Full class specialization + generic/full specialization function\n```C++\ntemplate<typename T, typename R>\nstruct A {\n    template<typename X, typename Y>\n    void f();\n};\ntemplate<typename T, typename R>\ntemplate<typename X, typename Y>\nvoid A<T, R>::f() {}\n// ok, A<T, R> and f<X, Y> are not specialized\ntemplate<>\ntemplate<typename X, typename Y>\nvoid A<int, int>::f() {}\n// ok, A<int, int> is full specialized\n// ok, f<X, Y> is not specialized\ntemplate<>\ntemplate<>\nvoid A<int, int>::f<int, int>() {}\n// ok, A<int, int> and f<int, int> are full specialized\ntemplate<typename T>\ntemplate<typename X, typename Y>\nvoid A<T, int>::f() {}\n// error A<T, int> is partially specialized\n// (A<T, int> class must be defined before)\ntemplate<typename T, typename R>\ntemplate<typename X>\nvoid A<T, R>::f<int, X>() {}\n// error function members cannot be partially specialized\ntemplate<typename T, typename R>\ntemplate<>\nvoid A<T, R>::f<int, int>() {}\n// error function members of a non-specialized class cannot be specialized\n// (requires a binding to a specific template instantiation at compile-time)\n```\n# enable_if\n## 原理\n```C++\ntemplate<bool Condition, typename T = void>\nstruct enable_if {\n// \"type\" is not defined if \"Condition == false\"\n};\ntemplate<typename T>\nstruct enable_if<true, T> {\n    using type = T;\n};\n```\n## array/pointer\n```C++\n# include <type_traits>\ntemplate<typename T, int Size>\nvoid f(T (&array)[Size]) {} // (1)\n//template<typename T, int Size>\n//void f(T* array) {} // (2)\ntemplate<typename T>\nstd::enable_if_t<std::is_pointer_v<T>>\nf(T ptr) {} // (3)\nint array[3];\nf(array); // It is not possible to call (1) if (2) is present\n// The reason is that 'array' decays to a pointer\n// Now with (3), the code calls (1)\n```\n## 检查类是否含有某个成员\n```C++\nstruct A {\nstatic int x;\nint y;\nusing type = int;\n};\nstruct B {};\n\n# include <type_traits>\ntemplate<typename T, typename = void>\nstruct has_x : std::false_type {};\ntemplate<typename T>\nstruct has_x<T, decltype((void) T::x)> : std::true_type {};\ntemplate<typename T, typename = void>\nstruct has_y : std::false_type {};\ntemplate<typename T>\nstruct has_y<T, decltype((void) std::declval<T>().y)> : std::true_type {};\nhas_x< A >::value; // returns true\nhas_x< B >::value; // returns false\nhas_y< A >::value; // returns true\nhas_y< B >::value; // returns false\n```\n## 判断是否定义某个类型\n```C++\ntemplate<typename...>\nusing void_t = void; // included in C++17 <utility>\ntemplate<typename T, typename = void>\nstruct has_type : std::false_type {};\ntemplate<typename T>\nstruct has_type<T,\nstd::void_t<typename T::type> > : std::true_type {};\nhas_type< A >::value; // returns true\nhas_type< B >::value; // returns false\n```\n## 判断是否支持流操作\n```C++\ntemplate<typename T>\nusing EnableP = decltype( std::declval<std::ostream&>() <<\nstd::declval<T>() );\ntemplate<typename T, typename = void>\nstruct is_stream_supported : std::false_type {};\ntemplate<typename T>\nstruct is_stream_supported<T, EnableP<T>> : std::true_type {};\nstruct A {};\nis_stream_supported<int>::value; // returns true\nis_stream_supported<A>::value; // returns false\n```\n# 模板参数类型\n- integral type\n- enum, enum class\n- floating-point type(c++20)\n- auto placeholder(c++ 17)\n- class literals and concepts(c++20)\n- typename一般类型\n- function\n- reference/pointer to global static function or object\n- pointer to member type\n- nullptr(c++14)\n## array/pointer\n```c++\ntemplate<int* ptr> // pointer\nvoid g() {\ncout << ptr[0];\n}\ntemplate<int (&array)[3]> // reference\nvoid f() {\ncout << array[0];\n}\nint array[] = {2, 3, 4}; // global\nint main() {\nf<array>(); // print 2\ng<array>(); // print 2\n}\n```\n## class member\n```c++\nstruct A {\nint x = 5;\nint y[3] = {4, 2, 3};\n};\ntemplate<int A::*x> // pointer to\nvoid h1() {} // member type\ntemplate<int (A::*y)[3]> // pointer to\nvoid h2() {} // member type\nint main() {\nh1<&A::x>();\nh2<&A::y>();\n}\n```\n## function type\n```c++\ntemplate<int (*F)(int, int)> // <-- signature of \"f\"\nint apply1(int a, int b) {\nreturn F(a, b);\n}\nint f(int a, int b) { return a + b; }\nint g(int a, int b) { return a * b; }\ntemplate<decltype(f) F> // alternative syntax\nint apply2(int a, int b) {\nreturn F(a, b);\n}\nint main() {\napply1<f>(2, 3); // return 5\napply2<g>(2, 3); // return 6\n}\n```\n# type_traits\n- `#include<type_traits>`\n- std::is_integral<T>::value 等价于 std::is_integral_v<T>\n\n|函数|说明|\n|:-:|:-:|\n|is_integral|checks for an integral type(bool,char,unsigned char,short,int,long,etc)|\n|is_floating_point|checks for a floating-point type(float,double)|\n|is_arithmetic|checks for a integral or floating-point type|\n|is_signed|checks for a signed type|\n|is_unsigned|checks for an unsigned type|\n|is_enum|checks for an enumerator type(enum,enum class)|\n|is_void|checks for(void)|\n|is_pointer|checks for a pointer(`T*`)|\n|is_null_pointer||\n|is_reference|checks for a reference(T&)|\n|is_array|checks for an array(`T (&)[N]`)|\n|is_function||\n|is_class|checks for a class type(struct class)|\n|is_abstract|checks for a class with at least one pure virtual function|\n|is_polymorphic|checks for a class with at least one virtual function|\n|is_const||\n|is_same<T,R>|checks if T and R are the same type|\n|is_base_of<T,R>|checks if T is base of R|\n|is_convertible<T,R>|checks if T can be converted to R|\n\n- using U = typename std::make_unsigned<int>::type 等价于 std::make_unsigned_t<T>;\n\n|函数|说明|\n|:-:|:-:|\n|make_signed|make a signed type|\n|make_unsigned|makes an unsigned type|\n|remove_pointer|remove pointer(`T*->T`)|\n|add_pointer|add pointer(`T->T*`)|\n|remove_reference|remove reference(`T*->T`)|\n|add_lvalue_reference|add reference(T->T&)|\n|remove_const|remove const|\n|add_const|add const|\n|common_type<T,R>|(see the example)|\n|conditional<pred,T,R>|returns T if pred is true,R otherwise|\n|decay<T>|returns the same type as a function parameter passed by-value|\n\n```C++\n# include <type_traits>\ntemplate<typename T, typename R>\nstd::common_type_t<R, T> // <-- return type\nadd(T a, R b) {\nreturn a + b;\n}\n// we can also use decltype to derive the result type\nusing result_t = decltype(add(3, 4.0f));\nresult_t x = add(3, 4.0f);\n```\n\n- 如果 T 是一个引用类型（如 int&），std::decay<T>::type 就是 int。\n- 如果 T 是一个数组类型（如 int[5]），std::decay<T>::type 就是 int*。\n- 如果 T 是一个函数类型，std::decay<T>::type 就是相应的函数指针类型。\n- 如果 T 是一个 cv-qualified 类型（如 const int 或 volatile int），std::decay<T>::type 就是没有这些限定符的 int。\n\n# Variadic Template\n- 可以用`sizeof...(args)`得出个数\n```C++\n// BASE CASE\ntemplate<typename T, typename R>\nauto add(T a, R b) {\nreturn a + b;\n}\n// RECURSIVE CASE\ntemplate<typename T, typename... TArgs> // Variadic typename\nauto add(T a, TArgs... args) { // Typename expansion\nreturn a + add(args...); // Arguments expansion\n}\nadd(2, 3.0); // 5\nadd(2, 3.0, 4); // 9\nadd(2, 3.0, 4, 5); // 14\n// add(2); // compile error the base case accepts only two arguments\n```\n## 存到数组\n```C++\ntemplate<typename... TArgs>\nvoid f(TArgs... args) {\nconstexpr int Size = sizeof...(args);\nint array[] = {args...};\nfor (auto x : array)\ncout << x << \" \";\n}\nf(1, 2, 3); // print \"1 2 3\"\nf(1, 2, 3, 4); // print \"1 2 3 4\"\n```\n## Folding Expression\n- Example1\n```C++\ntemplate<typename... Args>\nauto add_unary(Args... args) { // Unary folding\nreturn (... + args); // unfold: 1 + 2.0f + 3ull\n}\ntemplate<typename... Args>\nauto add_binary(Args... args) { // Binary folding\nreturn (1 + ... + args); // unfold: 1 + 1 + 2.0f + 3ull\n}\nadd_unary(1, 2.0f, 3ll); // returns 6.0f (float)\nadd_binary(1, 2.0f, 3ll); // returns 7.0f (float) \n```\n- Example2\n```C++\ntemplate<typename T>\nT square(T value) { return value * value; }\ntemplate<typename... TArgs>\nauto add_square(TArgs... args) {\nreturn (square(args) + ...); // square() is applied to each\n} // variadic argument\nadd_square(2, 2, 3.0f); // returns 17.0f\n```\n## 获取函数的形参个数\n```C++\ntemplate <typename T>\nstruct GetArity;\n// generic function pointer\ntemplate<typename R, typename... Args>\nstruct GetArity<R(*)(Args...)> {\nstatic constexpr int value = sizeof...(Args);\n};\n// generic function reference\ntemplate<typename R, typename... Args>\nstruct GetArity<R(&)(Args...)> {\nstatic constexpr int value = sizeof...(Args);\n};\n// generic function object\ntemplate<typename R, typename... Args>\nstruct GetArity<R(Args...)> {\nstatic constexpr int value = sizeof...(Args);\n}; \nvoid f(int, char, double) {}\nint main() {\n// function object\nGetArity<decltype(f)>::value;\nauto& g = f;\n// function reference\nGetArity<decltype(g)>::value;\n// function reference\nGetArity<decltype((f))>::value;\nauto* h = f;\n// function pointer\nGetArity<decltype(h)>::value;\n}\n```\n## 获得lamda或operator()的参数个数\n```C++\ntemplate <typename T>\nstruct GetArity;\ntemplate<typename R, typename C, typename... Args>\nstruct GetArity<R(C::*)(Args...)> { // class member\nstatic constexpr int value = sizeof...(Args);\n};\ntemplate<typename R, typename C, typename... Args>\nstruct GetArity<R(C::*)(Args...) const> { // \"const\" class member\nstatic constexpr int value = sizeof...(Args);\n};\nstruct A {\nvoid operator()(char, char) {}\nvoid operator()(char, char) const {}\n};\nGetArity<A>::value; // call GetArity<R(C::*)(Args...)>\nGetArity<const A>::value; // call GetArity<R(C::*)(Args...) const>\n```\n# Concepts和requires(c++20)\n## concepts语法\n```C++\n[template arguments]\nconcept [name] = [compile-time boolean expression];\n```\n## concepts例子\n```C++\ntemplate<typename T>\nconcept Arithmetic = std::is_arithmetic_v<T>;\ntemplate<Arithmetic T>\nT add(T valueA, T valueB) {\nreturn valueA + valueB;\n}\n```\n## requires clause语法\n```C++\nrequires [compile-time boolean expression or Concept]\n```\n### concept example\n```C++\ntemplate<typename T>\nrequires Arithmetic<T>\nT add(T valueA, T valueB) {\nreturn valueA + valueB;\n}\n```\n### bool expression example\n```C++\ntemplate<typename T>\nT add(T valueA, T valueB) requires (sizeof(T) == 4) {\nreturn valueA + valueB;\n}\n```\n## requires expression语法\nA requires expression is a compile-time expression of type bool that defines the\nconstraints on template arguments\n```C++\nrequires [(arguments)] {\n[SFINAE contrain]; // or\nrequires [predicate];\n} -> bool\n```\n### example\n```C++\ntemplate<typename T>\nconcept MyConcept = requires (T a, T b) { // First case: SFINAE constrains\na + b; // Req. 1 - support add operator\na[0]; // Req. 2 - support subscript operator\na.x; // Req. 3 - has \"x\" data member\na.f(); // Req. 4 - has \"f\" function member\ntypename T::type; // Req. 5 - has \"type\" field\n};\n# include <concept>\ntemplate<typename T>\nconcept MyConcept2 = requires (T a, T b) {\n{*a + 1} -> std::convertible_to<float>; // Req. 6 - can be deferred and the sum\n// with an integer is convertible\n// to float\n{a * a} -> std::same_as<int>; // Req. 7 - \"a * a\" must be valid and\n// the result type is \"int\"\n};\n```\n## requires Clause + Expression\n```C++\ntemplate<typename T>\nvoid f(T a) requires requires { T::value; }\n// clause -> SFINAE followed by\n// expression -> bool (zero args)\n{}\n\ntemplate<typename T>\nT increment(T a) requires requires (T x) { x + 1; }\n// clause -> SFINAE followed by\n// expression -> bool (one arg)\n{\nreturn a + 1;\n}\n```\n\n# Examples\n## 利用特例化判断类型是否一致\n```C++\ntemplate<typename T, typename R> // GENERIC template declaration\nstruct is_same {\nstatic constexpr bool value = false;\n};\ntemplate<typename T>\nstruct is_same<T, T> { // PARTIAL template specialization\nstatic constexpr bool value = true;\n};\ncout << is_same< int, char>::value; // print false, generic template\ncout << is_same<float, float>::value; // print true, partial template\n```\n## 利用特例化判断const指针\n```C++\n# include <type_traits>\n// std::true type and std::false type contain a field \"value\"\n// set to true or false respectively\ntemplate<typename T>\nstruct is_const_pointer : std::false_type {}; // GENERIC template declaration\ntemplate<typename R> // PARTIAL specialization\nstruct is_const_pointer<const R*> : std::true_type {};\ncout << is_const_pointer<int*>::value; // print false, generic template\ncout << is_const_pointer<const int*>::value; // print true, partial template\ncout << is_const_pointer<int* const>::value; // print false, generic template\n```\n","slug":"C-Template","published":1,"updated":"2024-06-17T21:13:43.673Z","_id":"clue1wnfx0000qoq297lx2rn7","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Class-Template-Deduction-Guide\"><a href=\"#Class-Template-Deduction-Guide\" class=\"headerlink\" title=\"Class Template-Deduction Guide\"></a>Class Template-Deduction Guide</h1><h2 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span> <span class=\"hljs-comment\">// std::remove_reference_t</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span> <span class=\"hljs-comment\">// std::vector</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Container</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Iter&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Container</span><span class=\"hljs-params\">(Iter beg, Iter end)</span> </span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Iter&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Container</span><span class=\"hljs-params\">(Iter b, Iter e)</span> -&gt; <span class=\"hljs-comment\">// deduction guide</span></span><br><span class=\"hljs-function\">Container&lt;<span class=\"hljs-keyword\">typename</span> std::iterator_traits&lt;Iter&gt;::value_type&gt;</span>;<br>std::vector v&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;;<br>Container c&#123;v.<span class=\"hljs-built_in\">begin</span>(), v.<span class=\"hljs-built_in\">end</span>()&#125;; <span class=\"hljs-comment\">// construct &#x27;Container&lt;int&gt;&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyString</span> &#123;<br><span class=\"hljs-built_in\">MyString</span>(T) &#123;&#125;<br>&#125;;<br><span class=\"hljs-comment\">// constructor class instantiation</span><br><span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-type\">char</span> <span class=\"hljs-type\">const</span>*) -&gt; MyString&lt;std::string&gt;; <span class=\"hljs-comment\">// deduction guide</span><br>MyString s&#123;<span class=\"hljs-string\">&quot;abc&quot;</span>&#125;; <span class=\"hljs-comment\">// construct &#x27;MyString&lt;std::string&gt;&#x27;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"类与成员函数\"><a href=\"#类与成员函数\" class=\"headerlink\" title=\"类与成员函数\"></a>类与成员函数</h1><p>有两种方式：</p>\n<ul>\n<li>Generic class + generic function</li>\n<li>Full class specialization + generic&#x2F;full specialization function<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;</span><br><span class=\"hljs-function\">    <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, R&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125;<br><span class=\"hljs-comment\">// ok, A&lt;T, R&gt; and f&lt;X, Y&gt; are not specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;<br><span class=\"hljs-type\">void</span> A&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125;<br><span class=\"hljs-comment\">// ok, A&lt;int, int&gt; is full specialized</span><br><span class=\"hljs-comment\">// ok, f&lt;X, Y&gt; is not specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-type\">void</span> A&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;::<span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;() &#123;&#125;<br><span class=\"hljs-comment\">// ok, A&lt;int, int&gt; and f&lt;int, int&gt; are full specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, <span class=\"hljs-type\">int</span>&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125;<br><span class=\"hljs-comment\">// error A&lt;T, int&gt; is partially specialized</span><br><span class=\"hljs-comment\">// (A&lt;T, int&gt; class must be defined before)</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, R&gt;::<span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>, X&gt;() &#123;&#125;<br><span class=\"hljs-comment\">// error function members cannot be partially specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, R&gt;::<span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;() &#123;&#125;<br><span class=\"hljs-comment\">// error function members of a non-specialized class cannot be specialized</span><br><span class=\"hljs-comment\">// (requires a binding to a specific template instantiation at compile-time)</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"enable-if\"><a href=\"#enable-if\" class=\"headerlink\" title=\"enable_if\"></a>enable_if</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">bool</span> Condition, <span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> enable_if &#123;<br><span class=\"hljs-comment\">// &quot;type&quot; is not defined if &quot;Condition == false&quot;</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">enable_if</span>&lt;<span class=\"hljs-literal\">true</span>, T&gt; &#123;<br>    <span class=\"hljs-keyword\">using</span> type = T;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"array-pointer\"><a href=\"#array-pointer\" class=\"headerlink\" title=\"array&#x2F;pointer\"></a>array&#x2F;pointer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-type\">int</span> Size&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T (&amp;array)[Size])</span> </span>&#123;&#125; <span class=\"hljs-comment\">// (1)</span><br><span class=\"hljs-comment\">//template&lt;typename T, int Size&gt;</span><br><span class=\"hljs-comment\">//void f(T* array) &#123;&#125; // (2)</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br>std::<span class=\"hljs-type\">enable_if_t</span>&lt;std::is_pointer_v&lt;T&gt;&gt;<br><span class=\"hljs-built_in\">f</span>(T ptr) &#123;&#125; <span class=\"hljs-comment\">// (3)</span><br><span class=\"hljs-type\">int</span> array[<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-built_in\">f</span>(array); <span class=\"hljs-comment\">// It is not possible to call (1) if (2) is present</span><br><span class=\"hljs-comment\">// The reason is that &#x27;array&#x27; decays to a pointer</span><br><span class=\"hljs-comment\">// Now with (3), the code calls (1)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"检查类是否含有某个成员\"><a href=\"#检查类是否含有某个成员\" class=\"headerlink\" title=\"检查类是否含有某个成员\"></a>检查类是否含有某个成员</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> x;<br><span class=\"hljs-type\">int</span> y;<br><span class=\"hljs-keyword\">using</span> type = <span class=\"hljs-type\">int</span>;<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">B</span> &#123;&#125;;<br><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> has_x : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">has_x</span>&lt;T, <span class=\"hljs-keyword\">decltype</span>((<span class=\"hljs-type\">void</span>) T::x)&gt; : std::true_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> has_y : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">has_y</span>&lt;T, <span class=\"hljs-keyword\">decltype</span>((<span class=\"hljs-type\">void</span>) std::<span class=\"hljs-built_in\">declval</span>&lt;T&gt;().y)&gt; : std::true_type &#123;&#125;;<br>has_x&lt; A &gt;::value; <span class=\"hljs-comment\">// returns true</span><br>has_x&lt; B &gt;::value; <span class=\"hljs-comment\">// returns false</span><br>has_y&lt; A &gt;::value; <span class=\"hljs-comment\">// returns true</span><br>has_y&lt; B &gt;::value; <span class=\"hljs-comment\">// returns false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"判断是否定义某个类型\"><a href=\"#判断是否定义某个类型\" class=\"headerlink\" title=\"判断是否定义某个类型\"></a>判断是否定义某个类型</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>...&gt;<br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-type\">void_t</span> = <span class=\"hljs-type\">void</span>; <span class=\"hljs-comment\">// included in C++17 &lt;utility&gt;</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> has_type : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">has_type</span>&lt;T,<br>std::<span class=\"hljs-type\">void_t</span>&lt;<span class=\"hljs-keyword\">typename</span> T::type&gt; &gt; : std::true_type &#123;&#125;;<br>has_type&lt; A &gt;::value; <span class=\"hljs-comment\">// returns true</span><br>has_type&lt; B &gt;::value; <span class=\"hljs-comment\">// returns false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"判断是否支持流操作\"><a href=\"#判断是否支持流操作\" class=\"headerlink\" title=\"判断是否支持流操作\"></a>判断是否支持流操作</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">using</span> EnableP = <span class=\"hljs-keyword\">decltype</span>( std::<span class=\"hljs-built_in\">declval</span>&lt;std::ostream&amp;&gt;() &lt;&lt;<br>std::<span class=\"hljs-built_in\">declval</span>&lt;T&gt;() );<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> is_stream_supported : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_stream_supported</span>&lt;T, EnableP&lt;T&gt;&gt; : std::true_type &#123;&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;&#125;;<br>is_stream_supported&lt;<span class=\"hljs-type\">int</span>&gt;::value; <span class=\"hljs-comment\">// returns true</span><br>is_stream_supported&lt;A&gt;::value; <span class=\"hljs-comment\">// returns false</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"模板参数类型\"><a href=\"#模板参数类型\" class=\"headerlink\" title=\"模板参数类型\"></a>模板参数类型</h1><ul>\n<li>integral type</li>\n<li>enum, enum class</li>\n<li>floating-point type(c++20)</li>\n<li>auto placeholder(c++ 17)</li>\n<li>class literals and concepts(c++20)</li>\n<li>typename一般类型</li>\n<li>function</li>\n<li>reference&#x2F;pointer to global static function or object</li>\n<li>pointer to member type</li>\n<li>nullptr(c++14)</li>\n</ul>\n<h2 id=\"array-pointer-1\"><a href=\"#array-pointer-1\" class=\"headerlink\" title=\"array&#x2F;pointer\"></a>array&#x2F;pointer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span>* ptr&gt; <span class=\"hljs-comment\">// pointer</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br>cout &lt;&lt; ptr[<span class=\"hljs-number\">0</span>];<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-built_in\">int</span> (&amp;array)[<span class=\"hljs-number\">3</span>]&gt; <span class=\"hljs-comment\">// reference</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;<br>cout &lt;&lt; array[<span class=\"hljs-number\">0</span>];<br>&#125;<br><span class=\"hljs-type\">int</span> array[] = &#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;; <span class=\"hljs-comment\">// global</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;array&gt;(); <span class=\"hljs-comment\">// print 2</span><br><span class=\"hljs-built_in\">g</span>&lt;array&gt;(); <span class=\"hljs-comment\">// print 2</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"class-member\"><a href=\"#class-member\" class=\"headerlink\" title=\"class member\"></a>class member</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-type\">int</span> y[<span class=\"hljs-number\">3</span>] = &#123;<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span> A::*x&gt; <span class=\"hljs-comment\">// pointer to</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h1</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// member type</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-built_in\">int</span> (A::*y)[<span class=\"hljs-number\">3</span>]&gt; <span class=\"hljs-comment\">// pointer to</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h2</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// member type</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">h1</span>&lt;&amp;A::x&gt;();<br><span class=\"hljs-built_in\">h2</span>&lt;&amp;A::y&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"function-type\"><a href=\"#function-type\" class=\"headerlink\" title=\"function type\"></a>function type</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-built_in\">int</span> (*F)(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)&gt; <span class=\"hljs-comment\">// &lt;-- signature of &quot;f&quot;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">apply1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">F</span>(a, b);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> a + b; &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> a * b; &#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">decltype</span>(f) F&gt; <span class=\"hljs-comment\">// alternative syntax</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">apply2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">F</span>(a, b);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">apply1</span>&lt;f&gt;(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// return 5</span><br><span class=\"hljs-built_in\">apply2</span>&lt;g&gt;(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// return 6</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"type-traits\"><a href=\"#type-traits\" class=\"headerlink\" title=\"type_traits\"></a>type_traits</h1><ul>\n<li><code>#include&lt;type_traits&gt;</code></li>\n<li>std::is_integral<T>::value 等价于 std::is_integral_v<T></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">is_integral</td>\n<td align=\"center\">checks for an integral type(bool,char,unsigned char,short,int,long,etc)</td>\n</tr>\n<tr>\n<td align=\"center\">is_floating_point</td>\n<td align=\"center\">checks for a floating-point type(float,double)</td>\n</tr>\n<tr>\n<td align=\"center\">is_arithmetic</td>\n<td align=\"center\">checks for a integral or floating-point type</td>\n</tr>\n<tr>\n<td align=\"center\">is_signed</td>\n<td align=\"center\">checks for a signed type</td>\n</tr>\n<tr>\n<td align=\"center\">is_unsigned</td>\n<td align=\"center\">checks for an unsigned type</td>\n</tr>\n<tr>\n<td align=\"center\">is_enum</td>\n<td align=\"center\">checks for an enumerator type(enum,enum class)</td>\n</tr>\n<tr>\n<td align=\"center\">is_void</td>\n<td align=\"center\">checks for(void)</td>\n</tr>\n<tr>\n<td align=\"center\">is_pointer</td>\n<td align=\"center\">checks for a pointer(<code>T*</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">is_null_pointer</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">is_reference</td>\n<td align=\"center\">checks for a reference(T&amp;)</td>\n</tr>\n<tr>\n<td align=\"center\">is_array</td>\n<td align=\"center\">checks for an array(<code>T (&amp;)[N]</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">is_function</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">is_class</td>\n<td align=\"center\">checks for a class type(struct class)</td>\n</tr>\n<tr>\n<td align=\"center\">is_abstract</td>\n<td align=\"center\">checks for a class with at least one pure virtual function</td>\n</tr>\n<tr>\n<td align=\"center\">is_polymorphic</td>\n<td align=\"center\">checks for a class with at least one virtual function</td>\n</tr>\n<tr>\n<td align=\"center\">is_const</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">is_same&lt;T,R&gt;</td>\n<td align=\"center\">checks if T and R are the same type</td>\n</tr>\n<tr>\n<td align=\"center\">is_base_of&lt;T,R&gt;</td>\n<td align=\"center\">checks if T is base of R</td>\n</tr>\n<tr>\n<td align=\"center\">is_convertible&lt;T,R&gt;</td>\n<td align=\"center\">checks if T can be converted to R</td>\n</tr>\n</tbody></table>\n<ul>\n<li>using U &#x3D; typename std::make_unsigned<int>::type 等价于 std::make_unsigned_t<T>;</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">make_signed</td>\n<td align=\"center\">make a signed type</td>\n</tr>\n<tr>\n<td align=\"center\">make_unsigned</td>\n<td align=\"center\">makes an unsigned type</td>\n</tr>\n<tr>\n<td align=\"center\">remove_pointer</td>\n<td align=\"center\">remove pointer(<code>T*-&gt;T</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">add_pointer</td>\n<td align=\"center\">add pointer(<code>T-&gt;T*</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">remove_reference</td>\n<td align=\"center\">remove reference(<code>T*-&gt;T</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">add_lvalue_reference</td>\n<td align=\"center\">add reference(T-&gt;T&amp;)</td>\n</tr>\n<tr>\n<td align=\"center\">remove_const</td>\n<td align=\"center\">remove const</td>\n</tr>\n<tr>\n<td align=\"center\">add_const</td>\n<td align=\"center\">add const</td>\n</tr>\n<tr>\n<td align=\"center\">common_type&lt;T,R&gt;</td>\n<td align=\"center\">(see the example)</td>\n</tr>\n<tr>\n<td align=\"center\">conditional&lt;pred,T,R&gt;</td>\n<td align=\"center\">returns T if pred is true,R otherwise</td>\n</tr>\n<tr>\n<td align=\"center\">decay<T></td>\n<td align=\"center\">returns the same type as a function parameter passed by-value</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br>std::<span class=\"hljs-type\">common_type_t</span>&lt;R, T&gt; <span class=\"hljs-comment\">// &lt;-- return type</span><br><span class=\"hljs-built_in\">add</span>(T a, R b) &#123;<br><span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-comment\">// we can also use decltype to derive the result type</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-type\">result_t</span> = <span class=\"hljs-keyword\">decltype</span>(<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4.0f</span>));<br><span class=\"hljs-type\">result_t</span> x = <span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4.0f</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 T 是一个引用类型（如 int&amp;），std::decay<T>::type 就是 int。</li>\n<li>如果 T 是一个数组类型（如 int[5]），std::decay<T>::type 就是 int*。</li>\n<li>如果 T 是一个函数类型，std::decay<T>::type 就是相应的函数指针类型。</li>\n<li>如果 T 是一个 cv-qualified 类型（如 const int 或 volatile int），std::decay<T>::type 就是没有这些限定符的 int。</li>\n</ul>\n<h1 id=\"Variadic-Template\"><a href=\"#Variadic-Template\" class=\"headerlink\" title=\"Variadic Template\"></a>Variadic Template</h1><ul>\n<li>可以用<code>sizeof...(args)</code>得出个数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// BASE CASE</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T a, R b)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-comment\">// RECURSIVE CASE</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span>... TArgs&gt; <span class=\"hljs-comment\">// Variadic typename</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T a, TArgs... args)</span> </span>&#123; <span class=\"hljs-comment\">// Typename expansion</span><br><span class=\"hljs-keyword\">return</span> a + <span class=\"hljs-built_in\">add</span>(args...); <span class=\"hljs-comment\">// Arguments expansion</span><br>&#125;<br><span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0</span>); <span class=\"hljs-comment\">// 5</span><br><span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 9</span><br><span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 14</span><br><span class=\"hljs-comment\">// add(2); // compile error the base case accepts only two arguments</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"存到数组\"><a href=\"#存到数组\" class=\"headerlink\" title=\"存到数组\"></a>存到数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... TArgs&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(TArgs... args)</span> </span>&#123;<br><span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> Size = <span class=\"hljs-keyword\">sizeof</span>...(args);<br><span class=\"hljs-type\">int</span> array[] = &#123;args...&#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> x : array)<br>cout &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// print &quot;1 2 3&quot;</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// print &quot;1 2 3 4&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Folding-Expression\"><a href=\"#Folding-Expression\" class=\"headerlink\" title=\"Folding Expression\"></a>Folding Expression</h2><ul>\n<li>Example1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... Args&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add_unary</span><span class=\"hljs-params\">(Args... args)</span> </span>&#123; <span class=\"hljs-comment\">// Unary folding</span><br><span class=\"hljs-keyword\">return</span> (... + args); <span class=\"hljs-comment\">// unfold: 1 + 2.0f + 3ull</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... Args&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add_binary</span><span class=\"hljs-params\">(Args... args)</span> </span>&#123; <span class=\"hljs-comment\">// Binary folding</span><br><span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span> + ... + args); <span class=\"hljs-comment\">// unfold: 1 + 1 + 2.0f + 3ull</span><br>&#125;<br><span class=\"hljs-built_in\">add_unary</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">3ll</span>); <span class=\"hljs-comment\">// returns 6.0f (float)</span><br><span class=\"hljs-built_in\">add_binary</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">3ll</span>); <span class=\"hljs-comment\">// returns 7.0f (float) </span><br></code></pre></td></tr></table></figure></li>\n<li>Example2<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">square</span><span class=\"hljs-params\">(T value)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> value * value; &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... TArgs&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add_square</span><span class=\"hljs-params\">(TArgs... args)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">square</span>(args) + ...); <span class=\"hljs-comment\">// square() is applied to each</span><br>&#125; <span class=\"hljs-comment\">// variadic argument</span><br><span class=\"hljs-built_in\">add_square</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0f</span>); <span class=\"hljs-comment\">// returns 17.0f</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"获取函数的形参个数\"><a href=\"#获取函数的形参个数\" class=\"headerlink\" title=\"获取函数的形参个数\"></a>获取函数的形参个数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>;<br><span class=\"hljs-comment\">// generic function pointer</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(*)(Args...)&gt; &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-comment\">// generic function reference</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(&amp;)(Args...)&gt; &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-comment\">// generic function object</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(Args...)&gt; &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;; <br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">double</span>)</span> </span>&#123;&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-comment\">// function object</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>(f)&gt;::value;<br><span class=\"hljs-keyword\">auto</span>&amp; g = f;<br><span class=\"hljs-comment\">// function reference</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>(g)&gt;::value;<br><span class=\"hljs-comment\">// function reference</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>((f))&gt;::value;<br><span class=\"hljs-keyword\">auto</span>* h = f;<br><span class=\"hljs-comment\">// function pointer</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>(h)&gt;::value;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"获得lamda或operator-的参数个数\"><a href=\"#获得lamda或operator-的参数个数\" class=\"headerlink\" title=\"获得lamda或operator()的参数个数\"></a>获得lamda或operator()的参数个数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span> C, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(C::*)(Args...)&gt; &#123; <span class=\"hljs-comment\">// class member</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span> C, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(C::*)(Args...) <span class=\"hljs-type\">const</span>&gt; &#123; <span class=\"hljs-comment\">// &quot;const&quot; class member</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">char</span>)</span> </span>&#123;&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">char</span>)</span> <span class=\"hljs-type\">const</span> </span>&#123;&#125;<br>&#125;;<br>GetArity&lt;A&gt;::value; <span class=\"hljs-comment\">// call GetArity&lt;R(C::*)(Args...)&gt;</span><br>GetArity&lt;<span class=\"hljs-type\">const</span> A&gt;::value; <span class=\"hljs-comment\">// call GetArity&lt;R(C::*)(Args...) const&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"Concepts和requires-c-20\"><a href=\"#Concepts和requires-c-20\" class=\"headerlink\" title=\"Concepts和requires(c++20)\"></a>Concepts和requires(c++20)</h1><h2 id=\"concepts语法\"><a href=\"#concepts语法\" class=\"headerlink\" title=\"concepts语法\"></a>concepts语法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">[<span class=\"hljs-keyword\">template</span> arguments]<br><span class=\"hljs-keyword\">concept</span> [name] = [compile-time boolean expression];<br></code></pre></td></tr></table></figure>\n<h2 id=\"concepts例子\"><a href=\"#concepts例子\" class=\"headerlink\" title=\"concepts例子\"></a>concepts例子</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">concept</span> Arithmetic = std::is_arithmetic_v&lt;T&gt;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;Arithmetic T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T valueA, T valueB)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> valueA + valueB;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"requires-clause语法\"><a href=\"#requires-clause语法\" class=\"headerlink\" title=\"requires clause语法\"></a>requires clause语法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">requires</span> [compile-time boolean expression <span class=\"hljs-keyword\">or</span> Concept]<br></code></pre></td></tr></table></figure>\n<h3 id=\"concept-example\"><a href=\"#concept-example\" class=\"headerlink\" title=\"concept example\"></a>concept example</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">requires</span> Arithmetic&lt;T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T valueA, T valueB)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> valueA + valueB;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"bool-expression-example\"><a href=\"#bool-expression-example\" class=\"headerlink\" title=\"bool expression example\"></a>bool expression example</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T valueA, T valueB)</span> <span class=\"hljs-title\">requires</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">sizeof</span>(T) == <span class=\"hljs-number\">4</span>)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> valueA + valueB;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"requires-expression语法\"><a href=\"#requires-expression语法\" class=\"headerlink\" title=\"requires expression语法\"></a>requires expression语法</h2><p>A requires expression is a compile-time expression of type bool that defines the<br>constraints on template arguments</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">requires</span> [(arguments)] &#123;<br>[SFINAE contrain]; <span class=\"hljs-comment\">// or</span><br><span class=\"hljs-keyword\">requires</span> [predicate];<br>&#125; -&gt; <span class=\"hljs-type\">bool</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">concept</span> MyConcept = <span class=\"hljs-built_in\">requires</span> (T a, T b) &#123; <span class=\"hljs-comment\">// First case: SFINAE constrains</span><br>a + b; <span class=\"hljs-comment\">// Req. 1 - support add operator</span><br>a[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// Req. 2 - support subscript operator</span><br>a.x; <span class=\"hljs-comment\">// Req. 3 - has &quot;x&quot; data member</span><br>a.<span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">// Req. 4 - has &quot;f&quot; function member</span><br><span class=\"hljs-keyword\">typename</span> T::type; <span class=\"hljs-comment\">// Req. 5 - has &quot;type&quot; field</span><br>&#125;;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;concept&gt;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">concept</span> MyConcept2 = <span class=\"hljs-built_in\">requires</span> (T a, T b) &#123;<br>&#123;*a + <span class=\"hljs-number\">1</span>&#125; -&gt; std::convertible_to&lt;<span class=\"hljs-type\">float</span>&gt;; <span class=\"hljs-comment\">// Req. 6 - can be deferred and the sum</span><br><span class=\"hljs-comment\">// with an integer is convertible</span><br><span class=\"hljs-comment\">// to float</span><br>&#123;a * a&#125; -&gt; std::same_as&lt;<span class=\"hljs-type\">int</span>&gt;; <span class=\"hljs-comment\">// Req. 7 - &quot;a * a&quot; must be valid and</span><br><span class=\"hljs-comment\">// the result type is &quot;int&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"requires-Clause-Expression\"><a href=\"#requires-Clause-Expression\" class=\"headerlink\" title=\"requires Clause + Expression\"></a>requires Clause + Expression</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T a)</span> <span class=\"hljs-keyword\">requires</span> <span class=\"hljs-keyword\">requires</span> </span>&#123; T::value; &#125;<br><span class=\"hljs-comment\">// clause -&gt; SFINAE followed by</span><br><span class=\"hljs-comment\">// expression -&gt; bool (zero args)</span><br>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">increment</span><span class=\"hljs-params\">(T a)</span> <span class=\"hljs-keyword\">requires</span> <span class=\"hljs-title\">requires</span> <span class=\"hljs-params\">(T x)</span> </span>&#123; x + <span class=\"hljs-number\">1</span>; &#125;<br><span class=\"hljs-comment\">// clause -&gt; SFINAE followed by</span><br><span class=\"hljs-comment\">// expression -&gt; bool (one arg)</span><br>&#123;<br><span class=\"hljs-keyword\">return</span> a + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h1><h2 id=\"利用特例化判断类型是否一致\"><a href=\"#利用特例化判断类型是否一致\" class=\"headerlink\" title=\"利用特例化判断类型是否一致\"></a>利用特例化判断类型是否一致</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt; <span class=\"hljs-comment\">// GENERIC template declaration</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_same</span> &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">bool</span> value = <span class=\"hljs-literal\">false</span>;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_same</span>&lt;T, T&gt; &#123; <span class=\"hljs-comment\">// PARTIAL template specialization</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">bool</span> value = <span class=\"hljs-literal\">true</span>;<br>&#125;;<br>cout &lt;&lt; is_same&lt; <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>&gt;::value; <span class=\"hljs-comment\">// print false, generic template</span><br>cout &lt;&lt; is_same&lt;<span class=\"hljs-type\">float</span>, <span class=\"hljs-type\">float</span>&gt;::value; <span class=\"hljs-comment\">// print true, partial template</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"利用特例化判断const指针\"><a href=\"#利用特例化判断const指针\" class=\"headerlink\" title=\"利用特例化判断const指针\"></a>利用特例化判断const指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-comment\">// std::true type and std::false type contain a field &quot;value&quot;</span><br><span class=\"hljs-comment\">// set to true or false respectively</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_const_pointer</span> : std::false_type &#123;&#125;; <span class=\"hljs-comment\">// GENERIC template declaration</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R&gt; <span class=\"hljs-comment\">// PARTIAL specialization</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_const_pointer</span>&lt;<span class=\"hljs-type\">const</span> R*&gt; : std::true_type &#123;&#125;;<br>cout &lt;&lt; is_const_pointer&lt;<span class=\"hljs-type\">int</span>*&gt;::value; <span class=\"hljs-comment\">// print false, generic template</span><br>cout &lt;&lt; is_const_pointer&lt;<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>*&gt;::value; <span class=\"hljs-comment\">// print true, partial template</span><br>cout &lt;&lt; is_const_pointer&lt;<span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span>&gt;::value; <span class=\"hljs-comment\">// print false, generic template</span><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Class-Template-Deduction-Guide\"><a href=\"#Class-Template-Deduction-Guide\" class=\"headerlink\" title=\"Class Template-Deduction Guide\"></a>Class Template-Deduction Guide</h1><h2 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span> <span class=\"hljs-comment\">// std::remove_reference_t</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span> <span class=\"hljs-comment\">// std::vector</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Container</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Iter&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Container</span><span class=\"hljs-params\">(Iter beg, Iter end)</span> </span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Iter&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Container</span><span class=\"hljs-params\">(Iter b, Iter e)</span> -&gt; <span class=\"hljs-comment\">// deduction guide</span></span><br><span class=\"hljs-function\">Container&lt;<span class=\"hljs-keyword\">typename</span> std::iterator_traits&lt;Iter&gt;::value_type&gt;</span>;<br>std::vector v&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;;<br>Container c&#123;v.<span class=\"hljs-built_in\">begin</span>(), v.<span class=\"hljs-built_in\">end</span>()&#125;; <span class=\"hljs-comment\">// construct &#x27;Container&lt;int&gt;&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyString</span> &#123;<br><span class=\"hljs-built_in\">MyString</span>(T) &#123;&#125;<br>&#125;;<br><span class=\"hljs-comment\">// constructor class instantiation</span><br><span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-type\">char</span> <span class=\"hljs-type\">const</span>*) -&gt; MyString&lt;std::string&gt;; <span class=\"hljs-comment\">// deduction guide</span><br>MyString s&#123;<span class=\"hljs-string\">&quot;abc&quot;</span>&#125;; <span class=\"hljs-comment\">// construct &#x27;MyString&lt;std::string&gt;&#x27;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"类与成员函数\"><a href=\"#类与成员函数\" class=\"headerlink\" title=\"类与成员函数\"></a>类与成员函数</h1><p>有两种方式：</p>\n<ul>\n<li>Generic class + generic function</li>\n<li>Full class specialization + generic&#x2F;full specialization function<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;</span><br><span class=\"hljs-function\">    <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, R&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125;<br><span class=\"hljs-comment\">// ok, A&lt;T, R&gt; and f&lt;X, Y&gt; are not specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;<br><span class=\"hljs-type\">void</span> A&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125;<br><span class=\"hljs-comment\">// ok, A&lt;int, int&gt; is full specialized</span><br><span class=\"hljs-comment\">// ok, f&lt;X, Y&gt; is not specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-type\">void</span> A&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;::<span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;() &#123;&#125;<br><span class=\"hljs-comment\">// ok, A&lt;int, int&gt; and f&lt;int, int&gt; are full specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X, <span class=\"hljs-keyword\">typename</span> Y&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, <span class=\"hljs-type\">int</span>&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125;<br><span class=\"hljs-comment\">// error A&lt;T, int&gt; is partially specialized</span><br><span class=\"hljs-comment\">// (A&lt;T, int&gt; class must be defined before)</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> X&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, R&gt;::<span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>, X&gt;() &#123;&#125;<br><span class=\"hljs-comment\">// error function members cannot be partially specialized</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-type\">void</span> A&lt;T, R&gt;::<span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;() &#123;&#125;<br><span class=\"hljs-comment\">// error function members of a non-specialized class cannot be specialized</span><br><span class=\"hljs-comment\">// (requires a binding to a specific template instantiation at compile-time)</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"enable-if\"><a href=\"#enable-if\" class=\"headerlink\" title=\"enable_if\"></a>enable_if</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">bool</span> Condition, <span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> enable_if &#123;<br><span class=\"hljs-comment\">// &quot;type&quot; is not defined if &quot;Condition == false&quot;</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">enable_if</span>&lt;<span class=\"hljs-literal\">true</span>, T&gt; &#123;<br>    <span class=\"hljs-keyword\">using</span> type = T;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"array-pointer\"><a href=\"#array-pointer\" class=\"headerlink\" title=\"array&#x2F;pointer\"></a>array&#x2F;pointer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-type\">int</span> Size&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T (&amp;array)[Size])</span> </span>&#123;&#125; <span class=\"hljs-comment\">// (1)</span><br><span class=\"hljs-comment\">//template&lt;typename T, int Size&gt;</span><br><span class=\"hljs-comment\">//void f(T* array) &#123;&#125; // (2)</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br>std::<span class=\"hljs-type\">enable_if_t</span>&lt;std::is_pointer_v&lt;T&gt;&gt;<br><span class=\"hljs-built_in\">f</span>(T ptr) &#123;&#125; <span class=\"hljs-comment\">// (3)</span><br><span class=\"hljs-type\">int</span> array[<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-built_in\">f</span>(array); <span class=\"hljs-comment\">// It is not possible to call (1) if (2) is present</span><br><span class=\"hljs-comment\">// The reason is that &#x27;array&#x27; decays to a pointer</span><br><span class=\"hljs-comment\">// Now with (3), the code calls (1)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"检查类是否含有某个成员\"><a href=\"#检查类是否含有某个成员\" class=\"headerlink\" title=\"检查类是否含有某个成员\"></a>检查类是否含有某个成员</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> x;<br><span class=\"hljs-type\">int</span> y;<br><span class=\"hljs-keyword\">using</span> type = <span class=\"hljs-type\">int</span>;<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">B</span> &#123;&#125;;<br><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> has_x : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">has_x</span>&lt;T, <span class=\"hljs-keyword\">decltype</span>((<span class=\"hljs-type\">void</span>) T::x)&gt; : std::true_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> has_y : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">has_y</span>&lt;T, <span class=\"hljs-keyword\">decltype</span>((<span class=\"hljs-type\">void</span>) std::<span class=\"hljs-built_in\">declval</span>&lt;T&gt;().y)&gt; : std::true_type &#123;&#125;;<br>has_x&lt; A &gt;::value; <span class=\"hljs-comment\">// returns true</span><br>has_x&lt; B &gt;::value; <span class=\"hljs-comment\">// returns false</span><br>has_y&lt; A &gt;::value; <span class=\"hljs-comment\">// returns true</span><br>has_y&lt; B &gt;::value; <span class=\"hljs-comment\">// returns false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"判断是否定义某个类型\"><a href=\"#判断是否定义某个类型\" class=\"headerlink\" title=\"判断是否定义某个类型\"></a>判断是否定义某个类型</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>...&gt;<br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-type\">void_t</span> = <span class=\"hljs-type\">void</span>; <span class=\"hljs-comment\">// included in C++17 &lt;utility&gt;</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> has_type : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">has_type</span>&lt;T,<br>std::<span class=\"hljs-type\">void_t</span>&lt;<span class=\"hljs-keyword\">typename</span> T::type&gt; &gt; : std::true_type &#123;&#125;;<br>has_type&lt; A &gt;::value; <span class=\"hljs-comment\">// returns true</span><br>has_type&lt; B &gt;::value; <span class=\"hljs-comment\">// returns false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"判断是否支持流操作\"><a href=\"#判断是否支持流操作\" class=\"headerlink\" title=\"判断是否支持流操作\"></a>判断是否支持流操作</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">using</span> EnableP = <span class=\"hljs-keyword\">decltype</span>( std::<span class=\"hljs-built_in\">declval</span>&lt;std::ostream&amp;&gt;() &lt;&lt;<br>std::<span class=\"hljs-built_in\">declval</span>&lt;T&gt;() );<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> = <span class=\"hljs-type\">void</span>&gt;<br><span class=\"hljs-keyword\">struct</span> is_stream_supported : std::false_type &#123;&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_stream_supported</span>&lt;T, EnableP&lt;T&gt;&gt; : std::true_type &#123;&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;&#125;;<br>is_stream_supported&lt;<span class=\"hljs-type\">int</span>&gt;::value; <span class=\"hljs-comment\">// returns true</span><br>is_stream_supported&lt;A&gt;::value; <span class=\"hljs-comment\">// returns false</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"模板参数类型\"><a href=\"#模板参数类型\" class=\"headerlink\" title=\"模板参数类型\"></a>模板参数类型</h1><ul>\n<li>integral type</li>\n<li>enum, enum class</li>\n<li>floating-point type(c++20)</li>\n<li>auto placeholder(c++ 17)</li>\n<li>class literals and concepts(c++20)</li>\n<li>typename一般类型</li>\n<li>function</li>\n<li>reference&#x2F;pointer to global static function or object</li>\n<li>pointer to member type</li>\n<li>nullptr(c++14)</li>\n</ul>\n<h2 id=\"array-pointer-1\"><a href=\"#array-pointer-1\" class=\"headerlink\" title=\"array&#x2F;pointer\"></a>array&#x2F;pointer</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span>* ptr&gt; <span class=\"hljs-comment\">// pointer</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br>cout &lt;&lt; ptr[<span class=\"hljs-number\">0</span>];<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-built_in\">int</span> (&amp;array)[<span class=\"hljs-number\">3</span>]&gt; <span class=\"hljs-comment\">// reference</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;<br>cout &lt;&lt; array[<span class=\"hljs-number\">0</span>];<br>&#125;<br><span class=\"hljs-type\">int</span> array[] = &#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;; <span class=\"hljs-comment\">// global</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;array&gt;(); <span class=\"hljs-comment\">// print 2</span><br><span class=\"hljs-built_in\">g</span>&lt;array&gt;(); <span class=\"hljs-comment\">// print 2</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"class-member\"><a href=\"#class-member\" class=\"headerlink\" title=\"class member\"></a>class member</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-type\">int</span> y[<span class=\"hljs-number\">3</span>] = &#123;<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-type\">int</span> A::*x&gt; <span class=\"hljs-comment\">// pointer to</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h1</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// member type</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-built_in\">int</span> (A::*y)[<span class=\"hljs-number\">3</span>]&gt; <span class=\"hljs-comment\">// pointer to</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h2</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// member type</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">h1</span>&lt;&amp;A::x&gt;();<br><span class=\"hljs-built_in\">h2</span>&lt;&amp;A::y&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"function-type\"><a href=\"#function-type\" class=\"headerlink\" title=\"function type\"></a>function type</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-built_in\">int</span> (*F)(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)&gt; <span class=\"hljs-comment\">// &lt;-- signature of &quot;f&quot;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">apply1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">F</span>(a, b);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> a + b; &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> a * b; &#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">decltype</span>(f) F&gt; <span class=\"hljs-comment\">// alternative syntax</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">apply2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">F</span>(a, b);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">apply1</span>&lt;f&gt;(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// return 5</span><br><span class=\"hljs-built_in\">apply2</span>&lt;g&gt;(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// return 6</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"type-traits\"><a href=\"#type-traits\" class=\"headerlink\" title=\"type_traits\"></a>type_traits</h1><ul>\n<li><code>#include&lt;type_traits&gt;</code></li>\n<li>std::is_integral<T>::value 等价于 std::is_integral_v<T></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">is_integral</td>\n<td align=\"center\">checks for an integral type(bool,char,unsigned char,short,int,long,etc)</td>\n</tr>\n<tr>\n<td align=\"center\">is_floating_point</td>\n<td align=\"center\">checks for a floating-point type(float,double)</td>\n</tr>\n<tr>\n<td align=\"center\">is_arithmetic</td>\n<td align=\"center\">checks for a integral or floating-point type</td>\n</tr>\n<tr>\n<td align=\"center\">is_signed</td>\n<td align=\"center\">checks for a signed type</td>\n</tr>\n<tr>\n<td align=\"center\">is_unsigned</td>\n<td align=\"center\">checks for an unsigned type</td>\n</tr>\n<tr>\n<td align=\"center\">is_enum</td>\n<td align=\"center\">checks for an enumerator type(enum,enum class)</td>\n</tr>\n<tr>\n<td align=\"center\">is_void</td>\n<td align=\"center\">checks for(void)</td>\n</tr>\n<tr>\n<td align=\"center\">is_pointer</td>\n<td align=\"center\">checks for a pointer(<code>T*</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">is_null_pointer</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">is_reference</td>\n<td align=\"center\">checks for a reference(T&amp;)</td>\n</tr>\n<tr>\n<td align=\"center\">is_array</td>\n<td align=\"center\">checks for an array(<code>T (&amp;)[N]</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">is_function</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">is_class</td>\n<td align=\"center\">checks for a class type(struct class)</td>\n</tr>\n<tr>\n<td align=\"center\">is_abstract</td>\n<td align=\"center\">checks for a class with at least one pure virtual function</td>\n</tr>\n<tr>\n<td align=\"center\">is_polymorphic</td>\n<td align=\"center\">checks for a class with at least one virtual function</td>\n</tr>\n<tr>\n<td align=\"center\">is_const</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">is_same&lt;T,R&gt;</td>\n<td align=\"center\">checks if T and R are the same type</td>\n</tr>\n<tr>\n<td align=\"center\">is_base_of&lt;T,R&gt;</td>\n<td align=\"center\">checks if T is base of R</td>\n</tr>\n<tr>\n<td align=\"center\">is_convertible&lt;T,R&gt;</td>\n<td align=\"center\">checks if T can be converted to R</td>\n</tr>\n</tbody></table>\n<ul>\n<li>using U &#x3D; typename std::make_unsigned<int>::type 等价于 std::make_unsigned_t<T>;</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">make_signed</td>\n<td align=\"center\">make a signed type</td>\n</tr>\n<tr>\n<td align=\"center\">make_unsigned</td>\n<td align=\"center\">makes an unsigned type</td>\n</tr>\n<tr>\n<td align=\"center\">remove_pointer</td>\n<td align=\"center\">remove pointer(<code>T*-&gt;T</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">add_pointer</td>\n<td align=\"center\">add pointer(<code>T-&gt;T*</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">remove_reference</td>\n<td align=\"center\">remove reference(<code>T*-&gt;T</code>)</td>\n</tr>\n<tr>\n<td align=\"center\">add_lvalue_reference</td>\n<td align=\"center\">add reference(T-&gt;T&amp;)</td>\n</tr>\n<tr>\n<td align=\"center\">remove_const</td>\n<td align=\"center\">remove const</td>\n</tr>\n<tr>\n<td align=\"center\">add_const</td>\n<td align=\"center\">add const</td>\n</tr>\n<tr>\n<td align=\"center\">common_type&lt;T,R&gt;</td>\n<td align=\"center\">(see the example)</td>\n</tr>\n<tr>\n<td align=\"center\">conditional&lt;pred,T,R&gt;</td>\n<td align=\"center\">returns T if pred is true,R otherwise</td>\n</tr>\n<tr>\n<td align=\"center\">decay<T></td>\n<td align=\"center\">returns the same type as a function parameter passed by-value</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;<br>std::<span class=\"hljs-type\">common_type_t</span>&lt;R, T&gt; <span class=\"hljs-comment\">// &lt;-- return type</span><br><span class=\"hljs-built_in\">add</span>(T a, R b) &#123;<br><span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-comment\">// we can also use decltype to derive the result type</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-type\">result_t</span> = <span class=\"hljs-keyword\">decltype</span>(<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4.0f</span>));<br><span class=\"hljs-type\">result_t</span> x = <span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4.0f</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 T 是一个引用类型（如 int&amp;），std::decay<T>::type 就是 int。</li>\n<li>如果 T 是一个数组类型（如 int[5]），std::decay<T>::type 就是 int*。</li>\n<li>如果 T 是一个函数类型，std::decay<T>::type 就是相应的函数指针类型。</li>\n<li>如果 T 是一个 cv-qualified 类型（如 const int 或 volatile int），std::decay<T>::type 就是没有这些限定符的 int。</li>\n</ul>\n<h1 id=\"Variadic-Template\"><a href=\"#Variadic-Template\" class=\"headerlink\" title=\"Variadic Template\"></a>Variadic Template</h1><ul>\n<li>可以用<code>sizeof...(args)</code>得出个数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// BASE CASE</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T a, R b)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-comment\">// RECURSIVE CASE</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span>... TArgs&gt; <span class=\"hljs-comment\">// Variadic typename</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T a, TArgs... args)</span> </span>&#123; <span class=\"hljs-comment\">// Typename expansion</span><br><span class=\"hljs-keyword\">return</span> a + <span class=\"hljs-built_in\">add</span>(args...); <span class=\"hljs-comment\">// Arguments expansion</span><br>&#125;<br><span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0</span>); <span class=\"hljs-comment\">// 5</span><br><span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 9</span><br><span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 14</span><br><span class=\"hljs-comment\">// add(2); // compile error the base case accepts only two arguments</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"存到数组\"><a href=\"#存到数组\" class=\"headerlink\" title=\"存到数组\"></a>存到数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... TArgs&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(TArgs... args)</span> </span>&#123;<br><span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> Size = <span class=\"hljs-keyword\">sizeof</span>...(args);<br><span class=\"hljs-type\">int</span> array[] = &#123;args...&#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> x : array)<br>cout &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// print &quot;1 2 3&quot;</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// print &quot;1 2 3 4&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Folding-Expression\"><a href=\"#Folding-Expression\" class=\"headerlink\" title=\"Folding Expression\"></a>Folding Expression</h2><ul>\n<li>Example1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... Args&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add_unary</span><span class=\"hljs-params\">(Args... args)</span> </span>&#123; <span class=\"hljs-comment\">// Unary folding</span><br><span class=\"hljs-keyword\">return</span> (... + args); <span class=\"hljs-comment\">// unfold: 1 + 2.0f + 3ull</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... Args&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add_binary</span><span class=\"hljs-params\">(Args... args)</span> </span>&#123; <span class=\"hljs-comment\">// Binary folding</span><br><span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span> + ... + args); <span class=\"hljs-comment\">// unfold: 1 + 1 + 2.0f + 3ull</span><br>&#125;<br><span class=\"hljs-built_in\">add_unary</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">3ll</span>); <span class=\"hljs-comment\">// returns 6.0f (float)</span><br><span class=\"hljs-built_in\">add_binary</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">3ll</span>); <span class=\"hljs-comment\">// returns 7.0f (float) </span><br></code></pre></td></tr></table></figure></li>\n<li>Example2<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">square</span><span class=\"hljs-params\">(T value)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> value * value; &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span>... TArgs&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">add_square</span><span class=\"hljs-params\">(TArgs... args)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">square</span>(args) + ...); <span class=\"hljs-comment\">// square() is applied to each</span><br>&#125; <span class=\"hljs-comment\">// variadic argument</span><br><span class=\"hljs-built_in\">add_square</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.0f</span>); <span class=\"hljs-comment\">// returns 17.0f</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"获取函数的形参个数\"><a href=\"#获取函数的形参个数\" class=\"headerlink\" title=\"获取函数的形参个数\"></a>获取函数的形参个数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>;<br><span class=\"hljs-comment\">// generic function pointer</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(*)(Args...)&gt; &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-comment\">// generic function reference</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(&amp;)(Args...)&gt; &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-comment\">// generic function object</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(Args...)&gt; &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;; <br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">double</span>)</span> </span>&#123;&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-comment\">// function object</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>(f)&gt;::value;<br><span class=\"hljs-keyword\">auto</span>&amp; g = f;<br><span class=\"hljs-comment\">// function reference</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>(g)&gt;::value;<br><span class=\"hljs-comment\">// function reference</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>((f))&gt;::value;<br><span class=\"hljs-keyword\">auto</span>* h = f;<br><span class=\"hljs-comment\">// function pointer</span><br>GetArity&lt;<span class=\"hljs-keyword\">decltype</span>(h)&gt;::value;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"获得lamda或operator-的参数个数\"><a href=\"#获得lamda或operator-的参数个数\" class=\"headerlink\" title=\"获得lamda或operator()的参数个数\"></a>获得lamda或operator()的参数个数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span> C, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(C::*)(Args...)&gt; &#123; <span class=\"hljs-comment\">// class member</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R, <span class=\"hljs-keyword\">typename</span> C, <span class=\"hljs-keyword\">typename</span>... Args&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">GetArity</span>&lt;<span class=\"hljs-built_in\">R</span>(C::*)(Args...) <span class=\"hljs-type\">const</span>&gt; &#123; <span class=\"hljs-comment\">// &quot;const&quot; class member</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> value = <span class=\"hljs-keyword\">sizeof</span>...(Args);<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">char</span>)</span> </span>&#123;&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">char</span>)</span> <span class=\"hljs-type\">const</span> </span>&#123;&#125;<br>&#125;;<br>GetArity&lt;A&gt;::value; <span class=\"hljs-comment\">// call GetArity&lt;R(C::*)(Args...)&gt;</span><br>GetArity&lt;<span class=\"hljs-type\">const</span> A&gt;::value; <span class=\"hljs-comment\">// call GetArity&lt;R(C::*)(Args...) const&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"Concepts和requires-c-20\"><a href=\"#Concepts和requires-c-20\" class=\"headerlink\" title=\"Concepts和requires(c++20)\"></a>Concepts和requires(c++20)</h1><h2 id=\"concepts语法\"><a href=\"#concepts语法\" class=\"headerlink\" title=\"concepts语法\"></a>concepts语法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">[<span class=\"hljs-keyword\">template</span> arguments]<br><span class=\"hljs-keyword\">concept</span> [name] = [compile-time boolean expression];<br></code></pre></td></tr></table></figure>\n<h2 id=\"concepts例子\"><a href=\"#concepts例子\" class=\"headerlink\" title=\"concepts例子\"></a>concepts例子</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">concept</span> Arithmetic = std::is_arithmetic_v&lt;T&gt;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;Arithmetic T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T valueA, T valueB)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> valueA + valueB;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"requires-clause语法\"><a href=\"#requires-clause语法\" class=\"headerlink\" title=\"requires clause语法\"></a>requires clause语法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">requires</span> [compile-time boolean expression <span class=\"hljs-keyword\">or</span> Concept]<br></code></pre></td></tr></table></figure>\n<h3 id=\"concept-example\"><a href=\"#concept-example\" class=\"headerlink\" title=\"concept example\"></a>concept example</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">requires</span> Arithmetic&lt;T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T valueA, T valueB)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> valueA + valueB;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"bool-expression-example\"><a href=\"#bool-expression-example\" class=\"headerlink\" title=\"bool expression example\"></a>bool expression example</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(T valueA, T valueB)</span> <span class=\"hljs-title\">requires</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">sizeof</span>(T) == <span class=\"hljs-number\">4</span>)</span> </span>&#123;<br><span class=\"hljs-keyword\">return</span> valueA + valueB;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"requires-expression语法\"><a href=\"#requires-expression语法\" class=\"headerlink\" title=\"requires expression语法\"></a>requires expression语法</h2><p>A requires expression is a compile-time expression of type bool that defines the<br>constraints on template arguments</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">requires</span> [(arguments)] &#123;<br>[SFINAE contrain]; <span class=\"hljs-comment\">// or</span><br><span class=\"hljs-keyword\">requires</span> [predicate];<br>&#125; -&gt; <span class=\"hljs-type\">bool</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">concept</span> MyConcept = <span class=\"hljs-built_in\">requires</span> (T a, T b) &#123; <span class=\"hljs-comment\">// First case: SFINAE constrains</span><br>a + b; <span class=\"hljs-comment\">// Req. 1 - support add operator</span><br>a[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// Req. 2 - support subscript operator</span><br>a.x; <span class=\"hljs-comment\">// Req. 3 - has &quot;x&quot; data member</span><br>a.<span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">// Req. 4 - has &quot;f&quot; function member</span><br><span class=\"hljs-keyword\">typename</span> T::type; <span class=\"hljs-comment\">// Req. 5 - has &quot;type&quot; field</span><br>&#125;;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;concept&gt;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">concept</span> MyConcept2 = <span class=\"hljs-built_in\">requires</span> (T a, T b) &#123;<br>&#123;*a + <span class=\"hljs-number\">1</span>&#125; -&gt; std::convertible_to&lt;<span class=\"hljs-type\">float</span>&gt;; <span class=\"hljs-comment\">// Req. 6 - can be deferred and the sum</span><br><span class=\"hljs-comment\">// with an integer is convertible</span><br><span class=\"hljs-comment\">// to float</span><br>&#123;a * a&#125; -&gt; std::same_as&lt;<span class=\"hljs-type\">int</span>&gt;; <span class=\"hljs-comment\">// Req. 7 - &quot;a * a&quot; must be valid and</span><br><span class=\"hljs-comment\">// the result type is &quot;int&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"requires-Clause-Expression\"><a href=\"#requires-Clause-Expression\" class=\"headerlink\" title=\"requires Clause + Expression\"></a>requires Clause + Expression</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T a)</span> <span class=\"hljs-keyword\">requires</span> <span class=\"hljs-keyword\">requires</span> </span>&#123; T::value; &#125;<br><span class=\"hljs-comment\">// clause -&gt; SFINAE followed by</span><br><span class=\"hljs-comment\">// expression -&gt; bool (zero args)</span><br>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">increment</span><span class=\"hljs-params\">(T a)</span> <span class=\"hljs-keyword\">requires</span> <span class=\"hljs-title\">requires</span> <span class=\"hljs-params\">(T x)</span> </span>&#123; x + <span class=\"hljs-number\">1</span>; &#125;<br><span class=\"hljs-comment\">// clause -&gt; SFINAE followed by</span><br><span class=\"hljs-comment\">// expression -&gt; bool (one arg)</span><br>&#123;<br><span class=\"hljs-keyword\">return</span> a + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h1><h2 id=\"利用特例化判断类型是否一致\"><a href=\"#利用特例化判断类型是否一致\" class=\"headerlink\" title=\"利用特例化判断类型是否一致\"></a>利用特例化判断类型是否一致</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> R&gt; <span class=\"hljs-comment\">// GENERIC template declaration</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_same</span> &#123;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">bool</span> value = <span class=\"hljs-literal\">false</span>;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_same</span>&lt;T, T&gt; &#123; <span class=\"hljs-comment\">// PARTIAL template specialization</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">bool</span> value = <span class=\"hljs-literal\">true</span>;<br>&#125;;<br>cout &lt;&lt; is_same&lt; <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>&gt;::value; <span class=\"hljs-comment\">// print false, generic template</span><br>cout &lt;&lt; is_same&lt;<span class=\"hljs-type\">float</span>, <span class=\"hljs-type\">float</span>&gt;::value; <span class=\"hljs-comment\">// print true, partial template</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"利用特例化判断const指针\"><a href=\"#利用特例化判断const指针\" class=\"headerlink\" title=\"利用特例化判断const指针\"></a>利用特例化判断const指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span></span><br><span class=\"hljs-comment\">// std::true type and std::false type contain a field &quot;value&quot;</span><br><span class=\"hljs-comment\">// set to true or false respectively</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_const_pointer</span> : std::false_type &#123;&#125;; <span class=\"hljs-comment\">// GENERIC template declaration</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R&gt; <span class=\"hljs-comment\">// PARTIAL specialization</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">is_const_pointer</span>&lt;<span class=\"hljs-type\">const</span> R*&gt; : std::true_type &#123;&#125;;<br>cout &lt;&lt; is_const_pointer&lt;<span class=\"hljs-type\">int</span>*&gt;::value; <span class=\"hljs-comment\">// print false, generic template</span><br>cout &lt;&lt; is_const_pointer&lt;<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>*&gt;::value; <span class=\"hljs-comment\">// print true, partial template</span><br>cout &lt;&lt; is_const_pointer&lt;<span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span>&gt;::value; <span class=\"hljs-comment\">// print false, generic template</span><br></code></pre></td></tr></table></figure>\n"},{"title":"translation_unit","date":"2024-03-30T09:46:13.000Z","index_img":"/images/units_translate.jpg","banner_img":"/images/units_translate.jpg","_content":"\n# 编译过程\n![](/images/compile_process.png)\n# static\n- static修饰的全局变量或函数旨在当前文件可见属于内部链接\n- 非static修饰的全局变量和函数在不同编译单元，如果有相同的名字，会产生编译错误\n- static的局部变量的是否内外部连接依赖于所在函数的连接属性\n# extern\n- extern修饰的变量或函数必须定义在唯一一个编译单元\n- 函数默认就是extern，无需加extern修饰符\n# const和constexpr\n- const和constexpr变量是内部连接(inline修饰符除外)\n- const变量在不同编译单元，有不同的地址\n- 最好不要和inline一起用，尽管会使const成external linkage,但会造成可能undefined behaviour\n# inline\n- inline修饰的函数或变量，可以被多次包含而不被编译器报重定义错误\n- inline entities cannot be exported, namely, used by other translation units even\nif they have external linkage (related warning: -Wundefined-inline )\n- inline doesn’t mean that the compiler is forced to perform function inlining. It\njust increases the optimization heuristic threshold\n\n# namespace\n- 匿名的namespace是内部连接\n# No Linkage\n- 局部变量（非static）\n- 函数\n- 类\n# Internal Linkage\n- static 全局变量\n- const或constexpr(non-inline,non-template,non-specialized,non-extern)\n- static 函数\n- 匿名namespace内的所有内容包括类\n# External Linkage\n- 没修饰符的全局变量(extern除外)\n- template/specialized的全局变量\n- inline的全局变量 const????????\n- 没有修饰符的函数\n- template/specialized的函数\n- 枚举，类以及它们的静态、非静态成员\n# ODR\n## Rules\n1) In any (single) translation unit, a template, type, function, or object, cannot\nhave more than one definition\n- Compiler error otherwise\n- Any number of declarations are allowed\n2) In the entire program, an object or non-inline function cannot have more\nthan one definition\n- Multiple definitions linking error otherwise\n- Entities with internal linkage in different translation units are allowed, even if their\nnames and types are the same\n3) A template, type, or inline functions/variables, can be defined in more than\none translation unit. For a given entity, each definition must be the same\n- Undefined behavior otherwise(为啥不报错误)\n- Common case: same header included in multiple translation units\n## 编译器辅助flag\n以下flag可以帮助检查rule\n- -detect-odr-violations flag for gold/llvm linker\n- -Wodr -flto flag for GCC\n- Clang address sanitizer + ASAN OPTIONS=detect odr violation=2\n## UnknownTitle\n- 模板，类型或inline 函数和变量可以在不同单元定义(定义肯定是一样的，最简单例子头文件可被多个文件包含)\n  - 连接器会移除inline/template多余的定义\n  - inline / template entities have the same linkage as the corresponding variables/functions without the specifier\n  - inline / template entities have a unique memory address across all translation units\n## function template case\n- case 1\n```C++\n//==========================\nheader.hpp:\ntemplate<typename T>\nvoid f(T x) {}; // DECLARATION and DEFINITION\n//===========================\nmain.cpp:\n# include \"header.hpp\"\nint main() {\nf(3); // call f<int>()\nf(3.3f); // call f<float>()\nf('a'); // call f<char>()\n}\n//=====================================================\nsource.cpp:\n# include \"header.hpp\"\nvoid h() {\nf(3); // call f<int>()\nf(3.3f); // call f<float>()\nf('a'); // call f<char>()\n}\n//=====================================================\nf<int>() , f<float>() , f<char>() are generated two times (in both translation units)\n```\n- case 2\n```C++\n//==================================\nheader.hpp:\ntemplate<typename T>\nvoid f(T x); // DECLARATION\n//=================================\nmain.cpp:\n# include \"header.hpp\"\nint main() {\nf(3); // call f<int>()\nf(3.3f); // call f<float>()\n// f('a'); // linking error\n} // the specialization does not exist\n//=================================\nsource.cpp:\n# include \"header.hpp\"\ntemplate<typename T>\nvoid f(T x) {} // DEFINITION\n// template SPECIALIZATION\ntemplate void f<int>(int);\ntemplate void f<float>(float);\n// any explicit instance is also\n// fine, e.g. f<int>(3)\n```\n- case 3\n```C++\n//==================================\nheader.hpp:\ntemplate<typename T>\nvoid f() {} // DECLARATION and DEFINITION\n//==================================\nmain.cpp:\n# include \"header.hpp\"\nint main() {\nf<char>(); // use the generic function\nf<int>(); // use the specialization\n}\n//=================================\nsource.cpp:\n# include \"header.hpp\"\ntemplate<>\nvoid f<int>() {} // SPECIALIZATION\n// DEFINITION\n```\n- case 4\n```C++\n//===============================\nheader.hpp:\ntemplate<typename T>\nvoid f() {} // DECLARATION and DEFINITION\n//============================\nmain.cpp:\n# include \"header.hpp\"\nextern template void f<int>();\n// f<int>() is not generated by the\n// compiler in this translation unit\nint main() {\nf<int>();\n}\n//==========================\nsource.cpp:\n# include \"header.hpp\"\nvoid g() {\nf<int>();\n}\n// or 'template void f<int>(int);'\n```\n- case 5\n```C++\n//===================\nheader.hpp:\ntemplate<typename T>\nvoid f(); // DECLARATION\n// template<> // linking error\n// void f<int>() {} // multiple definitions -> included twice\n// full specializations are like standard functions\n// it can be solved by adding \"inline\"\n//===================\nmain.cpp:\n# include \"header.hpp\"\nint main() {}\n//=====================\nsource.cpp:\n# include \"header.hpp\"\n// some code\n```\n## class template case\n- case 1\n```C++\n//=====================header.hpp:\ntemplate<typename T>\nstruct A {\nT x = 3; // \"inline\" DEFINITION\nvoid f() {}; // \"inline\" DEFINITION\n};\n//====================main.cpp:\n# include \"header.hpp\"\nint main() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n}\n//===================source.cpp:\n# include \"header.hpp\"\nint g() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n}\n```\n- case 2\n```C++\n//==========================header.hpp:\ntemplate<typename T>\nstruct A {\nT x;\nvoid f(); // DECLARATION\n};\n# include \"header.i.hpp\"\n//==========================header.i.hpp:\ntemplate<typename T>\nT A<T>::x = 3; // DEFINITION\ntemplate<typename T>\nvoid A<T>::f() {} // DEFINITION\n//==========================main.cpp:\n# include \"header.hpp\"\nint main() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n}\n//==========================source.cpp:\n# include \"header.hpp\"\nint g() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n} \n```\n- case 3\n```C++\n//============================header.hpp:\ntemplate<typename T>\nstruct A {\nT x;\nvoid f(); // DECLARATION\n};\n//============================main.cpp:\n# include \"header.hpp\"\nint main() {\nA<int> a1; // ok\n// A<char> a2; // linking error\n} // 'f()' is undefined\n// while 'x' has an undefined\n// value for A<char>\nsource.cpp:\n# include \"header.hpp\"\ntemplate<typename T>\nint A<T>::x = 3; // initialization\ntemplate<typename T>\nvoid A<T>::f() {} // DEFINITION\n// generate template special\ntemplate class A<int>;\n```\n\n# notes\n- If the same identifier within a translation unit appears with both internal and external linkage,\nthe behavior is undefined\n- inline , constexpr (which implies inline for functions) functions are not\naccessible by other translation units even with external linkage\n","source":"_posts/translation-unit.md","raw":"---\ntitle: translation_unit\ndate: 2024-03-30 17:46:13\ntags:\nindex_img: /images/units_translate.jpg\nbanner_img: /images/units_translate.jpg\n---\n\n# 编译过程\n![](/images/compile_process.png)\n# static\n- static修饰的全局变量或函数旨在当前文件可见属于内部链接\n- 非static修饰的全局变量和函数在不同编译单元，如果有相同的名字，会产生编译错误\n- static的局部变量的是否内外部连接依赖于所在函数的连接属性\n# extern\n- extern修饰的变量或函数必须定义在唯一一个编译单元\n- 函数默认就是extern，无需加extern修饰符\n# const和constexpr\n- const和constexpr变量是内部连接(inline修饰符除外)\n- const变量在不同编译单元，有不同的地址\n- 最好不要和inline一起用，尽管会使const成external linkage,但会造成可能undefined behaviour\n# inline\n- inline修饰的函数或变量，可以被多次包含而不被编译器报重定义错误\n- inline entities cannot be exported, namely, used by other translation units even\nif they have external linkage (related warning: -Wundefined-inline )\n- inline doesn’t mean that the compiler is forced to perform function inlining. It\njust increases the optimization heuristic threshold\n\n# namespace\n- 匿名的namespace是内部连接\n# No Linkage\n- 局部变量（非static）\n- 函数\n- 类\n# Internal Linkage\n- static 全局变量\n- const或constexpr(non-inline,non-template,non-specialized,non-extern)\n- static 函数\n- 匿名namespace内的所有内容包括类\n# External Linkage\n- 没修饰符的全局变量(extern除外)\n- template/specialized的全局变量\n- inline的全局变量 const????????\n- 没有修饰符的函数\n- template/specialized的函数\n- 枚举，类以及它们的静态、非静态成员\n# ODR\n## Rules\n1) In any (single) translation unit, a template, type, function, or object, cannot\nhave more than one definition\n- Compiler error otherwise\n- Any number of declarations are allowed\n2) In the entire program, an object or non-inline function cannot have more\nthan one definition\n- Multiple definitions linking error otherwise\n- Entities with internal linkage in different translation units are allowed, even if their\nnames and types are the same\n3) A template, type, or inline functions/variables, can be defined in more than\none translation unit. For a given entity, each definition must be the same\n- Undefined behavior otherwise(为啥不报错误)\n- Common case: same header included in multiple translation units\n## 编译器辅助flag\n以下flag可以帮助检查rule\n- -detect-odr-violations flag for gold/llvm linker\n- -Wodr -flto flag for GCC\n- Clang address sanitizer + ASAN OPTIONS=detect odr violation=2\n## UnknownTitle\n- 模板，类型或inline 函数和变量可以在不同单元定义(定义肯定是一样的，最简单例子头文件可被多个文件包含)\n  - 连接器会移除inline/template多余的定义\n  - inline / template entities have the same linkage as the corresponding variables/functions without the specifier\n  - inline / template entities have a unique memory address across all translation units\n## function template case\n- case 1\n```C++\n//==========================\nheader.hpp:\ntemplate<typename T>\nvoid f(T x) {}; // DECLARATION and DEFINITION\n//===========================\nmain.cpp:\n# include \"header.hpp\"\nint main() {\nf(3); // call f<int>()\nf(3.3f); // call f<float>()\nf('a'); // call f<char>()\n}\n//=====================================================\nsource.cpp:\n# include \"header.hpp\"\nvoid h() {\nf(3); // call f<int>()\nf(3.3f); // call f<float>()\nf('a'); // call f<char>()\n}\n//=====================================================\nf<int>() , f<float>() , f<char>() are generated two times (in both translation units)\n```\n- case 2\n```C++\n//==================================\nheader.hpp:\ntemplate<typename T>\nvoid f(T x); // DECLARATION\n//=================================\nmain.cpp:\n# include \"header.hpp\"\nint main() {\nf(3); // call f<int>()\nf(3.3f); // call f<float>()\n// f('a'); // linking error\n} // the specialization does not exist\n//=================================\nsource.cpp:\n# include \"header.hpp\"\ntemplate<typename T>\nvoid f(T x) {} // DEFINITION\n// template SPECIALIZATION\ntemplate void f<int>(int);\ntemplate void f<float>(float);\n// any explicit instance is also\n// fine, e.g. f<int>(3)\n```\n- case 3\n```C++\n//==================================\nheader.hpp:\ntemplate<typename T>\nvoid f() {} // DECLARATION and DEFINITION\n//==================================\nmain.cpp:\n# include \"header.hpp\"\nint main() {\nf<char>(); // use the generic function\nf<int>(); // use the specialization\n}\n//=================================\nsource.cpp:\n# include \"header.hpp\"\ntemplate<>\nvoid f<int>() {} // SPECIALIZATION\n// DEFINITION\n```\n- case 4\n```C++\n//===============================\nheader.hpp:\ntemplate<typename T>\nvoid f() {} // DECLARATION and DEFINITION\n//============================\nmain.cpp:\n# include \"header.hpp\"\nextern template void f<int>();\n// f<int>() is not generated by the\n// compiler in this translation unit\nint main() {\nf<int>();\n}\n//==========================\nsource.cpp:\n# include \"header.hpp\"\nvoid g() {\nf<int>();\n}\n// or 'template void f<int>(int);'\n```\n- case 5\n```C++\n//===================\nheader.hpp:\ntemplate<typename T>\nvoid f(); // DECLARATION\n// template<> // linking error\n// void f<int>() {} // multiple definitions -> included twice\n// full specializations are like standard functions\n// it can be solved by adding \"inline\"\n//===================\nmain.cpp:\n# include \"header.hpp\"\nint main() {}\n//=====================\nsource.cpp:\n# include \"header.hpp\"\n// some code\n```\n## class template case\n- case 1\n```C++\n//=====================header.hpp:\ntemplate<typename T>\nstruct A {\nT x = 3; // \"inline\" DEFINITION\nvoid f() {}; // \"inline\" DEFINITION\n};\n//====================main.cpp:\n# include \"header.hpp\"\nint main() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n}\n//===================source.cpp:\n# include \"header.hpp\"\nint g() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n}\n```\n- case 2\n```C++\n//==========================header.hpp:\ntemplate<typename T>\nstruct A {\nT x;\nvoid f(); // DECLARATION\n};\n# include \"header.i.hpp\"\n//==========================header.i.hpp:\ntemplate<typename T>\nT A<T>::x = 3; // DEFINITION\ntemplate<typename T>\nvoid A<T>::f() {} // DEFINITION\n//==========================main.cpp:\n# include \"header.hpp\"\nint main() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n}\n//==========================source.cpp:\n# include \"header.hpp\"\nint g() {\nA<int> a1; // ok\nA<float> a2; // ok\nA<char> a3; // ok\n} \n```\n- case 3\n```C++\n//============================header.hpp:\ntemplate<typename T>\nstruct A {\nT x;\nvoid f(); // DECLARATION\n};\n//============================main.cpp:\n# include \"header.hpp\"\nint main() {\nA<int> a1; // ok\n// A<char> a2; // linking error\n} // 'f()' is undefined\n// while 'x' has an undefined\n// value for A<char>\nsource.cpp:\n# include \"header.hpp\"\ntemplate<typename T>\nint A<T>::x = 3; // initialization\ntemplate<typename T>\nvoid A<T>::f() {} // DEFINITION\n// generate template special\ntemplate class A<int>;\n```\n\n# notes\n- If the same identifier within a translation unit appears with both internal and external linkage,\nthe behavior is undefined\n- inline , constexpr (which implies inline for functions) functions are not\naccessible by other translation units even with external linkage\n","slug":"translation-unit","published":1,"updated":"2024-03-30T12:10:42.445Z","comments":1,"layout":"post","photos":[],"_id":"clue1wng00001qoq29zfh47x4","content":"<h1 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h1><p><img src=\"/images/compile_process.png\"></p>\n<h1 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h1><ul>\n<li>static修饰的全局变量或函数旨在当前文件可见属于内部链接</li>\n<li>非static修饰的全局变量和函数在不同编译单元，如果有相同的名字，会产生编译错误</li>\n<li>static的局部变量的是否内外部连接依赖于所在函数的连接属性</li>\n</ul>\n<h1 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h1><ul>\n<li>extern修饰的变量或函数必须定义在唯一一个编译单元</li>\n<li>函数默认就是extern，无需加extern修饰符</li>\n</ul>\n<h1 id=\"const和constexpr\"><a href=\"#const和constexpr\" class=\"headerlink\" title=\"const和constexpr\"></a>const和constexpr</h1><ul>\n<li>const和constexpr变量是内部连接(inline修饰符除外)</li>\n<li>const变量在不同编译单元，有不同的地址</li>\n<li>最好不要和inline一起用，尽管会使const成external linkage,但会造成可能undefined behaviour</li>\n</ul>\n<h1 id=\"inline\"><a href=\"#inline\" class=\"headerlink\" title=\"inline\"></a>inline</h1><ul>\n<li>inline修饰的函数或变量，可以被多次包含而不被编译器报重定义错误</li>\n<li>inline entities cannot be exported, namely, used by other translation units even<br>if they have external linkage (related warning: -Wundefined-inline )</li>\n<li>inline doesn’t mean that the compiler is forced to perform function inlining. It<br>just increases the optimization heuristic threshold</li>\n</ul>\n<h1 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h1><ul>\n<li>匿名的namespace是内部连接</li>\n</ul>\n<h1 id=\"No-Linkage\"><a href=\"#No-Linkage\" class=\"headerlink\" title=\"No Linkage\"></a>No Linkage</h1><ul>\n<li>局部变量（非static）</li>\n<li>函数</li>\n<li>类</li>\n</ul>\n<h1 id=\"Internal-Linkage\"><a href=\"#Internal-Linkage\" class=\"headerlink\" title=\"Internal Linkage\"></a>Internal Linkage</h1><ul>\n<li>static 全局变量</li>\n<li>const或constexpr(non-inline,non-template,non-specialized,non-extern)</li>\n<li>static 函数</li>\n<li>匿名namespace内的所有内容包括类</li>\n</ul>\n<h1 id=\"External-Linkage\"><a href=\"#External-Linkage\" class=\"headerlink\" title=\"External Linkage\"></a>External Linkage</h1><ul>\n<li>没修饰符的全局变量(extern除外)</li>\n<li>template&#x2F;specialized的全局变量</li>\n<li>inline的全局变量 const????????</li>\n<li>没有修饰符的函数</li>\n<li>template&#x2F;specialized的函数</li>\n<li>枚举，类以及它们的静态、非静态成员</li>\n</ul>\n<h1 id=\"ODR\"><a href=\"#ODR\" class=\"headerlink\" title=\"ODR\"></a>ODR</h1><h2 id=\"Rules\"><a href=\"#Rules\" class=\"headerlink\" title=\"Rules\"></a>Rules</h2><ol>\n<li>In any (single) translation unit, a template, type, function, or object, cannot<br>have more than one definition</li>\n</ol>\n<ul>\n<li>Compiler error otherwise</li>\n<li>Any number of declarations are allowed</li>\n</ul>\n<ol start=\"2\">\n<li>In the entire program, an object or non-inline function cannot have more<br>than one definition</li>\n</ol>\n<ul>\n<li>Multiple definitions linking error otherwise</li>\n<li>Entities with internal linkage in different translation units are allowed, even if their<br>names and types are the same</li>\n</ul>\n<ol start=\"3\">\n<li>A template, type, or inline functions&#x2F;variables, can be defined in more than<br>one translation unit. For a given entity, each definition must be the same</li>\n</ol>\n<ul>\n<li>Undefined behavior otherwise(为啥不报错误)</li>\n<li>Common case: same header included in multiple translation units</li>\n</ul>\n<h2 id=\"编译器辅助flag\"><a href=\"#编译器辅助flag\" class=\"headerlink\" title=\"编译器辅助flag\"></a>编译器辅助flag</h2><p>以下flag可以帮助检查rule</p>\n<ul>\n<li>-detect-odr-violations flag for gold&#x2F;llvm linker</li>\n<li>-Wodr -flto flag for GCC</li>\n<li>Clang address sanitizer + ASAN OPTIONS&#x3D;detect odr violation&#x3D;2</li>\n</ul>\n<h2 id=\"UnknownTitle\"><a href=\"#UnknownTitle\" class=\"headerlink\" title=\"UnknownTitle\"></a>UnknownTitle</h2><ul>\n<li>模板，类型或inline 函数和变量可以在不同单元定义(定义肯定是一样的，最简单例子头文件可被多个文件包含)<ul>\n<li>连接器会移除inline&#x2F;template多余的定义</li>\n<li>inline &#x2F; template entities have the same linkage as the corresponding variables&#x2F;functions without the specifier</li>\n<li>inline &#x2F; template entities have a unique memory address across all translation units</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"function-template-case\"><a href=\"#function-template-case\" class=\"headerlink\" title=\"function template case\"></a>function template case</h2><ul>\n<li>case 1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==========================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T x)</span> </span>&#123;&#125;; <span class=\"hljs-comment\">// DECLARATION and DEFINITION</span><br><span class=\"hljs-comment\">//===========================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// call f&lt;int&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3.3f</span>); <span class=\"hljs-comment\">// call f&lt;float&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// call f&lt;char&gt;()</span><br>&#125;<br><span class=\"hljs-comment\">//=====================================================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// call f&lt;int&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3.3f</span>); <span class=\"hljs-comment\">// call f&lt;float&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// call f&lt;char&gt;()</span><br>&#125;<br><span class=\"hljs-comment\">//=====================================================</span><br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;() , <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">float</span>&gt;() , <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">char</span>&gt;() <span class=\"hljs-function\">are generated two <span class=\"hljs-title\">times</span> <span class=\"hljs-params\">(in both translation units)</span></span><br></code></pre></td></tr></table></figure></li>\n<li>case 2<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==================================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T x)</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br><span class=\"hljs-comment\">//=================================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// call f&lt;int&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3.3f</span>); <span class=\"hljs-comment\">// call f&lt;float&gt;()</span><br><span class=\"hljs-comment\">// f(&#x27;a&#x27;); // linking error</span><br>&#125; <span class=\"hljs-comment\">// the specialization does not exist</span><br><span class=\"hljs-comment\">//=================================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T x)</span> </span>&#123;&#125; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-comment\">// template SPECIALIZATION</span><br><span class=\"hljs-keyword\">template</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-type\">int</span>);<br><span class=\"hljs-keyword\">template</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">float</span>&gt;(<span class=\"hljs-type\">float</span>);<br><span class=\"hljs-comment\">// any explicit instance is also</span><br><span class=\"hljs-comment\">// fine, e.g. f&lt;int&gt;(3)</span><br></code></pre></td></tr></table></figure></li>\n<li>case 3<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==================================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// DECLARATION and DEFINITION</span><br><span class=\"hljs-comment\">//==================================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">char</span>&gt;(); <span class=\"hljs-comment\">// use the generic function</span><br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;(); <span class=\"hljs-comment\">// use the specialization</span><br>&#125;<br><span class=\"hljs-comment\">//=================================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;() &#123;&#125; <span class=\"hljs-comment\">// SPECIALIZATION</span><br><span class=\"hljs-comment\">// DEFINITION</span><br></code></pre></td></tr></table></figure></li>\n<li>case 4<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//===============================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// DECLARATION and DEFINITION</span><br><span class=\"hljs-comment\">//============================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">template</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;();<br><span class=\"hljs-comment\">// f&lt;int&gt;() is not generated by the</span><br><span class=\"hljs-comment\">// compiler in this translation unit</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;();<br>&#125;<br><span class=\"hljs-comment\">//==========================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;();<br>&#125;<br><span class=\"hljs-comment\">// or &#x27;template void f&lt;int&gt;(int);&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>case 5<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//===================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br><span class=\"hljs-comment\">// template&lt;&gt; // linking error</span><br><span class=\"hljs-comment\">// void f&lt;int&gt;() &#123;&#125; // multiple definitions -&gt; included twice</span><br><span class=\"hljs-comment\">// full specializations are like standard functions</span><br><span class=\"hljs-comment\">// it can be solved by adding &quot;inline&quot;</span><br><span class=\"hljs-comment\">//===================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><span class=\"hljs-comment\">//=====================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-comment\">// some code</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"class-template-case\"><a href=\"#class-template-case\" class=\"headerlink\" title=\"class template case\"></a>class template case</h2><ul>\n<li>case 1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//=====================header.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>T x = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// &quot;inline&quot; DEFINITION</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;; <span class=\"hljs-comment\">// &quot;inline&quot; DEFINITION</span><br>&#125;;<br><span class=\"hljs-comment\">//====================main.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125;<br><span class=\"hljs-comment\">//===================source.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>case 2<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==========================header.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>T x;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br>&#125;;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.i.hpp&quot;</span></span><br><span class=\"hljs-comment\">//==========================header.i.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br>T A&lt;T&gt;::x = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-type\">void</span> A&lt;T&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-comment\">//==========================main.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125;<br><span class=\"hljs-comment\">//==========================source.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125; <br></code></pre></td></tr></table></figure></li>\n<li>case 3<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//============================header.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>T x;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br>&#125;;<br><span class=\"hljs-comment\">//============================main.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br><span class=\"hljs-comment\">// A&lt;char&gt; a2; // linking error</span><br>&#125; <span class=\"hljs-comment\">// &#x27;f()&#x27; is undefined</span><br><span class=\"hljs-comment\">// while &#x27;x&#x27; has an undefined</span><br><span class=\"hljs-comment\">// value for A&lt;char&gt;</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-type\">int</span> A&lt;T&gt;::x = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// initialization</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-type\">void</span> A&lt;T&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-comment\">// generate template special</span><br><span class=\"hljs-keyword\">template</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>&lt;<span class=\"hljs-type\">int</span>&gt;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"notes\"><a href=\"#notes\" class=\"headerlink\" title=\"notes\"></a>notes</h1><ul>\n<li>If the same identifier within a translation unit appears with both internal and external linkage,<br>the behavior is undefined</li>\n<li>inline , constexpr (which implies inline for functions) functions are not<br>accessible by other translation units even with external linkage</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h1><p><img src=\"/images/compile_process.png\"></p>\n<h1 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h1><ul>\n<li>static修饰的全局变量或函数旨在当前文件可见属于内部链接</li>\n<li>非static修饰的全局变量和函数在不同编译单元，如果有相同的名字，会产生编译错误</li>\n<li>static的局部变量的是否内外部连接依赖于所在函数的连接属性</li>\n</ul>\n<h1 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h1><ul>\n<li>extern修饰的变量或函数必须定义在唯一一个编译单元</li>\n<li>函数默认就是extern，无需加extern修饰符</li>\n</ul>\n<h1 id=\"const和constexpr\"><a href=\"#const和constexpr\" class=\"headerlink\" title=\"const和constexpr\"></a>const和constexpr</h1><ul>\n<li>const和constexpr变量是内部连接(inline修饰符除外)</li>\n<li>const变量在不同编译单元，有不同的地址</li>\n<li>最好不要和inline一起用，尽管会使const成external linkage,但会造成可能undefined behaviour</li>\n</ul>\n<h1 id=\"inline\"><a href=\"#inline\" class=\"headerlink\" title=\"inline\"></a>inline</h1><ul>\n<li>inline修饰的函数或变量，可以被多次包含而不被编译器报重定义错误</li>\n<li>inline entities cannot be exported, namely, used by other translation units even<br>if they have external linkage (related warning: -Wundefined-inline )</li>\n<li>inline doesn’t mean that the compiler is forced to perform function inlining. It<br>just increases the optimization heuristic threshold</li>\n</ul>\n<h1 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h1><ul>\n<li>匿名的namespace是内部连接</li>\n</ul>\n<h1 id=\"No-Linkage\"><a href=\"#No-Linkage\" class=\"headerlink\" title=\"No Linkage\"></a>No Linkage</h1><ul>\n<li>局部变量（非static）</li>\n<li>函数</li>\n<li>类</li>\n</ul>\n<h1 id=\"Internal-Linkage\"><a href=\"#Internal-Linkage\" class=\"headerlink\" title=\"Internal Linkage\"></a>Internal Linkage</h1><ul>\n<li>static 全局变量</li>\n<li>const或constexpr(non-inline,non-template,non-specialized,non-extern)</li>\n<li>static 函数</li>\n<li>匿名namespace内的所有内容包括类</li>\n</ul>\n<h1 id=\"External-Linkage\"><a href=\"#External-Linkage\" class=\"headerlink\" title=\"External Linkage\"></a>External Linkage</h1><ul>\n<li>没修饰符的全局变量(extern除外)</li>\n<li>template&#x2F;specialized的全局变量</li>\n<li>inline的全局变量 const????????</li>\n<li>没有修饰符的函数</li>\n<li>template&#x2F;specialized的函数</li>\n<li>枚举，类以及它们的静态、非静态成员</li>\n</ul>\n<h1 id=\"ODR\"><a href=\"#ODR\" class=\"headerlink\" title=\"ODR\"></a>ODR</h1><h2 id=\"Rules\"><a href=\"#Rules\" class=\"headerlink\" title=\"Rules\"></a>Rules</h2><ol>\n<li>In any (single) translation unit, a template, type, function, or object, cannot<br>have more than one definition</li>\n</ol>\n<ul>\n<li>Compiler error otherwise</li>\n<li>Any number of declarations are allowed</li>\n</ul>\n<ol start=\"2\">\n<li>In the entire program, an object or non-inline function cannot have more<br>than one definition</li>\n</ol>\n<ul>\n<li>Multiple definitions linking error otherwise</li>\n<li>Entities with internal linkage in different translation units are allowed, even if their<br>names and types are the same</li>\n</ul>\n<ol start=\"3\">\n<li>A template, type, or inline functions&#x2F;variables, can be defined in more than<br>one translation unit. For a given entity, each definition must be the same</li>\n</ol>\n<ul>\n<li>Undefined behavior otherwise(为啥不报错误)</li>\n<li>Common case: same header included in multiple translation units</li>\n</ul>\n<h2 id=\"编译器辅助flag\"><a href=\"#编译器辅助flag\" class=\"headerlink\" title=\"编译器辅助flag\"></a>编译器辅助flag</h2><p>以下flag可以帮助检查rule</p>\n<ul>\n<li>-detect-odr-violations flag for gold&#x2F;llvm linker</li>\n<li>-Wodr -flto flag for GCC</li>\n<li>Clang address sanitizer + ASAN OPTIONS&#x3D;detect odr violation&#x3D;2</li>\n</ul>\n<h2 id=\"UnknownTitle\"><a href=\"#UnknownTitle\" class=\"headerlink\" title=\"UnknownTitle\"></a>UnknownTitle</h2><ul>\n<li>模板，类型或inline 函数和变量可以在不同单元定义(定义肯定是一样的，最简单例子头文件可被多个文件包含)<ul>\n<li>连接器会移除inline&#x2F;template多余的定义</li>\n<li>inline &#x2F; template entities have the same linkage as the corresponding variables&#x2F;functions without the specifier</li>\n<li>inline &#x2F; template entities have a unique memory address across all translation units</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"function-template-case\"><a href=\"#function-template-case\" class=\"headerlink\" title=\"function template case\"></a>function template case</h2><ul>\n<li>case 1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==========================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T x)</span> </span>&#123;&#125;; <span class=\"hljs-comment\">// DECLARATION and DEFINITION</span><br><span class=\"hljs-comment\">//===========================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// call f&lt;int&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3.3f</span>); <span class=\"hljs-comment\">// call f&lt;float&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// call f&lt;char&gt;()</span><br>&#125;<br><span class=\"hljs-comment\">//=====================================================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">h</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// call f&lt;int&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3.3f</span>); <span class=\"hljs-comment\">// call f&lt;float&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// call f&lt;char&gt;()</span><br>&#125;<br><span class=\"hljs-comment\">//=====================================================</span><br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;() , <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">float</span>&gt;() , <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">char</span>&gt;() <span class=\"hljs-function\">are generated two <span class=\"hljs-title\">times</span> <span class=\"hljs-params\">(in both translation units)</span></span><br></code></pre></td></tr></table></figure></li>\n<li>case 2<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==================================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T x)</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br><span class=\"hljs-comment\">//=================================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// call f&lt;int&gt;()</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">3.3f</span>); <span class=\"hljs-comment\">// call f&lt;float&gt;()</span><br><span class=\"hljs-comment\">// f(&#x27;a&#x27;); // linking error</span><br>&#125; <span class=\"hljs-comment\">// the specialization does not exist</span><br><span class=\"hljs-comment\">//=================================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(T x)</span> </span>&#123;&#125; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-comment\">// template SPECIALIZATION</span><br><span class=\"hljs-keyword\">template</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-type\">int</span>);<br><span class=\"hljs-keyword\">template</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">float</span>&gt;(<span class=\"hljs-type\">float</span>);<br><span class=\"hljs-comment\">// any explicit instance is also</span><br><span class=\"hljs-comment\">// fine, e.g. f&lt;int&gt;(3)</span><br></code></pre></td></tr></table></figure></li>\n<li>case 3<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==================================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// DECLARATION and DEFINITION</span><br><span class=\"hljs-comment\">//==================================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">char</span>&gt;(); <span class=\"hljs-comment\">// use the generic function</span><br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;(); <span class=\"hljs-comment\">// use the specialization</span><br>&#125;<br><span class=\"hljs-comment\">//=================================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;&gt;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;() &#123;&#125; <span class=\"hljs-comment\">// SPECIALIZATION</span><br><span class=\"hljs-comment\">// DEFINITION</span><br></code></pre></td></tr></table></figure></li>\n<li>case 4<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//===============================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">// DECLARATION and DEFINITION</span><br><span class=\"hljs-comment\">//============================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">template</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;();<br><span class=\"hljs-comment\">// f&lt;int&gt;() is not generated by the</span><br><span class=\"hljs-comment\">// compiler in this translation unit</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;();<br>&#125;<br><span class=\"hljs-comment\">//==========================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-built_in\">f</span>&lt;<span class=\"hljs-type\">int</span>&gt;();<br>&#125;<br><span class=\"hljs-comment\">// or &#x27;template void f&lt;int&gt;(int);&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>case 5<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//===================</span><br>header.hpp:<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br><span class=\"hljs-comment\">// template&lt;&gt; // linking error</span><br><span class=\"hljs-comment\">// void f&lt;int&gt;() &#123;&#125; // multiple definitions -&gt; included twice</span><br><span class=\"hljs-comment\">// full specializations are like standard functions</span><br><span class=\"hljs-comment\">// it can be solved by adding &quot;inline&quot;</span><br><span class=\"hljs-comment\">//===================</span><br>main.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><span class=\"hljs-comment\">//=====================</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-comment\">// some code</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"class-template-case\"><a href=\"#class-template-case\" class=\"headerlink\" title=\"class template case\"></a>class template case</h2><ul>\n<li>case 1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//=====================header.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>T x = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// &quot;inline&quot; DEFINITION</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;; <span class=\"hljs-comment\">// &quot;inline&quot; DEFINITION</span><br>&#125;;<br><span class=\"hljs-comment\">//====================main.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125;<br><span class=\"hljs-comment\">//===================source.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>case 2<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//==========================header.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>T x;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br>&#125;;<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.i.hpp&quot;</span></span><br><span class=\"hljs-comment\">//==========================header.i.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br>T A&lt;T&gt;::x = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-type\">void</span> A&lt;T&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-comment\">//==========================main.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125;<br><span class=\"hljs-comment\">//==========================source.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">float</span>&gt; a2; <span class=\"hljs-comment\">// ok</span><br>A&lt;<span class=\"hljs-type\">char</span>&gt; a3; <span class=\"hljs-comment\">// ok</span><br>&#125; <br></code></pre></td></tr></table></figure></li>\n<li>case 3<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//============================header.hpp:</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span> &#123;<br>T x;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// DECLARATION</span><br>&#125;;<br><span class=\"hljs-comment\">//============================main.cpp:</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>A&lt;<span class=\"hljs-type\">int</span>&gt; a1; <span class=\"hljs-comment\">// ok</span><br><span class=\"hljs-comment\">// A&lt;char&gt; a2; // linking error</span><br>&#125; <span class=\"hljs-comment\">// &#x27;f()&#x27; is undefined</span><br><span class=\"hljs-comment\">// while &#x27;x&#x27; has an undefined</span><br><span class=\"hljs-comment\">// value for A&lt;char&gt;</span><br>source.cpp:<br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;header.hpp&quot;</span></span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-type\">int</span> A&lt;T&gt;::x = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// initialization</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-type\">void</span> A&lt;T&gt;::<span class=\"hljs-built_in\">f</span>() &#123;&#125; <span class=\"hljs-comment\">// DEFINITION</span><br><span class=\"hljs-comment\">// generate template special</span><br><span class=\"hljs-keyword\">template</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>&lt;<span class=\"hljs-type\">int</span>&gt;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"notes\"><a href=\"#notes\" class=\"headerlink\" title=\"notes\"></a>notes</h1><ul>\n<li>If the same identifier within a translation unit appears with both internal and external linkage,<br>the behavior is undefined</li>\n<li>inline , constexpr (which implies inline for functions) functions are not<br>accessible by other translation units even with external linkage</li>\n</ul>\n"},{"title":"C++性能篇","date":"2024-04-17T19:55:26.000Z","index_img":"/images/performance.jpeg","banner_img":"/images/performance.jpeg","_content":"\n# IO\n- 尽可能使用`\\n`,而不是endl\n- `std::ios_base::sync_with_stdio(false)`,禁止与printf/scanf的同步\n- `<istream_obj>.tie(nullptr)`:Disable IO flushing when mixing istream/ostream\n- `<ifstream_obj>.rdbuf()->pubsetbuf(buffer_var,buffer_size)`:increase io buffer size\n- printf比ostream更快\n- LZ4和zstd是很快的开元库 \n# 内存\n- 在局部作用域中，static const比const更快，避免了栈分配\n# 操作\n- 尽可能常量放在一起\n- unsigned比signed更快\n- `||`比`|`更好\n- 乘法比除法更快\n- Checking if a non-negative value x is within a range [A, B] can be optimized if B > A (useful when the condition is repeated multiple times)\n- 指针用中括号操作比加法操作更好\n- 尽可能的使得symbol不全局可见，即多用匿名空间，static\n- Prefer signed integer for loop indexing. The compiler optimizes more aggressively such loops since integer overflow is not defined\n- exceptions影响性能，尽可能用noexcept\n- smart pointer影响性能\n- lambda比std::function和函数指针更好\n- 避免dynamic_cast\n- 除了以上几点尽可能用STL\n```C++\nif (x >= A && x <= B)\n// STEP 1: subtract A\nif (x - A >= A - A && x - A <= B - A)\n// -->\nif (x - A >= 0 && x - A <= B - A) // B - A is precomputed\n// STEP 2\n// - convert \"x - A >= 0\" --> (unsigned) (x - A)\n// - \"B - A\" is always positive\nif ((unsigned) (x - A) <= (unsigned) (B - A))\n```\n# 数值转换\n|From|To|Cost|\n|:-:|:-:|:-:|\n|Signed|Unsigned|no cost, bit representation is the same|\n|Unsigned|Larger Unsigned|no cost, register extended|\n|Signed|Larger Signed|1 clock-cycle, register + sign extended|\n|Integer|Floating-point|4-16 clock-cycles Signed → Floating-point is faster than Unsigned → Floating-point (except AVX512 instruction set is enabled)|\n|Floating-point|Integer|fast if SSE2, slow otherwise (50-100 clock-cycles)|\n# Compiler intrinsic functions\n编译器内提供的函数，可能缺少跨平台支持，但更好的优化，不支持的花会是很危险的\n# __restrict\n该关键字表明，这两个指针指向的内存不在同一快区域，可以使得编译器更好的优化\n```\nvoid matrix_mul_v1(const int* A,\nconst int* B,\nint N,\nint* C) {\n// below is faster\nvoid matrix_mul_v2(const int* __restrict A,\nconst int* __restrict B,\nint N,\nint* __restrict C) {\n```\n# 编译器__attribute__\n设置某些属性可以帮助编译器更好的优化\n- `__attribute__((visibility(\"hidden\")))`:效果等价于匿名空间\n- `__attribute__(always_inline)`:强制inline\n- `__attribute__(noinline)`:强制不inline\n- `__attribute__(pure)`:attribute (Clang, GCC) specifies that a function has no side effects on its parameters or program state (external global references)\n- `__attribute__(const)`:attribute (Clang, GCC) specifies that a function doesn’t depend (read) on external global references\n# gprof\nCode Instrumentation\n`g++ -pg [flags] <source_files>`\nImportant: -pg is required also for linking and it is not supported by clang\n- Run the program (it produces the file gmon.out)\n- Run gprof on gmon.out\n- `gprof -q <executable> gmon.out`可以分析出函数调用图\n# uftrace\n火焰图\n```bash\n$ gcc -pg <program>.cpp\n$ uftrace record <executable>\n$ uftrace replay\n```\n# 性能工具\n- callgrind(valgrind)\n- cachegrind\n- KCachegrind(linux)/Qcachegrind(win)\n- gprof2dot\n- perf\n- hotspot\n","source":"_posts/C-性能篇.md","raw":"---\ntitle: C++性能篇\ndate: 2024-04-18 03:55:26\ntags:\nindex_img: /images/performance.jpeg\nbanner_img: /images/performance.jpeg\n---\n\n# IO\n- 尽可能使用`\\n`,而不是endl\n- `std::ios_base::sync_with_stdio(false)`,禁止与printf/scanf的同步\n- `<istream_obj>.tie(nullptr)`:Disable IO flushing when mixing istream/ostream\n- `<ifstream_obj>.rdbuf()->pubsetbuf(buffer_var,buffer_size)`:increase io buffer size\n- printf比ostream更快\n- LZ4和zstd是很快的开元库 \n# 内存\n- 在局部作用域中，static const比const更快，避免了栈分配\n# 操作\n- 尽可能常量放在一起\n- unsigned比signed更快\n- `||`比`|`更好\n- 乘法比除法更快\n- Checking if a non-negative value x is within a range [A, B] can be optimized if B > A (useful when the condition is repeated multiple times)\n- 指针用中括号操作比加法操作更好\n- 尽可能的使得symbol不全局可见，即多用匿名空间，static\n- Prefer signed integer for loop indexing. The compiler optimizes more aggressively such loops since integer overflow is not defined\n- exceptions影响性能，尽可能用noexcept\n- smart pointer影响性能\n- lambda比std::function和函数指针更好\n- 避免dynamic_cast\n- 除了以上几点尽可能用STL\n```C++\nif (x >= A && x <= B)\n// STEP 1: subtract A\nif (x - A >= A - A && x - A <= B - A)\n// -->\nif (x - A >= 0 && x - A <= B - A) // B - A is precomputed\n// STEP 2\n// - convert \"x - A >= 0\" --> (unsigned) (x - A)\n// - \"B - A\" is always positive\nif ((unsigned) (x - A) <= (unsigned) (B - A))\n```\n# 数值转换\n|From|To|Cost|\n|:-:|:-:|:-:|\n|Signed|Unsigned|no cost, bit representation is the same|\n|Unsigned|Larger Unsigned|no cost, register extended|\n|Signed|Larger Signed|1 clock-cycle, register + sign extended|\n|Integer|Floating-point|4-16 clock-cycles Signed → Floating-point is faster than Unsigned → Floating-point (except AVX512 instruction set is enabled)|\n|Floating-point|Integer|fast if SSE2, slow otherwise (50-100 clock-cycles)|\n# Compiler intrinsic functions\n编译器内提供的函数，可能缺少跨平台支持，但更好的优化，不支持的花会是很危险的\n# __restrict\n该关键字表明，这两个指针指向的内存不在同一快区域，可以使得编译器更好的优化\n```\nvoid matrix_mul_v1(const int* A,\nconst int* B,\nint N,\nint* C) {\n// below is faster\nvoid matrix_mul_v2(const int* __restrict A,\nconst int* __restrict B,\nint N,\nint* __restrict C) {\n```\n# 编译器__attribute__\n设置某些属性可以帮助编译器更好的优化\n- `__attribute__((visibility(\"hidden\")))`:效果等价于匿名空间\n- `__attribute__(always_inline)`:强制inline\n- `__attribute__(noinline)`:强制不inline\n- `__attribute__(pure)`:attribute (Clang, GCC) specifies that a function has no side effects on its parameters or program state (external global references)\n- `__attribute__(const)`:attribute (Clang, GCC) specifies that a function doesn’t depend (read) on external global references\n# gprof\nCode Instrumentation\n`g++ -pg [flags] <source_files>`\nImportant: -pg is required also for linking and it is not supported by clang\n- Run the program (it produces the file gmon.out)\n- Run gprof on gmon.out\n- `gprof -q <executable> gmon.out`可以分析出函数调用图\n# uftrace\n火焰图\n```bash\n$ gcc -pg <program>.cpp\n$ uftrace record <executable>\n$ uftrace replay\n```\n# 性能工具\n- callgrind(valgrind)\n- cachegrind\n- KCachegrind(linux)/Qcachegrind(win)\n- gprof2dot\n- perf\n- hotspot\n","slug":"C-性能篇","published":1,"updated":"2024-06-10T14:26:09.935Z","_id":"clwnyxnda0000qzq243af04rb","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><ul>\n<li>尽可能使用<code>\\n</code>,而不是endl</li>\n<li><code>std::ios_base::sync_with_stdio(false)</code>,禁止与printf&#x2F;scanf的同步</li>\n<li><code>&lt;istream_obj&gt;.tie(nullptr)</code>:Disable IO flushing when mixing istream&#x2F;ostream</li>\n<li><code>&lt;ifstream_obj&gt;.rdbuf()-&gt;pubsetbuf(buffer_var,buffer_size)</code>:increase io buffer size</li>\n<li>printf比ostream更快</li>\n<li>LZ4和zstd是很快的开元库</li>\n</ul>\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><ul>\n<li>在局部作用域中，static const比const更快，避免了栈分配</li>\n</ul>\n<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><ul>\n<li>尽可能常量放在一起</li>\n<li>unsigned比signed更快</li>\n<li><code>||</code>比<code>|</code>更好</li>\n<li>乘法比除法更快</li>\n<li>Checking if a non-negative value x is within a range [A, B] can be optimized if B &gt; A (useful when the condition is repeated multiple times)</li>\n<li>指针用中括号操作比加法操作更好</li>\n<li>尽可能的使得symbol不全局可见，即多用匿名空间，static</li>\n<li>Prefer signed integer for loop indexing. The compiler optimizes more aggressively such loops since integer overflow is not defined</li>\n<li>exceptions影响性能，尽可能用noexcept</li>\n<li>smart pointer影响性能</li>\n<li>lambda比std::function和函数指针更好</li>\n<li>避免dynamic_cast</li>\n<li>除了以上几点尽可能用STL<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (x &gt;= A &amp;&amp; x &lt;= B)<br><span class=\"hljs-comment\">// STEP 1: subtract A</span><br><span class=\"hljs-keyword\">if</span> (x - A &gt;= A - A &amp;&amp; x - A &lt;= B - A)<br><span class=\"hljs-comment\">// --&gt;</span><br><span class=\"hljs-keyword\">if</span> (x - A &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; x - A &lt;= B - A) <span class=\"hljs-comment\">// B - A is precomputed</span><br><span class=\"hljs-comment\">// STEP 2</span><br><span class=\"hljs-comment\">// - convert &quot;x - A &gt;= 0&quot; --&gt; (unsigned) (x - A)</span><br><span class=\"hljs-comment\">// - &quot;B - A&quot; is always positive</span><br><span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">unsigned</span>) (x - A) &lt;= (<span class=\"hljs-type\">unsigned</span>) (B - A))<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h1><table>\n<thead>\n<tr>\n<th align=\"center\">From</th>\n<th align=\"center\">To</th>\n<th align=\"center\">Cost</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Signed</td>\n<td align=\"center\">Unsigned</td>\n<td align=\"center\">no cost, bit representation is the same</td>\n</tr>\n<tr>\n<td align=\"center\">Unsigned</td>\n<td align=\"center\">Larger Unsigned</td>\n<td align=\"center\">no cost, register extended</td>\n</tr>\n<tr>\n<td align=\"center\">Signed</td>\n<td align=\"center\">Larger Signed</td>\n<td align=\"center\">1 clock-cycle, register + sign extended</td>\n</tr>\n<tr>\n<td align=\"center\">Integer</td>\n<td align=\"center\">Floating-point</td>\n<td align=\"center\">4-16 clock-cycles Signed → Floating-point is faster than Unsigned → Floating-point (except AVX512 instruction set is enabled)</td>\n</tr>\n<tr>\n<td align=\"center\">Floating-point</td>\n<td align=\"center\">Integer</td>\n<td align=\"center\">fast if SSE2, slow otherwise (50-100 clock-cycles)</td>\n</tr>\n</tbody></table>\n<h1 id=\"Compiler-intrinsic-functions\"><a href=\"#Compiler-intrinsic-functions\" class=\"headerlink\" title=\"Compiler intrinsic functions\"></a>Compiler intrinsic functions</h1><p>编译器内提供的函数，可能缺少跨平台支持，但更好的优化，不支持的花会是很危险的</p>\n<h1 id=\"restrict\"><a href=\"#restrict\" class=\"headerlink\" title=\"__restrict\"></a>__restrict</h1><p>该关键字表明，这两个指针指向的内存不在同一快区域，可以使得编译器更好的优化</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">matrix_mul_v1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* A,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* B,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> N,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>* C)</span> </span>&#123;<br><span class=\"hljs-comment\">// below is faster</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">matrix_mul_v2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* __restrict A,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* __restrict B,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> N,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>* __restrict C)</span> </span>&#123;<br></code></pre></td></tr></table></figure>\n<h1 id=\"编译器-attribute\"><a href=\"#编译器-attribute\" class=\"headerlink\" title=\"编译器__attribute__\"></a>编译器__attribute__</h1><p>设置某些属性可以帮助编译器更好的优化</p>\n<ul>\n<li><code>__attribute__((visibility(&quot;hidden&quot;)))</code>:效果等价于匿名空间</li>\n<li><code>__attribute__(always_inline)</code>:强制inline</li>\n<li><code>__attribute__(noinline)</code>:强制不inline</li>\n<li><code>__attribute__(pure)</code>:attribute (Clang, GCC) specifies that a function has no side effects on its parameters or program state (external global references)</li>\n<li><code>__attribute__(const)</code>:attribute (Clang, GCC) specifies that a function doesn’t depend (read) on external global references</li>\n</ul>\n<h1 id=\"gprof\"><a href=\"#gprof\" class=\"headerlink\" title=\"gprof\"></a>gprof</h1><p>Code Instrumentation<br><code>g++ -pg [flags] &lt;source_files&gt;</code><br>Important: -pg is required also for linking and it is not supported by clang</p>\n<ul>\n<li>Run the program (it produces the file gmon.out)</li>\n<li>Run gprof on gmon.out</li>\n<li><code>gprof -q &lt;executable&gt; gmon.out</code>可以分析出函数调用图</li>\n</ul>\n<h1 id=\"uftrace\"><a href=\"#uftrace\" class=\"headerlink\" title=\"uftrace\"></a>uftrace</h1><p>火焰图</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ gcc -pg &lt;program&gt;.cpp<br>$ uftrace record &lt;executable&gt;<br>$ uftrace replay<br></code></pre></td></tr></table></figure>\n<h1 id=\"性能工具\"><a href=\"#性能工具\" class=\"headerlink\" title=\"性能工具\"></a>性能工具</h1><ul>\n<li>callgrind(valgrind)</li>\n<li>cachegrind</li>\n<li>KCachegrind(linux)&#x2F;Qcachegrind(win)</li>\n<li>gprof2dot</li>\n<li>perf</li>\n<li>hotspot</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><ul>\n<li>尽可能使用<code>\\n</code>,而不是endl</li>\n<li><code>std::ios_base::sync_with_stdio(false)</code>,禁止与printf&#x2F;scanf的同步</li>\n<li><code>&lt;istream_obj&gt;.tie(nullptr)</code>:Disable IO flushing when mixing istream&#x2F;ostream</li>\n<li><code>&lt;ifstream_obj&gt;.rdbuf()-&gt;pubsetbuf(buffer_var,buffer_size)</code>:increase io buffer size</li>\n<li>printf比ostream更快</li>\n<li>LZ4和zstd是很快的开元库</li>\n</ul>\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><ul>\n<li>在局部作用域中，static const比const更快，避免了栈分配</li>\n</ul>\n<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><ul>\n<li>尽可能常量放在一起</li>\n<li>unsigned比signed更快</li>\n<li><code>||</code>比<code>|</code>更好</li>\n<li>乘法比除法更快</li>\n<li>Checking if a non-negative value x is within a range [A, B] can be optimized if B &gt; A (useful when the condition is repeated multiple times)</li>\n<li>指针用中括号操作比加法操作更好</li>\n<li>尽可能的使得symbol不全局可见，即多用匿名空间，static</li>\n<li>Prefer signed integer for loop indexing. The compiler optimizes more aggressively such loops since integer overflow is not defined</li>\n<li>exceptions影响性能，尽可能用noexcept</li>\n<li>smart pointer影响性能</li>\n<li>lambda比std::function和函数指针更好</li>\n<li>避免dynamic_cast</li>\n<li>除了以上几点尽可能用STL<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (x &gt;= A &amp;&amp; x &lt;= B)<br><span class=\"hljs-comment\">// STEP 1: subtract A</span><br><span class=\"hljs-keyword\">if</span> (x - A &gt;= A - A &amp;&amp; x - A &lt;= B - A)<br><span class=\"hljs-comment\">// --&gt;</span><br><span class=\"hljs-keyword\">if</span> (x - A &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; x - A &lt;= B - A) <span class=\"hljs-comment\">// B - A is precomputed</span><br><span class=\"hljs-comment\">// STEP 2</span><br><span class=\"hljs-comment\">// - convert &quot;x - A &gt;= 0&quot; --&gt; (unsigned) (x - A)</span><br><span class=\"hljs-comment\">// - &quot;B - A&quot; is always positive</span><br><span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">unsigned</span>) (x - A) &lt;= (<span class=\"hljs-type\">unsigned</span>) (B - A))<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h1><table>\n<thead>\n<tr>\n<th align=\"center\">From</th>\n<th align=\"center\">To</th>\n<th align=\"center\">Cost</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Signed</td>\n<td align=\"center\">Unsigned</td>\n<td align=\"center\">no cost, bit representation is the same</td>\n</tr>\n<tr>\n<td align=\"center\">Unsigned</td>\n<td align=\"center\">Larger Unsigned</td>\n<td align=\"center\">no cost, register extended</td>\n</tr>\n<tr>\n<td align=\"center\">Signed</td>\n<td align=\"center\">Larger Signed</td>\n<td align=\"center\">1 clock-cycle, register + sign extended</td>\n</tr>\n<tr>\n<td align=\"center\">Integer</td>\n<td align=\"center\">Floating-point</td>\n<td align=\"center\">4-16 clock-cycles Signed → Floating-point is faster than Unsigned → Floating-point (except AVX512 instruction set is enabled)</td>\n</tr>\n<tr>\n<td align=\"center\">Floating-point</td>\n<td align=\"center\">Integer</td>\n<td align=\"center\">fast if SSE2, slow otherwise (50-100 clock-cycles)</td>\n</tr>\n</tbody></table>\n<h1 id=\"Compiler-intrinsic-functions\"><a href=\"#Compiler-intrinsic-functions\" class=\"headerlink\" title=\"Compiler intrinsic functions\"></a>Compiler intrinsic functions</h1><p>编译器内提供的函数，可能缺少跨平台支持，但更好的优化，不支持的花会是很危险的</p>\n<h1 id=\"restrict\"><a href=\"#restrict\" class=\"headerlink\" title=\"__restrict\"></a>__restrict</h1><p>该关键字表明，这两个指针指向的内存不在同一快区域，可以使得编译器更好的优化</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">matrix_mul_v1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* A,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* B,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> N,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>* C)</span> </span>&#123;<br><span class=\"hljs-comment\">// below is faster</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">matrix_mul_v2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* __restrict A,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* __restrict B,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> N,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>* __restrict C)</span> </span>&#123;<br></code></pre></td></tr></table></figure>\n<h1 id=\"编译器-attribute\"><a href=\"#编译器-attribute\" class=\"headerlink\" title=\"编译器__attribute__\"></a>编译器__attribute__</h1><p>设置某些属性可以帮助编译器更好的优化</p>\n<ul>\n<li><code>__attribute__((visibility(&quot;hidden&quot;)))</code>:效果等价于匿名空间</li>\n<li><code>__attribute__(always_inline)</code>:强制inline</li>\n<li><code>__attribute__(noinline)</code>:强制不inline</li>\n<li><code>__attribute__(pure)</code>:attribute (Clang, GCC) specifies that a function has no side effects on its parameters or program state (external global references)</li>\n<li><code>__attribute__(const)</code>:attribute (Clang, GCC) specifies that a function doesn’t depend (read) on external global references</li>\n</ul>\n<h1 id=\"gprof\"><a href=\"#gprof\" class=\"headerlink\" title=\"gprof\"></a>gprof</h1><p>Code Instrumentation<br><code>g++ -pg [flags] &lt;source_files&gt;</code><br>Important: -pg is required also for linking and it is not supported by clang</p>\n<ul>\n<li>Run the program (it produces the file gmon.out)</li>\n<li>Run gprof on gmon.out</li>\n<li><code>gprof -q &lt;executable&gt; gmon.out</code>可以分析出函数调用图</li>\n</ul>\n<h1 id=\"uftrace\"><a href=\"#uftrace\" class=\"headerlink\" title=\"uftrace\"></a>uftrace</h1><p>火焰图</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ gcc -pg &lt;program&gt;.cpp<br>$ uftrace record &lt;executable&gt;<br>$ uftrace replay<br></code></pre></td></tr></table></figure>\n<h1 id=\"性能工具\"><a href=\"#性能工具\" class=\"headerlink\" title=\"性能工具\"></a>性能工具</h1><ul>\n<li>callgrind(valgrind)</li>\n<li>cachegrind</li>\n<li>KCachegrind(linux)&#x2F;Qcachegrind(win)</li>\n<li>gprof2dot</li>\n<li>perf</li>\n<li>hotspot</li>\n</ul>\n"},{"title":"Linux命令_网络","date":"2024-04-28T20:14:32.000Z","index_img":"/images/linuc_network.png","banner_img":"/images/linuc_network.png","_content":"# netstat\n- `netstat -a`:列出所有端口(包括监听和未监听)\n- `netstat -at`:列出所有TCP端口\n- `netstat -l`:列出所有监听的服务状态\n- `netstat -antp |grep 6379`:查询某个端口\n# traceroute\n探测前往地址IP的路由路径\n# host\nDNS查询\n# route\n查看路由状态\n","source":"_posts/Linux命令-网络.md","raw":"---\ntitle: Linux命令_网络\ndate: 2024-04-29 04:14:32\ntags:\nindex_img: /images/linuc_network.png\nbanner_img: /images/linuc_network.png\n---\n# netstat\n- `netstat -a`:列出所有端口(包括监听和未监听)\n- `netstat -at`:列出所有TCP端口\n- `netstat -l`:列出所有监听的服务状态\n- `netstat -antp |grep 6379`:查询某个端口\n# traceroute\n探测前往地址IP的路由路径\n# host\nDNS查询\n# route\n查看路由状态\n","slug":"Linux命令-网络","published":1,"updated":"2024-06-10T14:28:01.751Z","_id":"clwnyxndd0001qzq24gx35gos","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h1><ul>\n<li><code>netstat -a</code>:列出所有端口(包括监听和未监听)</li>\n<li><code>netstat -at</code>:列出所有TCP端口</li>\n<li><code>netstat -l</code>:列出所有监听的服务状态</li>\n<li><code>netstat -antp |grep 6379</code>:查询某个端口</li>\n</ul>\n<h1 id=\"traceroute\"><a href=\"#traceroute\" class=\"headerlink\" title=\"traceroute\"></a>traceroute</h1><p>探测前往地址IP的路由路径</p>\n<h1 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h1><p>DNS查询</p>\n<h1 id=\"route\"><a href=\"#route\" class=\"headerlink\" title=\"route\"></a>route</h1><p>查看路由状态</p>\n","excerpt":"","more":"<h1 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h1><ul>\n<li><code>netstat -a</code>:列出所有端口(包括监听和未监听)</li>\n<li><code>netstat -at</code>:列出所有TCP端口</li>\n<li><code>netstat -l</code>:列出所有监听的服务状态</li>\n<li><code>netstat -antp |grep 6379</code>:查询某个端口</li>\n</ul>\n<h1 id=\"traceroute\"><a href=\"#traceroute\" class=\"headerlink\" title=\"traceroute\"></a>traceroute</h1><p>探测前往地址IP的路由路径</p>\n<h1 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h1><p>DNS查询</p>\n<h1 id=\"route\"><a href=\"#route\" class=\"headerlink\" title=\"route\"></a>route</h1><p>查看路由状态</p>\n"},{"title":"Linux命令_资源性能篇","date":"2024-04-25T19:52:39.000Z","index_img":"/images/linux_performance.jpeg","banner_img":"/images/linux_performance.jpeg","_content":"\n# uptime\n该命令输出如下：\n```bash\n23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02\n```\n该平均负载指标了**要**运行的任务(进程)数量，包括要在CPU上运行的进程以及在不中断IO(磁盘IO)中阻塞的进程。\n三个值分别代表了1min，5min,15min的平均值\n# dmesg\n操作系统消息日志\n# free\n[linuxtools-free](https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/free.html)\n# vmstat\n`vmstat [-V] [-n] [delay [count]]`\n- -V表示打印出版本信息；\n- -n表示在周期性循环输出时，输出的头部信息仅显示一次；\n- delay是两次输出之间的延迟时间；\n- count是指按照这个时间间隔统计的次数。\n## 输出信息\n```bash\n$ vmstat 1\nprocs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0\n32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0\n32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0\n32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0\n32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0\n```\n### Procs(进程)\n- `r`:在CPU上运行并等待回合的进程数。由于它不包含IO，因此它比指示CPU饱和的平均负载提供了更多的信息。一个大于CPU核数的r值就是饱和的。\n- `b`:等待IO的进程数量\n### Memory(内存)\n- free:空闲的内存(单位KB)\n- swpd: 使用虚拟内存大小\n- buff: 用作缓冲的内存大小\n- cache: 用作缓存的内存大小\n### Swap\n- si: 每秒从交换区写到内存的大小\n- so: 每秒写入交换区的内存大小\n这两个非空，说明物理内存用完了，现在使用交换内存\n### IO\n- bi: 每秒读取的块数\n- bo: 每秒写入的块数(每块1024bytes)\n### system\n- in: 每秒中断数，包括时钟中断\n- cs: 每秒上下文切换数\n### CPU\n显示的是所有cpu的平均值\n- `us、sy、id、wa、st`:这些是CPU时间的分类，\n- us: 用户进程执行时间(user time)\n- sy: 系统进程执行时间(system time)\n- id: 空闲时间(包括IO等待时间)\n- wa: 等待IO时间\n- st: 被偷窃时间（被其它宾客系统进行使用，或宾客系统隔离的驱动程序域Xen）\n通过将用户时间和系统时间这两个分类相加，即可判断CPU是否繁忙。一定的等待IO时间说明磁盘有可能是性能瓶颈。你可以认为等待IO时间是另一种形式的空闲时间，它提供了它是如何空闲的线索。 IO处理需要占用CPU系统时间。一个较高的CPU系统时间（超过20%）可能会很有趣，有必要进一步研究：也许内核在很低效地处理IO。\n# mpstat\n`mpstat -P ALL 1`：显示每个CPU的时间明细，用于检查不平衡状况\n# iostat\n`iostat [参数][时间][次数]`\n这是了解块设备（磁盘），应用的工作负载和产生的性能影响的绝佳工具。\n## 命令参数\n-C 显示CPU使用情况\n-d 显示磁盘使用情况\n-k 以 KB 为单位显示\n-m 以 M 为单位显示\n-N 显示磁盘阵列(LVM) 信息\n-n 显示NFS 使用情况\n-p[磁盘] 显示磁盘和分区的情况\n-t 显示终端和CPU的信息\n-x 显示详细信息\n-V 显示版本信息\n## 输出\n`iostat -xz 1`\n```bash\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n          73.96    0.00    3.73    0.03    0.06   22.21\nDevice:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util\nxvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09\nxvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25\nxvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26\ndm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04\ndm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00\ndm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03\n```\n### cpu属性值\n- %user：CPU处在用户模式下的时间百分比。\n- %nice：CPU处在带NICE值的用户模式下的时间百分比。\n- %system：CPU处在系统模式下的时间百分比。\n- %iowait：CPU等待输入输出完成时间的百分比。\n- %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。\n- %idle：CPU空闲时间百分比。\n如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。\n### disk属性值\n- rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s\n- wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s\n- r/s: 每秒完成的读 I/O 设备次数。即 rio/s\n- w/s: 每秒完成的写 I/O 设备次数。即 wio/s\n- rsec/s: 每秒读扇区数。即 rsect/s\n- wsec/s: 每秒写扇区数。即 wsect/s\n- rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。\n- wkB/s: 每秒写K字节数。是 wsect/s 的一半。\n- avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。\n- avgqu-sz: 平均I/O队列长度。发给设备的平均请求数。值大于1可以表明已达到饱和状态（尽管设备通常可以并行处理请求，尤其是在多个后端磁盘所组成的前端虚拟设备的情况下）。\n- await: 平均每次设备I/O操作的等待时间 (毫秒)。这是应用程序所感受到的时间，它包括IO排队时间和IO服务时间。大于预期的平均时间可能表示块设备饱和或设备出现问题了。\n- svctm: 平均每次设备I/O操作的服务时间 (毫秒)。\n- %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比，设备利用率。这是一个表征繁忙度的百分比，它表示设备每秒工作的时间。尽管它的值取决于设备，但值大于60%通常会导致性能不佳（也会通过await的值观察到）。接近100␐%的值通常表示饱和。\n### 信息意义\n- 如果%iowait的值过高，表示硬盘存在I/O瓶颈。\n- 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。\n- 如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；\n- 如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。\n- 如果avgqu-sz比较大，也表示有大量io在等待。\n# sar\nsar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。需要启动service(systemctl start sysstat.service),并保存相关日志到文件\n## 参数\n- -A 汇总所有的报告\n- -a 报告文件读写使用情况\n- -B 报告附加的缓存的使用情况\n- -b 报告缓存的使用情况\n- -c 报告系统调用的使用情况\n- -d 报告磁盘的使用情况\n- -g 报告串口的使用情况\n- -h 报告关于buffer使用的统计数据\n- -m 报告IPC消息队列和信号量的使用情况\n- -n 报告命名cache的使用情况\n- -p 报告调页活动的使用情况\n- -q 报告运行队列和交换队列的平均长度\n- -R 报告进程的活动情况\n- -r 报告没有使用的内存页面和硬盘块\n- -u 报告CPU的利用率\n- -v 报告进程、i节点、文件和锁表状态\n- -w 报告系统交换活动状况\n- -y 报告TTY设备活动状况\n## example\n### `sar -n DEV 1`\n```bash\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     _x86_64_    (32 CPU)\n12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00\n12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00\n12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00\n12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00\n12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n```\n此命令可以检查网络接口的吞吐量：rxkB/s和txkB/s，作为工作负载的度量，还可以检查是否已达到网络接口的限制。在上面的示例中，eth0接收速率达到22MB/s，即176Mbit/s（远低于1Gbit/s的网络接口限制，假设是千兆网卡）。\n### `sar -n TCP,ETCP 1`\n```bash\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)\n12:17:19 AM  active/s passive/s    iseg/s    oseg/s\n12:17:20 AM      1.00      0.00  10233.00  18846.00\n12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s\n12:17:20 AM      0.00      0.00      0.00      0.00      0.00\n```\n这是一些关键的TCP指标的摘要，包括：\n- `active/s`：每秒本地启动的TCP连接数（例如，通过connect（））。\n- `passive/s`：每秒远程启动的TCP连接数（例如，通过accept（））。\n- `retrans/s`：每秒TCP重传的次数。\n主动和被动计数通常作为服务器TCP负载的粗略度量：新接受的连接数（被动）和新出站的连接数（主动）。将主动视为出站，将被动视为入站可能对理解这两个指标有些帮助，但这并不是严格意义上的（例如，考虑从localhost到localhost的连接）。\n重新传输是网络或服务器问题的迹象；它可能是不可靠的网络（例如，公共Internet），也可能是由于服务器过载并丢弃了数据包。上面的示例仅显示每秒一个新的TCP连接。\n### `sar -u 1 2`\ncpu使用率\n- %user 用户模式下消耗的CPU时间的比例；\n- %nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例\n- %system 系统模式下消耗的CPU时间的比例；\n- %iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；\n- %steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；\n- %idle CPU空闲时间比例；\n\n### `sar -q 1 2`\ncpu平均负载\n- runq-sz：运行队列的长度（等待运行的进程数）\n- plist-sz：进程列表中进程（processes）和线程（threads）的数量\n- ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载\n- ldavg-15：过去15分钟的系统平均负载\n### `sar -r 1 2`\n内存情况\n- kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.\n- kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.\n- %memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.\n- kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.\n- kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).\n- %commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.\n### `sar -W 1 2`\n页面交换情况\npswpin/s：每秒系统换入的交换页面（swap page）数量\npswpout/s：每秒系统换出的交换页面（swap page）数量\n### summary\n- 怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看\n- 怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看\n- 怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看\n# ipcs\n- `ipcs -m`:共享内存资源\n- `ipcs -q`:队列资源\n- `ipcs -s`:信号量资源\n- `ipcs -l`:类似于ulimit,列出系统资源限制\n## 修改ipc资源限制\n```bash\n$cat /etc/sysctl.conf\n# 一个消息的最大长度\nkernel.msgmax = 524288\n\n# 一个消息队列上的最大字节数\n# 524288*10\nkernel.msgmnb = 5242880\n\n#最大消息队列的个数\nkernel.msgmni=2048\n\n#一个共享内存区的最大字节数\nkernel.shmmax = 17179869184\n\n#系统范围内最大共享内存标识数\nkernel.shmmni=4096\n\n#每个信号灯集的最大信号灯数 系统范围内最大信号灯数 每个信号灯支持的最大操作数 系统范围内最大信号灯集数\n#此参数为系统默认，可以不用修改\n#kernel.sem = <semmsl> <semmni>*<semmsl> <semopm> <semmni>\nkernel.sem = 250 32000 32 128\n```\n修改保存后使用sysctl -p\n## 清除IPC资源\n- ipcrm -M shmkey  移除用shmkey创建的共享内存段\n- ipcrm -m shmid    移除用shmid标识的共享内存段\n- ipcrm -Q msgkey  移除用msqkey创建的消息队列\n- ipcrm -q msqid  移除用msqid标识的消息队列\n- ipcrm -S semkey  移除用semkey创建的信号\n- ipcrm -s semid  移除用semid标识的信号\n## example\n- 清除当前用户创建的所有的IPC资源\n```bash\nipcs -q | awk '{ print \"ipcrm -q \"$2}' | sh > /dev/null 2>&1;\nipcs -m | awk '{ print \"ipcrm -m \"$2}' | sh > /dev/null 2>&1;\nipcs -s | awk '{ print \"ipcrm -s \"$2}' | sh > /dev/null 2>&1;\n```\n# fuser\n显示所有正在使用着指定file,file system或sockets的进程信息\n`fuser -m -u redis-server`用来查找所有正在使用redis-server的所有进程的PID以及该进程的OWNER\n`fuser –k /path/to/your/filename`:kill所有正在使用某一指定的file, file system or sockets的进程\n# top(htop更强大的替换工具)\n## 输出信息\n```bash\n$top\n    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00\n    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie\n    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st\n    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers\n    Swap:   397308k total,    67192k used,   330116k free,    71900k cached\n    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init\n    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd\n    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0\n    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0\n```\n\n### 第一行\n- 09:14:56 ： 系统当前时间\n- 264 days, 20:56 ： 系统开机到现在经过了多少时间\n- 1 users ： 当前2用户在线\n- load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息\n### Tasks\n- 87 total：很好理解，就是当前有87个任务，也就是87个进程。\n- 1 running：1个进程正在运行\n- 86 sleeping：86个进程睡眠\n- 0 stopped：停止的进程数\n- 0 zombie：僵死的进程数\n### Cpu(s)\n- 0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。\n- 0.7%sy：内核占用CPU时间百分比\n- 0.0%ni：改变过优先级的进程占用CPU的百分比\n- 99.3%id：空闲CPU时间百分比\n- 0.0%wa：等待I/O的CPU时间百分比\n- 0.0%hi：CPU硬中断时间百分比\n- 0.0%si：CPU软中断时间百分比\n注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；\n### Men：内存\n- 8175320kk total：物理内存总量\n- 8058868k used：使用的物理内存量\n- 116452k free：空闲的物理内存量\n- 283084k buffers：用作内核缓存的物理内存量\n### Swap：交换空间\n- 6881272k total：交换区总量\n- 4010444k used：使用的交换区量\n- 2870828k free：空闲的交换区量\n- 4336992k cached：缓冲交换区总量\n### 进程信息\n- PID：进程的ID\n- USER：进程所有者\n- PR：进程的优先级别，越小越优先被执行\n- NInice：值\n- VIRT：进程占用的虚拟内存\n- RES：进程占用的物理内存\n- SHR：进程使用的共享内存\n- S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数\n- %CPU：进程占用CPU的使用率\n- %MEM：进程使用的物理内存和总内存的百分比\n- TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。\n- COMMAND：进程启动命令名称\n## 交互模式\n- q：退出top命令\n- <Space>：立即刷新\n- s：设置刷新时间间隔\n- c：显示命令完全模式\n- t:：显示或隐藏进程和CPU状态信息\n- m：显示或隐藏内存状态信息\n- l：显示或隐藏uptime信息\n- f：增加或减少进程显示标志\n- S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+\n- P：按%CPU使用率排行\n- T：按MITE+排行\n- M：按%MEM排行\n- u：指定显示用户进程\n- r：修改进程renice值\n- kkill：进程\n- i：只显示正在运行的进程\n- W：保存对top的设置到文件^/.toprc，下次启动将自动调用toprc文件的设置。\n- h：帮助命令。\n- 1: 显示各个Cpu信息\n## example\n- `top -p pid`:显示指定进程信息(支持pid,pid多个进程id)\n- \n# 查询软硬件信息\n- `uname -a`,`lsb_release -a`linux系统版本\n- `more /etc/release`操作系统版本\n- `neofetch`系统概览\n- `cat /proc/cpuinfo`:cpu信息\n- `cat /proc/meminfo`:内存信息\n- `pagesize`:显示内存page大小(kb)\n- `ulimit -a`:显示系统资源限制信息\n# lsof\n## 命令参数\n- -p:指定进程ID\n- -d:指定要显示的文件描述符编号\n- -a:列出打开文件存在的进程\n- -c<进程名>:列出指定进程所打开的文件\n- -g:列出GID号进程详情\n- -d<文件号>:列出占用该文件号的进程\n- +d<目录>:列出目录下被打开的文件\n- +D<目录>:递归列出目录下被打开的文件\n- -n<目录>:列出使用NFS的文件\n- -i<条件>:列出符合条件的进程。（4、6、协议、:端口、 @ip ）\n- -p<进程号>:列出指定进程号所打开的文件\n- -u:列出UID号进程详情\n- -h:显示帮助信息\n- -v:显示版本信息\n## 列信息\n* COMMAND 正在运行的命令名字的前 9 个字符\n* PID 进程的 PID\n* USER 进程属主的登录名\n* DEVICE 设备的设备号（主设备号和从设备号）\n* SIZE 如果有的话，表示文件的大小\n* NODE 本地文件的节点号\n* NAME 文件名\n### TYPE\nTYPE 文件的类型\n1) DIR：表示目录\n2) CHR：表示字符类型\n3) BLK：块设备类型\n4) UNIX： UNIX 域套接字\n5) FIFO：先进先出 (FIFO) 队列\n6) IPv4：网际协议 (IP) 套接字\n7) REG: 常规文件\n### FD\nFD 文件描述符号以及访问类型\n1)cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改\n2)txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序\n3)lnn：library references (AIX);\n4)er：FD information error (see NAME column);\n5)jld：jail directory (FreeBSD);\n6)ltx：shared library text (code and data);\n7)mxx ：hex memory-mapped type number xx.\n8)m86：DOS Merge mapped file;\n9)mem：memory-mapped file;\n10)mmap：memory-mapped device;\n11)pd：parent directory;\n12)rtd：root directory;\n13)tr：kernel trace file (OpenBSD);\n14)v86  VP/ix mapped file;\n15)0：表示标准输入\n16)1：表示标准输出\n17)2：表示标准错误\n一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等\n1)u：表示该文件被打开并处于读取/写入模式\n2)r：表示该文件被打开并处于只读模式\n3)w：表示该文件被打开并处于\n4)空格：表示该文件的状态模式为unknow，且没有锁定\n5)-：表示该文件的状态模式为unknow，且被锁定\n同时在文件状态模式后面，还跟着相关的锁\n1)N：for a Solaris NFS lock of unknown type;\n2)r：for read lock on part of the file;\n3)R：for a read lock on the entire file;\n4)w：for a write lock on part of the file;文件的部分写锁)\n5)W：for a write lock on the entire file;整个文件的写锁)\n6)u：for a read and write lock of any length;\n7)U：for a lock of unknown type;\n8)x：for an SCO OpenServer Xenix lock on part      of the file;\n9)X：for an SCO OpenServer Xenix lock on the      entire file;\n10)space：if there is no lock.\n## example\n- `lsof -a -p $$ -d 0,1,2`显示当前进程0,1,2的文件描述符信息,信息含义如下:\n- `lsof -i tcp`:列出所有tcp网络连接信息\n- `lsof - i :3306`:列出谁在使用某个端口\n- `lsof -a -u test -i`:列出某个用户的所有活跃的网络端口\n- `lsof -i @nf5260i5-td:20,21,80 -r 3`:列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行\n- `lsof -i 4 -a -p 1234`:列出被进程号为1234的进程所打开的所有IPV4 network files\n# ps\n## 命令参数\n- a 显示所有进程\n- -a 显示同一终端下的所有程序\n- -A 显示所有进程\n- c 显示进程的真实名称\n- -N 反向选择\n- -e 等于“-A”\n- e 显示环境变量\n- f 显示程序间的关系\n- -H 显示树状结构\n- r 显示当前终端的进程\n- T 显示当前终端的所有程序\n- u 指定用户的所有进程\n- -au 显示较详细的资讯\n- -aux 显示所有包含其他使用者的行程\n- -C<命令> 列出指定命令的状况\n- –lines<行数> 每页显示的行数\n- –width<字符数> 每页显示的字符数\n- –help 显示帮助信息\n- –version 显示版本显示\n## 输出列\n- F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user\n- S 代表这个程序的状态 (STAT)\n- UID 程序被该 UID 所拥有\n- PID 进程的ID\n- PPID 则是其上级父程序的ID\n- C CPU 使用的资源百分比\n- PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍\n- NI 这个是 Nice 值\n- ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“\n- SZ 使用掉的内存大小\n- WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作\n- TTY 登入者的终端机位置\n- TIME 使用掉的 CPU 时间。\n- CMD 所下达的指令为何\n### STAT\n- D 不可中断 uninterruptible sleep (usually IO)\n- R 运行 runnable (on run queue)\n- S 中断 sleeping\n- T 停止 traced or stopped\n- Z 僵死 a defunct (”zombie”) process\n### example\n- `ps -ef`:显示所有进程信息，连同命令行\n- `ps aux`:列出目前所有的正在内存中的程序\n# strace\nstrace常用来跟踪进程执行时的系统调用和所接收的信号\n## 输出信息\n每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。\n## 参数\n- -c 统计每一系统调用的所执行的时间,次数和出错的次数等.\n- -d 输出strace关于标准错误的调试信息.\n- -f 跟踪由fork调用所产生的子进程.\n- -ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.\n- -F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.\n- -h 输出简要的帮助信息.\n- -i 输出系统调用的入口指针.\n- -q 禁止输出关于脱离的消息.\n- -r 打印出相对时间关于,,每一个系统调用.\n- -t 在输出中的每一行前加上时间信息.\n- -tt 在输出中的每一行前加上时间信息,微秒级.\n- -ttt 微秒级输出,以秒了表示时间.\n- -T 显示每一调用所耗的时间.\n- -v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.\n- -V 输出strace的版本信息.\n- -x 以十六进制形式输出非标准字符串\n- -xx 所有字符串以十六进制形式输出.\n- -a <column>设置返回值的输出位置.默认 为40.\n输出写入到指定文件中的数据.\n- -o filename 将strace的输出写入文件filename\n- -p pid 跟踪指定的进程pid.\n- -s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.\n- -u username 以username 的UID和GID执行被跟踪的命令\n### -e\n-e expr 指定一个表达式,用来控制如何跟踪.格式如下:\n`[qualifier=][!]value1[,value2]...`\nqualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:\n-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.\n注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\.\n- -e trace=<set>\n只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.\n    - -e trace=file 只跟踪有关文件操作的系统调用.\n    - -e trace=process 只跟踪有关进程控制的系统调用.\n    - -e trace=network 跟踪与网络有关的所有系统调用.\n    - -e strace=signal 跟踪所有与系统信号有关的 系统调用\n    - -e strace=ipc 跟踪所有与进程通讯有关的系统调用\n- -e abbrev=<set> 设定 strace输出的系统调用的结果集.`-v`等价于`abbrev=none`.默认为abbrev=all.\n- -e raw=<set> 将指定的系统调用的参数以十六进制显示.\n- -e signal=<set> 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.\n-e read=<set> 输出从指定文件中读出 的数据.例如:\n    -e read=3,5.从文件描述符3,5读出的系统调用\n    -e write=<set>\n## example\n`strace -o output.txt -T -tt -e trace=all -p 28979`\n`strace -p <process-pid>`:实时输出程序的系统调用\n`strace -f -F -o ~/straceout.txt myserver`:跟踪可执行程序\n\n","source":"_posts/Linux命令-资源性能篇.md","raw":"---\ntitle: Linux命令_资源性能篇\ndate: 2024-04-26 03:52:39\ntags:\nindex_img: /images/linux_performance.jpeg\nbanner_img: /images/linux_performance.jpeg\n---\n\n# uptime\n该命令输出如下：\n```bash\n23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02\n```\n该平均负载指标了**要**运行的任务(进程)数量，包括要在CPU上运行的进程以及在不中断IO(磁盘IO)中阻塞的进程。\n三个值分别代表了1min，5min,15min的平均值\n# dmesg\n操作系统消息日志\n# free\n[linuxtools-free](https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/free.html)\n# vmstat\n`vmstat [-V] [-n] [delay [count]]`\n- -V表示打印出版本信息；\n- -n表示在周期性循环输出时，输出的头部信息仅显示一次；\n- delay是两次输出之间的延迟时间；\n- count是指按照这个时间间隔统计的次数。\n## 输出信息\n```bash\n$ vmstat 1\nprocs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0\n32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0\n32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0\n32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0\n32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0\n```\n### Procs(进程)\n- `r`:在CPU上运行并等待回合的进程数。由于它不包含IO，因此它比指示CPU饱和的平均负载提供了更多的信息。一个大于CPU核数的r值就是饱和的。\n- `b`:等待IO的进程数量\n### Memory(内存)\n- free:空闲的内存(单位KB)\n- swpd: 使用虚拟内存大小\n- buff: 用作缓冲的内存大小\n- cache: 用作缓存的内存大小\n### Swap\n- si: 每秒从交换区写到内存的大小\n- so: 每秒写入交换区的内存大小\n这两个非空，说明物理内存用完了，现在使用交换内存\n### IO\n- bi: 每秒读取的块数\n- bo: 每秒写入的块数(每块1024bytes)\n### system\n- in: 每秒中断数，包括时钟中断\n- cs: 每秒上下文切换数\n### CPU\n显示的是所有cpu的平均值\n- `us、sy、id、wa、st`:这些是CPU时间的分类，\n- us: 用户进程执行时间(user time)\n- sy: 系统进程执行时间(system time)\n- id: 空闲时间(包括IO等待时间)\n- wa: 等待IO时间\n- st: 被偷窃时间（被其它宾客系统进行使用，或宾客系统隔离的驱动程序域Xen）\n通过将用户时间和系统时间这两个分类相加，即可判断CPU是否繁忙。一定的等待IO时间说明磁盘有可能是性能瓶颈。你可以认为等待IO时间是另一种形式的空闲时间，它提供了它是如何空闲的线索。 IO处理需要占用CPU系统时间。一个较高的CPU系统时间（超过20%）可能会很有趣，有必要进一步研究：也许内核在很低效地处理IO。\n# mpstat\n`mpstat -P ALL 1`：显示每个CPU的时间明细，用于检查不平衡状况\n# iostat\n`iostat [参数][时间][次数]`\n这是了解块设备（磁盘），应用的工作负载和产生的性能影响的绝佳工具。\n## 命令参数\n-C 显示CPU使用情况\n-d 显示磁盘使用情况\n-k 以 KB 为单位显示\n-m 以 M 为单位显示\n-N 显示磁盘阵列(LVM) 信息\n-n 显示NFS 使用情况\n-p[磁盘] 显示磁盘和分区的情况\n-t 显示终端和CPU的信息\n-x 显示详细信息\n-V 显示版本信息\n## 输出\n`iostat -xz 1`\n```bash\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n          73.96    0.00    3.73    0.03    0.06   22.21\nDevice:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util\nxvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09\nxvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25\nxvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26\ndm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04\ndm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00\ndm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03\n```\n### cpu属性值\n- %user：CPU处在用户模式下的时间百分比。\n- %nice：CPU处在带NICE值的用户模式下的时间百分比。\n- %system：CPU处在系统模式下的时间百分比。\n- %iowait：CPU等待输入输出完成时间的百分比。\n- %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。\n- %idle：CPU空闲时间百分比。\n如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。\n### disk属性值\n- rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s\n- wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s\n- r/s: 每秒完成的读 I/O 设备次数。即 rio/s\n- w/s: 每秒完成的写 I/O 设备次数。即 wio/s\n- rsec/s: 每秒读扇区数。即 rsect/s\n- wsec/s: 每秒写扇区数。即 wsect/s\n- rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。\n- wkB/s: 每秒写K字节数。是 wsect/s 的一半。\n- avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。\n- avgqu-sz: 平均I/O队列长度。发给设备的平均请求数。值大于1可以表明已达到饱和状态（尽管设备通常可以并行处理请求，尤其是在多个后端磁盘所组成的前端虚拟设备的情况下）。\n- await: 平均每次设备I/O操作的等待时间 (毫秒)。这是应用程序所感受到的时间，它包括IO排队时间和IO服务时间。大于预期的平均时间可能表示块设备饱和或设备出现问题了。\n- svctm: 平均每次设备I/O操作的服务时间 (毫秒)。\n- %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比，设备利用率。这是一个表征繁忙度的百分比，它表示设备每秒工作的时间。尽管它的值取决于设备，但值大于60%通常会导致性能不佳（也会通过await的值观察到）。接近100␐%的值通常表示饱和。\n### 信息意义\n- 如果%iowait的值过高，表示硬盘存在I/O瓶颈。\n- 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。\n- 如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；\n- 如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。\n- 如果avgqu-sz比较大，也表示有大量io在等待。\n# sar\nsar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。需要启动service(systemctl start sysstat.service),并保存相关日志到文件\n## 参数\n- -A 汇总所有的报告\n- -a 报告文件读写使用情况\n- -B 报告附加的缓存的使用情况\n- -b 报告缓存的使用情况\n- -c 报告系统调用的使用情况\n- -d 报告磁盘的使用情况\n- -g 报告串口的使用情况\n- -h 报告关于buffer使用的统计数据\n- -m 报告IPC消息队列和信号量的使用情况\n- -n 报告命名cache的使用情况\n- -p 报告调页活动的使用情况\n- -q 报告运行队列和交换队列的平均长度\n- -R 报告进程的活动情况\n- -r 报告没有使用的内存页面和硬盘块\n- -u 报告CPU的利用率\n- -v 报告进程、i节点、文件和锁表状态\n- -w 报告系统交换活动状况\n- -y 报告TTY设备活动状况\n## example\n### `sar -n DEV 1`\n```bash\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     _x86_64_    (32 CPU)\n12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00\n12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00\n12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00\n12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00\n12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n```\n此命令可以检查网络接口的吞吐量：rxkB/s和txkB/s，作为工作负载的度量，还可以检查是否已达到网络接口的限制。在上面的示例中，eth0接收速率达到22MB/s，即176Mbit/s（远低于1Gbit/s的网络接口限制，假设是千兆网卡）。\n### `sar -n TCP,ETCP 1`\n```bash\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)\n12:17:19 AM  active/s passive/s    iseg/s    oseg/s\n12:17:20 AM      1.00      0.00  10233.00  18846.00\n12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s\n12:17:20 AM      0.00      0.00      0.00      0.00      0.00\n```\n这是一些关键的TCP指标的摘要，包括：\n- `active/s`：每秒本地启动的TCP连接数（例如，通过connect（））。\n- `passive/s`：每秒远程启动的TCP连接数（例如，通过accept（））。\n- `retrans/s`：每秒TCP重传的次数。\n主动和被动计数通常作为服务器TCP负载的粗略度量：新接受的连接数（被动）和新出站的连接数（主动）。将主动视为出站，将被动视为入站可能对理解这两个指标有些帮助，但这并不是严格意义上的（例如，考虑从localhost到localhost的连接）。\n重新传输是网络或服务器问题的迹象；它可能是不可靠的网络（例如，公共Internet），也可能是由于服务器过载并丢弃了数据包。上面的示例仅显示每秒一个新的TCP连接。\n### `sar -u 1 2`\ncpu使用率\n- %user 用户模式下消耗的CPU时间的比例；\n- %nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例\n- %system 系统模式下消耗的CPU时间的比例；\n- %iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；\n- %steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；\n- %idle CPU空闲时间比例；\n\n### `sar -q 1 2`\ncpu平均负载\n- runq-sz：运行队列的长度（等待运行的进程数）\n- plist-sz：进程列表中进程（processes）和线程（threads）的数量\n- ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载\n- ldavg-15：过去15分钟的系统平均负载\n### `sar -r 1 2`\n内存情况\n- kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.\n- kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.\n- %memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.\n- kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.\n- kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).\n- %commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.\n### `sar -W 1 2`\n页面交换情况\npswpin/s：每秒系统换入的交换页面（swap page）数量\npswpout/s：每秒系统换出的交换页面（swap page）数量\n### summary\n- 怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看\n- 怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看\n- 怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看\n# ipcs\n- `ipcs -m`:共享内存资源\n- `ipcs -q`:队列资源\n- `ipcs -s`:信号量资源\n- `ipcs -l`:类似于ulimit,列出系统资源限制\n## 修改ipc资源限制\n```bash\n$cat /etc/sysctl.conf\n# 一个消息的最大长度\nkernel.msgmax = 524288\n\n# 一个消息队列上的最大字节数\n# 524288*10\nkernel.msgmnb = 5242880\n\n#最大消息队列的个数\nkernel.msgmni=2048\n\n#一个共享内存区的最大字节数\nkernel.shmmax = 17179869184\n\n#系统范围内最大共享内存标识数\nkernel.shmmni=4096\n\n#每个信号灯集的最大信号灯数 系统范围内最大信号灯数 每个信号灯支持的最大操作数 系统范围内最大信号灯集数\n#此参数为系统默认，可以不用修改\n#kernel.sem = <semmsl> <semmni>*<semmsl> <semopm> <semmni>\nkernel.sem = 250 32000 32 128\n```\n修改保存后使用sysctl -p\n## 清除IPC资源\n- ipcrm -M shmkey  移除用shmkey创建的共享内存段\n- ipcrm -m shmid    移除用shmid标识的共享内存段\n- ipcrm -Q msgkey  移除用msqkey创建的消息队列\n- ipcrm -q msqid  移除用msqid标识的消息队列\n- ipcrm -S semkey  移除用semkey创建的信号\n- ipcrm -s semid  移除用semid标识的信号\n## example\n- 清除当前用户创建的所有的IPC资源\n```bash\nipcs -q | awk '{ print \"ipcrm -q \"$2}' | sh > /dev/null 2>&1;\nipcs -m | awk '{ print \"ipcrm -m \"$2}' | sh > /dev/null 2>&1;\nipcs -s | awk '{ print \"ipcrm -s \"$2}' | sh > /dev/null 2>&1;\n```\n# fuser\n显示所有正在使用着指定file,file system或sockets的进程信息\n`fuser -m -u redis-server`用来查找所有正在使用redis-server的所有进程的PID以及该进程的OWNER\n`fuser –k /path/to/your/filename`:kill所有正在使用某一指定的file, file system or sockets的进程\n# top(htop更强大的替换工具)\n## 输出信息\n```bash\n$top\n    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00\n    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie\n    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st\n    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers\n    Swap:   397308k total,    67192k used,   330116k free,    71900k cached\n    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init\n    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd\n    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0\n    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0\n```\n\n### 第一行\n- 09:14:56 ： 系统当前时间\n- 264 days, 20:56 ： 系统开机到现在经过了多少时间\n- 1 users ： 当前2用户在线\n- load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息\n### Tasks\n- 87 total：很好理解，就是当前有87个任务，也就是87个进程。\n- 1 running：1个进程正在运行\n- 86 sleeping：86个进程睡眠\n- 0 stopped：停止的进程数\n- 0 zombie：僵死的进程数\n### Cpu(s)\n- 0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。\n- 0.7%sy：内核占用CPU时间百分比\n- 0.0%ni：改变过优先级的进程占用CPU的百分比\n- 99.3%id：空闲CPU时间百分比\n- 0.0%wa：等待I/O的CPU时间百分比\n- 0.0%hi：CPU硬中断时间百分比\n- 0.0%si：CPU软中断时间百分比\n注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；\n### Men：内存\n- 8175320kk total：物理内存总量\n- 8058868k used：使用的物理内存量\n- 116452k free：空闲的物理内存量\n- 283084k buffers：用作内核缓存的物理内存量\n### Swap：交换空间\n- 6881272k total：交换区总量\n- 4010444k used：使用的交换区量\n- 2870828k free：空闲的交换区量\n- 4336992k cached：缓冲交换区总量\n### 进程信息\n- PID：进程的ID\n- USER：进程所有者\n- PR：进程的优先级别，越小越优先被执行\n- NInice：值\n- VIRT：进程占用的虚拟内存\n- RES：进程占用的物理内存\n- SHR：进程使用的共享内存\n- S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数\n- %CPU：进程占用CPU的使用率\n- %MEM：进程使用的物理内存和总内存的百分比\n- TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。\n- COMMAND：进程启动命令名称\n## 交互模式\n- q：退出top命令\n- <Space>：立即刷新\n- s：设置刷新时间间隔\n- c：显示命令完全模式\n- t:：显示或隐藏进程和CPU状态信息\n- m：显示或隐藏内存状态信息\n- l：显示或隐藏uptime信息\n- f：增加或减少进程显示标志\n- S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+\n- P：按%CPU使用率排行\n- T：按MITE+排行\n- M：按%MEM排行\n- u：指定显示用户进程\n- r：修改进程renice值\n- kkill：进程\n- i：只显示正在运行的进程\n- W：保存对top的设置到文件^/.toprc，下次启动将自动调用toprc文件的设置。\n- h：帮助命令。\n- 1: 显示各个Cpu信息\n## example\n- `top -p pid`:显示指定进程信息(支持pid,pid多个进程id)\n- \n# 查询软硬件信息\n- `uname -a`,`lsb_release -a`linux系统版本\n- `more /etc/release`操作系统版本\n- `neofetch`系统概览\n- `cat /proc/cpuinfo`:cpu信息\n- `cat /proc/meminfo`:内存信息\n- `pagesize`:显示内存page大小(kb)\n- `ulimit -a`:显示系统资源限制信息\n# lsof\n## 命令参数\n- -p:指定进程ID\n- -d:指定要显示的文件描述符编号\n- -a:列出打开文件存在的进程\n- -c<进程名>:列出指定进程所打开的文件\n- -g:列出GID号进程详情\n- -d<文件号>:列出占用该文件号的进程\n- +d<目录>:列出目录下被打开的文件\n- +D<目录>:递归列出目录下被打开的文件\n- -n<目录>:列出使用NFS的文件\n- -i<条件>:列出符合条件的进程。（4、6、协议、:端口、 @ip ）\n- -p<进程号>:列出指定进程号所打开的文件\n- -u:列出UID号进程详情\n- -h:显示帮助信息\n- -v:显示版本信息\n## 列信息\n* COMMAND 正在运行的命令名字的前 9 个字符\n* PID 进程的 PID\n* USER 进程属主的登录名\n* DEVICE 设备的设备号（主设备号和从设备号）\n* SIZE 如果有的话，表示文件的大小\n* NODE 本地文件的节点号\n* NAME 文件名\n### TYPE\nTYPE 文件的类型\n1) DIR：表示目录\n2) CHR：表示字符类型\n3) BLK：块设备类型\n4) UNIX： UNIX 域套接字\n5) FIFO：先进先出 (FIFO) 队列\n6) IPv4：网际协议 (IP) 套接字\n7) REG: 常规文件\n### FD\nFD 文件描述符号以及访问类型\n1)cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改\n2)txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序\n3)lnn：library references (AIX);\n4)er：FD information error (see NAME column);\n5)jld：jail directory (FreeBSD);\n6)ltx：shared library text (code and data);\n7)mxx ：hex memory-mapped type number xx.\n8)m86：DOS Merge mapped file;\n9)mem：memory-mapped file;\n10)mmap：memory-mapped device;\n11)pd：parent directory;\n12)rtd：root directory;\n13)tr：kernel trace file (OpenBSD);\n14)v86  VP/ix mapped file;\n15)0：表示标准输入\n16)1：表示标准输出\n17)2：表示标准错误\n一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等\n1)u：表示该文件被打开并处于读取/写入模式\n2)r：表示该文件被打开并处于只读模式\n3)w：表示该文件被打开并处于\n4)空格：表示该文件的状态模式为unknow，且没有锁定\n5)-：表示该文件的状态模式为unknow，且被锁定\n同时在文件状态模式后面，还跟着相关的锁\n1)N：for a Solaris NFS lock of unknown type;\n2)r：for read lock on part of the file;\n3)R：for a read lock on the entire file;\n4)w：for a write lock on part of the file;文件的部分写锁)\n5)W：for a write lock on the entire file;整个文件的写锁)\n6)u：for a read and write lock of any length;\n7)U：for a lock of unknown type;\n8)x：for an SCO OpenServer Xenix lock on part      of the file;\n9)X：for an SCO OpenServer Xenix lock on the      entire file;\n10)space：if there is no lock.\n## example\n- `lsof -a -p $$ -d 0,1,2`显示当前进程0,1,2的文件描述符信息,信息含义如下:\n- `lsof -i tcp`:列出所有tcp网络连接信息\n- `lsof - i :3306`:列出谁在使用某个端口\n- `lsof -a -u test -i`:列出某个用户的所有活跃的网络端口\n- `lsof -i @nf5260i5-td:20,21,80 -r 3`:列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行\n- `lsof -i 4 -a -p 1234`:列出被进程号为1234的进程所打开的所有IPV4 network files\n# ps\n## 命令参数\n- a 显示所有进程\n- -a 显示同一终端下的所有程序\n- -A 显示所有进程\n- c 显示进程的真实名称\n- -N 反向选择\n- -e 等于“-A”\n- e 显示环境变量\n- f 显示程序间的关系\n- -H 显示树状结构\n- r 显示当前终端的进程\n- T 显示当前终端的所有程序\n- u 指定用户的所有进程\n- -au 显示较详细的资讯\n- -aux 显示所有包含其他使用者的行程\n- -C<命令> 列出指定命令的状况\n- –lines<行数> 每页显示的行数\n- –width<字符数> 每页显示的字符数\n- –help 显示帮助信息\n- –version 显示版本显示\n## 输出列\n- F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user\n- S 代表这个程序的状态 (STAT)\n- UID 程序被该 UID 所拥有\n- PID 进程的ID\n- PPID 则是其上级父程序的ID\n- C CPU 使用的资源百分比\n- PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍\n- NI 这个是 Nice 值\n- ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“\n- SZ 使用掉的内存大小\n- WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作\n- TTY 登入者的终端机位置\n- TIME 使用掉的 CPU 时间。\n- CMD 所下达的指令为何\n### STAT\n- D 不可中断 uninterruptible sleep (usually IO)\n- R 运行 runnable (on run queue)\n- S 中断 sleeping\n- T 停止 traced or stopped\n- Z 僵死 a defunct (”zombie”) process\n### example\n- `ps -ef`:显示所有进程信息，连同命令行\n- `ps aux`:列出目前所有的正在内存中的程序\n# strace\nstrace常用来跟踪进程执行时的系统调用和所接收的信号\n## 输出信息\n每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。\n## 参数\n- -c 统计每一系统调用的所执行的时间,次数和出错的次数等.\n- -d 输出strace关于标准错误的调试信息.\n- -f 跟踪由fork调用所产生的子进程.\n- -ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.\n- -F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.\n- -h 输出简要的帮助信息.\n- -i 输出系统调用的入口指针.\n- -q 禁止输出关于脱离的消息.\n- -r 打印出相对时间关于,,每一个系统调用.\n- -t 在输出中的每一行前加上时间信息.\n- -tt 在输出中的每一行前加上时间信息,微秒级.\n- -ttt 微秒级输出,以秒了表示时间.\n- -T 显示每一调用所耗的时间.\n- -v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.\n- -V 输出strace的版本信息.\n- -x 以十六进制形式输出非标准字符串\n- -xx 所有字符串以十六进制形式输出.\n- -a <column>设置返回值的输出位置.默认 为40.\n输出写入到指定文件中的数据.\n- -o filename 将strace的输出写入文件filename\n- -p pid 跟踪指定的进程pid.\n- -s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.\n- -u username 以username 的UID和GID执行被跟踪的命令\n### -e\n-e expr 指定一个表达式,用来控制如何跟踪.格式如下:\n`[qualifier=][!]value1[,value2]...`\nqualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:\n-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.\n注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\.\n- -e trace=<set>\n只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.\n    - -e trace=file 只跟踪有关文件操作的系统调用.\n    - -e trace=process 只跟踪有关进程控制的系统调用.\n    - -e trace=network 跟踪与网络有关的所有系统调用.\n    - -e strace=signal 跟踪所有与系统信号有关的 系统调用\n    - -e strace=ipc 跟踪所有与进程通讯有关的系统调用\n- -e abbrev=<set> 设定 strace输出的系统调用的结果集.`-v`等价于`abbrev=none`.默认为abbrev=all.\n- -e raw=<set> 将指定的系统调用的参数以十六进制显示.\n- -e signal=<set> 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.\n-e read=<set> 输出从指定文件中读出 的数据.例如:\n    -e read=3,5.从文件描述符3,5读出的系统调用\n    -e write=<set>\n## example\n`strace -o output.txt -T -tt -e trace=all -p 28979`\n`strace -p <process-pid>`:实时输出程序的系统调用\n`strace -f -F -o ~/straceout.txt myserver`:跟踪可执行程序\n\n","slug":"Linux命令-资源性能篇","published":1,"updated":"2024-08-08T22:24:51.870Z","_id":"clwnyxnde0002qzq2djbtcbz7","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"uptime\"><a href=\"#uptime\" class=\"headerlink\" title=\"uptime\"></a>uptime</h1><p>该命令输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02<br></code></pre></td></tr></table></figure>\n<p>该平均负载指标了<strong>要</strong>运行的任务(进程)数量，包括要在CPU上运行的进程以及在不中断IO(磁盘IO)中阻塞的进程。<br>三个值分别代表了1min，5min,15min的平均值</p>\n<h1 id=\"dmesg\"><a href=\"#dmesg\" class=\"headerlink\" title=\"dmesg\"></a>dmesg</h1><p>操作系统消息日志</p>\n<h1 id=\"free\"><a href=\"#free\" class=\"headerlink\" title=\"free\"></a>free</h1><p><a href=\"https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/free.html\">linuxtools-free</a></p>\n<h1 id=\"vmstat\"><a href=\"#vmstat\" class=\"headerlink\" title=\"vmstat\"></a>vmstat</h1><p><code>vmstat [-V] [-n] [delay [count]]</code></p>\n<ul>\n<li>-V表示打印出版本信息；</li>\n<li>-n表示在周期性循环输出时，输出的头部信息仅显示一次；</li>\n<li>delay是两次输出之间的延迟时间；</li>\n<li>count是指按照这个时间间隔统计的次数。</li>\n</ul>\n<h2 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ vmstat 1<br>procs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----<br> r  b swpd   free   buff  cache   si   so    bi    bo   <span class=\"hljs-keyword\">in</span>   cs us sy <span class=\"hljs-built_in\">id</span> wa st<br>34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0<br>32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0<br>32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0<br>32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0<br>32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0<br></code></pre></td></tr></table></figure>\n<h3 id=\"Procs-进程\"><a href=\"#Procs-进程\" class=\"headerlink\" title=\"Procs(进程)\"></a>Procs(进程)</h3><ul>\n<li><code>r</code>:在CPU上运行并等待回合的进程数。由于它不包含IO，因此它比指示CPU饱和的平均负载提供了更多的信息。一个大于CPU核数的r值就是饱和的。</li>\n<li><code>b</code>:等待IO的进程数量</li>\n</ul>\n<h3 id=\"Memory-内存\"><a href=\"#Memory-内存\" class=\"headerlink\" title=\"Memory(内存)\"></a>Memory(内存)</h3><ul>\n<li>free:空闲的内存(单位KB)</li>\n<li>swpd: 使用虚拟内存大小</li>\n<li>buff: 用作缓冲的内存大小</li>\n<li>cache: 用作缓存的内存大小</li>\n</ul>\n<h3 id=\"Swap\"><a href=\"#Swap\" class=\"headerlink\" title=\"Swap\"></a>Swap</h3><ul>\n<li>si: 每秒从交换区写到内存的大小</li>\n<li>so: 每秒写入交换区的内存大小<br>这两个非空，说明物理内存用完了，现在使用交换内存</li>\n</ul>\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3><ul>\n<li>bi: 每秒读取的块数</li>\n<li>bo: 每秒写入的块数(每块1024bytes)</li>\n</ul>\n<h3 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h3><ul>\n<li>in: 每秒中断数，包括时钟中断</li>\n<li>cs: 每秒上下文切换数</li>\n</ul>\n<h3 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h3><p>显示的是所有cpu的平均值</p>\n<ul>\n<li><code>us、sy、id、wa、st</code>:这些是CPU时间的分类，</li>\n<li>us: 用户进程执行时间(user time)</li>\n<li>sy: 系统进程执行时间(system time)</li>\n<li>id: 空闲时间(包括IO等待时间)</li>\n<li>wa: 等待IO时间</li>\n<li>st: 被偷窃时间（被其它宾客系统进行使用，或宾客系统隔离的驱动程序域Xen）<br>通过将用户时间和系统时间这两个分类相加，即可判断CPU是否繁忙。一定的等待IO时间说明磁盘有可能是性能瓶颈。你可以认为等待IO时间是另一种形式的空闲时间，它提供了它是如何空闲的线索。 IO处理需要占用CPU系统时间。一个较高的CPU系统时间（超过20%）可能会很有趣，有必要进一步研究：也许内核在很低效地处理IO。</li>\n</ul>\n<h1 id=\"mpstat\"><a href=\"#mpstat\" class=\"headerlink\" title=\"mpstat\"></a>mpstat</h1><p><code>mpstat -P ALL 1</code>：显示每个CPU的时间明细，用于检查不平衡状况</p>\n<h1 id=\"iostat\"><a href=\"#iostat\" class=\"headerlink\" title=\"iostat\"></a>iostat</h1><p><code>iostat [参数][时间][次数]</code><br>这是了解块设备（磁盘），应用的工作负载和产生的性能影响的绝佳工具。</p>\n<h2 id=\"命令参数\"><a href=\"#命令参数\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h2><p>-C 显示CPU使用情况<br>-d 显示磁盘使用情况<br>-k 以 KB 为单位显示<br>-m 以 M 为单位显示<br>-N 显示磁盘阵列(LVM) 信息<br>-n 显示NFS 使用情况<br>-p[磁盘] 显示磁盘和分区的情况<br>-t 显示终端和CPU的信息<br>-x 显示详细信息<br>-V 显示版本信息</p>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p><code>iostat -xz 1</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)<br>avg-cpu:  %user   %<span class=\"hljs-built_in\">nice</span> %system %iowait  %steal   %idle<br>          73.96    0.00    3.73    0.03    0.06   22.21<br>Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util<br>xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09<br>xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25<br>xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26<br>dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04<br>dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00<br>dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03<br></code></pre></td></tr></table></figure>\n<h3 id=\"cpu属性值\"><a href=\"#cpu属性值\" class=\"headerlink\" title=\"cpu属性值\"></a>cpu属性值</h3><ul>\n<li>%user：CPU处在用户模式下的时间百分比。</li>\n<li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li>\n<li>%system：CPU处在系统模式下的时间百分比。</li>\n<li>%iowait：CPU等待输入输出完成时间的百分比。</li>\n<li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>\n<li>%idle：CPU空闲时间百分比。<br>如果%iowait的值过高，表示硬盘存在I&#x2F;O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</li>\n</ul>\n<h3 id=\"disk属性值\"><a href=\"#disk属性值\" class=\"headerlink\" title=\"disk属性值\"></a>disk属性值</h3><ul>\n<li>rrqm&#x2F;s: 每秒进行 merge 的读操作数目。即 rmerge&#x2F;s</li>\n<li>wrqm&#x2F;s: 每秒进行 merge 的写操作数目。即 wmerge&#x2F;s</li>\n<li>r&#x2F;s: 每秒完成的读 I&#x2F;O 设备次数。即 rio&#x2F;s</li>\n<li>w&#x2F;s: 每秒完成的写 I&#x2F;O 设备次数。即 wio&#x2F;s</li>\n<li>rsec&#x2F;s: 每秒读扇区数。即 rsect&#x2F;s</li>\n<li>wsec&#x2F;s: 每秒写扇区数。即 wsect&#x2F;s</li>\n<li>rkB&#x2F;s: 每秒读K字节数。是 rsect&#x2F;s 的一半，因为每扇区大小为512字节。</li>\n<li>wkB&#x2F;s: 每秒写K字节数。是 wsect&#x2F;s 的一半。</li>\n<li>avgrq-sz: 平均每次设备I&#x2F;O操作的数据大小 (扇区)。</li>\n<li>avgqu-sz: 平均I&#x2F;O队列长度。发给设备的平均请求数。值大于1可以表明已达到饱和状态（尽管设备通常可以并行处理请求，尤其是在多个后端磁盘所组成的前端虚拟设备的情况下）。</li>\n<li>await: 平均每次设备I&#x2F;O操作的等待时间 (毫秒)。这是应用程序所感受到的时间，它包括IO排队时间和IO服务时间。大于预期的平均时间可能表示块设备饱和或设备出现问题了。</li>\n<li>svctm: 平均每次设备I&#x2F;O操作的服务时间 (毫秒)。</li>\n<li>%util: 一秒中有百分之多少的时间用于 I&#x2F;O 操作，即被io消耗的cpu百分比，设备利用率。这是一个表征繁忙度的百分比，它表示设备每秒工作的时间。尽管它的值取决于设备，但值大于60%通常会导致性能不佳（也会通过await的值观察到）。接近100␐%的值通常表示饱和。</li>\n</ul>\n<h3 id=\"信息意义\"><a href=\"#信息意义\" class=\"headerlink\" title=\"信息意义\"></a>信息意义</h3><ul>\n<li>如果%iowait的值过高，表示硬盘存在I&#x2F;O瓶颈。</li>\n<li>如果 %util 接近 100%，说明产生的I&#x2F;O请求太多，I&#x2F;O系统已经满负荷，该磁盘可能存在瓶颈。</li>\n<li>如果 svctm 比较接近 await，说明 I&#x2F;O 几乎没有等待时间；</li>\n<li>如果 await 远大于 svctm，说明I&#x2F;O 队列太长，io响应太慢，则需要进行必要优化。</li>\n<li>如果avgqu-sz比较大，也表示有大量io在等待。</li>\n</ul>\n<h1 id=\"sar\"><a href=\"#sar\" class=\"headerlink\" title=\"sar\"></a>sar</h1><p>sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。需要启动service(systemctl start sysstat.service),并保存相关日志到文件</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>-A 汇总所有的报告</li>\n<li>-a 报告文件读写使用情况</li>\n<li>-B 报告附加的缓存的使用情况</li>\n<li>-b 报告缓存的使用情况</li>\n<li>-c 报告系统调用的使用情况</li>\n<li>-d 报告磁盘的使用情况</li>\n<li>-g 报告串口的使用情况</li>\n<li>-h 报告关于buffer使用的统计数据</li>\n<li>-m 报告IPC消息队列和信号量的使用情况</li>\n<li>-n 报告命名cache的使用情况</li>\n<li>-p 报告调页活动的使用情况</li>\n<li>-q 报告运行队列和交换队列的平均长度</li>\n<li>-R 报告进程的活动情况</li>\n<li>-r 报告没有使用的内存页面和硬盘块</li>\n<li>-u 报告CPU的利用率</li>\n<li>-v 报告进程、i节点、文件和锁表状态</li>\n<li>-w 报告系统交换活动状况</li>\n<li>-y 报告TTY设备活动状况</li>\n</ul>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><h3 id=\"sar-n-DEV-1\"><a href=\"#sar-n-DEV-1\" class=\"headerlink\" title=\"sar -n DEV 1\"></a><code>sar -n DEV 1</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     _x86_64_    (32 CPU)<br>12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<br>12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00<br>12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00<br>12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00<br>12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<br>12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00<br>12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00<br>12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00<br></code></pre></td></tr></table></figure>\n<p>此命令可以检查网络接口的吞吐量：rxkB&#x2F;s和txkB&#x2F;s，作为工作负载的度量，还可以检查是否已达到网络接口的限制。在上面的示例中，eth0接收速率达到22MB&#x2F;s，即176Mbit&#x2F;s（远低于1Gbit&#x2F;s的网络接口限制，假设是千兆网卡）。</p>\n<h3 id=\"sar-n-TCP-ETCP-1\"><a href=\"#sar-n-TCP-ETCP-1\" class=\"headerlink\" title=\"sar -n TCP,ETCP 1\"></a><code>sar -n TCP,ETCP 1</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)<br>12:17:19 AM  active/s passive/s    iseg/s    oseg/s<br>12:17:20 AM      1.00      0.00  10233.00  18846.00<br>12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s<br>12:17:20 AM      0.00      0.00      0.00      0.00      0.00<br></code></pre></td></tr></table></figure>\n<p>这是一些关键的TCP指标的摘要，包括：</p>\n<ul>\n<li><code>active/s</code>：每秒本地启动的TCP连接数（例如，通过connect（））。</li>\n<li><code>passive/s</code>：每秒远程启动的TCP连接数（例如，通过accept（））。</li>\n<li><code>retrans/s</code>：每秒TCP重传的次数。<br>主动和被动计数通常作为服务器TCP负载的粗略度量：新接受的连接数（被动）和新出站的连接数（主动）。将主动视为出站，将被动视为入站可能对理解这两个指标有些帮助，但这并不是严格意义上的（例如，考虑从localhost到localhost的连接）。<br>重新传输是网络或服务器问题的迹象；它可能是不可靠的网络（例如，公共Internet），也可能是由于服务器过载并丢弃了数据包。上面的示例仅显示每秒一个新的TCP连接。</li>\n</ul>\n<h3 id=\"sar-u-1-2\"><a href=\"#sar-u-1-2\" class=\"headerlink\" title=\"sar -u 1 2\"></a><code>sar -u 1 2</code></h3><p>cpu使用率</p>\n<ul>\n<li>%user 用户模式下消耗的CPU时间的比例；</li>\n<li>%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>\n<li>%system 系统模式下消耗的CPU时间的比例；</li>\n<li>%iowait CPU等待磁盘I&#x2F;O导致空闲状态消耗的时间比例；</li>\n<li>%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</li>\n<li>%idle CPU空闲时间比例；</li>\n</ul>\n<h3 id=\"sar-q-1-2\"><a href=\"#sar-q-1-2\" class=\"headerlink\" title=\"sar -q 1 2\"></a><code>sar -q 1 2</code></h3><p>cpu平均负载</p>\n<ul>\n<li>runq-sz：运行队列的长度（等待运行的进程数）</li>\n<li>plist-sz：进程列表中进程（processes）和线程（threads）的数量</li>\n<li>ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载</li>\n<li>ldavg-15：过去15分钟的系统平均负载</li>\n</ul>\n<h3 id=\"sar-r-1-2\"><a href=\"#sar-r-1-2\" class=\"headerlink\" title=\"sar -r 1 2\"></a><code>sar -r 1 2</code></h3><p>内存情况</p>\n<ul>\n<li>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>\n<li>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>\n<li>%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>\n<li>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</li>\n<li>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>\n<li>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>\n</ul>\n<h3 id=\"sar-W-1-2\"><a href=\"#sar-W-1-2\" class=\"headerlink\" title=\"sar -W 1 2\"></a><code>sar -W 1 2</code></h3><p>页面交换情况<br>pswpin&#x2F;s：每秒系统换入的交换页面（swap page）数量<br>pswpout&#x2F;s：每秒系统换出的交换页面（swap page）数量</p>\n<h3 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h3><ul>\n<li>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</li>\n<li>怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看</li>\n<li>怀疑I&#x2F;O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</li>\n</ul>\n<h1 id=\"ipcs\"><a href=\"#ipcs\" class=\"headerlink\" title=\"ipcs\"></a>ipcs</h1><ul>\n<li><code>ipcs -m</code>:共享内存资源</li>\n<li><code>ipcs -q</code>:队列资源</li>\n<li><code>ipcs -s</code>:信号量资源</li>\n<li><code>ipcs -l</code>:类似于ulimit,列出系统资源限制</li>\n</ul>\n<h2 id=\"修改ipc资源限制\"><a href=\"#修改ipc资源限制\" class=\"headerlink\" title=\"修改ipc资源限制\"></a>修改ipc资源限制</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$cat</span> /etc/sysctl.conf<br><span class=\"hljs-comment\"># 一个消息的最大长度</span><br>kernel.msgmax = 524288<br><br><span class=\"hljs-comment\"># 一个消息队列上的最大字节数</span><br><span class=\"hljs-comment\"># 524288*10</span><br>kernel.msgmnb = 5242880<br><br><span class=\"hljs-comment\">#最大消息队列的个数</span><br>kernel.msgmni=2048<br><br><span class=\"hljs-comment\">#一个共享内存区的最大字节数</span><br>kernel.shmmax = 17179869184<br><br><span class=\"hljs-comment\">#系统范围内最大共享内存标识数</span><br>kernel.shmmni=4096<br><br><span class=\"hljs-comment\">#每个信号灯集的最大信号灯数 系统范围内最大信号灯数 每个信号灯支持的最大操作数 系统范围内最大信号灯集数</span><br><span class=\"hljs-comment\">#此参数为系统默认，可以不用修改</span><br><span class=\"hljs-comment\">#kernel.sem = &lt;semmsl&gt; &lt;semmni&gt;*&lt;semmsl&gt; &lt;semopm&gt; &lt;semmni&gt;</span><br>kernel.sem = 250 32000 32 128<br></code></pre></td></tr></table></figure>\n<p>修改保存后使用sysctl -p</p>\n<h2 id=\"清除IPC资源\"><a href=\"#清除IPC资源\" class=\"headerlink\" title=\"清除IPC资源\"></a>清除IPC资源</h2><ul>\n<li>ipcrm -M shmkey  移除用shmkey创建的共享内存段</li>\n<li>ipcrm -m shmid    移除用shmid标识的共享内存段</li>\n<li>ipcrm -Q msgkey  移除用msqkey创建的消息队列</li>\n<li>ipcrm -q msqid  移除用msqid标识的消息队列</li>\n<li>ipcrm -S semkey  移除用semkey创建的信号</li>\n<li>ipcrm -s semid  移除用semid标识的信号</li>\n</ul>\n<h2 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li>清除当前用户创建的所有的IPC资源<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ipcs -q | awk <span class=\"hljs-string\">&#x27;&#123; print &quot;ipcrm -q &quot;$2&#125;&#x27;</span> | sh &gt; /dev/null 2&gt;&amp;1;<br>ipcs -m | awk <span class=\"hljs-string\">&#x27;&#123; print &quot;ipcrm -m &quot;$2&#125;&#x27;</span> | sh &gt; /dev/null 2&gt;&amp;1;<br>ipcs -s | awk <span class=\"hljs-string\">&#x27;&#123; print &quot;ipcrm -s &quot;$2&#125;&#x27;</span> | sh &gt; /dev/null 2&gt;&amp;1;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"fuser\"><a href=\"#fuser\" class=\"headerlink\" title=\"fuser\"></a>fuser</h1><p>显示所有正在使用着指定file,file system或sockets的进程信息<br><code>fuser -m -u redis-server</code>用来查找所有正在使用redis-server的所有进程的PID以及该进程的OWNER<br><code>fuser –k /path/to/your/filename</code>:kill所有正在使用某一指定的file, file system or sockets的进程</p>\n<h1 id=\"top-htop更强大的替换工具\"><a href=\"#top-htop更强大的替换工具\" class=\"headerlink\" title=\"top(htop更强大的替换工具)\"></a>top(htop更强大的替换工具)</h1><h2 id=\"输出信息-1\"><a href=\"#输出信息-1\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$top</span><br>    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00<br>    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie<br>    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%<span class=\"hljs-built_in\">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st<br>    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers<br>    Swap:   397308k total,    67192k used,   330116k free,    71900k cached<br>    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init<br>    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd<br>    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0<br>    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"第一行\"><a href=\"#第一行\" class=\"headerlink\" title=\"第一行\"></a>第一行</h3><ul>\n<li>09:14:56 ： 系统当前时间</li>\n<li>264 days, 20:56 ： 系统开机到现在经过了多少时间</li>\n<li>1 users ： 当前2用户在线</li>\n<li>load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息</li>\n</ul>\n<h3 id=\"Tasks\"><a href=\"#Tasks\" class=\"headerlink\" title=\"Tasks\"></a>Tasks</h3><ul>\n<li>87 total：很好理解，就是当前有87个任务，也就是87个进程。</li>\n<li>1 running：1个进程正在运行</li>\n<li>86 sleeping：86个进程睡眠</li>\n<li>0 stopped：停止的进程数</li>\n<li>0 zombie：僵死的进程数</li>\n</ul>\n<h3 id=\"Cpu-s\"><a href=\"#Cpu-s\" class=\"headerlink\" title=\"Cpu(s)\"></a>Cpu(s)</h3><ul>\n<li>0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。</li>\n<li>0.7%sy：内核占用CPU时间百分比</li>\n<li>0.0%ni：改变过优先级的进程占用CPU的百分比</li>\n<li>99.3%id：空闲CPU时间百分比</li>\n<li>0.0%wa：等待I&#x2F;O的CPU时间百分比</li>\n<li>0.0%hi：CPU硬中断时间百分比</li>\n<li>0.0%si：CPU软中断时间百分比<br>注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；</li>\n</ul>\n<h3 id=\"Men：内存\"><a href=\"#Men：内存\" class=\"headerlink\" title=\"Men：内存\"></a>Men：内存</h3><ul>\n<li>8175320kk total：物理内存总量</li>\n<li>8058868k used：使用的物理内存量</li>\n<li>116452k free：空闲的物理内存量</li>\n<li>283084k buffers：用作内核缓存的物理内存量</li>\n</ul>\n<h3 id=\"Swap：交换空间\"><a href=\"#Swap：交换空间\" class=\"headerlink\" title=\"Swap：交换空间\"></a>Swap：交换空间</h3><ul>\n<li>6881272k total：交换区总量</li>\n<li>4010444k used：使用的交换区量</li>\n<li>2870828k free：空闲的交换区量</li>\n<li>4336992k cached：缓冲交换区总量</li>\n</ul>\n<h3 id=\"进程信息\"><a href=\"#进程信息\" class=\"headerlink\" title=\"进程信息\"></a>进程信息</h3><ul>\n<li>PID：进程的ID</li>\n<li>USER：进程所有者</li>\n<li>PR：进程的优先级别，越小越优先被执行</li>\n<li>NInice：值</li>\n<li>VIRT：进程占用的虚拟内存</li>\n<li>RES：进程占用的物理内存</li>\n<li>SHR：进程使用的共享内存</li>\n<li>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</li>\n<li>%CPU：进程占用CPU的使用率</li>\n<li>%MEM：进程使用的物理内存和总内存的百分比</li>\n<li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</li>\n<li>COMMAND：进程启动命令名称</li>\n</ul>\n<h2 id=\"交互模式\"><a href=\"#交互模式\" class=\"headerlink\" title=\"交互模式\"></a>交互模式</h2><ul>\n<li>q：退出top命令</li>\n<li><Space>：立即刷新</li>\n<li>s：设置刷新时间间隔</li>\n<li>c：显示命令完全模式</li>\n<li>t:：显示或隐藏进程和CPU状态信息</li>\n<li>m：显示或隐藏内存状态信息</li>\n<li>l：显示或隐藏uptime信息</li>\n<li>f：增加或减少进程显示标志</li>\n<li>S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+</li>\n<li>P：按%CPU使用率排行</li>\n<li>T：按MITE+排行</li>\n<li>M：按%MEM排行</li>\n<li>u：指定显示用户进程</li>\n<li>r：修改进程renice值</li>\n<li>kkill：进程</li>\n<li>i：只显示正在运行的进程</li>\n<li>W：保存对top的设置到文件^&#x2F;.toprc，下次启动将自动调用toprc文件的设置。</li>\n<li>h：帮助命令。</li>\n<li>1: 显示各个Cpu信息</li>\n</ul>\n<h2 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>top -p pid</code>:显示指定进程信息(支持pid,pid多个进程id)</li>\n<li></li>\n</ul>\n<h1 id=\"查询软硬件信息\"><a href=\"#查询软硬件信息\" class=\"headerlink\" title=\"查询软硬件信息\"></a>查询软硬件信息</h1><ul>\n<li><code>uname -a</code>,<code>lsb_release -a</code>linux系统版本</li>\n<li><code>more /etc/release</code>操作系统版本</li>\n<li><code>neofetch</code>系统概览</li>\n<li><code>cat /proc/cpuinfo</code>:cpu信息</li>\n<li><code>cat /proc/meminfo</code>:内存信息</li>\n<li><code>pagesize</code>:显示内存page大小(kb)</li>\n<li><code>ulimit -a</code>:显示系统资源限制信息</li>\n</ul>\n<h1 id=\"lsof\"><a href=\"#lsof\" class=\"headerlink\" title=\"lsof\"></a>lsof</h1><h2 id=\"命令参数-1\"><a href=\"#命令参数-1\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h2><ul>\n<li>-p:指定进程ID</li>\n<li>-d:指定要显示的文件描述符编号</li>\n<li>-a:列出打开文件存在的进程</li>\n<li>-c&lt;进程名&gt;:列出指定进程所打开的文件</li>\n<li>-g:列出GID号进程详情</li>\n<li>-d&lt;文件号&gt;:列出占用该文件号的进程</li>\n<li>+d&lt;目录&gt;:列出目录下被打开的文件</li>\n<li>+D&lt;目录&gt;:递归列出目录下被打开的文件</li>\n<li>-n&lt;目录&gt;:列出使用NFS的文件</li>\n<li>-i&lt;条件&gt;:列出符合条件的进程。（4、6、协议、:端口、 @ip ）</li>\n<li>-p&lt;进程号&gt;:列出指定进程号所打开的文件</li>\n<li>-u:列出UID号进程详情</li>\n<li>-h:显示帮助信息</li>\n<li>-v:显示版本信息</li>\n</ul>\n<h2 id=\"列信息\"><a href=\"#列信息\" class=\"headerlink\" title=\"列信息\"></a>列信息</h2><ul>\n<li>COMMAND 正在运行的命令名字的前 9 个字符</li>\n<li>PID 进程的 PID</li>\n<li>USER 进程属主的登录名</li>\n<li>DEVICE 设备的设备号（主设备号和从设备号）</li>\n<li>SIZE 如果有的话，表示文件的大小</li>\n<li>NODE 本地文件的节点号</li>\n<li>NAME 文件名</li>\n</ul>\n<h3 id=\"TYPE\"><a href=\"#TYPE\" class=\"headerlink\" title=\"TYPE\"></a>TYPE</h3><p>TYPE 文件的类型</p>\n<ol>\n<li>DIR：表示目录</li>\n<li>CHR：表示字符类型</li>\n<li>BLK：块设备类型</li>\n<li>UNIX： UNIX 域套接字</li>\n<li>FIFO：先进先出 (FIFO) 队列</li>\n<li>IPv4：网际协议 (IP) 套接字</li>\n<li>REG: 常规文件</li>\n</ol>\n<h3 id=\"FD\"><a href=\"#FD\" class=\"headerlink\" title=\"FD\"></a>FD</h3><p>FD 文件描述符号以及访问类型<br>1)cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改<br>2)txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序<br>3)lnn：library references (AIX);<br>4)er：FD information error (see NAME column);<br>5)jld：jail directory (FreeBSD);<br>6)ltx：shared library text (code and data);<br>7)mxx ：hex memory-mapped type number xx.<br>8)m86：DOS Merge mapped file;<br>9)mem：memory-mapped file;<br>10)mmap：memory-mapped device;<br>11)pd：parent directory;<br>12)rtd：root directory;<br>13)tr：kernel trace file (OpenBSD);<br>14)v86  VP&#x2F;ix mapped file;<br>15)0：表示标准输入<br>16)1：表示标准输出<br>17)2：表示标准错误<br>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等<br>1)u：表示该文件被打开并处于读取&#x2F;写入模式<br>2)r：表示该文件被打开并处于只读模式<br>3)w：表示该文件被打开并处于<br>4)空格：表示该文件的状态模式为unknow，且没有锁定<br>5)-：表示该文件的状态模式为unknow，且被锁定<br>同时在文件状态模式后面，还跟着相关的锁<br>1)N：for a Solaris NFS lock of unknown type;<br>2)r：for read lock on part of the file;<br>3)R：for a read lock on the entire file;<br>4)w：for a write lock on part of the file;文件的部分写锁)<br>5)W：for a write lock on the entire file;整个文件的写锁)<br>6)u：for a read and write lock of any length;<br>7)U：for a lock of unknown type;<br>8)x：for an SCO OpenServer Xenix lock on part      of the file;<br>9)X：for an SCO OpenServer Xenix lock on the      entire file;<br>10)space：if there is no lock.</p>\n<h2 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>lsof -a -p $$ -d 0,1,2</code>显示当前进程0,1,2的文件描述符信息,信息含义如下:</li>\n<li><code>lsof -i tcp</code>:列出所有tcp网络连接信息</li>\n<li><code>lsof - i :3306</code>:列出谁在使用某个端口</li>\n<li><code>lsof -a -u test -i</code>:列出某个用户的所有活跃的网络端口</li>\n<li><code>lsof -i @nf5260i5-td:20,21,80 -r 3</code>:列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行</li>\n<li><code>lsof -i 4 -a -p 1234</code>:列出被进程号为1234的进程所打开的所有IPV4 network files</li>\n</ul>\n<h1 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h1><h2 id=\"命令参数-2\"><a href=\"#命令参数-2\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h2><ul>\n<li>a 显示所有进程</li>\n<li>-a 显示同一终端下的所有程序</li>\n<li>-A 显示所有进程</li>\n<li>c 显示进程的真实名称</li>\n<li>-N 反向选择</li>\n<li>-e 等于“-A”</li>\n<li>e 显示环境变量</li>\n<li>f 显示程序间的关系</li>\n<li>-H 显示树状结构</li>\n<li>r 显示当前终端的进程</li>\n<li>T 显示当前终端的所有程序</li>\n<li>u 指定用户的所有进程</li>\n<li>-au 显示较详细的资讯</li>\n<li>-aux 显示所有包含其他使用者的行程</li>\n<li>-C&lt;命令&gt; 列出指定命令的状况</li>\n<li>–lines&lt;行数&gt; 每页显示的行数</li>\n<li>–width&lt;字符数&gt; 每页显示的字符数</li>\n<li>–help 显示帮助信息</li>\n<li>–version 显示版本显示</li>\n</ul>\n<h2 id=\"输出列\"><a href=\"#输出列\" class=\"headerlink\" title=\"输出列\"></a>输出列</h2><ul>\n<li>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li>\n<li>S 代表这个程序的状态 (STAT)</li>\n<li>UID 程序被该 UID 所拥有</li>\n<li>PID 进程的ID</li>\n<li>PPID 则是其上级父程序的ID</li>\n<li>C CPU 使用的资源百分比</li>\n<li>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</li>\n<li>NI 这个是 Nice 值</li>\n<li>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</li>\n<li>SZ 使用掉的内存大小</li>\n<li>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</li>\n<li>TTY 登入者的终端机位置</li>\n<li>TIME 使用掉的 CPU 时间。</li>\n<li>CMD 所下达的指令为何</li>\n</ul>\n<h3 id=\"STAT\"><a href=\"#STAT\" class=\"headerlink\" title=\"STAT\"></a>STAT</h3><ul>\n<li>D 不可中断 uninterruptible sleep (usually IO)</li>\n<li>R 运行 runnable (on run queue)</li>\n<li>S 中断 sleeping</li>\n<li>T 停止 traced or stopped</li>\n<li>Z 僵死 a defunct (”zombie”) process</li>\n</ul>\n<h3 id=\"example-4\"><a href=\"#example-4\" class=\"headerlink\" title=\"example\"></a>example</h3><ul>\n<li><code>ps -ef</code>:显示所有进程信息，连同命令行</li>\n<li><code>ps aux</code>:列出目前所有的正在内存中的程序</li>\n</ul>\n<h1 id=\"strace\"><a href=\"#strace\" class=\"headerlink\" title=\"strace\"></a>strace</h1><p>strace常用来跟踪进程执行时的系统调用和所接收的信号</p>\n<h2 id=\"输出信息-2\"><a href=\"#输出信息-2\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。</p>\n<h2 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</li>\n<li>-d 输出strace关于标准错误的调试信息.</li>\n<li>-f 跟踪由fork调用所产生的子进程.</li>\n<li>-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</li>\n<li>-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</li>\n<li>-h 输出简要的帮助信息.</li>\n<li>-i 输出系统调用的入口指针.</li>\n<li>-q 禁止输出关于脱离的消息.</li>\n<li>-r 打印出相对时间关于,,每一个系统调用.</li>\n<li>-t 在输出中的每一行前加上时间信息.</li>\n<li>-tt 在输出中的每一行前加上时间信息,微秒级.</li>\n<li>-ttt 微秒级输出,以秒了表示时间.</li>\n<li>-T 显示每一调用所耗的时间.</li>\n<li>-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</li>\n<li>-V 输出strace的版本信息.</li>\n<li>-x 以十六进制形式输出非标准字符串</li>\n<li>-xx 所有字符串以十六进制形式输出.</li>\n<li>-a <column>设置返回值的输出位置.默认 为40.<br>输出写入到指定文件中的数据.</li>\n<li>-o filename 将strace的输出写入文件filename</li>\n<li>-p pid 跟踪指定的进程pid.</li>\n<li>-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</li>\n<li>-u username 以username 的UID和GID执行被跟踪的命令</li>\n</ul>\n<h3 id=\"e\"><a href=\"#e\" class=\"headerlink\" title=\"-e\"></a>-e</h3><p>-e expr 指定一个表达式,用来控制如何跟踪.格式如下:<br><code>[qualifier=][!]value1[,value2]...</code><br>qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:<br>-eopen等价于 -e trace&#x3D;open,表示只跟踪open调用.而-etrace!&#x3D;open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.<br>注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</p>\n<ul>\n<li>-e trace&#x3D;<set><br>只跟踪指定的系统 调用.例如:-e trace&#x3D;open,close,rean,write表示只跟踪这四个系统调用.默认的为set&#x3D;all.<ul>\n<li>-e trace&#x3D;file 只跟踪有关文件操作的系统调用.</li>\n<li>-e trace&#x3D;process 只跟踪有关进程控制的系统调用.</li>\n<li>-e trace&#x3D;network 跟踪与网络有关的所有系统调用.</li>\n<li>-e strace&#x3D;signal 跟踪所有与系统信号有关的 系统调用</li>\n<li>-e strace&#x3D;ipc 跟踪所有与进程通讯有关的系统调用</li>\n</ul>\n</li>\n<li>-e abbrev&#x3D;<set> 设定 strace输出的系统调用的结果集.<code>-v</code>等价于<code>abbrev=none</code>.默认为abbrev&#x3D;all.</li>\n<li>-e raw&#x3D;<set> 将指定的系统调用的参数以十六进制显示.</li>\n<li>-e signal&#x3D;<set> 指定跟踪的系统信号.默认为all.如 signal&#x3D;!SIGIO(或者signal&#x3D;!io),表示不跟踪SIGIO信号.<br>-e read&#x3D;<set> 输出从指定文件中读出 的数据.例如:<br>  -e read&#x3D;3,5.从文件描述符3,5读出的系统调用<br>  -e write&#x3D;<set></li>\n</ul>\n<h2 id=\"example-5\"><a href=\"#example-5\" class=\"headerlink\" title=\"example\"></a>example</h2><p><code>strace -o output.txt -T -tt -e trace=all -p 28979</code><br><code>strace -p &lt;process-pid&gt;</code>:实时输出程序的系统调用<br><code>strace -f -F -o ~/straceout.txt myserver</code>:跟踪可执行程序</p>\n","excerpt":"","more":"<h1 id=\"uptime\"><a href=\"#uptime\" class=\"headerlink\" title=\"uptime\"></a>uptime</h1><p>该命令输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02<br></code></pre></td></tr></table></figure>\n<p>该平均负载指标了<strong>要</strong>运行的任务(进程)数量，包括要在CPU上运行的进程以及在不中断IO(磁盘IO)中阻塞的进程。<br>三个值分别代表了1min，5min,15min的平均值</p>\n<h1 id=\"dmesg\"><a href=\"#dmesg\" class=\"headerlink\" title=\"dmesg\"></a>dmesg</h1><p>操作系统消息日志</p>\n<h1 id=\"free\"><a href=\"#free\" class=\"headerlink\" title=\"free\"></a>free</h1><p><a href=\"https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/free.html\">linuxtools-free</a></p>\n<h1 id=\"vmstat\"><a href=\"#vmstat\" class=\"headerlink\" title=\"vmstat\"></a>vmstat</h1><p><code>vmstat [-V] [-n] [delay [count]]</code></p>\n<ul>\n<li>-V表示打印出版本信息；</li>\n<li>-n表示在周期性循环输出时，输出的头部信息仅显示一次；</li>\n<li>delay是两次输出之间的延迟时间；</li>\n<li>count是指按照这个时间间隔统计的次数。</li>\n</ul>\n<h2 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ vmstat 1<br>procs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----<br> r  b swpd   free   buff  cache   si   so    bi    bo   <span class=\"hljs-keyword\">in</span>   cs us sy <span class=\"hljs-built_in\">id</span> wa st<br>34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0<br>32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0<br>32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0<br>32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0<br>32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0<br></code></pre></td></tr></table></figure>\n<h3 id=\"Procs-进程\"><a href=\"#Procs-进程\" class=\"headerlink\" title=\"Procs(进程)\"></a>Procs(进程)</h3><ul>\n<li><code>r</code>:在CPU上运行并等待回合的进程数。由于它不包含IO，因此它比指示CPU饱和的平均负载提供了更多的信息。一个大于CPU核数的r值就是饱和的。</li>\n<li><code>b</code>:等待IO的进程数量</li>\n</ul>\n<h3 id=\"Memory-内存\"><a href=\"#Memory-内存\" class=\"headerlink\" title=\"Memory(内存)\"></a>Memory(内存)</h3><ul>\n<li>free:空闲的内存(单位KB)</li>\n<li>swpd: 使用虚拟内存大小</li>\n<li>buff: 用作缓冲的内存大小</li>\n<li>cache: 用作缓存的内存大小</li>\n</ul>\n<h3 id=\"Swap\"><a href=\"#Swap\" class=\"headerlink\" title=\"Swap\"></a>Swap</h3><ul>\n<li>si: 每秒从交换区写到内存的大小</li>\n<li>so: 每秒写入交换区的内存大小<br>这两个非空，说明物理内存用完了，现在使用交换内存</li>\n</ul>\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3><ul>\n<li>bi: 每秒读取的块数</li>\n<li>bo: 每秒写入的块数(每块1024bytes)</li>\n</ul>\n<h3 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h3><ul>\n<li>in: 每秒中断数，包括时钟中断</li>\n<li>cs: 每秒上下文切换数</li>\n</ul>\n<h3 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h3><p>显示的是所有cpu的平均值</p>\n<ul>\n<li><code>us、sy、id、wa、st</code>:这些是CPU时间的分类，</li>\n<li>us: 用户进程执行时间(user time)</li>\n<li>sy: 系统进程执行时间(system time)</li>\n<li>id: 空闲时间(包括IO等待时间)</li>\n<li>wa: 等待IO时间</li>\n<li>st: 被偷窃时间（被其它宾客系统进行使用，或宾客系统隔离的驱动程序域Xen）<br>通过将用户时间和系统时间这两个分类相加，即可判断CPU是否繁忙。一定的等待IO时间说明磁盘有可能是性能瓶颈。你可以认为等待IO时间是另一种形式的空闲时间，它提供了它是如何空闲的线索。 IO处理需要占用CPU系统时间。一个较高的CPU系统时间（超过20%）可能会很有趣，有必要进一步研究：也许内核在很低效地处理IO。</li>\n</ul>\n<h1 id=\"mpstat\"><a href=\"#mpstat\" class=\"headerlink\" title=\"mpstat\"></a>mpstat</h1><p><code>mpstat -P ALL 1</code>：显示每个CPU的时间明细，用于检查不平衡状况</p>\n<h1 id=\"iostat\"><a href=\"#iostat\" class=\"headerlink\" title=\"iostat\"></a>iostat</h1><p><code>iostat [参数][时间][次数]</code><br>这是了解块设备（磁盘），应用的工作负载和产生的性能影响的绝佳工具。</p>\n<h2 id=\"命令参数\"><a href=\"#命令参数\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h2><p>-C 显示CPU使用情况<br>-d 显示磁盘使用情况<br>-k 以 KB 为单位显示<br>-m 以 M 为单位显示<br>-N 显示磁盘阵列(LVM) 信息<br>-n 显示NFS 使用情况<br>-p[磁盘] 显示磁盘和分区的情况<br>-t 显示终端和CPU的信息<br>-x 显示详细信息<br>-V 显示版本信息</p>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p><code>iostat -xz 1</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)<br>avg-cpu:  %user   %<span class=\"hljs-built_in\">nice</span> %system %iowait  %steal   %idle<br>          73.96    0.00    3.73    0.03    0.06   22.21<br>Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util<br>xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09<br>xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25<br>xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26<br>dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04<br>dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00<br>dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03<br></code></pre></td></tr></table></figure>\n<h3 id=\"cpu属性值\"><a href=\"#cpu属性值\" class=\"headerlink\" title=\"cpu属性值\"></a>cpu属性值</h3><ul>\n<li>%user：CPU处在用户模式下的时间百分比。</li>\n<li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li>\n<li>%system：CPU处在系统模式下的时间百分比。</li>\n<li>%iowait：CPU等待输入输出完成时间的百分比。</li>\n<li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>\n<li>%idle：CPU空闲时间百分比。<br>如果%iowait的值过高，表示硬盘存在I&#x2F;O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</li>\n</ul>\n<h3 id=\"disk属性值\"><a href=\"#disk属性值\" class=\"headerlink\" title=\"disk属性值\"></a>disk属性值</h3><ul>\n<li>rrqm&#x2F;s: 每秒进行 merge 的读操作数目。即 rmerge&#x2F;s</li>\n<li>wrqm&#x2F;s: 每秒进行 merge 的写操作数目。即 wmerge&#x2F;s</li>\n<li>r&#x2F;s: 每秒完成的读 I&#x2F;O 设备次数。即 rio&#x2F;s</li>\n<li>w&#x2F;s: 每秒完成的写 I&#x2F;O 设备次数。即 wio&#x2F;s</li>\n<li>rsec&#x2F;s: 每秒读扇区数。即 rsect&#x2F;s</li>\n<li>wsec&#x2F;s: 每秒写扇区数。即 wsect&#x2F;s</li>\n<li>rkB&#x2F;s: 每秒读K字节数。是 rsect&#x2F;s 的一半，因为每扇区大小为512字节。</li>\n<li>wkB&#x2F;s: 每秒写K字节数。是 wsect&#x2F;s 的一半。</li>\n<li>avgrq-sz: 平均每次设备I&#x2F;O操作的数据大小 (扇区)。</li>\n<li>avgqu-sz: 平均I&#x2F;O队列长度。发给设备的平均请求数。值大于1可以表明已达到饱和状态（尽管设备通常可以并行处理请求，尤其是在多个后端磁盘所组成的前端虚拟设备的情况下）。</li>\n<li>await: 平均每次设备I&#x2F;O操作的等待时间 (毫秒)。这是应用程序所感受到的时间，它包括IO排队时间和IO服务时间。大于预期的平均时间可能表示块设备饱和或设备出现问题了。</li>\n<li>svctm: 平均每次设备I&#x2F;O操作的服务时间 (毫秒)。</li>\n<li>%util: 一秒中有百分之多少的时间用于 I&#x2F;O 操作，即被io消耗的cpu百分比，设备利用率。这是一个表征繁忙度的百分比，它表示设备每秒工作的时间。尽管它的值取决于设备，但值大于60%通常会导致性能不佳（也会通过await的值观察到）。接近100␐%的值通常表示饱和。</li>\n</ul>\n<h3 id=\"信息意义\"><a href=\"#信息意义\" class=\"headerlink\" title=\"信息意义\"></a>信息意义</h3><ul>\n<li>如果%iowait的值过高，表示硬盘存在I&#x2F;O瓶颈。</li>\n<li>如果 %util 接近 100%，说明产生的I&#x2F;O请求太多，I&#x2F;O系统已经满负荷，该磁盘可能存在瓶颈。</li>\n<li>如果 svctm 比较接近 await，说明 I&#x2F;O 几乎没有等待时间；</li>\n<li>如果 await 远大于 svctm，说明I&#x2F;O 队列太长，io响应太慢，则需要进行必要优化。</li>\n<li>如果avgqu-sz比较大，也表示有大量io在等待。</li>\n</ul>\n<h1 id=\"sar\"><a href=\"#sar\" class=\"headerlink\" title=\"sar\"></a>sar</h1><p>sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。需要启动service(systemctl start sysstat.service),并保存相关日志到文件</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>-A 汇总所有的报告</li>\n<li>-a 报告文件读写使用情况</li>\n<li>-B 报告附加的缓存的使用情况</li>\n<li>-b 报告缓存的使用情况</li>\n<li>-c 报告系统调用的使用情况</li>\n<li>-d 报告磁盘的使用情况</li>\n<li>-g 报告串口的使用情况</li>\n<li>-h 报告关于buffer使用的统计数据</li>\n<li>-m 报告IPC消息队列和信号量的使用情况</li>\n<li>-n 报告命名cache的使用情况</li>\n<li>-p 报告调页活动的使用情况</li>\n<li>-q 报告运行队列和交换队列的平均长度</li>\n<li>-R 报告进程的活动情况</li>\n<li>-r 报告没有使用的内存页面和硬盘块</li>\n<li>-u 报告CPU的利用率</li>\n<li>-v 报告进程、i节点、文件和锁表状态</li>\n<li>-w 报告系统交换活动状况</li>\n<li>-y 报告TTY设备活动状况</li>\n</ul>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><h3 id=\"sar-n-DEV-1\"><a href=\"#sar-n-DEV-1\" class=\"headerlink\" title=\"sar -n DEV 1\"></a><code>sar -n DEV 1</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     _x86_64_    (32 CPU)<br>12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<br>12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00<br>12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00<br>12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00<br>12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<br>12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00<br>12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00<br>12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00<br></code></pre></td></tr></table></figure>\n<p>此命令可以检查网络接口的吞吐量：rxkB&#x2F;s和txkB&#x2F;s，作为工作负载的度量，还可以检查是否已达到网络接口的限制。在上面的示例中，eth0接收速率达到22MB&#x2F;s，即176Mbit&#x2F;s（远低于1Gbit&#x2F;s的网络接口限制，假设是千兆网卡）。</p>\n<h3 id=\"sar-n-TCP-ETCP-1\"><a href=\"#sar-n-TCP-ETCP-1\" class=\"headerlink\" title=\"sar -n TCP,ETCP 1\"></a><code>sar -n TCP,ETCP 1</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)<br>12:17:19 AM  active/s passive/s    iseg/s    oseg/s<br>12:17:20 AM      1.00      0.00  10233.00  18846.00<br>12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s<br>12:17:20 AM      0.00      0.00      0.00      0.00      0.00<br></code></pre></td></tr></table></figure>\n<p>这是一些关键的TCP指标的摘要，包括：</p>\n<ul>\n<li><code>active/s</code>：每秒本地启动的TCP连接数（例如，通过connect（））。</li>\n<li><code>passive/s</code>：每秒远程启动的TCP连接数（例如，通过accept（））。</li>\n<li><code>retrans/s</code>：每秒TCP重传的次数。<br>主动和被动计数通常作为服务器TCP负载的粗略度量：新接受的连接数（被动）和新出站的连接数（主动）。将主动视为出站，将被动视为入站可能对理解这两个指标有些帮助，但这并不是严格意义上的（例如，考虑从localhost到localhost的连接）。<br>重新传输是网络或服务器问题的迹象；它可能是不可靠的网络（例如，公共Internet），也可能是由于服务器过载并丢弃了数据包。上面的示例仅显示每秒一个新的TCP连接。</li>\n</ul>\n<h3 id=\"sar-u-1-2\"><a href=\"#sar-u-1-2\" class=\"headerlink\" title=\"sar -u 1 2\"></a><code>sar -u 1 2</code></h3><p>cpu使用率</p>\n<ul>\n<li>%user 用户模式下消耗的CPU时间的比例；</li>\n<li>%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>\n<li>%system 系统模式下消耗的CPU时间的比例；</li>\n<li>%iowait CPU等待磁盘I&#x2F;O导致空闲状态消耗的时间比例；</li>\n<li>%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</li>\n<li>%idle CPU空闲时间比例；</li>\n</ul>\n<h3 id=\"sar-q-1-2\"><a href=\"#sar-q-1-2\" class=\"headerlink\" title=\"sar -q 1 2\"></a><code>sar -q 1 2</code></h3><p>cpu平均负载</p>\n<ul>\n<li>runq-sz：运行队列的长度（等待运行的进程数）</li>\n<li>plist-sz：进程列表中进程（processes）和线程（threads）的数量</li>\n<li>ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载</li>\n<li>ldavg-15：过去15分钟的系统平均负载</li>\n</ul>\n<h3 id=\"sar-r-1-2\"><a href=\"#sar-r-1-2\" class=\"headerlink\" title=\"sar -r 1 2\"></a><code>sar -r 1 2</code></h3><p>内存情况</p>\n<ul>\n<li>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>\n<li>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>\n<li>%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>\n<li>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</li>\n<li>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>\n<li>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>\n</ul>\n<h3 id=\"sar-W-1-2\"><a href=\"#sar-W-1-2\" class=\"headerlink\" title=\"sar -W 1 2\"></a><code>sar -W 1 2</code></h3><p>页面交换情况<br>pswpin&#x2F;s：每秒系统换入的交换页面（swap page）数量<br>pswpout&#x2F;s：每秒系统换出的交换页面（swap page）数量</p>\n<h3 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h3><ul>\n<li>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</li>\n<li>怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看</li>\n<li>怀疑I&#x2F;O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</li>\n</ul>\n<h1 id=\"ipcs\"><a href=\"#ipcs\" class=\"headerlink\" title=\"ipcs\"></a>ipcs</h1><ul>\n<li><code>ipcs -m</code>:共享内存资源</li>\n<li><code>ipcs -q</code>:队列资源</li>\n<li><code>ipcs -s</code>:信号量资源</li>\n<li><code>ipcs -l</code>:类似于ulimit,列出系统资源限制</li>\n</ul>\n<h2 id=\"修改ipc资源限制\"><a href=\"#修改ipc资源限制\" class=\"headerlink\" title=\"修改ipc资源限制\"></a>修改ipc资源限制</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$cat</span> /etc/sysctl.conf<br><span class=\"hljs-comment\"># 一个消息的最大长度</span><br>kernel.msgmax = 524288<br><br><span class=\"hljs-comment\"># 一个消息队列上的最大字节数</span><br><span class=\"hljs-comment\"># 524288*10</span><br>kernel.msgmnb = 5242880<br><br><span class=\"hljs-comment\">#最大消息队列的个数</span><br>kernel.msgmni=2048<br><br><span class=\"hljs-comment\">#一个共享内存区的最大字节数</span><br>kernel.shmmax = 17179869184<br><br><span class=\"hljs-comment\">#系统范围内最大共享内存标识数</span><br>kernel.shmmni=4096<br><br><span class=\"hljs-comment\">#每个信号灯集的最大信号灯数 系统范围内最大信号灯数 每个信号灯支持的最大操作数 系统范围内最大信号灯集数</span><br><span class=\"hljs-comment\">#此参数为系统默认，可以不用修改</span><br><span class=\"hljs-comment\">#kernel.sem = &lt;semmsl&gt; &lt;semmni&gt;*&lt;semmsl&gt; &lt;semopm&gt; &lt;semmni&gt;</span><br>kernel.sem = 250 32000 32 128<br></code></pre></td></tr></table></figure>\n<p>修改保存后使用sysctl -p</p>\n<h2 id=\"清除IPC资源\"><a href=\"#清除IPC资源\" class=\"headerlink\" title=\"清除IPC资源\"></a>清除IPC资源</h2><ul>\n<li>ipcrm -M shmkey  移除用shmkey创建的共享内存段</li>\n<li>ipcrm -m shmid    移除用shmid标识的共享内存段</li>\n<li>ipcrm -Q msgkey  移除用msqkey创建的消息队列</li>\n<li>ipcrm -q msqid  移除用msqid标识的消息队列</li>\n<li>ipcrm -S semkey  移除用semkey创建的信号</li>\n<li>ipcrm -s semid  移除用semid标识的信号</li>\n</ul>\n<h2 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li>清除当前用户创建的所有的IPC资源<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ipcs -q | awk <span class=\"hljs-string\">&#x27;&#123; print &quot;ipcrm -q &quot;$2&#125;&#x27;</span> | sh &gt; /dev/null 2&gt;&amp;1;<br>ipcs -m | awk <span class=\"hljs-string\">&#x27;&#123; print &quot;ipcrm -m &quot;$2&#125;&#x27;</span> | sh &gt; /dev/null 2&gt;&amp;1;<br>ipcs -s | awk <span class=\"hljs-string\">&#x27;&#123; print &quot;ipcrm -s &quot;$2&#125;&#x27;</span> | sh &gt; /dev/null 2&gt;&amp;1;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"fuser\"><a href=\"#fuser\" class=\"headerlink\" title=\"fuser\"></a>fuser</h1><p>显示所有正在使用着指定file,file system或sockets的进程信息<br><code>fuser -m -u redis-server</code>用来查找所有正在使用redis-server的所有进程的PID以及该进程的OWNER<br><code>fuser –k /path/to/your/filename</code>:kill所有正在使用某一指定的file, file system or sockets的进程</p>\n<h1 id=\"top-htop更强大的替换工具\"><a href=\"#top-htop更强大的替换工具\" class=\"headerlink\" title=\"top(htop更强大的替换工具)\"></a>top(htop更强大的替换工具)</h1><h2 id=\"输出信息-1\"><a href=\"#输出信息-1\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$top</span><br>    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00<br>    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie<br>    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%<span class=\"hljs-built_in\">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st<br>    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers<br>    Swap:   397308k total,    67192k used,   330116k free,    71900k cached<br>    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init<br>    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd<br>    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0<br>    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"第一行\"><a href=\"#第一行\" class=\"headerlink\" title=\"第一行\"></a>第一行</h3><ul>\n<li>09:14:56 ： 系统当前时间</li>\n<li>264 days, 20:56 ： 系统开机到现在经过了多少时间</li>\n<li>1 users ： 当前2用户在线</li>\n<li>load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息</li>\n</ul>\n<h3 id=\"Tasks\"><a href=\"#Tasks\" class=\"headerlink\" title=\"Tasks\"></a>Tasks</h3><ul>\n<li>87 total：很好理解，就是当前有87个任务，也就是87个进程。</li>\n<li>1 running：1个进程正在运行</li>\n<li>86 sleeping：86个进程睡眠</li>\n<li>0 stopped：停止的进程数</li>\n<li>0 zombie：僵死的进程数</li>\n</ul>\n<h3 id=\"Cpu-s\"><a href=\"#Cpu-s\" class=\"headerlink\" title=\"Cpu(s)\"></a>Cpu(s)</h3><ul>\n<li>0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。</li>\n<li>0.7%sy：内核占用CPU时间百分比</li>\n<li>0.0%ni：改变过优先级的进程占用CPU的百分比</li>\n<li>99.3%id：空闲CPU时间百分比</li>\n<li>0.0%wa：等待I&#x2F;O的CPU时间百分比</li>\n<li>0.0%hi：CPU硬中断时间百分比</li>\n<li>0.0%si：CPU软中断时间百分比<br>注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；</li>\n</ul>\n<h3 id=\"Men：内存\"><a href=\"#Men：内存\" class=\"headerlink\" title=\"Men：内存\"></a>Men：内存</h3><ul>\n<li>8175320kk total：物理内存总量</li>\n<li>8058868k used：使用的物理内存量</li>\n<li>116452k free：空闲的物理内存量</li>\n<li>283084k buffers：用作内核缓存的物理内存量</li>\n</ul>\n<h3 id=\"Swap：交换空间\"><a href=\"#Swap：交换空间\" class=\"headerlink\" title=\"Swap：交换空间\"></a>Swap：交换空间</h3><ul>\n<li>6881272k total：交换区总量</li>\n<li>4010444k used：使用的交换区量</li>\n<li>2870828k free：空闲的交换区量</li>\n<li>4336992k cached：缓冲交换区总量</li>\n</ul>\n<h3 id=\"进程信息\"><a href=\"#进程信息\" class=\"headerlink\" title=\"进程信息\"></a>进程信息</h3><ul>\n<li>PID：进程的ID</li>\n<li>USER：进程所有者</li>\n<li>PR：进程的优先级别，越小越优先被执行</li>\n<li>NInice：值</li>\n<li>VIRT：进程占用的虚拟内存</li>\n<li>RES：进程占用的物理内存</li>\n<li>SHR：进程使用的共享内存</li>\n<li>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</li>\n<li>%CPU：进程占用CPU的使用率</li>\n<li>%MEM：进程使用的物理内存和总内存的百分比</li>\n<li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</li>\n<li>COMMAND：进程启动命令名称</li>\n</ul>\n<h2 id=\"交互模式\"><a href=\"#交互模式\" class=\"headerlink\" title=\"交互模式\"></a>交互模式</h2><ul>\n<li>q：退出top命令</li>\n<li><Space>：立即刷新</li>\n<li>s：设置刷新时间间隔</li>\n<li>c：显示命令完全模式</li>\n<li>t:：显示或隐藏进程和CPU状态信息</li>\n<li>m：显示或隐藏内存状态信息</li>\n<li>l：显示或隐藏uptime信息</li>\n<li>f：增加或减少进程显示标志</li>\n<li>S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+</li>\n<li>P：按%CPU使用率排行</li>\n<li>T：按MITE+排行</li>\n<li>M：按%MEM排行</li>\n<li>u：指定显示用户进程</li>\n<li>r：修改进程renice值</li>\n<li>kkill：进程</li>\n<li>i：只显示正在运行的进程</li>\n<li>W：保存对top的设置到文件^&#x2F;.toprc，下次启动将自动调用toprc文件的设置。</li>\n<li>h：帮助命令。</li>\n<li>1: 显示各个Cpu信息</li>\n</ul>\n<h2 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>top -p pid</code>:显示指定进程信息(支持pid,pid多个进程id)</li>\n<li></li>\n</ul>\n<h1 id=\"查询软硬件信息\"><a href=\"#查询软硬件信息\" class=\"headerlink\" title=\"查询软硬件信息\"></a>查询软硬件信息</h1><ul>\n<li><code>uname -a</code>,<code>lsb_release -a</code>linux系统版本</li>\n<li><code>more /etc/release</code>操作系统版本</li>\n<li><code>neofetch</code>系统概览</li>\n<li><code>cat /proc/cpuinfo</code>:cpu信息</li>\n<li><code>cat /proc/meminfo</code>:内存信息</li>\n<li><code>pagesize</code>:显示内存page大小(kb)</li>\n<li><code>ulimit -a</code>:显示系统资源限制信息</li>\n</ul>\n<h1 id=\"lsof\"><a href=\"#lsof\" class=\"headerlink\" title=\"lsof\"></a>lsof</h1><h2 id=\"命令参数-1\"><a href=\"#命令参数-1\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h2><ul>\n<li>-p:指定进程ID</li>\n<li>-d:指定要显示的文件描述符编号</li>\n<li>-a:列出打开文件存在的进程</li>\n<li>-c&lt;进程名&gt;:列出指定进程所打开的文件</li>\n<li>-g:列出GID号进程详情</li>\n<li>-d&lt;文件号&gt;:列出占用该文件号的进程</li>\n<li>+d&lt;目录&gt;:列出目录下被打开的文件</li>\n<li>+D&lt;目录&gt;:递归列出目录下被打开的文件</li>\n<li>-n&lt;目录&gt;:列出使用NFS的文件</li>\n<li>-i&lt;条件&gt;:列出符合条件的进程。（4、6、协议、:端口、 @ip ）</li>\n<li>-p&lt;进程号&gt;:列出指定进程号所打开的文件</li>\n<li>-u:列出UID号进程详情</li>\n<li>-h:显示帮助信息</li>\n<li>-v:显示版本信息</li>\n</ul>\n<h2 id=\"列信息\"><a href=\"#列信息\" class=\"headerlink\" title=\"列信息\"></a>列信息</h2><ul>\n<li>COMMAND 正在运行的命令名字的前 9 个字符</li>\n<li>PID 进程的 PID</li>\n<li>USER 进程属主的登录名</li>\n<li>DEVICE 设备的设备号（主设备号和从设备号）</li>\n<li>SIZE 如果有的话，表示文件的大小</li>\n<li>NODE 本地文件的节点号</li>\n<li>NAME 文件名</li>\n</ul>\n<h3 id=\"TYPE\"><a href=\"#TYPE\" class=\"headerlink\" title=\"TYPE\"></a>TYPE</h3><p>TYPE 文件的类型</p>\n<ol>\n<li>DIR：表示目录</li>\n<li>CHR：表示字符类型</li>\n<li>BLK：块设备类型</li>\n<li>UNIX： UNIX 域套接字</li>\n<li>FIFO：先进先出 (FIFO) 队列</li>\n<li>IPv4：网际协议 (IP) 套接字</li>\n<li>REG: 常规文件</li>\n</ol>\n<h3 id=\"FD\"><a href=\"#FD\" class=\"headerlink\" title=\"FD\"></a>FD</h3><p>FD 文件描述符号以及访问类型<br>1)cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改<br>2)txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序<br>3)lnn：library references (AIX);<br>4)er：FD information error (see NAME column);<br>5)jld：jail directory (FreeBSD);<br>6)ltx：shared library text (code and data);<br>7)mxx ：hex memory-mapped type number xx.<br>8)m86：DOS Merge mapped file;<br>9)mem：memory-mapped file;<br>10)mmap：memory-mapped device;<br>11)pd：parent directory;<br>12)rtd：root directory;<br>13)tr：kernel trace file (OpenBSD);<br>14)v86  VP&#x2F;ix mapped file;<br>15)0：表示标准输入<br>16)1：表示标准输出<br>17)2：表示标准错误<br>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等<br>1)u：表示该文件被打开并处于读取&#x2F;写入模式<br>2)r：表示该文件被打开并处于只读模式<br>3)w：表示该文件被打开并处于<br>4)空格：表示该文件的状态模式为unknow，且没有锁定<br>5)-：表示该文件的状态模式为unknow，且被锁定<br>同时在文件状态模式后面，还跟着相关的锁<br>1)N：for a Solaris NFS lock of unknown type;<br>2)r：for read lock on part of the file;<br>3)R：for a read lock on the entire file;<br>4)w：for a write lock on part of the file;文件的部分写锁)<br>5)W：for a write lock on the entire file;整个文件的写锁)<br>6)u：for a read and write lock of any length;<br>7)U：for a lock of unknown type;<br>8)x：for an SCO OpenServer Xenix lock on part      of the file;<br>9)X：for an SCO OpenServer Xenix lock on the      entire file;<br>10)space：if there is no lock.</p>\n<h2 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>lsof -a -p $$ -d 0,1,2</code>显示当前进程0,1,2的文件描述符信息,信息含义如下:</li>\n<li><code>lsof -i tcp</code>:列出所有tcp网络连接信息</li>\n<li><code>lsof - i :3306</code>:列出谁在使用某个端口</li>\n<li><code>lsof -a -u test -i</code>:列出某个用户的所有活跃的网络端口</li>\n<li><code>lsof -i @nf5260i5-td:20,21,80 -r 3</code>:列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行</li>\n<li><code>lsof -i 4 -a -p 1234</code>:列出被进程号为1234的进程所打开的所有IPV4 network files</li>\n</ul>\n<h1 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h1><h2 id=\"命令参数-2\"><a href=\"#命令参数-2\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h2><ul>\n<li>a 显示所有进程</li>\n<li>-a 显示同一终端下的所有程序</li>\n<li>-A 显示所有进程</li>\n<li>c 显示进程的真实名称</li>\n<li>-N 反向选择</li>\n<li>-e 等于“-A”</li>\n<li>e 显示环境变量</li>\n<li>f 显示程序间的关系</li>\n<li>-H 显示树状结构</li>\n<li>r 显示当前终端的进程</li>\n<li>T 显示当前终端的所有程序</li>\n<li>u 指定用户的所有进程</li>\n<li>-au 显示较详细的资讯</li>\n<li>-aux 显示所有包含其他使用者的行程</li>\n<li>-C&lt;命令&gt; 列出指定命令的状况</li>\n<li>–lines&lt;行数&gt; 每页显示的行数</li>\n<li>–width&lt;字符数&gt; 每页显示的字符数</li>\n<li>–help 显示帮助信息</li>\n<li>–version 显示版本显示</li>\n</ul>\n<h2 id=\"输出列\"><a href=\"#输出列\" class=\"headerlink\" title=\"输出列\"></a>输出列</h2><ul>\n<li>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li>\n<li>S 代表这个程序的状态 (STAT)</li>\n<li>UID 程序被该 UID 所拥有</li>\n<li>PID 进程的ID</li>\n<li>PPID 则是其上级父程序的ID</li>\n<li>C CPU 使用的资源百分比</li>\n<li>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</li>\n<li>NI 这个是 Nice 值</li>\n<li>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</li>\n<li>SZ 使用掉的内存大小</li>\n<li>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</li>\n<li>TTY 登入者的终端机位置</li>\n<li>TIME 使用掉的 CPU 时间。</li>\n<li>CMD 所下达的指令为何</li>\n</ul>\n<h3 id=\"STAT\"><a href=\"#STAT\" class=\"headerlink\" title=\"STAT\"></a>STAT</h3><ul>\n<li>D 不可中断 uninterruptible sleep (usually IO)</li>\n<li>R 运行 runnable (on run queue)</li>\n<li>S 中断 sleeping</li>\n<li>T 停止 traced or stopped</li>\n<li>Z 僵死 a defunct (”zombie”) process</li>\n</ul>\n<h3 id=\"example-4\"><a href=\"#example-4\" class=\"headerlink\" title=\"example\"></a>example</h3><ul>\n<li><code>ps -ef</code>:显示所有进程信息，连同命令行</li>\n<li><code>ps aux</code>:列出目前所有的正在内存中的程序</li>\n</ul>\n<h1 id=\"strace\"><a href=\"#strace\" class=\"headerlink\" title=\"strace\"></a>strace</h1><p>strace常用来跟踪进程执行时的系统调用和所接收的信号</p>\n<h2 id=\"输出信息-2\"><a href=\"#输出信息-2\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。</p>\n<h2 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</li>\n<li>-d 输出strace关于标准错误的调试信息.</li>\n<li>-f 跟踪由fork调用所产生的子进程.</li>\n<li>-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</li>\n<li>-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</li>\n<li>-h 输出简要的帮助信息.</li>\n<li>-i 输出系统调用的入口指针.</li>\n<li>-q 禁止输出关于脱离的消息.</li>\n<li>-r 打印出相对时间关于,,每一个系统调用.</li>\n<li>-t 在输出中的每一行前加上时间信息.</li>\n<li>-tt 在输出中的每一行前加上时间信息,微秒级.</li>\n<li>-ttt 微秒级输出,以秒了表示时间.</li>\n<li>-T 显示每一调用所耗的时间.</li>\n<li>-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</li>\n<li>-V 输出strace的版本信息.</li>\n<li>-x 以十六进制形式输出非标准字符串</li>\n<li>-xx 所有字符串以十六进制形式输出.</li>\n<li>-a <column>设置返回值的输出位置.默认 为40.<br>输出写入到指定文件中的数据.</li>\n<li>-o filename 将strace的输出写入文件filename</li>\n<li>-p pid 跟踪指定的进程pid.</li>\n<li>-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</li>\n<li>-u username 以username 的UID和GID执行被跟踪的命令</li>\n</ul>\n<h3 id=\"e\"><a href=\"#e\" class=\"headerlink\" title=\"-e\"></a>-e</h3><p>-e expr 指定一个表达式,用来控制如何跟踪.格式如下:<br><code>[qualifier=][!]value1[,value2]...</code><br>qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:<br>-eopen等价于 -e trace&#x3D;open,表示只跟踪open调用.而-etrace!&#x3D;open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.<br>注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</p>\n<ul>\n<li>-e trace&#x3D;<set><br>只跟踪指定的系统 调用.例如:-e trace&#x3D;open,close,rean,write表示只跟踪这四个系统调用.默认的为set&#x3D;all.<ul>\n<li>-e trace&#x3D;file 只跟踪有关文件操作的系统调用.</li>\n<li>-e trace&#x3D;process 只跟踪有关进程控制的系统调用.</li>\n<li>-e trace&#x3D;network 跟踪与网络有关的所有系统调用.</li>\n<li>-e strace&#x3D;signal 跟踪所有与系统信号有关的 系统调用</li>\n<li>-e strace&#x3D;ipc 跟踪所有与进程通讯有关的系统调用</li>\n</ul>\n</li>\n<li>-e abbrev&#x3D;<set> 设定 strace输出的系统调用的结果集.<code>-v</code>等价于<code>abbrev=none</code>.默认为abbrev&#x3D;all.</li>\n<li>-e raw&#x3D;<set> 将指定的系统调用的参数以十六进制显示.</li>\n<li>-e signal&#x3D;<set> 指定跟踪的系统信号.默认为all.如 signal&#x3D;!SIGIO(或者signal&#x3D;!io),表示不跟踪SIGIO信号.<br>-e read&#x3D;<set> 输出从指定文件中读出 的数据.例如:<br>  -e read&#x3D;3,5.从文件描述符3,5读出的系统调用<br>  -e write&#x3D;<set></li>\n</ul>\n<h2 id=\"example-5\"><a href=\"#example-5\" class=\"headerlink\" title=\"example\"></a>example</h2><p><code>strace -o output.txt -T -tt -e trace=all -p 28979</code><br><code>strace -p &lt;process-pid&gt;</code>:实时输出程序的系统调用<br><code>strace -f -F -o ~/straceout.txt myserver</code>:跟踪可执行程序</p>\n"},{"title":"c++_tools","date":"2024-04-04T20:05:08.000Z","index_img":"/images/cpp_eco.jpg","banner_img":"/images/cpp_eco.jpg","_content":"\n# valgrind\n## 描述\n用来检测内存和线程bug\n## 用法\n`valgrind <-options> ./program <args>`,program should be compiled with -g\n## 选项\n- `--leak-check=full` print details for each “definitely lost” or “possibly lost”\nblock, including where it was allocated\n- `--show-leak-kinds=all` to combine with --leak-check=full. Print all leak kinds\n- `--track-fds=yes` list open file descriptors on exit (not closed)\n- `--track-origins=yes` tracks the origin of uninitialized values (very slow execution)\n# c++filt\n- `c++filt`可以把mangle的字符串demangle\n# ldd\n- `ldd` shows the shared objects (shared libraries) required by a program or other shared objects\n## 输出信息\n```bash\n/opt/app/todeav1/test$ldd test\nlibstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)\nlibm.so.6 => /lib64/libm.so.6 (0x0000003996400000)\nlibgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00000039a5600000)\nlibc.so.6 => /lib64/libc.so.6 (0x0000003995800000)\n/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)\n```\n- 第一列：程序需要依赖什么库\n- 第二列：系统提供的与程序需要的库所对应的库\n- 第三列：库加载的开始地址\n# nm\nThe nm utility provides information on the symbols being used in an object file or executable file\n## 参数\n- -a或–debug-syms：显示所有的符号，包括debugger-only symbols。\n- -B：等同于–format=bsd，用来兼容MIPS的nm。\n- -C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。\n- –no-demangle：默认的选项，不需要将低级符号名解析成用户级名。\n- -D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。\n- -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。\n- -g或–extern-only：仅显示外部符号。\n- -n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。\n- -p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。\n- -P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。\n- -s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。\n- -r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。\n- –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。\n- –target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。\n- -u或–undefined-only：仅显示没有定义的符号(那些外部符号)。\n- –defined-only:仅显示定义的符号。\n- -l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。\n- -V或–version：显示nm的版本号。\n- –help：显示nm的选项。\n## 符号说明\n对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的\n- A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。\n- B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。\n- C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。\n- D 该符号位于初始化数据段中。一般来说，分配到data section中。\n- G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。\n- I 该符号是对另一个符号的间接引用。\n- N 该符号是一个debugging符号。\n- R 该符号位于只读数据区。\n  - 例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。\n  - 值得注意的是，如果在一个函数中定义`const char *test = “abc”, const char test_int = 3`。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。\n- S 符号位于非初始化数据区，用于small object。\n- T 该符号位于代码区text section。\n- U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。 例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。\n- V 该符号是一个weak object。\n- W The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.\n- ? 该符号类型没有定义\n## example\n- `nm -uCA *.o|grep foo`:等价于`objdump -t; readelf -s`\n- `nm -e a.out`:对象文件的静态和外部符\n- `nm -xv a.out`:以十六进制显示符号大小和值并且按值排序符号\n- `nm -X64 /usr/lib/libc.a`:显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象\n\n# size\n查看程序被映射到内存中的映像所占用的大小信息。\n## 各个段\n程序映射到内存中，从低地址到高地址依次为下列段:\n- 代码段： 只读，可共享; 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。\n- 数据段： 储存已被初始化了的静态数据。数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。\n- BSS 段：未初始化的数据段. BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配。\n- 堆（heap ）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）\n- 栈(stack) ：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{} ”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。\n# readelf\n- `readelf`:displays information about ELF format object files\n这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库\n## elf文件种类\n- 可重定位的对象文件：由汇编器生成的.o文件\n- 可执行对象文件\n- 动态库文件\n## 参数\n\n|短选项|长选项|comment|\n|:-:|:-:|:-:|\n|-a|–all|全部,Equivalent to: -h -l -S -s -r -d -V -A -I|\n|-h|–file-header|文件头Display the ELF file header|\n|-l|–program-headers/-segments|程序Display the program headers|\n|-S|–section-headers/--sections|段头Display the sections’ header|\n|-e|–headers|全部头Equivalent to: -h -l -S|\n|-s|–syms/--symbols|符号表 Display the symbol table|\n|-n|–notes|内核注释 Display the core notes (if present)|\n|-r|–relocs|重定位 Display the relocations (if present)|\n|-u|–unwind|Display the unwind info (if present)|\n|-d|–dynamic|动态段 Display the dynamic segment (if present)|\n|-V|–version-info|版本 Display the version sections (if present)|\n|-A|–arch-specific|CPU构架 Display architecture specific information (if any).|\n|-D|–use-dynamic|动态段 Use the dynamic section info when displaying symbols|\n|-x|–hex-dump=<number>|显示 段内内容Dump the contents of section <number>|\n|-I|–histogram|Display histogram of bucket list lengths|\n|-W|–wide|宽行输出 Allow output width to exceed 80 characters|\n|-H|–help|Display this information|\n|-v|–version|Display the version number of readelf|\n\n## 常见输出信息\n- .text section 里装载了可执行代码；\n- .data section 里面装载了被初始化的数据；\n- .bss section 里面装载了未被初始化的数据；\n- 以 .rec 打头的 sections 里面装载了重定位条目；\n- .symtab 或者 .dynsym section 里面装载了符号信息；\n- .strtab 或者 .dynstr section 里面装载了字符串信息；\nmore:![](http://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html)\n## example\n- `readelf -h main| grep Machine`:查看程序的可运行的架构平台\n- `readelf -S main|grep debug`:编译时是否使用了-g选项\n# objdump\n- `objdump`:displays information about object files\n## 参数\n-f 显示文件头信息\n-D 反汇编所有section (-d反汇编特定section)\n-h 显示目标文件各个section的头部摘要信息\n-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。\n-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。\n-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。\n-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。\n-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。\n-t 显示文件的符号表入口。类似于nm -s提供的信息\n## example\n- `objdump -i`:查看本机目标结构(大小端)\n- `objdump -d main.o`:反汇编程序\n- `objdump -t main.o`:显示符号表入口\n- below:\n```bash\n$ objdump -t -C something.so | c++filt\n... df *ABS* ... prog.cpp\n... O .rodata ... CC1\n... O .rodata ... CC2\n... F .text ... g()\n... O .rodata ... (anonymous namespace)::CC3\n... O .rodata ... (anonymous namespace)::CC4\n... F .text ... (anonymous namespace)::h()\n... F .text ... (anonymous namespace)::B::j1()\n... F .text ... (anonymous namespace)::B::j2()\n```\n# cppcheck\n# gcovr(有bug)\n覆盖率工具，需要配合g++的`--coverage`选项\n```bash\n$ gcc -g --coverage program.cpp -o program\n$ ./program 9\nfirst\n$ gcovr -r --html --html-details <path> # generate html\n```\n# clang-tidy\n代码风格及静态检查\n# doxygen\n生成帮助文档，配置文件Doxyfile\n- `doxygen -g`\n- comment the code with `///` or `/** comment *`\n- generate doxygen base configuration file\n## 注释关键字\n- `@file` Document a file\n- `@brief` Brief description for an entity\n- `@param` Run-time parameter description\n- `@tparam` Template parameter description\n- `@return` Return value description\n## 配置信息\n```bash\nHAVE DOT = YES\nGRAPHICAL HIERARCHY = YES\nCALL GRAPH = YES\nCALLER GRAPH = YES\n```\n## example\n```C++\n/**\n* @file\n* @copyright MyProject\n* license BSD3, Apache, MIT, etc.\n* @author MySelf\n* @version v3.14159265359\n* @date March, 2018\n*/\n/// @brief Namespace brief description\nnamespace my_namespace {\n/// @brief \"Class brief description\"\n/// @tparam R \"Class template for\"\ntemplate<typename R>\nclass A {\n```\n```C++\n/**\n* @brief \"What the function does?\"\n* @details \"Some additional details\",\n* Latex/MathJax: $\\sqrt a$\n* @tparam T Type of input and output\n* @param[in] input Input array\n* @param[out] output Output array\n* @return `true` if correct,\n* `false` otherwise\n* @remark it is *useful* if ...\n* @warning the behavior is **undefined** if\n* @p input is `nullptr`\n* @see related_function\n*/\ntemplate<typename T>\nbool my_function(const T* input, T* output);\n/// @brief\nvoid related_function();\n```\n# cloc\n行数统计信息\n# lizard\n圈复杂度分析工具\n`lizard my_project/`\n## example\n```bash\n$lizard my_project/\n==============================================================\nNLOC CCN token param function@line@file\n--------------------------------------------------------------\n10 2 29 2 start_new_player@26@./html_game.c\n6 1 3 0 set_shutdown_flag@449@./httpd.c\n24 3 61 1 server_main@454@./httpd.c\n--------------------------------------------------------------\n```\n- CCN:圈复杂度\n- NLOC：无注释的代码行数\n- token：number of conditional statements\n# clang-format\n# pstack\npstack是一个脚本工具，可显示每个进程的栈跟踪。pstack命令必须由相应进程的属主或root运行\n`pstrack <program-pid>`\n# compiler explorer\n编码实时二进制查看\n# cppinsights\n编译器实时查看\n# AI补全工具\n- CoPilot\n- TabNine\n- Kite\n# 代码在线搜索\n- [searchcode](https://searchcode.com/)\n- [grep.app](https://grep.app/)\n# 在线代码段性能比较\n- [benchmark](http://quick-bench.com/)\n\n\n","source":"_posts/c-tools.md","raw":"---\ntitle: c++_tools\ndate: 2024-04-05 04:05:08\ntags:\nindex_img: /images/cpp_eco.jpg\nbanner_img: /images/cpp_eco.jpg\n---\n\n# valgrind\n## 描述\n用来检测内存和线程bug\n## 用法\n`valgrind <-options> ./program <args>`,program should be compiled with -g\n## 选项\n- `--leak-check=full` print details for each “definitely lost” or “possibly lost”\nblock, including where it was allocated\n- `--show-leak-kinds=all` to combine with --leak-check=full. Print all leak kinds\n- `--track-fds=yes` list open file descriptors on exit (not closed)\n- `--track-origins=yes` tracks the origin of uninitialized values (very slow execution)\n# c++filt\n- `c++filt`可以把mangle的字符串demangle\n# ldd\n- `ldd` shows the shared objects (shared libraries) required by a program or other shared objects\n## 输出信息\n```bash\n/opt/app/todeav1/test$ldd test\nlibstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)\nlibm.so.6 => /lib64/libm.so.6 (0x0000003996400000)\nlibgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00000039a5600000)\nlibc.so.6 => /lib64/libc.so.6 (0x0000003995800000)\n/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)\n```\n- 第一列：程序需要依赖什么库\n- 第二列：系统提供的与程序需要的库所对应的库\n- 第三列：库加载的开始地址\n# nm\nThe nm utility provides information on the symbols being used in an object file or executable file\n## 参数\n- -a或–debug-syms：显示所有的符号，包括debugger-only symbols。\n- -B：等同于–format=bsd，用来兼容MIPS的nm。\n- -C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。\n- –no-demangle：默认的选项，不需要将低级符号名解析成用户级名。\n- -D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。\n- -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。\n- -g或–extern-only：仅显示外部符号。\n- -n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。\n- -p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。\n- -P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。\n- -s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。\n- -r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。\n- –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。\n- –target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。\n- -u或–undefined-only：仅显示没有定义的符号(那些外部符号)。\n- –defined-only:仅显示定义的符号。\n- -l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。\n- -V或–version：显示nm的版本号。\n- –help：显示nm的选项。\n## 符号说明\n对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的\n- A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。\n- B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。\n- C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。\n- D 该符号位于初始化数据段中。一般来说，分配到data section中。\n- G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。\n- I 该符号是对另一个符号的间接引用。\n- N 该符号是一个debugging符号。\n- R 该符号位于只读数据区。\n  - 例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。\n  - 值得注意的是，如果在一个函数中定义`const char *test = “abc”, const char test_int = 3`。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。\n- S 符号位于非初始化数据区，用于small object。\n- T 该符号位于代码区text section。\n- U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。 例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。\n- V 该符号是一个weak object。\n- W The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.\n- ? 该符号类型没有定义\n## example\n- `nm -uCA *.o|grep foo`:等价于`objdump -t; readelf -s`\n- `nm -e a.out`:对象文件的静态和外部符\n- `nm -xv a.out`:以十六进制显示符号大小和值并且按值排序符号\n- `nm -X64 /usr/lib/libc.a`:显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象\n\n# size\n查看程序被映射到内存中的映像所占用的大小信息。\n## 各个段\n程序映射到内存中，从低地址到高地址依次为下列段:\n- 代码段： 只读，可共享; 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。\n- 数据段： 储存已被初始化了的静态数据。数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。\n- BSS 段：未初始化的数据段. BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配。\n- 堆（heap ）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）\n- 栈(stack) ：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{} ”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。\n# readelf\n- `readelf`:displays information about ELF format object files\n这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库\n## elf文件种类\n- 可重定位的对象文件：由汇编器生成的.o文件\n- 可执行对象文件\n- 动态库文件\n## 参数\n\n|短选项|长选项|comment|\n|:-:|:-:|:-:|\n|-a|–all|全部,Equivalent to: -h -l -S -s -r -d -V -A -I|\n|-h|–file-header|文件头Display the ELF file header|\n|-l|–program-headers/-segments|程序Display the program headers|\n|-S|–section-headers/--sections|段头Display the sections’ header|\n|-e|–headers|全部头Equivalent to: -h -l -S|\n|-s|–syms/--symbols|符号表 Display the symbol table|\n|-n|–notes|内核注释 Display the core notes (if present)|\n|-r|–relocs|重定位 Display the relocations (if present)|\n|-u|–unwind|Display the unwind info (if present)|\n|-d|–dynamic|动态段 Display the dynamic segment (if present)|\n|-V|–version-info|版本 Display the version sections (if present)|\n|-A|–arch-specific|CPU构架 Display architecture specific information (if any).|\n|-D|–use-dynamic|动态段 Use the dynamic section info when displaying symbols|\n|-x|–hex-dump=<number>|显示 段内内容Dump the contents of section <number>|\n|-I|–histogram|Display histogram of bucket list lengths|\n|-W|–wide|宽行输出 Allow output width to exceed 80 characters|\n|-H|–help|Display this information|\n|-v|–version|Display the version number of readelf|\n\n## 常见输出信息\n- .text section 里装载了可执行代码；\n- .data section 里面装载了被初始化的数据；\n- .bss section 里面装载了未被初始化的数据；\n- 以 .rec 打头的 sections 里面装载了重定位条目；\n- .symtab 或者 .dynsym section 里面装载了符号信息；\n- .strtab 或者 .dynstr section 里面装载了字符串信息；\nmore:![](http://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html)\n## example\n- `readelf -h main| grep Machine`:查看程序的可运行的架构平台\n- `readelf -S main|grep debug`:编译时是否使用了-g选项\n# objdump\n- `objdump`:displays information about object files\n## 参数\n-f 显示文件头信息\n-D 反汇编所有section (-d反汇编特定section)\n-h 显示目标文件各个section的头部摘要信息\n-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。\n-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。\n-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。\n-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。\n-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。\n-t 显示文件的符号表入口。类似于nm -s提供的信息\n## example\n- `objdump -i`:查看本机目标结构(大小端)\n- `objdump -d main.o`:反汇编程序\n- `objdump -t main.o`:显示符号表入口\n- below:\n```bash\n$ objdump -t -C something.so | c++filt\n... df *ABS* ... prog.cpp\n... O .rodata ... CC1\n... O .rodata ... CC2\n... F .text ... g()\n... O .rodata ... (anonymous namespace)::CC3\n... O .rodata ... (anonymous namespace)::CC4\n... F .text ... (anonymous namespace)::h()\n... F .text ... (anonymous namespace)::B::j1()\n... F .text ... (anonymous namespace)::B::j2()\n```\n# cppcheck\n# gcovr(有bug)\n覆盖率工具，需要配合g++的`--coverage`选项\n```bash\n$ gcc -g --coverage program.cpp -o program\n$ ./program 9\nfirst\n$ gcovr -r --html --html-details <path> # generate html\n```\n# clang-tidy\n代码风格及静态检查\n# doxygen\n生成帮助文档，配置文件Doxyfile\n- `doxygen -g`\n- comment the code with `///` or `/** comment *`\n- generate doxygen base configuration file\n## 注释关键字\n- `@file` Document a file\n- `@brief` Brief description for an entity\n- `@param` Run-time parameter description\n- `@tparam` Template parameter description\n- `@return` Return value description\n## 配置信息\n```bash\nHAVE DOT = YES\nGRAPHICAL HIERARCHY = YES\nCALL GRAPH = YES\nCALLER GRAPH = YES\n```\n## example\n```C++\n/**\n* @file\n* @copyright MyProject\n* license BSD3, Apache, MIT, etc.\n* @author MySelf\n* @version v3.14159265359\n* @date March, 2018\n*/\n/// @brief Namespace brief description\nnamespace my_namespace {\n/// @brief \"Class brief description\"\n/// @tparam R \"Class template for\"\ntemplate<typename R>\nclass A {\n```\n```C++\n/**\n* @brief \"What the function does?\"\n* @details \"Some additional details\",\n* Latex/MathJax: $\\sqrt a$\n* @tparam T Type of input and output\n* @param[in] input Input array\n* @param[out] output Output array\n* @return `true` if correct,\n* `false` otherwise\n* @remark it is *useful* if ...\n* @warning the behavior is **undefined** if\n* @p input is `nullptr`\n* @see related_function\n*/\ntemplate<typename T>\nbool my_function(const T* input, T* output);\n/// @brief\nvoid related_function();\n```\n# cloc\n行数统计信息\n# lizard\n圈复杂度分析工具\n`lizard my_project/`\n## example\n```bash\n$lizard my_project/\n==============================================================\nNLOC CCN token param function@line@file\n--------------------------------------------------------------\n10 2 29 2 start_new_player@26@./html_game.c\n6 1 3 0 set_shutdown_flag@449@./httpd.c\n24 3 61 1 server_main@454@./httpd.c\n--------------------------------------------------------------\n```\n- CCN:圈复杂度\n- NLOC：无注释的代码行数\n- token：number of conditional statements\n# clang-format\n# pstack\npstack是一个脚本工具，可显示每个进程的栈跟踪。pstack命令必须由相应进程的属主或root运行\n`pstrack <program-pid>`\n# compiler explorer\n编码实时二进制查看\n# cppinsights\n编译器实时查看\n# AI补全工具\n- CoPilot\n- TabNine\n- Kite\n# 代码在线搜索\n- [searchcode](https://searchcode.com/)\n- [grep.app](https://grep.app/)\n# 在线代码段性能比较\n- [benchmark](http://quick-bench.com/)\n\n\n","slug":"c-tools","published":1,"updated":"2024-06-10T14:25:15.815Z","_id":"clwnyxnde0003qzq20ynb53a6","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"valgrind\"><a href=\"#valgrind\" class=\"headerlink\" title=\"valgrind\"></a>valgrind</h1><h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>用来检测内存和线程bug</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p><code>valgrind &lt;-options&gt; ./program &lt;args&gt;</code>,program should be compiled with -g</p>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><ul>\n<li><code>--leak-check=full</code> print details for each “definitely lost” or “possibly lost”<br>block, including where it was allocated</li>\n<li><code>--show-leak-kinds=all</code> to combine with –leak-check&#x3D;full. Print all leak kinds</li>\n<li><code>--track-fds=yes</code> list open file descriptors on exit (not closed)</li>\n<li><code>--track-origins=yes</code> tracks the origin of uninitialized values (very slow execution)</li>\n</ul>\n<h1 id=\"c-filt\"><a href=\"#c-filt\" class=\"headerlink\" title=\"c++filt\"></a>c++filt</h1><ul>\n<li><code>c++filt</code>可以把mangle的字符串demangle</li>\n</ul>\n<h1 id=\"ldd\"><a href=\"#ldd\" class=\"headerlink\" title=\"ldd\"></a>ldd</h1><ul>\n<li><code>ldd</code> shows the shared objects (shared libraries) required by a program or other shared objects</li>\n</ul>\n<h2 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/opt/app/todeav1/test<span class=\"hljs-variable\">$ldd</span> <span class=\"hljs-built_in\">test</span><br>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)<br>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)<br>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)<br>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003995800000)<br>/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第一列：程序需要依赖什么库</li>\n<li>第二列：系统提供的与程序需要的库所对应的库</li>\n<li>第三列：库加载的开始地址</li>\n</ul>\n<h1 id=\"nm\"><a href=\"#nm\" class=\"headerlink\" title=\"nm\"></a>nm</h1><p>The nm utility provides information on the symbols being used in an object file or executable file</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>-a或–debug-syms：显示所有的符号，包括debugger-only symbols。</li>\n<li>-B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。</li>\n<li>-C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</li>\n<li>–no-demangle：默认的选项，不需要将低级符号名解析成用户级名。</li>\n<li>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</li>\n<li>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</li>\n<li>-g或–extern-only：仅显示外部符号。</li>\n<li>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</li>\n<li>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</li>\n<li>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</li>\n<li>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</li>\n<li>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</li>\n<li>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</li>\n<li>–target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</li>\n<li>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</li>\n<li>–defined-only:仅显示定义的符号。</li>\n<li>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。</li>\n<li>-V或–version：显示nm的版本号。</li>\n<li>–help：显示nm的选项。</li>\n</ul>\n<h2 id=\"符号说明\"><a href=\"#符号说明\" class=\"headerlink\" title=\"符号说明\"></a>符号说明</h2><p>对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的</p>\n<ul>\n<li>A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</li>\n<li>B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。</li>\n<li>C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。</li>\n<li>D 该符号位于初始化数据段中。一般来说，分配到data section中。</li>\n<li>G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。</li>\n<li>I 该符号是对另一个符号的间接引用。</li>\n<li>N 该符号是一个debugging符号。</li>\n<li>R 该符号位于只读数据区。<ul>\n<li>例如定义全局const int test[] &#x3D; {123, 123};则test就是一个只读数据区的符号。</li>\n<li>值得注意的是，如果在一个函数中定义<code>const char *test = “abc”, const char test_int = 3</code>。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。</li>\n</ul>\n</li>\n<li>S 符号位于非初始化数据区，用于small object。</li>\n<li>T 该符号位于代码区text section。</li>\n<li>U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。 例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。</li>\n<li>V 该符号是一个weak object。</li>\n<li>W The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</li>\n<li>? 该符号类型没有定义</li>\n</ul>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>nm -uCA *.o|grep foo</code>:等价于<code>objdump -t; readelf -s</code></li>\n<li><code>nm -e a.out</code>:对象文件的静态和外部符</li>\n<li><code>nm -xv a.out</code>:以十六进制显示符号大小和值并且按值排序符号</li>\n<li><code>nm -X64 /usr/lib/libc.a</code>:显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象</li>\n</ul>\n<h1 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size\"></a>size</h1><p>查看程序被映射到内存中的映像所占用的大小信息。</p>\n<h2 id=\"各个段\"><a href=\"#各个段\" class=\"headerlink\" title=\"各个段\"></a>各个段</h2><p>程序映射到内存中，从低地址到高地址依次为下列段:</p>\n<ul>\n<li>代码段： 只读，可共享; 代码段（code segment&#x2F;text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>\n<li>数据段： 储存已被初始化了的静态数据。数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li>\n<li>BSS 段：未初始化的数据段. BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配。</li>\n<li>堆（heap ）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>\n<li>栈(stack) ：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{} ”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存&#x2F; 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>\n</ul>\n<h1 id=\"readelf\"><a href=\"#readelf\" class=\"headerlink\" title=\"readelf\"></a>readelf</h1><ul>\n<li><code>readelf</code>:displays information about ELF format object files<br>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库</li>\n</ul>\n<h2 id=\"elf文件种类\"><a href=\"#elf文件种类\" class=\"headerlink\" title=\"elf文件种类\"></a>elf文件种类</h2><ul>\n<li>可重定位的对象文件：由汇编器生成的.o文件</li>\n<li>可执行对象文件</li>\n<li>动态库文件</li>\n</ul>\n<h2 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h2><table>\n<thead>\n<tr>\n<th align=\"center\">短选项</th>\n<th align=\"center\">长选项</th>\n<th align=\"center\">comment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">–all</td>\n<td align=\"center\">全部,Equivalent to: -h -l -S -s -r -d -V -A -I</td>\n</tr>\n<tr>\n<td align=\"center\">-h</td>\n<td align=\"center\">–file-header</td>\n<td align=\"center\">文件头Display the ELF file header</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">–program-headers&#x2F;-segments</td>\n<td align=\"center\">程序Display the program headers</td>\n</tr>\n<tr>\n<td align=\"center\">-S</td>\n<td align=\"center\">–section-headers&#x2F;–sections</td>\n<td align=\"center\">段头Display the sections’ header</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">–headers</td>\n<td align=\"center\">全部头Equivalent to: -h -l -S</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">–syms&#x2F;–symbols</td>\n<td align=\"center\">符号表 Display the symbol table</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">–notes</td>\n<td align=\"center\">内核注释 Display the core notes (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">–relocs</td>\n<td align=\"center\">重定位 Display the relocations (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">–unwind</td>\n<td align=\"center\">Display the unwind info (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">–dynamic</td>\n<td align=\"center\">动态段 Display the dynamic segment (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-V</td>\n<td align=\"center\">–version-info</td>\n<td align=\"center\">版本 Display the version sections (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-A</td>\n<td align=\"center\">–arch-specific</td>\n<td align=\"center\">CPU构架 Display architecture specific information (if any).</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">–use-dynamic</td>\n<td align=\"center\">动态段 Use the dynamic section info when displaying symbols</td>\n</tr>\n<tr>\n<td align=\"center\">-x</td>\n<td align=\"center\">–hex-dump&#x3D;<number></td>\n<td align=\"center\">显示 段内内容Dump the contents of section <number></td>\n</tr>\n<tr>\n<td align=\"center\">-I</td>\n<td align=\"center\">–histogram</td>\n<td align=\"center\">Display histogram of bucket list lengths</td>\n</tr>\n<tr>\n<td align=\"center\">-W</td>\n<td align=\"center\">–wide</td>\n<td align=\"center\">宽行输出 Allow output width to exceed 80 characters</td>\n</tr>\n<tr>\n<td align=\"center\">-H</td>\n<td align=\"center\">–help</td>\n<td align=\"center\">Display this information</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">–version</td>\n<td align=\"center\">Display the version number of readelf</td>\n</tr>\n</tbody></table>\n<h2 id=\"常见输出信息\"><a href=\"#常见输出信息\" class=\"headerlink\" title=\"常见输出信息\"></a>常见输出信息</h2><ul>\n<li>.text section 里装载了可执行代码；</li>\n<li>.data section 里面装载了被初始化的数据；</li>\n<li>.bss section 里面装载了未被初始化的数据；</li>\n<li>以 .rec 打头的 sections 里面装载了重定位条目；</li>\n<li>.symtab 或者 .dynsym section 里面装载了符号信息；</li>\n<li>.strtab 或者 .dynstr section 里面装载了字符串信息；<br>more:<img src=\"http://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html\"></li>\n</ul>\n<h2 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>readelf -h main| grep Machine</code>:查看程序的可运行的架构平台</li>\n<li><code>readelf -S main|grep debug</code>:编译时是否使用了-g选项</li>\n</ul>\n<h1 id=\"objdump\"><a href=\"#objdump\" class=\"headerlink\" title=\"objdump\"></a>objdump</h1><ul>\n<li><code>objdump</code>:displays information about object files</li>\n</ul>\n<h2 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>-f 显示文件头信息<br>-D 反汇编所有section (-d反汇编特定section)<br>-h 显示目标文件各个section的头部摘要信息<br>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。<br>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。<br>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。<br>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。<br>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。<br>-t 显示文件的符号表入口。类似于nm -s提供的信息</p>\n<h2 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>objdump -i</code>:查看本机目标结构(大小端)</li>\n<li><code>objdump -d main.o</code>:反汇编程序</li>\n<li><code>objdump -t main.o</code>:显示符号表入口</li>\n<li>below:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ objdump -t -C something.so | c++filt<br>... <span class=\"hljs-built_in\">df</span> *ABS* ... prog.cpp<br>... O .rodata ... CC1<br>... O .rodata ... CC2<br>... F .text ... g()<br>... O .rodata ... (anonymous namespace)::CC3<br>... O .rodata ... (anonymous namespace)::CC4<br>... F .text ... (anonymous namespace)::h()<br>... F .text ... (anonymous namespace)::B::j1()<br>... F .text ... (anonymous namespace)::B::j2()<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"cppcheck\"><a href=\"#cppcheck\" class=\"headerlink\" title=\"cppcheck\"></a>cppcheck</h1><h1 id=\"gcovr-有bug\"><a href=\"#gcovr-有bug\" class=\"headerlink\" title=\"gcovr(有bug)\"></a>gcovr(有bug)</h1><p>覆盖率工具，需要配合g++的<code>--coverage</code>选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ gcc -g --coverage program.cpp -o program<br>$ ./program 9<br>first<br>$ gcovr -r --html --html-details &lt;path&gt; <span class=\"hljs-comment\"># generate html</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"clang-tidy\"><a href=\"#clang-tidy\" class=\"headerlink\" title=\"clang-tidy\"></a>clang-tidy</h1><p>代码风格及静态检查</p>\n<h1 id=\"doxygen\"><a href=\"#doxygen\" class=\"headerlink\" title=\"doxygen\"></a>doxygen</h1><p>生成帮助文档，配置文件Doxyfile</p>\n<ul>\n<li><code>doxygen -g</code></li>\n<li>comment the code with <code>///</code> or <code>/** comment *</code></li>\n<li>generate doxygen base configuration file</li>\n</ul>\n<h2 id=\"注释关键字\"><a href=\"#注释关键字\" class=\"headerlink\" title=\"注释关键字\"></a>注释关键字</h2><ul>\n<li><code>@file</code> Document a file</li>\n<li><code>@brief</code> Brief description for an entity</li>\n<li><code>@param</code> Run-time parameter description</li>\n<li><code>@tparam</code> Template parameter description</li>\n<li><code>@return</code> Return value description</li>\n</ul>\n<h2 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">HAVE DOT = YES<br>GRAPHICAL HIERARCHY = YES<br>CALL GRAPH = YES<br>CALLER GRAPH = YES<br></code></pre></td></tr></table></figure>\n<h2 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example\"></a>example</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* @file</span><br><span class=\"hljs-comment\">* @copyright MyProject</span><br><span class=\"hljs-comment\">* license BSD3, Apache, MIT, etc.</span><br><span class=\"hljs-comment\">* @author MySelf</span><br><span class=\"hljs-comment\">* @version v3.14159265359</span><br><span class=\"hljs-comment\">* @date March, 2018</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-comment\">/// @brief Namespace brief description</span><br><span class=\"hljs-keyword\">namespace</span> my_namespace &#123;<br><span class=\"hljs-comment\">/// @brief &quot;Class brief description&quot;</span><br><span class=\"hljs-comment\">/// @tparam R &quot;Class template for&quot;</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* @brief &quot;What the function does?&quot;</span><br><span class=\"hljs-comment\">* @details &quot;Some additional details&quot;,</span><br><span class=\"hljs-comment\">* Latex/MathJax: $\\sqrt a$</span><br><span class=\"hljs-comment\">* @tparam T Type of input and output</span><br><span class=\"hljs-comment\">* @param[in] input Input array</span><br><span class=\"hljs-comment\">* @param[out] output Output array</span><br><span class=\"hljs-comment\">* @return `true` if correct,</span><br><span class=\"hljs-comment\">* `false` otherwise</span><br><span class=\"hljs-comment\">* @remark it is *useful* if ...</span><br><span class=\"hljs-comment\">* @warning the behavior is **undefined** if</span><br><span class=\"hljs-comment\">* @p input is `nullptr`</span><br><span class=\"hljs-comment\">* @see related_function</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">my_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T* input, T* output)</span></span>;<br><span class=\"hljs-comment\">/// @brief</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">related_function</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\n<h1 id=\"cloc\"><a href=\"#cloc\" class=\"headerlink\" title=\"cloc\"></a>cloc</h1><p>行数统计信息</p>\n<h1 id=\"lizard\"><a href=\"#lizard\" class=\"headerlink\" title=\"lizard\"></a>lizard</h1><p>圈复杂度分析工具<br><code>lizard my_project/</code></p>\n<h2 id=\"example-4\"><a href=\"#example-4\" class=\"headerlink\" title=\"example\"></a>example</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$lizard</span> my_project/<br>==============================================================<br>NLOC CCN token param <span class=\"hljs-keyword\">function</span>@line@file<br>--------------------------------------------------------------<br>10 2 29 2 start_new_player@26@./html_game.c<br>6 1 3 0 set_shutdown_flag@449@./httpd.c<br>24 3 61 1 server_main@454@./httpd.c<br>--------------------------------------------------------------<br></code></pre></td></tr></table></figure>\n<ul>\n<li>CCN:圈复杂度</li>\n<li>NLOC：无注释的代码行数</li>\n<li>token：number of conditional statements</li>\n</ul>\n<h1 id=\"clang-format\"><a href=\"#clang-format\" class=\"headerlink\" title=\"clang-format\"></a>clang-format</h1><h1 id=\"pstack\"><a href=\"#pstack\" class=\"headerlink\" title=\"pstack\"></a>pstack</h1><p>pstack是一个脚本工具，可显示每个进程的栈跟踪。pstack命令必须由相应进程的属主或root运行<br><code>pstrack &lt;program-pid&gt;</code></p>\n<h1 id=\"compiler-explorer\"><a href=\"#compiler-explorer\" class=\"headerlink\" title=\"compiler explorer\"></a>compiler explorer</h1><p>编码实时二进制查看</p>\n<h1 id=\"cppinsights\"><a href=\"#cppinsights\" class=\"headerlink\" title=\"cppinsights\"></a>cppinsights</h1><p>编译器实时查看</p>\n<h1 id=\"AI补全工具\"><a href=\"#AI补全工具\" class=\"headerlink\" title=\"AI补全工具\"></a>AI补全工具</h1><ul>\n<li>CoPilot</li>\n<li>TabNine</li>\n<li>Kite</li>\n</ul>\n<h1 id=\"代码在线搜索\"><a href=\"#代码在线搜索\" class=\"headerlink\" title=\"代码在线搜索\"></a>代码在线搜索</h1><ul>\n<li><a href=\"https://searchcode.com/\">searchcode</a></li>\n<li><a href=\"https://grep.app/\">grep.app</a></li>\n</ul>\n<h1 id=\"在线代码段性能比较\"><a href=\"#在线代码段性能比较\" class=\"headerlink\" title=\"在线代码段性能比较\"></a>在线代码段性能比较</h1><ul>\n<li><a href=\"http://quick-bench.com/\">benchmark</a></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"valgrind\"><a href=\"#valgrind\" class=\"headerlink\" title=\"valgrind\"></a>valgrind</h1><h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>用来检测内存和线程bug</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p><code>valgrind &lt;-options&gt; ./program &lt;args&gt;</code>,program should be compiled with -g</p>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><ul>\n<li><code>--leak-check=full</code> print details for each “definitely lost” or “possibly lost”<br>block, including where it was allocated</li>\n<li><code>--show-leak-kinds=all</code> to combine with –leak-check&#x3D;full. Print all leak kinds</li>\n<li><code>--track-fds=yes</code> list open file descriptors on exit (not closed)</li>\n<li><code>--track-origins=yes</code> tracks the origin of uninitialized values (very slow execution)</li>\n</ul>\n<h1 id=\"c-filt\"><a href=\"#c-filt\" class=\"headerlink\" title=\"c++filt\"></a>c++filt</h1><ul>\n<li><code>c++filt</code>可以把mangle的字符串demangle</li>\n</ul>\n<h1 id=\"ldd\"><a href=\"#ldd\" class=\"headerlink\" title=\"ldd\"></a>ldd</h1><ul>\n<li><code>ldd</code> shows the shared objects (shared libraries) required by a program or other shared objects</li>\n</ul>\n<h2 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/opt/app/todeav1/test<span class=\"hljs-variable\">$ldd</span> <span class=\"hljs-built_in\">test</span><br>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)<br>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)<br>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)<br>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003995800000)<br>/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第一列：程序需要依赖什么库</li>\n<li>第二列：系统提供的与程序需要的库所对应的库</li>\n<li>第三列：库加载的开始地址</li>\n</ul>\n<h1 id=\"nm\"><a href=\"#nm\" class=\"headerlink\" title=\"nm\"></a>nm</h1><p>The nm utility provides information on the symbols being used in an object file or executable file</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>-a或–debug-syms：显示所有的符号，包括debugger-only symbols。</li>\n<li>-B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。</li>\n<li>-C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</li>\n<li>–no-demangle：默认的选项，不需要将低级符号名解析成用户级名。</li>\n<li>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</li>\n<li>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</li>\n<li>-g或–extern-only：仅显示外部符号。</li>\n<li>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</li>\n<li>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</li>\n<li>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</li>\n<li>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</li>\n<li>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</li>\n<li>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</li>\n<li>–target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</li>\n<li>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</li>\n<li>–defined-only:仅显示定义的符号。</li>\n<li>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。</li>\n<li>-V或–version：显示nm的版本号。</li>\n<li>–help：显示nm的选项。</li>\n</ul>\n<h2 id=\"符号说明\"><a href=\"#符号说明\" class=\"headerlink\" title=\"符号说明\"></a>符号说明</h2><p>对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的</p>\n<ul>\n<li>A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</li>\n<li>B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。</li>\n<li>C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。</li>\n<li>D 该符号位于初始化数据段中。一般来说，分配到data section中。</li>\n<li>G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。</li>\n<li>I 该符号是对另一个符号的间接引用。</li>\n<li>N 该符号是一个debugging符号。</li>\n<li>R 该符号位于只读数据区。<ul>\n<li>例如定义全局const int test[] &#x3D; {123, 123};则test就是一个只读数据区的符号。</li>\n<li>值得注意的是，如果在一个函数中定义<code>const char *test = “abc”, const char test_int = 3</code>。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。</li>\n</ul>\n</li>\n<li>S 符号位于非初始化数据区，用于small object。</li>\n<li>T 该符号位于代码区text section。</li>\n<li>U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。 例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。</li>\n<li>V 该符号是一个weak object。</li>\n<li>W The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</li>\n<li>? 该符号类型没有定义</li>\n</ul>\n<h2 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>nm -uCA *.o|grep foo</code>:等价于<code>objdump -t; readelf -s</code></li>\n<li><code>nm -e a.out</code>:对象文件的静态和外部符</li>\n<li><code>nm -xv a.out</code>:以十六进制显示符号大小和值并且按值排序符号</li>\n<li><code>nm -X64 /usr/lib/libc.a</code>:显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象</li>\n</ul>\n<h1 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size\"></a>size</h1><p>查看程序被映射到内存中的映像所占用的大小信息。</p>\n<h2 id=\"各个段\"><a href=\"#各个段\" class=\"headerlink\" title=\"各个段\"></a>各个段</h2><p>程序映射到内存中，从低地址到高地址依次为下列段:</p>\n<ul>\n<li>代码段： 只读，可共享; 代码段（code segment&#x2F;text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>\n<li>数据段： 储存已被初始化了的静态数据。数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li>\n<li>BSS 段：未初始化的数据段. BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配。</li>\n<li>堆（heap ）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>\n<li>栈(stack) ：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{} ”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存&#x2F; 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>\n</ul>\n<h1 id=\"readelf\"><a href=\"#readelf\" class=\"headerlink\" title=\"readelf\"></a>readelf</h1><ul>\n<li><code>readelf</code>:displays information about ELF format object files<br>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库</li>\n</ul>\n<h2 id=\"elf文件种类\"><a href=\"#elf文件种类\" class=\"headerlink\" title=\"elf文件种类\"></a>elf文件种类</h2><ul>\n<li>可重定位的对象文件：由汇编器生成的.o文件</li>\n<li>可执行对象文件</li>\n<li>动态库文件</li>\n</ul>\n<h2 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h2><table>\n<thead>\n<tr>\n<th align=\"center\">短选项</th>\n<th align=\"center\">长选项</th>\n<th align=\"center\">comment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-a</td>\n<td align=\"center\">–all</td>\n<td align=\"center\">全部,Equivalent to: -h -l -S -s -r -d -V -A -I</td>\n</tr>\n<tr>\n<td align=\"center\">-h</td>\n<td align=\"center\">–file-header</td>\n<td align=\"center\">文件头Display the ELF file header</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"center\">–program-headers&#x2F;-segments</td>\n<td align=\"center\">程序Display the program headers</td>\n</tr>\n<tr>\n<td align=\"center\">-S</td>\n<td align=\"center\">–section-headers&#x2F;–sections</td>\n<td align=\"center\">段头Display the sections’ header</td>\n</tr>\n<tr>\n<td align=\"center\">-e</td>\n<td align=\"center\">–headers</td>\n<td align=\"center\">全部头Equivalent to: -h -l -S</td>\n</tr>\n<tr>\n<td align=\"center\">-s</td>\n<td align=\"center\">–syms&#x2F;–symbols</td>\n<td align=\"center\">符号表 Display the symbol table</td>\n</tr>\n<tr>\n<td align=\"center\">-n</td>\n<td align=\"center\">–notes</td>\n<td align=\"center\">内核注释 Display the core notes (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-r</td>\n<td align=\"center\">–relocs</td>\n<td align=\"center\">重定位 Display the relocations (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-u</td>\n<td align=\"center\">–unwind</td>\n<td align=\"center\">Display the unwind info (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-d</td>\n<td align=\"center\">–dynamic</td>\n<td align=\"center\">动态段 Display the dynamic segment (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-V</td>\n<td align=\"center\">–version-info</td>\n<td align=\"center\">版本 Display the version sections (if present)</td>\n</tr>\n<tr>\n<td align=\"center\">-A</td>\n<td align=\"center\">–arch-specific</td>\n<td align=\"center\">CPU构架 Display architecture specific information (if any).</td>\n</tr>\n<tr>\n<td align=\"center\">-D</td>\n<td align=\"center\">–use-dynamic</td>\n<td align=\"center\">动态段 Use the dynamic section info when displaying symbols</td>\n</tr>\n<tr>\n<td align=\"center\">-x</td>\n<td align=\"center\">–hex-dump&#x3D;<number></td>\n<td align=\"center\">显示 段内内容Dump the contents of section <number></td>\n</tr>\n<tr>\n<td align=\"center\">-I</td>\n<td align=\"center\">–histogram</td>\n<td align=\"center\">Display histogram of bucket list lengths</td>\n</tr>\n<tr>\n<td align=\"center\">-W</td>\n<td align=\"center\">–wide</td>\n<td align=\"center\">宽行输出 Allow output width to exceed 80 characters</td>\n</tr>\n<tr>\n<td align=\"center\">-H</td>\n<td align=\"center\">–help</td>\n<td align=\"center\">Display this information</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"center\">–version</td>\n<td align=\"center\">Display the version number of readelf</td>\n</tr>\n</tbody></table>\n<h2 id=\"常见输出信息\"><a href=\"#常见输出信息\" class=\"headerlink\" title=\"常见输出信息\"></a>常见输出信息</h2><ul>\n<li>.text section 里装载了可执行代码；</li>\n<li>.data section 里面装载了被初始化的数据；</li>\n<li>.bss section 里面装载了未被初始化的数据；</li>\n<li>以 .rec 打头的 sections 里面装载了重定位条目；</li>\n<li>.symtab 或者 .dynsym section 里面装载了符号信息；</li>\n<li>.strtab 或者 .dynstr section 里面装载了字符串信息；<br>more:<img src=\"http://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html\"></li>\n</ul>\n<h2 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>readelf -h main| grep Machine</code>:查看程序的可运行的架构平台</li>\n<li><code>readelf -S main|grep debug</code>:编译时是否使用了-g选项</li>\n</ul>\n<h1 id=\"objdump\"><a href=\"#objdump\" class=\"headerlink\" title=\"objdump\"></a>objdump</h1><ul>\n<li><code>objdump</code>:displays information about object files</li>\n</ul>\n<h2 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>-f 显示文件头信息<br>-D 反汇编所有section (-d反汇编特定section)<br>-h 显示目标文件各个section的头部摘要信息<br>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。<br>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。<br>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。<br>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。<br>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。<br>-t 显示文件的符号表入口。类似于nm -s提供的信息</p>\n<h2 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example\"></a>example</h2><ul>\n<li><code>objdump -i</code>:查看本机目标结构(大小端)</li>\n<li><code>objdump -d main.o</code>:反汇编程序</li>\n<li><code>objdump -t main.o</code>:显示符号表入口</li>\n<li>below:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ objdump -t -C something.so | c++filt<br>... <span class=\"hljs-built_in\">df</span> *ABS* ... prog.cpp<br>... O .rodata ... CC1<br>... O .rodata ... CC2<br>... F .text ... g()<br>... O .rodata ... (anonymous namespace)::CC3<br>... O .rodata ... (anonymous namespace)::CC4<br>... F .text ... (anonymous namespace)::h()<br>... F .text ... (anonymous namespace)::B::j1()<br>... F .text ... (anonymous namespace)::B::j2()<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"cppcheck\"><a href=\"#cppcheck\" class=\"headerlink\" title=\"cppcheck\"></a>cppcheck</h1><h1 id=\"gcovr-有bug\"><a href=\"#gcovr-有bug\" class=\"headerlink\" title=\"gcovr(有bug)\"></a>gcovr(有bug)</h1><p>覆盖率工具，需要配合g++的<code>--coverage</code>选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ gcc -g --coverage program.cpp -o program<br>$ ./program 9<br>first<br>$ gcovr -r --html --html-details &lt;path&gt; <span class=\"hljs-comment\"># generate html</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"clang-tidy\"><a href=\"#clang-tidy\" class=\"headerlink\" title=\"clang-tidy\"></a>clang-tidy</h1><p>代码风格及静态检查</p>\n<h1 id=\"doxygen\"><a href=\"#doxygen\" class=\"headerlink\" title=\"doxygen\"></a>doxygen</h1><p>生成帮助文档，配置文件Doxyfile</p>\n<ul>\n<li><code>doxygen -g</code></li>\n<li>comment the code with <code>///</code> or <code>/** comment *</code></li>\n<li>generate doxygen base configuration file</li>\n</ul>\n<h2 id=\"注释关键字\"><a href=\"#注释关键字\" class=\"headerlink\" title=\"注释关键字\"></a>注释关键字</h2><ul>\n<li><code>@file</code> Document a file</li>\n<li><code>@brief</code> Brief description for an entity</li>\n<li><code>@param</code> Run-time parameter description</li>\n<li><code>@tparam</code> Template parameter description</li>\n<li><code>@return</code> Return value description</li>\n</ul>\n<h2 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">HAVE DOT = YES<br>GRAPHICAL HIERARCHY = YES<br>CALL GRAPH = YES<br>CALLER GRAPH = YES<br></code></pre></td></tr></table></figure>\n<h2 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example\"></a>example</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* @file</span><br><span class=\"hljs-comment\">* @copyright MyProject</span><br><span class=\"hljs-comment\">* license BSD3, Apache, MIT, etc.</span><br><span class=\"hljs-comment\">* @author MySelf</span><br><span class=\"hljs-comment\">* @version v3.14159265359</span><br><span class=\"hljs-comment\">* @date March, 2018</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-comment\">/// @brief Namespace brief description</span><br><span class=\"hljs-keyword\">namespace</span> my_namespace &#123;<br><span class=\"hljs-comment\">/// @brief &quot;Class brief description&quot;</span><br><span class=\"hljs-comment\">/// @tparam R &quot;Class template for&quot;</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> R&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* @brief &quot;What the function does?&quot;</span><br><span class=\"hljs-comment\">* @details &quot;Some additional details&quot;,</span><br><span class=\"hljs-comment\">* Latex/MathJax: $\\sqrt a$</span><br><span class=\"hljs-comment\">* @tparam T Type of input and output</span><br><span class=\"hljs-comment\">* @param[in] input Input array</span><br><span class=\"hljs-comment\">* @param[out] output Output array</span><br><span class=\"hljs-comment\">* @return `true` if correct,</span><br><span class=\"hljs-comment\">* `false` otherwise</span><br><span class=\"hljs-comment\">* @remark it is *useful* if ...</span><br><span class=\"hljs-comment\">* @warning the behavior is **undefined** if</span><br><span class=\"hljs-comment\">* @p input is `nullptr`</span><br><span class=\"hljs-comment\">* @see related_function</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">my_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T* input, T* output)</span></span>;<br><span class=\"hljs-comment\">/// @brief</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">related_function</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\n<h1 id=\"cloc\"><a href=\"#cloc\" class=\"headerlink\" title=\"cloc\"></a>cloc</h1><p>行数统计信息</p>\n<h1 id=\"lizard\"><a href=\"#lizard\" class=\"headerlink\" title=\"lizard\"></a>lizard</h1><p>圈复杂度分析工具<br><code>lizard my_project/</code></p>\n<h2 id=\"example-4\"><a href=\"#example-4\" class=\"headerlink\" title=\"example\"></a>example</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$lizard</span> my_project/<br>==============================================================<br>NLOC CCN token param <span class=\"hljs-keyword\">function</span>@line@file<br>--------------------------------------------------------------<br>10 2 29 2 start_new_player@26@./html_game.c<br>6 1 3 0 set_shutdown_flag@449@./httpd.c<br>24 3 61 1 server_main@454@./httpd.c<br>--------------------------------------------------------------<br></code></pre></td></tr></table></figure>\n<ul>\n<li>CCN:圈复杂度</li>\n<li>NLOC：无注释的代码行数</li>\n<li>token：number of conditional statements</li>\n</ul>\n<h1 id=\"clang-format\"><a href=\"#clang-format\" class=\"headerlink\" title=\"clang-format\"></a>clang-format</h1><h1 id=\"pstack\"><a href=\"#pstack\" class=\"headerlink\" title=\"pstack\"></a>pstack</h1><p>pstack是一个脚本工具，可显示每个进程的栈跟踪。pstack命令必须由相应进程的属主或root运行<br><code>pstrack &lt;program-pid&gt;</code></p>\n<h1 id=\"compiler-explorer\"><a href=\"#compiler-explorer\" class=\"headerlink\" title=\"compiler explorer\"></a>compiler explorer</h1><p>编码实时二进制查看</p>\n<h1 id=\"cppinsights\"><a href=\"#cppinsights\" class=\"headerlink\" title=\"cppinsights\"></a>cppinsights</h1><p>编译器实时查看</p>\n<h1 id=\"AI补全工具\"><a href=\"#AI补全工具\" class=\"headerlink\" title=\"AI补全工具\"></a>AI补全工具</h1><ul>\n<li>CoPilot</li>\n<li>TabNine</li>\n<li>Kite</li>\n</ul>\n<h1 id=\"代码在线搜索\"><a href=\"#代码在线搜索\" class=\"headerlink\" title=\"代码在线搜索\"></a>代码在线搜索</h1><ul>\n<li><a href=\"https://searchcode.com/\">searchcode</a></li>\n<li><a href=\"https://grep.app/\">grep.app</a></li>\n</ul>\n<h1 id=\"在线代码段性能比较\"><a href=\"#在线代码段性能比较\" class=\"headerlink\" title=\"在线代码段性能比较\"></a>在线代码段性能比较</h1><ul>\n<li><a href=\"http://quick-bench.com/\">benchmark</a></li>\n</ul>\n"},{"title":"cmake","date":"2024-04-04T23:06:41.000Z","banner_img":"/images/cmake.png","index_img":"/images/cmake.png","_content":"\n# 命令行\n- `cmake -S . -B build`:构建build树\n- `cmake --build`:build二进制\n- `cmake --fresh -S <source tree> -B <build tree>`:确保重头开始cmake\n\n|长选项|短选项|含义|\n|:-:|:-:|:-:|\n|`--source <dir>`|`-S <dir>`|指定源码路径|\n||`-B <dir>`|build树路径，若不存在创建目录|\n|`-build <dir>`||build二进制路径|\n|`--parallel <number-of-jobs>` |`-j <number-of-jobs>`|多核运行|\n||`-G <generator name>`|指定生成器，可以--help查看系统上支持的生成器|\n||`-C <initial cache script>`|预填充缓存信息|\n||`-D <var>[:<type>]=<value>`|指定变量值,type可选以下值：BOOL，FILEPATH，PATH，STRING 或 INTERNAL|\n||`-L`|列出缓存变量，-D指定的不会打印, -LH则还会打印变量提供的帮助信息|\n||`-U <globbing_expr>`|删除一个变量|\n|`--system-information [file]`||获取关于变量、命令、宏和其他设置的通用信息,可保存在file中|\n|`--log-level=<level>`||可以是ERROR，WARNING，NOTICE，STATUS，VERBOSE，DEBUG，TRACE，输出打印级别|\n|`--trace`||它会打印每个执行的命令及其文件名、调用它的行号，以及传递的参数列表|\n|`--list-presets`||列出所有可用的预设|\n|`--fresh`||清理目录，等价于手动删除|\n|`--target <target>`|`-t <target>`|指定生成的目标（这些目标通常排除在正常构建外）|\n|`--clean-first`|`-t clean`|只影响目标产物而不影响其他，如缓存|\n|`--config <cfg>`||指定构建类型，只有visual studio等多配置生成器可用，也可以用`CMAKE_BUILD_TYPE`指定|\n|`--install <build tree> --install-prefix <prefix>`||指定安装路径，prefix是前缀路径|\n|`--verbose`|`-v`|输出细节|\n||`-E <command> [options]`|以平台无关的方式运行单个命令——例如复制文件或计算校验和|\n\n# 内置变量\n|变量名|类型|含义|\n|:-:|:-:|\n|`CMAKE_GENERATOR_TOOLSET`||\n|`CMAKE_GENERATOR_PLATFORM`||\n|`CMAKE_BUILD_TYPE`|可选值Debug,Release,MinSizeRel,RelWithDebInfo|\n## 主机系统变量\n|变量名|类型|含义|\n|:-:|:-:|:-:|\n|`CMAKE_SIZEOF_VOID_P`|Int|8代表64位，4代表32位|\n|`CMAKE_<LANG>_BYTE_ORDER`||Lang可选C，CXX等,存放字节序,值有可能是`LITTLE_ENDIAN`和`BIG_ENDIAN`|\n|`CMAKE_SYSTEM_NAME`|String|存放操作系统类型：`Linux,Darwin,Windows,AIX`|\n|`ANDROID,APPLE,CYGWIN,UNIX,IOS,WIN32,WINCE,WINDOWS_PHONE`|Bool||\n|`HOSTNAME`|String|主机名|\n|`FQDN`|String| 完全限定域名|\n|`TOTAL_VIRTUAL_MEMORY`|String| 以 MiB 为单位的虚拟内存总量|\n|`AVAILABLE_VIRTUAL_MEMORY`|String| 以 MiB 为单位的可用虚拟内存|\n|`TOTAL_PHYSICAL_MEMORY`|String| 以 MiB 为单位的总物理内存|\n|`AVAILABLE_PHYSICAL_MEMORY`|String| 以 MiB 为单位的可用物理内存|\n|`OS_NAME`|String| 如果存在，则输出 uname -s; 无论是 Windows、Linux，还是 Darwin|\n|`OS_RELEASE`|| 操作系统子类型，如 Windows Professional|\n|`OS_VERSION`|String| 操作系统构建 ID|\n|`OS_PLATFORM`|String| 在 Windows 上和 $ENV{PROCESSOR_ARCHITECTURE} 的值一样. 在 Unix/macOS 上和 uname -m 一样|\n|`NUMBER_OF_LOGICAL_CORES`|| 逻辑核数|\n|`NUMBER_OF_PHYSICAL_CORES`|| 物理核数|\n|`HAS_SERIAL_NUMBER`|| 如果处理器有序列号，则为 1|\n|`PROCESSOR_SERIAL_NUMBER`|| 处理器序列号|\n|`PROCESSOR_NAME`|| 可读的处理器名称|\n|`PROCESSOR_DESCRIPTION`|| 可读的完整处理器描述|\n|`IS_64BIT`|| 如果处理器是 64 位的为 1|\n|`HAS_FPU`|| 如果处理器有浮点单元为 1|\n|`HAS_MMX`|| 如果处理器支持 MMX 指令为 1|\n|`HAS_MMX_PLUS`|| 如果处理器支持 Ext. MMX 指令为 1|\n|`HAS_SSE`|| 如果处理器支持 SSE 指令为 1|\n|`HAS_SSE2`|| 如果处理器支持 SSE2 指令为 1|\n|`HAS_SSE_FP`|| 如果处理器支持 SSE FP 指令为 1|\n|`HAS_SSE_MMX`|| 如果处理器支持 SSE MMX 指令为 1|\n|`HAS_AMD_3DNOW`|| 如果处理器支持 3DNow 指令为 1|\n|`HAS_AMD_3DNOW_PLUS`|| 如果处理器支持 3DNow+ 指令为 1|\n|`HAS_IA64`|| 如果 IA64 处理器模拟 x86，则为 1|\n\n# 常见操作\n## C++标准\n- `set(CMAKE_CXX_STANDARD <version>)`\n- `set_property(Target <target> PROPERTY CXX_STANDARD <version>)`\n- `set_target_properties(<targets> PROPERTIES CXX_STANDARD <version>)`\n- `target_compile_features(<target> PUBLIC cxx_std_26)`\nversion可选值有：98,11,14,17,20,23,26\n使用target_compile_features可选值有cxx_std_14...\n强制应用标准：`set(CMAKE_CXX_STANDARD_REQUIRED ON)`\n## 检查支持的编译特性\n```cmake\nlist(FIND CMAKE_CXX_COMPILE_FEATURES cxx_variable_templates result)\nif(result EQUAL -1)\n    message(FATAL_ERROR \"Variable templates are required for compilation.\")\nendif()\n```\n可以在[c++支持特性列表里找到特性的完整列表](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html)\n## 过程间优化(ipo)\n```cmake\ninclude(CheckIPOSupported)\ncheck_ipo_supported(RESULT ipo_supported)\nset(CMAKE_INTERPROCEDURAL_OPTIMIZATION ${ipo_supported})\n```\n## 禁用源内构建\n```cmake\ncmake_minimum_required(VERSION 3.26.0)\nproject(NoInSource CXX)\nif(PROJECT_SOURCE_DIR STREQUAL PROJECT_BINARY_DIR)\n    message(FATAL_ERROR \"In-source builds are not allowed\")\nendif()\nmessage(\"Build successful!\")\n```\n## 生成目标依赖图\n- 使用命令`cmake --graphviz=test.dot .`\n- 更多信息见官网**CMakeGraphVizOptions**模块,\n- 默认自定义目标不会出现在图中，可以创建一个**CMakeGraphVizOptions.cmake**文件，里面设置`set(GRAPHVIZ_CUSTOM_TARGETS TRUE)`\n- 生成的dot文件可以在线查看[Graphviz](https://dreampuf.github.io/GraphvizOnline/)\n# 基本语法\n## 注释\n- 单行注释：行首添加`#`\n- 多行注释：以#开始，后跟方括号，任意数量等号=可以是0个，以及另一个方括号,并以相同数量等号及方括号关闭\n```cmake\n #[=[\n2 bracket comment\n    3 #[[\n        4 nested bracket comment\n    5 #]]\n6 #]=]\n```\n## 参数\n### 括号参数\n括号参数与多行注释格式类似，但它不能嵌套\n```cmake\nmessage([[multiline\n    bracket\n    argument\n]])\nmessage([==[\n    because we used two equal-signs \"==\"\n    this command receives only a single argument\n    even if it includes two square brackets in a row\n    { \"petsArray\" = [[\"mouse\",\"cat\"],[\"dog\"]] }\n]==])\n```\n### 引号参数\n```cmake\nmessage(\"1. escape sequence: \\\" \\n in a quoted argument\")\nmessage(\"2. multi...\nline\")\nmessage(\"3. and a variable reference: ${CMAKE_VERSION}\")\n```\n### 非引号参数\n```cmake\nmessage(a\\ single\\ argument)\nmessage(two arguments)\nmessage(three;separated arguments)\nmessage(${CMAKE_VERSION}) # a variable reference\n```\n## 使用变量\n- 设置与读取：\n```cmake\nset(MyString1 \"Text1\")\nset([[My String2]] \"Text2\")\nset(\"My String 3\" \"Text3\")\nmessage(${MyString1})\nmessage(${My\\ String2})\nmessage(${My\\ String\\ 3})\n```\n- 取消：`unset(MyString1)`\n- 环境变量：`$ENV{}`\n- 缓存变量：`$CACHE{}`\n### 缓存变量\n- 格式：`set(<variable> <value> CACHE <type> <docstring> [FORCE])`\n- BOOL: 一个布尔开关值。GUI 将显示一个复选框。\n- FILEPATH: 磁盘上一个文件的路径。GUI 将打开一个文件对话框。\n- PATH: 磁盘上一个目录的路径。GUI 将打开一个目录对话框。\n- STRING: 一 行 文 本。GUI 提 供 了 一 个 要 填 充 的 文 本 字 段， 可 以 通 过 调 用\nset_property(CACHE <variable> STRINGS <values>) 来替换为下拉控件。\n- INTERNAL: 一行文本。GUI 将跳过内部条目。内部条目可以用来在运行之间持久存储变量，\n使用此类型隐式添加 FORCE 关键字。\n`<doctring>` 值只是一个标签，GUI 将在字段旁边显示它，以便向用户提供此设置的更多细\n节。如果缓存文件中不存在该变量或指定了可选的 FORCE 参数，该值将持久化\n## 使用列表\n- `set(myList a list of five elements)`\n- `set(myList \"a;list;of;five;elements\")`\n- `set(myList a list \"of;five;elements\")`\n### list命令工具\n- list(LENGTH <list> <out-var>)\n- list(GET <list> <element index> [<index> ...] <out-var>)\n- list(JOIN <list> <glue> <out-var>)\n- list(SUBLIST <list> <begin> <length> <out-var>)\n- list(FIND <list> <value> <out-var>)\n- list(APPEND <list> [<element>...])\n- list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)\n- list(INSERT <list> <index> [<element>...])\n- list(POP_BACK <list> [<out-var>...])\n- list(POP_FRONT <list> [<out-var>...])\n- list(PREPEND <list> [<element>...])\n- list(REMOVE_ITEM <list> <value>...)\n- list(REMOVE_AT <list> <index>...)\n- list(REMOVE_DUPLICATES <list>)\n- list(TRANSFORM <list> <ACTION> [...])\n- list(REVERSE <list>)\n- list(SORT <list> [...])\n## 条件语句\n```cmake\nif(<condition>)\n<commands>\nelseif(<condition>) # optional block, can be repeated\n<commands>\nelse() # optional block\n<commands>\nendif()\n```\n### 条件格式\n- `<condition> AND <condition>`\n- `<condition> OR <condition>`\n- `NOT <condition>`\n- `DEFINED <variable>`\n- `DEFINED CACHE<variable>`\n- `DEFINED ENV<variable>`\n- `if(FOO)`:在以下情况才为假:\n    - OFF, NO, FALSE, N, IGNORE 或 NOTFOUND\n    - 以-NOTFOUND 结尾的字符串\n    - 空字符串\n    - 零\n- `if($(QUX))`字符串只有在等于 ON、Y、YES、TRUE 或非零数字，才可视为真（这些比较不区分大小写）。\n- `1 LESS/LESS_EQUAL/GREATER/GREATER_EQUAL/EQUAL 2`\n- `1.3.4 VERSION_LESS_EQUAL 1.4`\n- `\"str1\" STREQUAL \"${B}\"`\n- `<VARIABLE|STRING> MATCHES <regex>`\n- `<VARIABLE|STRING> IN_LIST <VARIABLE>`\n- `COMMAND <command-name>`是否可以调用某个cmake命令\n- `POLICY <policy-id>`是否存在cmake策略\n- `TEST <test-name>`是否add_test()添加了CTest测试\n- `TARGET <target-name>`是否定义了一个构建目标\n- `EXISTS <path-to-file-or-directory>`\n- `<file1> IS_NEWER_THAN <file2>:`\n- `IS_DIRECTORY <path-to-directory>`\n- `IS_SYMLINK <file-name>`\n- `IS_ABSOLUTE <path>`\n## 循环\n循环体支持`break()和continue()`\n### while\n```cmake\nwhile(<condition>)\n<commands>\nendwhile()\n```\n### foreach\n```cmake\nforeach(<loop_var> RANGE <max>)#CMake 将从 0 迭代到 <max>（包括）。\n    <commands>\nendforeach()\n```\n- `foreach(<loop_var> RANGE <min> <max> [<step>])`\n- `foreach(<loop_variable> IN [LISTS <lists>] [ITEMS <items>])`\n- `foreach(<loop_var>... IN ZIP_LISTS <lists>)`\n\n```cmake\nset(MyList 1 2 3)\nforeach(VAR IN LISTS MyList ITEMS e f)#等价于foreach(VAR 1 2 3 e f)\n    message(${VAR})\nendforeach()\n```\n```cmake\nset(L1 \"one;two;three;four\")\nset(L2 \"1;2;3;4;5\")\nforeach(num IN ZIP_LISTS L1 L2)\n    message(\"word=${num_0}, num=${num_1}\")\nendforeach()\n# 等价于下面\n# foreach(word num IN ZIP_LISTS L1 L2)\n#    message(\"word=${word}, num=${num}\")\n```\n## function\n```cmake\nfunction(<name> [<argument>...])\n<commands>\nendfunction()\n```\n```cmake\nfunction(MyFunction FirstArg)\n    message(\"Function: ${CMAKE_CURRENT_FUNCTION}\")\n    message(\"File: ${CMAKE_CURRENT_FUNCTION_LIST_FILE}\")\n    message(\"FirstArg: ${FirstArg}\")\n    set(FirstArg \"new value\")\n    message(\"FirstArg again: ${FirstArg}\")\n    message(\"ARGV0: ${ARGV0} ARGV1: ${ARGV1} ARGC: ${ARGC}\")\nendfunction()\nset(FirstArg \"first value\")\nMyFunction(\"Value1\" \"Value2\")\nmessage(\"FirstArg in global scope: ${FirstArg}\")\n```\n\n# 命令\n## cmake_minimum-required\n- 格式：`cmake_minimum_required(VERSION <x.xx>)`\n- 意义：设置cmake期望的版本\n## project\n- 格式一：`project(<PROJECT-NAME> [<language-name>...])`\n- 格式二：\n```cmake\nproject(<PROJECT-NAME>\n    [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]\n    [DESCRIPTION <project-description-string>]\n    [HOMEPAGE_URL <url-string>]\n    [LANGUAGES <language-name>...])\n```\n此命令将设置以下变量:\n- `PROJECT_NAME`\n- `CMAKE_PROJECT_NAME (only in the top-level CMakeLists.txt)`\n- `PROJECT_IS_TOP_LEVEL, <PROJECT-NAME>_IS_TOP_LEVEL`\n- `PROJECT_SOURCE_DIR, <PROJECT-NAME>_SOURCE_DIR`\n- `PROJECT_BINARY_DIR, <PROJECT-NAME>_BINARY_DIR`\n支持语言(仅列常用的)\n- C:C\n- CXX: C++\n指定VERSION关键字，将会设置以下变量:\n- `PROJECT_VERSION, <PROJECT-NAME>_VERSION`\n- `CMAKE_PROJECT_VERSION (only in the top-level CMakeLists.txt)`\n- `PROJECT_VERSION_MAJOR, <PROJECT-NAME>_VERSION_MAJOR`\n- `PROJECT_VERSION_MINOR, <PROJECT-NAME>_VERSION_MINOR`\n- `PROJECT_VERSION_PATCH, <PROJECT-NAME>_VERSION_PATCH`\n- `PROJECT_VERSION_TWEAK, <PROJECT-NAME>_VERSION_TWEAK`\n类似设置DESCRIPTION和HOMEPAGE_URL将设置以下变量\n- `PROJECT_DESCRIPTION, <PROJECT-NAME>_DESCRIPTION`\n- `PROJECT_HOMEPAGE_URL, <PROJECT-NAME>_HOMEPAGE_URL`\n## add_subdirectory\n- 格式：`add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])`\n- 意义：`将计算source_dir 路径（相对于当前目录）并解析其中的CMakeLists.txt 文件`\n- **[binary_dir]**: 构建的文件将写入该路径，默认是构建树\n- **[EXCLUDE_FROM_ALL]**: 禁用子目录中定义的目标的自动构建\n## add_executable\n- 格式：`add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1 source2...])`\n- [WIN32],[MACOSX_BUNDLE]分别生成win和mac下的gui程序\n- [EXCLUDE_FROM_ALL]将使得该目标在默认构建中排除在外，必须-t明确指明\n## add_library\n- 格式：`add_library(<name> [STATIC|SHARED|MODULE] [EXCLUDE_FROM_ALL] [source1 source2...])`\n- [STATIC|SHARED|MODULE],分别对应静态，动态，模块\n## add_custom_target\n- 格式：`add_custom_target(Name [ALL] [COMMAND command2 [args2...] ...])`\n[ALL]与[EXCLUDE_FROM_ALL]含义相反，自定义目标默认不生成,自定义目标通常用于以下场景：\n- 计算其他二进制文件的校验和\n- 运行代码消毒器并收集结果\n- 将编译报告发送到指标通道\n```cmake\ncmake_minimum_required(VERSION 3.26)\nproject(BankApp CXX)\nadd_executable(terminal_app terminal_app.cpp)\nadd_executable(gui_app gui_app.cpp)\ntarget_link_libraries(terminal_app calculations)\ntarget_link_libraries(gui_app calculations drawing)\nadd_library(calculations calculations.cpp)\nadd_library(drawing drawing.cpp)\nadd_custom_target(checksum ALL\n    COMMAND sh -c \"cksum terminal_app>terminal.ck\"\n    COMMAND sh -c \"cksum gui_app>gui.ck\"\n    BYPRODUCTS terminal.ck gui.ck\n    COMMENT \"Checking the sums...\"\n)\n```\n## find_package\n- `find_package(<Name> [version] [EXACT] [QUIET] [REQUIRED])`\n[version]可以指定一个范围，如`1.22...1.40.1`,EXACT指定确切版本，而不是更新,QUIET抑制包被找到的信息\n当找到库后，cmake将会自动设置以下变量：\n- `<PKG_NAME>_FOUND`: 这表明是否成功找到了包。\n- `<PKG_NAME>_INCLUDE_DIRS 或 <PKG_NAME>_INCLUDES`: 这指向包的头文件所在的目\n录。\n- `<PKG_NAME>_LIBRARIES 或 <PKG_NAME>_LIBS`: 这些是要链接的库的列表。\n可以设置扫描路径`CMAKE_MODULE_PATH`，而不是系统默认的\n## message\n- `message(<MODE> ”text to print”)`\nMODE可选以下：\n- FATAL_ERROR: 停止处理和生成。\n- SEND_ERROR: 继续处理，但跳过生成。\n- WARNING: 继续处理。\n- AUTHOR_WARNING: 输出警告，但继续处理。\n- DEPRECATION: 如 果 启 用 了 CMAKE_ERROR_DEPRECATED 或 CMAKE_WARN_DEPRECATED，则输出相应地信息。\n- NOTICE 或省略模式（默认）: 输出消息到 stderr，以吸引使用者的注意。\n- STATUS: 继续处理，推荐用于向用户显示的主要消息。\n- VERBOSE: 继续处理，应用于更详细的信息，通常不是非常必要。\n- DEBUG: 继续处理，应包含项目出现问题时，对处理问题有帮助的详细信息。\n- TRACE: 继续处理，建议在项目开发期间输出消息。通常，这类消息会在发布项目之前移除。\n## file\n- file(READ <filename> <out-var> [...])\n- file({WRITE | APPEND} <filename> <content>...)\n- file(DOWNLOAD <url> [<file>] [...])\n## execute_process()\n- `execute_process(COMMAND <cmd1> [<arguments>]... [OPTIONS])`\n可选地 TIMEOUT 参数，用来在进程未在所需限制内完成任务时终止该进程，并且可以根据\n需要设置 WORKING_DIRECTORY 。\n所有任务的退出代码可以通过提供 RESULTS_VARIABLE 参数来收集到一个列表中。如果只\n对最后执行的命令的结果感兴趣，请使用单数形式：RESULT_VARIABLE 。\n为了收集输出，CMake 提供了两个参数：OUTPUT_VARIABLE 和 ERROR_VARIABLE（用法\n类似）。如果想合并 stdout 和 stderr，请为这两个参数使用相同的变量。\n## 伪目标\n### 别名目标\n别名目标的确切作用就是你所期望的——为目标创建另一个不同的名称引用\n- `add_executable(<name> ALIAS <target>)`\n- `add_library(<name> ALIAS <target>)`\n### 接口库\n- `add_library(<name> INTERFACE [item1 ...])`\n有两个作用：一是**代表仅包含头文件的库**,二是**将一堆传播属性打包成一个逻辑单元**\n例子一：\n```cmake\nadd_library(Eigen INTERFACE\n  src/eigen.h src/vector.h src/matrix.h\n)\ntarget_include_directories(Eigen INTERFACE\n  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>\n  $<INSTALL_INTERFACE:include/Eigen>\n)\ntarget_link_libraries(executable Eigen)\n```\n例子二：\n```cmake\nadd_library(warning_properties INTERFACE)\ntarget_compile_options(warning_properties INTERFACE\n    -Wall -Wextra -Wpedantic\n)\n5 target_link_libraries(executable warning_properties)\n```\n## 对象库\n即.o对象文件\n- `add_library(<target> OBJECT <sources>)`\n可以使用target_link_libraries()作为依赖添加，抑或是如下：\n```cmake\nadd_library(... $<TARGET_OBJECTS:objname> ...)\nadd_executable(... $<TARGET_OBJECTS:objname> ...)\n```\n## target_include_directories\n```cmake\ntarget_include_directories(<target> [SYSTEM] [AFTER|BEFORE]\n<INTERFACE|PUBLIC|PRIVATE> [item1...]\n[<INTERFACE|PUBLIC|PRIVATE> [item2...]\n...])\n```\nSYSTEM 关键字告诉编译器给定的目录应该视为标准系统目录（与尖括号形式一起使用）。\nBEFORE或AFTER决定是否将这些头文件放在已有的路径之前或之后\n## target_compile_definitions\n- `target_compile_definitions(<target> [PRIVATE|PUBLIC|INTERFACE] [var1 \"var2=value\" ...])`\n定义宏变量,相当于-D传递,也可以传递-D选项\n```cmake\ntarget_compile_definitions(defined PRIVATE ABC \"DEF=${VAR}\")\ntarget_compile_definitions(hello PRIVATE -DFOO)\ntarget_compile_definitions(hello PRIVATE -D FOO)\n```\n## target_compile_options\n- 传递编译器参数\n- `target_compile_options(<target> [BEFORE] <INTERFACE|PUBLIC|PRIVATE> [items1...] <INTERFACE|PUBLIC|PRIVATE> [items2...]`\n## target_precompile_headers\n- 预编译头文件\n- `target_precompile_headers(<target> <INTERFACE|PUBLIC|PRIVATE> [header1...] [<INTERFACE|PUBLIC|PRIVATE> [header2...] ...])`\n添加的头文件列表存储在PRECOMPILE_HEADERS属性中,不应该对使用install命令导出的目标执行此操作\n# 目标的属性\n- 获取属性值:`get_target_property(<var> <target> <property-name>)`\n- 设置属性:`set_target_properties(<target1> <target2> ...  PROPERTIES <prop1-name> <value1> <prop2-name> <value2> ...)`或 `set_property(Target <target> PROPERTY <prop-name> <value>)`\n## 属性传播\n- PRIVATE:设置源目标属性\n- INTERFACE:设置使用目标的目标属性\n- PUBLIC：设置源目标和使用目标属性\n当指定 PRIVATE 或 PUBLIC 关键字时，CMake 将在目 标的属性中存储提供的值，COMPILE_DEFINITIONS。此外，关键字是 INTERFACE 或 PUBLIC， 将在具有 INTERFACE_前缀的属性中存储值——INTERFACE_COMPILE_DEFINITIONS。配置阶 段，CMake 将读取源目标的接口属性，并将其内容附加到目标目标。就这样传播属性，或 CMake 所说的传递目标的使用要求。\n设置属性时需要指定上述关键字，如`target_compile_definitions(<source> <INTERFACE|PUBLIC|PRIVATE> [items1...])`, `target_link_libraries(<target> <PRIVATE|PUBLIC|INTERFACE> <item1> [<PRIVATE|PUBLIC|INTERFACE> <item>...])`这个命令也需要传播关键字\n## 自定义属性的传播\nCMake 默认不会传播自定义属性（这个机制只适用 于内置目标属性），必须明确地将自定义属性添加到“兼容”属性列表中。\n每个目标都有四个这样的列表：\n- COMPATIBLE_INTEERFACE_BOOL\n- COMPATIBLE_INTERFACE_STRING\n- COMPATIBLE_INTERFACE_NUMBER_MAX\n- COMPATIBLE_INTERFACE_NUMBER_MIN\n将属性添加到它们中的任何一个，都会触发传播和兼容性检查。BOOL 列表将检查所有传递到 目标目标的属性是否评估为相同的布尔值。类似地，STRING 将评估为字符串。NUMBER_MAX 和 NUMBER_MIN 略有不同——传递的值不必匹配，但目标目标将只接收最高或最低值。\n### 例子\n```cmake\ncmake_minimum_required(VERSION 3.26)\n project(PropagatedProperties CXX)\n\nadd_library(source1 empty.cpp)\nset_property(TARGET source1 PROPERTY INTERFACE_LIB_VERSION 4)\nset_property(TARGET source1 APPEND PROPERTY\n    COMPATIBLE_INTERFACE_STRING LIB_VERSION)\n\nadd_library(source2 empty.cpp)\nset_property(TARGET source2 PROPERTY INTERFACE_LIB_VERSION 4)\nadd_library(destination empty.cpp)\ntarget_link_libraries(destination source1 source2)\n```\nCMake 将这个自定义属性传播到相应目标，并检查所有源目标的版本是否完全匹配（兼容性属性只需在目标目标上设置一次）。\n\n# 参考连接\n[19 reasons why cmake is actually awesome](https://kubasejdak.com/19-reasons-why-cmake-is-actually-awesome)\n[an introduction to modern cmake](https://cliutils.gitlab.io/modern-cmake/)\n[effective modern cmake](https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1)\n[awesome cmake](https://github.com/onqtam/awesome-cmake)\n[useful variables](https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/Useful-Variables)\n# CTest\ntesting tool(integrated in CMake)\n","source":"_posts/cmake.md","raw":"---\ntitle: cmake\ndate: 2024-04-05 07:06:41\ntags:\nbanner_img: /images/cmake.png\nindex_img: /images/cmake.png\n---\n\n# 命令行\n- `cmake -S . -B build`:构建build树\n- `cmake --build`:build二进制\n- `cmake --fresh -S <source tree> -B <build tree>`:确保重头开始cmake\n\n|长选项|短选项|含义|\n|:-:|:-:|:-:|\n|`--source <dir>`|`-S <dir>`|指定源码路径|\n||`-B <dir>`|build树路径，若不存在创建目录|\n|`-build <dir>`||build二进制路径|\n|`--parallel <number-of-jobs>` |`-j <number-of-jobs>`|多核运行|\n||`-G <generator name>`|指定生成器，可以--help查看系统上支持的生成器|\n||`-C <initial cache script>`|预填充缓存信息|\n||`-D <var>[:<type>]=<value>`|指定变量值,type可选以下值：BOOL，FILEPATH，PATH，STRING 或 INTERNAL|\n||`-L`|列出缓存变量，-D指定的不会打印, -LH则还会打印变量提供的帮助信息|\n||`-U <globbing_expr>`|删除一个变量|\n|`--system-information [file]`||获取关于变量、命令、宏和其他设置的通用信息,可保存在file中|\n|`--log-level=<level>`||可以是ERROR，WARNING，NOTICE，STATUS，VERBOSE，DEBUG，TRACE，输出打印级别|\n|`--trace`||它会打印每个执行的命令及其文件名、调用它的行号，以及传递的参数列表|\n|`--list-presets`||列出所有可用的预设|\n|`--fresh`||清理目录，等价于手动删除|\n|`--target <target>`|`-t <target>`|指定生成的目标（这些目标通常排除在正常构建外）|\n|`--clean-first`|`-t clean`|只影响目标产物而不影响其他，如缓存|\n|`--config <cfg>`||指定构建类型，只有visual studio等多配置生成器可用，也可以用`CMAKE_BUILD_TYPE`指定|\n|`--install <build tree> --install-prefix <prefix>`||指定安装路径，prefix是前缀路径|\n|`--verbose`|`-v`|输出细节|\n||`-E <command> [options]`|以平台无关的方式运行单个命令——例如复制文件或计算校验和|\n\n# 内置变量\n|变量名|类型|含义|\n|:-:|:-:|\n|`CMAKE_GENERATOR_TOOLSET`||\n|`CMAKE_GENERATOR_PLATFORM`||\n|`CMAKE_BUILD_TYPE`|可选值Debug,Release,MinSizeRel,RelWithDebInfo|\n## 主机系统变量\n|变量名|类型|含义|\n|:-:|:-:|:-:|\n|`CMAKE_SIZEOF_VOID_P`|Int|8代表64位，4代表32位|\n|`CMAKE_<LANG>_BYTE_ORDER`||Lang可选C，CXX等,存放字节序,值有可能是`LITTLE_ENDIAN`和`BIG_ENDIAN`|\n|`CMAKE_SYSTEM_NAME`|String|存放操作系统类型：`Linux,Darwin,Windows,AIX`|\n|`ANDROID,APPLE,CYGWIN,UNIX,IOS,WIN32,WINCE,WINDOWS_PHONE`|Bool||\n|`HOSTNAME`|String|主机名|\n|`FQDN`|String| 完全限定域名|\n|`TOTAL_VIRTUAL_MEMORY`|String| 以 MiB 为单位的虚拟内存总量|\n|`AVAILABLE_VIRTUAL_MEMORY`|String| 以 MiB 为单位的可用虚拟内存|\n|`TOTAL_PHYSICAL_MEMORY`|String| 以 MiB 为单位的总物理内存|\n|`AVAILABLE_PHYSICAL_MEMORY`|String| 以 MiB 为单位的可用物理内存|\n|`OS_NAME`|String| 如果存在，则输出 uname -s; 无论是 Windows、Linux，还是 Darwin|\n|`OS_RELEASE`|| 操作系统子类型，如 Windows Professional|\n|`OS_VERSION`|String| 操作系统构建 ID|\n|`OS_PLATFORM`|String| 在 Windows 上和 $ENV{PROCESSOR_ARCHITECTURE} 的值一样. 在 Unix/macOS 上和 uname -m 一样|\n|`NUMBER_OF_LOGICAL_CORES`|| 逻辑核数|\n|`NUMBER_OF_PHYSICAL_CORES`|| 物理核数|\n|`HAS_SERIAL_NUMBER`|| 如果处理器有序列号，则为 1|\n|`PROCESSOR_SERIAL_NUMBER`|| 处理器序列号|\n|`PROCESSOR_NAME`|| 可读的处理器名称|\n|`PROCESSOR_DESCRIPTION`|| 可读的完整处理器描述|\n|`IS_64BIT`|| 如果处理器是 64 位的为 1|\n|`HAS_FPU`|| 如果处理器有浮点单元为 1|\n|`HAS_MMX`|| 如果处理器支持 MMX 指令为 1|\n|`HAS_MMX_PLUS`|| 如果处理器支持 Ext. MMX 指令为 1|\n|`HAS_SSE`|| 如果处理器支持 SSE 指令为 1|\n|`HAS_SSE2`|| 如果处理器支持 SSE2 指令为 1|\n|`HAS_SSE_FP`|| 如果处理器支持 SSE FP 指令为 1|\n|`HAS_SSE_MMX`|| 如果处理器支持 SSE MMX 指令为 1|\n|`HAS_AMD_3DNOW`|| 如果处理器支持 3DNow 指令为 1|\n|`HAS_AMD_3DNOW_PLUS`|| 如果处理器支持 3DNow+ 指令为 1|\n|`HAS_IA64`|| 如果 IA64 处理器模拟 x86，则为 1|\n\n# 常见操作\n## C++标准\n- `set(CMAKE_CXX_STANDARD <version>)`\n- `set_property(Target <target> PROPERTY CXX_STANDARD <version>)`\n- `set_target_properties(<targets> PROPERTIES CXX_STANDARD <version>)`\n- `target_compile_features(<target> PUBLIC cxx_std_26)`\nversion可选值有：98,11,14,17,20,23,26\n使用target_compile_features可选值有cxx_std_14...\n强制应用标准：`set(CMAKE_CXX_STANDARD_REQUIRED ON)`\n## 检查支持的编译特性\n```cmake\nlist(FIND CMAKE_CXX_COMPILE_FEATURES cxx_variable_templates result)\nif(result EQUAL -1)\n    message(FATAL_ERROR \"Variable templates are required for compilation.\")\nendif()\n```\n可以在[c++支持特性列表里找到特性的完整列表](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html)\n## 过程间优化(ipo)\n```cmake\ninclude(CheckIPOSupported)\ncheck_ipo_supported(RESULT ipo_supported)\nset(CMAKE_INTERPROCEDURAL_OPTIMIZATION ${ipo_supported})\n```\n## 禁用源内构建\n```cmake\ncmake_minimum_required(VERSION 3.26.0)\nproject(NoInSource CXX)\nif(PROJECT_SOURCE_DIR STREQUAL PROJECT_BINARY_DIR)\n    message(FATAL_ERROR \"In-source builds are not allowed\")\nendif()\nmessage(\"Build successful!\")\n```\n## 生成目标依赖图\n- 使用命令`cmake --graphviz=test.dot .`\n- 更多信息见官网**CMakeGraphVizOptions**模块,\n- 默认自定义目标不会出现在图中，可以创建一个**CMakeGraphVizOptions.cmake**文件，里面设置`set(GRAPHVIZ_CUSTOM_TARGETS TRUE)`\n- 生成的dot文件可以在线查看[Graphviz](https://dreampuf.github.io/GraphvizOnline/)\n# 基本语法\n## 注释\n- 单行注释：行首添加`#`\n- 多行注释：以#开始，后跟方括号，任意数量等号=可以是0个，以及另一个方括号,并以相同数量等号及方括号关闭\n```cmake\n #[=[\n2 bracket comment\n    3 #[[\n        4 nested bracket comment\n    5 #]]\n6 #]=]\n```\n## 参数\n### 括号参数\n括号参数与多行注释格式类似，但它不能嵌套\n```cmake\nmessage([[multiline\n    bracket\n    argument\n]])\nmessage([==[\n    because we used two equal-signs \"==\"\n    this command receives only a single argument\n    even if it includes two square brackets in a row\n    { \"petsArray\" = [[\"mouse\",\"cat\"],[\"dog\"]] }\n]==])\n```\n### 引号参数\n```cmake\nmessage(\"1. escape sequence: \\\" \\n in a quoted argument\")\nmessage(\"2. multi...\nline\")\nmessage(\"3. and a variable reference: ${CMAKE_VERSION}\")\n```\n### 非引号参数\n```cmake\nmessage(a\\ single\\ argument)\nmessage(two arguments)\nmessage(three;separated arguments)\nmessage(${CMAKE_VERSION}) # a variable reference\n```\n## 使用变量\n- 设置与读取：\n```cmake\nset(MyString1 \"Text1\")\nset([[My String2]] \"Text2\")\nset(\"My String 3\" \"Text3\")\nmessage(${MyString1})\nmessage(${My\\ String2})\nmessage(${My\\ String\\ 3})\n```\n- 取消：`unset(MyString1)`\n- 环境变量：`$ENV{}`\n- 缓存变量：`$CACHE{}`\n### 缓存变量\n- 格式：`set(<variable> <value> CACHE <type> <docstring> [FORCE])`\n- BOOL: 一个布尔开关值。GUI 将显示一个复选框。\n- FILEPATH: 磁盘上一个文件的路径。GUI 将打开一个文件对话框。\n- PATH: 磁盘上一个目录的路径。GUI 将打开一个目录对话框。\n- STRING: 一 行 文 本。GUI 提 供 了 一 个 要 填 充 的 文 本 字 段， 可 以 通 过 调 用\nset_property(CACHE <variable> STRINGS <values>) 来替换为下拉控件。\n- INTERNAL: 一行文本。GUI 将跳过内部条目。内部条目可以用来在运行之间持久存储变量，\n使用此类型隐式添加 FORCE 关键字。\n`<doctring>` 值只是一个标签，GUI 将在字段旁边显示它，以便向用户提供此设置的更多细\n节。如果缓存文件中不存在该变量或指定了可选的 FORCE 参数，该值将持久化\n## 使用列表\n- `set(myList a list of five elements)`\n- `set(myList \"a;list;of;five;elements\")`\n- `set(myList a list \"of;five;elements\")`\n### list命令工具\n- list(LENGTH <list> <out-var>)\n- list(GET <list> <element index> [<index> ...] <out-var>)\n- list(JOIN <list> <glue> <out-var>)\n- list(SUBLIST <list> <begin> <length> <out-var>)\n- list(FIND <list> <value> <out-var>)\n- list(APPEND <list> [<element>...])\n- list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)\n- list(INSERT <list> <index> [<element>...])\n- list(POP_BACK <list> [<out-var>...])\n- list(POP_FRONT <list> [<out-var>...])\n- list(PREPEND <list> [<element>...])\n- list(REMOVE_ITEM <list> <value>...)\n- list(REMOVE_AT <list> <index>...)\n- list(REMOVE_DUPLICATES <list>)\n- list(TRANSFORM <list> <ACTION> [...])\n- list(REVERSE <list>)\n- list(SORT <list> [...])\n## 条件语句\n```cmake\nif(<condition>)\n<commands>\nelseif(<condition>) # optional block, can be repeated\n<commands>\nelse() # optional block\n<commands>\nendif()\n```\n### 条件格式\n- `<condition> AND <condition>`\n- `<condition> OR <condition>`\n- `NOT <condition>`\n- `DEFINED <variable>`\n- `DEFINED CACHE<variable>`\n- `DEFINED ENV<variable>`\n- `if(FOO)`:在以下情况才为假:\n    - OFF, NO, FALSE, N, IGNORE 或 NOTFOUND\n    - 以-NOTFOUND 结尾的字符串\n    - 空字符串\n    - 零\n- `if($(QUX))`字符串只有在等于 ON、Y、YES、TRUE 或非零数字，才可视为真（这些比较不区分大小写）。\n- `1 LESS/LESS_EQUAL/GREATER/GREATER_EQUAL/EQUAL 2`\n- `1.3.4 VERSION_LESS_EQUAL 1.4`\n- `\"str1\" STREQUAL \"${B}\"`\n- `<VARIABLE|STRING> MATCHES <regex>`\n- `<VARIABLE|STRING> IN_LIST <VARIABLE>`\n- `COMMAND <command-name>`是否可以调用某个cmake命令\n- `POLICY <policy-id>`是否存在cmake策略\n- `TEST <test-name>`是否add_test()添加了CTest测试\n- `TARGET <target-name>`是否定义了一个构建目标\n- `EXISTS <path-to-file-or-directory>`\n- `<file1> IS_NEWER_THAN <file2>:`\n- `IS_DIRECTORY <path-to-directory>`\n- `IS_SYMLINK <file-name>`\n- `IS_ABSOLUTE <path>`\n## 循环\n循环体支持`break()和continue()`\n### while\n```cmake\nwhile(<condition>)\n<commands>\nendwhile()\n```\n### foreach\n```cmake\nforeach(<loop_var> RANGE <max>)#CMake 将从 0 迭代到 <max>（包括）。\n    <commands>\nendforeach()\n```\n- `foreach(<loop_var> RANGE <min> <max> [<step>])`\n- `foreach(<loop_variable> IN [LISTS <lists>] [ITEMS <items>])`\n- `foreach(<loop_var>... IN ZIP_LISTS <lists>)`\n\n```cmake\nset(MyList 1 2 3)\nforeach(VAR IN LISTS MyList ITEMS e f)#等价于foreach(VAR 1 2 3 e f)\n    message(${VAR})\nendforeach()\n```\n```cmake\nset(L1 \"one;two;three;four\")\nset(L2 \"1;2;3;4;5\")\nforeach(num IN ZIP_LISTS L1 L2)\n    message(\"word=${num_0}, num=${num_1}\")\nendforeach()\n# 等价于下面\n# foreach(word num IN ZIP_LISTS L1 L2)\n#    message(\"word=${word}, num=${num}\")\n```\n## function\n```cmake\nfunction(<name> [<argument>...])\n<commands>\nendfunction()\n```\n```cmake\nfunction(MyFunction FirstArg)\n    message(\"Function: ${CMAKE_CURRENT_FUNCTION}\")\n    message(\"File: ${CMAKE_CURRENT_FUNCTION_LIST_FILE}\")\n    message(\"FirstArg: ${FirstArg}\")\n    set(FirstArg \"new value\")\n    message(\"FirstArg again: ${FirstArg}\")\n    message(\"ARGV0: ${ARGV0} ARGV1: ${ARGV1} ARGC: ${ARGC}\")\nendfunction()\nset(FirstArg \"first value\")\nMyFunction(\"Value1\" \"Value2\")\nmessage(\"FirstArg in global scope: ${FirstArg}\")\n```\n\n# 命令\n## cmake_minimum-required\n- 格式：`cmake_minimum_required(VERSION <x.xx>)`\n- 意义：设置cmake期望的版本\n## project\n- 格式一：`project(<PROJECT-NAME> [<language-name>...])`\n- 格式二：\n```cmake\nproject(<PROJECT-NAME>\n    [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]\n    [DESCRIPTION <project-description-string>]\n    [HOMEPAGE_URL <url-string>]\n    [LANGUAGES <language-name>...])\n```\n此命令将设置以下变量:\n- `PROJECT_NAME`\n- `CMAKE_PROJECT_NAME (only in the top-level CMakeLists.txt)`\n- `PROJECT_IS_TOP_LEVEL, <PROJECT-NAME>_IS_TOP_LEVEL`\n- `PROJECT_SOURCE_DIR, <PROJECT-NAME>_SOURCE_DIR`\n- `PROJECT_BINARY_DIR, <PROJECT-NAME>_BINARY_DIR`\n支持语言(仅列常用的)\n- C:C\n- CXX: C++\n指定VERSION关键字，将会设置以下变量:\n- `PROJECT_VERSION, <PROJECT-NAME>_VERSION`\n- `CMAKE_PROJECT_VERSION (only in the top-level CMakeLists.txt)`\n- `PROJECT_VERSION_MAJOR, <PROJECT-NAME>_VERSION_MAJOR`\n- `PROJECT_VERSION_MINOR, <PROJECT-NAME>_VERSION_MINOR`\n- `PROJECT_VERSION_PATCH, <PROJECT-NAME>_VERSION_PATCH`\n- `PROJECT_VERSION_TWEAK, <PROJECT-NAME>_VERSION_TWEAK`\n类似设置DESCRIPTION和HOMEPAGE_URL将设置以下变量\n- `PROJECT_DESCRIPTION, <PROJECT-NAME>_DESCRIPTION`\n- `PROJECT_HOMEPAGE_URL, <PROJECT-NAME>_HOMEPAGE_URL`\n## add_subdirectory\n- 格式：`add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])`\n- 意义：`将计算source_dir 路径（相对于当前目录）并解析其中的CMakeLists.txt 文件`\n- **[binary_dir]**: 构建的文件将写入该路径，默认是构建树\n- **[EXCLUDE_FROM_ALL]**: 禁用子目录中定义的目标的自动构建\n## add_executable\n- 格式：`add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1 source2...])`\n- [WIN32],[MACOSX_BUNDLE]分别生成win和mac下的gui程序\n- [EXCLUDE_FROM_ALL]将使得该目标在默认构建中排除在外，必须-t明确指明\n## add_library\n- 格式：`add_library(<name> [STATIC|SHARED|MODULE] [EXCLUDE_FROM_ALL] [source1 source2...])`\n- [STATIC|SHARED|MODULE],分别对应静态，动态，模块\n## add_custom_target\n- 格式：`add_custom_target(Name [ALL] [COMMAND command2 [args2...] ...])`\n[ALL]与[EXCLUDE_FROM_ALL]含义相反，自定义目标默认不生成,自定义目标通常用于以下场景：\n- 计算其他二进制文件的校验和\n- 运行代码消毒器并收集结果\n- 将编译报告发送到指标通道\n```cmake\ncmake_minimum_required(VERSION 3.26)\nproject(BankApp CXX)\nadd_executable(terminal_app terminal_app.cpp)\nadd_executable(gui_app gui_app.cpp)\ntarget_link_libraries(terminal_app calculations)\ntarget_link_libraries(gui_app calculations drawing)\nadd_library(calculations calculations.cpp)\nadd_library(drawing drawing.cpp)\nadd_custom_target(checksum ALL\n    COMMAND sh -c \"cksum terminal_app>terminal.ck\"\n    COMMAND sh -c \"cksum gui_app>gui.ck\"\n    BYPRODUCTS terminal.ck gui.ck\n    COMMENT \"Checking the sums...\"\n)\n```\n## find_package\n- `find_package(<Name> [version] [EXACT] [QUIET] [REQUIRED])`\n[version]可以指定一个范围，如`1.22...1.40.1`,EXACT指定确切版本，而不是更新,QUIET抑制包被找到的信息\n当找到库后，cmake将会自动设置以下变量：\n- `<PKG_NAME>_FOUND`: 这表明是否成功找到了包。\n- `<PKG_NAME>_INCLUDE_DIRS 或 <PKG_NAME>_INCLUDES`: 这指向包的头文件所在的目\n录。\n- `<PKG_NAME>_LIBRARIES 或 <PKG_NAME>_LIBS`: 这些是要链接的库的列表。\n可以设置扫描路径`CMAKE_MODULE_PATH`，而不是系统默认的\n## message\n- `message(<MODE> ”text to print”)`\nMODE可选以下：\n- FATAL_ERROR: 停止处理和生成。\n- SEND_ERROR: 继续处理，但跳过生成。\n- WARNING: 继续处理。\n- AUTHOR_WARNING: 输出警告，但继续处理。\n- DEPRECATION: 如 果 启 用 了 CMAKE_ERROR_DEPRECATED 或 CMAKE_WARN_DEPRECATED，则输出相应地信息。\n- NOTICE 或省略模式（默认）: 输出消息到 stderr，以吸引使用者的注意。\n- STATUS: 继续处理，推荐用于向用户显示的主要消息。\n- VERBOSE: 继续处理，应用于更详细的信息，通常不是非常必要。\n- DEBUG: 继续处理，应包含项目出现问题时，对处理问题有帮助的详细信息。\n- TRACE: 继续处理，建议在项目开发期间输出消息。通常，这类消息会在发布项目之前移除。\n## file\n- file(READ <filename> <out-var> [...])\n- file({WRITE | APPEND} <filename> <content>...)\n- file(DOWNLOAD <url> [<file>] [...])\n## execute_process()\n- `execute_process(COMMAND <cmd1> [<arguments>]... [OPTIONS])`\n可选地 TIMEOUT 参数，用来在进程未在所需限制内完成任务时终止该进程，并且可以根据\n需要设置 WORKING_DIRECTORY 。\n所有任务的退出代码可以通过提供 RESULTS_VARIABLE 参数来收集到一个列表中。如果只\n对最后执行的命令的结果感兴趣，请使用单数形式：RESULT_VARIABLE 。\n为了收集输出，CMake 提供了两个参数：OUTPUT_VARIABLE 和 ERROR_VARIABLE（用法\n类似）。如果想合并 stdout 和 stderr，请为这两个参数使用相同的变量。\n## 伪目标\n### 别名目标\n别名目标的确切作用就是你所期望的——为目标创建另一个不同的名称引用\n- `add_executable(<name> ALIAS <target>)`\n- `add_library(<name> ALIAS <target>)`\n### 接口库\n- `add_library(<name> INTERFACE [item1 ...])`\n有两个作用：一是**代表仅包含头文件的库**,二是**将一堆传播属性打包成一个逻辑单元**\n例子一：\n```cmake\nadd_library(Eigen INTERFACE\n  src/eigen.h src/vector.h src/matrix.h\n)\ntarget_include_directories(Eigen INTERFACE\n  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>\n  $<INSTALL_INTERFACE:include/Eigen>\n)\ntarget_link_libraries(executable Eigen)\n```\n例子二：\n```cmake\nadd_library(warning_properties INTERFACE)\ntarget_compile_options(warning_properties INTERFACE\n    -Wall -Wextra -Wpedantic\n)\n5 target_link_libraries(executable warning_properties)\n```\n## 对象库\n即.o对象文件\n- `add_library(<target> OBJECT <sources>)`\n可以使用target_link_libraries()作为依赖添加，抑或是如下：\n```cmake\nadd_library(... $<TARGET_OBJECTS:objname> ...)\nadd_executable(... $<TARGET_OBJECTS:objname> ...)\n```\n## target_include_directories\n```cmake\ntarget_include_directories(<target> [SYSTEM] [AFTER|BEFORE]\n<INTERFACE|PUBLIC|PRIVATE> [item1...]\n[<INTERFACE|PUBLIC|PRIVATE> [item2...]\n...])\n```\nSYSTEM 关键字告诉编译器给定的目录应该视为标准系统目录（与尖括号形式一起使用）。\nBEFORE或AFTER决定是否将这些头文件放在已有的路径之前或之后\n## target_compile_definitions\n- `target_compile_definitions(<target> [PRIVATE|PUBLIC|INTERFACE] [var1 \"var2=value\" ...])`\n定义宏变量,相当于-D传递,也可以传递-D选项\n```cmake\ntarget_compile_definitions(defined PRIVATE ABC \"DEF=${VAR}\")\ntarget_compile_definitions(hello PRIVATE -DFOO)\ntarget_compile_definitions(hello PRIVATE -D FOO)\n```\n## target_compile_options\n- 传递编译器参数\n- `target_compile_options(<target> [BEFORE] <INTERFACE|PUBLIC|PRIVATE> [items1...] <INTERFACE|PUBLIC|PRIVATE> [items2...]`\n## target_precompile_headers\n- 预编译头文件\n- `target_precompile_headers(<target> <INTERFACE|PUBLIC|PRIVATE> [header1...] [<INTERFACE|PUBLIC|PRIVATE> [header2...] ...])`\n添加的头文件列表存储在PRECOMPILE_HEADERS属性中,不应该对使用install命令导出的目标执行此操作\n# 目标的属性\n- 获取属性值:`get_target_property(<var> <target> <property-name>)`\n- 设置属性:`set_target_properties(<target1> <target2> ...  PROPERTIES <prop1-name> <value1> <prop2-name> <value2> ...)`或 `set_property(Target <target> PROPERTY <prop-name> <value>)`\n## 属性传播\n- PRIVATE:设置源目标属性\n- INTERFACE:设置使用目标的目标属性\n- PUBLIC：设置源目标和使用目标属性\n当指定 PRIVATE 或 PUBLIC 关键字时，CMake 将在目 标的属性中存储提供的值，COMPILE_DEFINITIONS。此外，关键字是 INTERFACE 或 PUBLIC， 将在具有 INTERFACE_前缀的属性中存储值——INTERFACE_COMPILE_DEFINITIONS。配置阶 段，CMake 将读取源目标的接口属性，并将其内容附加到目标目标。就这样传播属性，或 CMake 所说的传递目标的使用要求。\n设置属性时需要指定上述关键字，如`target_compile_definitions(<source> <INTERFACE|PUBLIC|PRIVATE> [items1...])`, `target_link_libraries(<target> <PRIVATE|PUBLIC|INTERFACE> <item1> [<PRIVATE|PUBLIC|INTERFACE> <item>...])`这个命令也需要传播关键字\n## 自定义属性的传播\nCMake 默认不会传播自定义属性（这个机制只适用 于内置目标属性），必须明确地将自定义属性添加到“兼容”属性列表中。\n每个目标都有四个这样的列表：\n- COMPATIBLE_INTEERFACE_BOOL\n- COMPATIBLE_INTERFACE_STRING\n- COMPATIBLE_INTERFACE_NUMBER_MAX\n- COMPATIBLE_INTERFACE_NUMBER_MIN\n将属性添加到它们中的任何一个，都会触发传播和兼容性检查。BOOL 列表将检查所有传递到 目标目标的属性是否评估为相同的布尔值。类似地，STRING 将评估为字符串。NUMBER_MAX 和 NUMBER_MIN 略有不同——传递的值不必匹配，但目标目标将只接收最高或最低值。\n### 例子\n```cmake\ncmake_minimum_required(VERSION 3.26)\n project(PropagatedProperties CXX)\n\nadd_library(source1 empty.cpp)\nset_property(TARGET source1 PROPERTY INTERFACE_LIB_VERSION 4)\nset_property(TARGET source1 APPEND PROPERTY\n    COMPATIBLE_INTERFACE_STRING LIB_VERSION)\n\nadd_library(source2 empty.cpp)\nset_property(TARGET source2 PROPERTY INTERFACE_LIB_VERSION 4)\nadd_library(destination empty.cpp)\ntarget_link_libraries(destination source1 source2)\n```\nCMake 将这个自定义属性传播到相应目标，并检查所有源目标的版本是否完全匹配（兼容性属性只需在目标目标上设置一次）。\n\n# 参考连接\n[19 reasons why cmake is actually awesome](https://kubasejdak.com/19-reasons-why-cmake-is-actually-awesome)\n[an introduction to modern cmake](https://cliutils.gitlab.io/modern-cmake/)\n[effective modern cmake](https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1)\n[awesome cmake](https://github.com/onqtam/awesome-cmake)\n[useful variables](https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/Useful-Variables)\n# CTest\ntesting tool(integrated in CMake)\n","slug":"cmake","published":1,"updated":"2024-10-18T13:07:47.787Z","_id":"clwnyxnde0004qzq2axcu7dia","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h1><ul>\n<li><code>cmake -S . -B build</code>:构建build树</li>\n<li><code>cmake --build</code>:build二进制</li>\n<li><code>cmake --fresh -S &lt;source tree&gt; -B &lt;build tree&gt;</code>:确保重头开始cmake</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">长选项</th>\n<th align=\"center\">短选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>--source &lt;dir&gt;</code></td>\n<td align=\"center\"><code>-S &lt;dir&gt;</code></td>\n<td align=\"center\">指定源码路径</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-B &lt;dir&gt;</code></td>\n<td align=\"center\">build树路径，若不存在创建目录</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-build &lt;dir&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">build二进制路径</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--parallel &lt;number-of-jobs&gt;</code></td>\n<td align=\"center\"><code>-j &lt;number-of-jobs&gt;</code></td>\n<td align=\"center\">多核运行</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-G &lt;generator name&gt;</code></td>\n<td align=\"center\">指定生成器，可以–help查看系统上支持的生成器</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-C &lt;initial cache script&gt;</code></td>\n<td align=\"center\">预填充缓存信息</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-D &lt;var&gt;[:&lt;type&gt;]=&lt;value&gt;</code></td>\n<td align=\"center\">指定变量值,type可选以下值：BOOL，FILEPATH，PATH，STRING 或 INTERNAL</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-L</code></td>\n<td align=\"center\">列出缓存变量，-D指定的不会打印, -LH则还会打印变量提供的帮助信息</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-U &lt;globbing_expr&gt;</code></td>\n<td align=\"center\">删除一个变量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--system-information [file]</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">获取关于变量、命令、宏和其他设置的通用信息,可保存在file中</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--log-level=&lt;level&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">可以是ERROR，WARNING，NOTICE，STATUS，VERBOSE，DEBUG，TRACE，输出打印级别</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--trace</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">它会打印每个执行的命令及其文件名、调用它的行号，以及传递的参数列表</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--list-presets</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">列出所有可用的预设</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--fresh</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">清理目录，等价于手动删除</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--target &lt;target&gt;</code></td>\n<td align=\"center\"><code>-t &lt;target&gt;</code></td>\n<td align=\"center\">指定生成的目标（这些目标通常排除在正常构建外）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--clean-first</code></td>\n<td align=\"center\"><code>-t clean</code></td>\n<td align=\"center\">只影响目标产物而不影响其他，如缓存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--config &lt;cfg&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">指定构建类型，只有visual studio等多配置生成器可用，也可以用<code>CMAKE_BUILD_TYPE</code>指定</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--install &lt;build tree&gt; --install-prefix &lt;prefix&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">指定安装路径，prefix是前缀路径</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--verbose</code></td>\n<td align=\"center\"><code>-v</code></td>\n<td align=\"center\">输出细节</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-E &lt;command&gt; [options]</code></td>\n<td align=\"center\">以平台无关的方式运行单个命令——例如复制文件或计算校验和</td>\n</tr>\n</tbody></table>\n<h1 id=\"内置变量\"><a href=\"#内置变量\" class=\"headerlink\" title=\"内置变量\"></a>内置变量</h1><p>|变量名|类型|含义|<br>|:-:|:-:|<br>|<code>CMAKE_GENERATOR_TOOLSET</code>||<br>|<code>CMAKE_GENERATOR_PLATFORM</code>||<br>|<code>CMAKE_BUILD_TYPE</code>|可选值Debug,Release,MinSizeRel,RelWithDebInfo|</p>\n<h2 id=\"主机系统变量\"><a href=\"#主机系统变量\" class=\"headerlink\" title=\"主机系统变量\"></a>主机系统变量</h2><table>\n<thead>\n<tr>\n<th align=\"center\">变量名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>CMAKE_SIZEOF_VOID_P</code></td>\n<td align=\"center\">Int</td>\n<td align=\"center\">8代表64位，4代表32位</td>\n</tr>\n<tr>\n<td align=\"center\"><code>CMAKE_&lt;LANG&gt;_BYTE_ORDER</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">Lang可选C，CXX等,存放字节序,值有可能是<code>LITTLE_ENDIAN</code>和<code>BIG_ENDIAN</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>CMAKE_SYSTEM_NAME</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">存放操作系统类型：<code>Linux,Darwin,Windows,AIX</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>ANDROID,APPLE,CYGWIN,UNIX,IOS,WIN32,WINCE,WINDOWS_PHONE</code></td>\n<td align=\"center\">Bool</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"><code>HOSTNAME</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">主机名</td>\n</tr>\n<tr>\n<td align=\"center\"><code>FQDN</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">完全限定域名</td>\n</tr>\n<tr>\n<td align=\"center\"><code>TOTAL_VIRTUAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的虚拟内存总量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>AVAILABLE_VIRTUAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的可用虚拟内存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>TOTAL_PHYSICAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的总物理内存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>AVAILABLE_PHYSICAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的可用物理内存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_NAME</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">如果存在，则输出 uname -s; 无论是 Windows、Linux，还是 Darwin</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_RELEASE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">操作系统子类型，如 Windows Professional</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_VERSION</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">操作系统构建 ID</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_PLATFORM</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">在 Windows 上和 $ENV{PROCESSOR_ARCHITECTURE} 的值一样. 在 Unix&#x2F;macOS 上和 uname -m 一样</td>\n</tr>\n<tr>\n<td align=\"center\"><code>NUMBER_OF_LOGICAL_CORES</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">逻辑核数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>NUMBER_OF_PHYSICAL_CORES</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">物理核数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SERIAL_NUMBER</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器有序列号，则为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>PROCESSOR_SERIAL_NUMBER</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">处理器序列号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>PROCESSOR_NAME</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">可读的处理器名称</td>\n</tr>\n<tr>\n<td align=\"center\"><code>PROCESSOR_DESCRIPTION</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">可读的完整处理器描述</td>\n</tr>\n<tr>\n<td align=\"center\"><code>IS_64BIT</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器是 64 位的为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_FPU</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器有浮点单元为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_MMX</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 MMX 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_MMX_PLUS</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 Ext. MMX 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE2</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE2 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE_FP</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE FP 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE_MMX</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE MMX 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_AMD_3DNOW</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 3DNow 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_AMD_3DNOW_PLUS</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 3DNow+ 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_IA64</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果 IA64 处理器模拟 x86，则为 1</td>\n</tr>\n</tbody></table>\n<h1 id=\"常见操作\"><a href=\"#常见操作\" class=\"headerlink\" title=\"常见操作\"></a>常见操作</h1><h2 id=\"C-标准\"><a href=\"#C-标准\" class=\"headerlink\" title=\"C++标准\"></a>C++标准</h2><ul>\n<li><code>set(CMAKE_CXX_STANDARD &lt;version&gt;)</code></li>\n<li><code>set_property(Target &lt;target&gt; PROPERTY CXX_STANDARD &lt;version&gt;)</code></li>\n<li><code>set_target_properties(&lt;targets&gt; PROPERTIES CXX_STANDARD &lt;version&gt;)</code></li>\n<li><code>target_compile_features(&lt;target&gt; PUBLIC cxx_std_26)</code><br>version可选值有：98,11,14,17,20,23,26<br>使用target_compile_features可选值有cxx_std_14…<br>强制应用标准：<code>set(CMAKE_CXX_STANDARD_REQUIRED ON)</code></li>\n</ul>\n<h2 id=\"检查支持的编译特性\"><a href=\"#检查支持的编译特性\" class=\"headerlink\" title=\"检查支持的编译特性\"></a>检查支持的编译特性</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">list</span>(FIND CMAKE_CXX_COMPILE_FEATURES cxx_variable_templates result)<br><span class=\"hljs-keyword\">if</span>(result <span class=\"hljs-keyword\">EQUAL</span> -<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">message</span>(FATAL_ERROR <span class=\"hljs-string\">&quot;Variable templates are required for compilation.&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\n<p>可以在<a href=\"https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html\">c++支持特性列表里找到特性的完整列表</a></p>\n<h2 id=\"过程间优化-ipo\"><a href=\"#过程间优化-ipo\" class=\"headerlink\" title=\"过程间优化(ipo)\"></a>过程间优化(ipo)</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">include</span>(CheckIPOSupported)<br>check_ipo_supported(RESULT ipo_supported)<br><span class=\"hljs-keyword\">set</span>(CMAKE_INTERPROCEDURAL_OPTIMIZATION <span class=\"hljs-variable\">$&#123;ipo_supported&#125;</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"禁用源内构建\"><a href=\"#禁用源内构建\" class=\"headerlink\" title=\"禁用源内构建\"></a>禁用源内构建</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.26</span>.<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">project</span>(NoInSource CXX)<br><span class=\"hljs-keyword\">if</span>(PROJECT_SOURCE_DIR <span class=\"hljs-keyword\">STREQUAL</span> PROJECT_BINARY_DIR)<br>    <span class=\"hljs-keyword\">message</span>(FATAL_ERROR <span class=\"hljs-string\">&quot;In-source builds are not allowed&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Build successful!&quot;</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"生成目标依赖图\"><a href=\"#生成目标依赖图\" class=\"headerlink\" title=\"生成目标依赖图\"></a>生成目标依赖图</h2><ul>\n<li>使用命令<code>cmake --graphviz=test.dot .</code></li>\n<li>更多信息见官网<strong>CMakeGraphVizOptions</strong>模块,</li>\n<li>默认自定义目标不会出现在图中，可以创建一个<strong>CMakeGraphVizOptions.cmake</strong>文件，里面设置<code>set(GRAPHVIZ_CUSTOM_TARGETS TRUE)</code></li>\n<li>生成的dot文件可以在线查看<a href=\"https://dreampuf.github.io/GraphvizOnline/\">Graphviz</a></li>\n</ul>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li>单行注释：行首添加<code>#</code></li>\n<li>多行注释：以#开始，后跟方括号，任意数量等号&#x3D;可以是0个，以及另一个方括号,并以相同数量等号及方括号关闭<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"> <span class=\"hljs-comment\">#[=[</span><br><span class=\"hljs-number\">2</span> bracket comment<br>    <span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">#[[</span><br><span class=\"hljs-comment\">        4 nested bracket comment</span><br><span class=\"hljs-comment\">    5 #]]</span><br><span class=\"hljs-number\">6</span> <span class=\"hljs-comment\">#]=]</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"括号参数\"><a href=\"#括号参数\" class=\"headerlink\" title=\"括号参数\"></a>括号参数</h3><p>括号参数与多行注释格式类似，但它不能嵌套</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>([[multiline<br>    bracket<br>    argument<br>]])<br><span class=\"hljs-keyword\">message</span>([==[<br>    because we used two <span class=\"hljs-keyword\">equal</span>-signs <span class=\"hljs-string\">&quot;==&quot;</span><br>    this <span class=\"hljs-keyword\">command</span> receives only a single argument<br>    even <span class=\"hljs-keyword\">if</span> it includes two square brackets in a row<br>    &#123; <span class=\"hljs-string\">&quot;petsArray&quot;</span> = [[<span class=\"hljs-string\">&quot;mouse&quot;</span>,<span class=\"hljs-string\">&quot;cat&quot;</span>],[<span class=\"hljs-string\">&quot;dog&quot;</span>]] &#125;<br>]==])<br></code></pre></td></tr></table></figure>\n<h3 id=\"引号参数\"><a href=\"#引号参数\" class=\"headerlink\" title=\"引号参数\"></a>引号参数</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;1. escape sequence: \\&quot; \\n in a quoted argument&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;2. multi...</span><br><span class=\"hljs-string\">line&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;3. and a variable reference: $&#123;CMAKE_VERSION&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"非引号参数\"><a href=\"#非引号参数\" class=\"headerlink\" title=\"非引号参数\"></a>非引号参数</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(a\\ single\\ argument)<br><span class=\"hljs-keyword\">message</span>(two arguments)<br><span class=\"hljs-keyword\">message</span>(three;separated arguments)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;CMAKE_VERSION&#125;</span>) <span class=\"hljs-comment\"># a variable reference</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><ul>\n<li>设置与读取：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MyString1 <span class=\"hljs-string\">&quot;Text1&quot;</span>)<br><span class=\"hljs-keyword\">set</span>([[My String2]] <span class=\"hljs-string\">&quot;Text2&quot;</span>)<br><span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&quot;My String 3&quot;</span> <span class=\"hljs-string\">&quot;Text3&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;MyString1&#125;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;My\\ String2&#125;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;My\\ String\\ 3&#125;</span>)<br></code></pre></td></tr></table></figure></li>\n<li>取消：<code>unset(MyString1)</code></li>\n<li>环境变量：<code>$ENV&#123;&#125;</code></li>\n<li>缓存变量：<code>$CACHE&#123;&#125;</code></li>\n</ul>\n<h3 id=\"缓存变量\"><a href=\"#缓存变量\" class=\"headerlink\" title=\"缓存变量\"></a>缓存变量</h3><ul>\n<li>格式：<code>set(&lt;variable&gt; &lt;value&gt; CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</code></li>\n<li>BOOL: 一个布尔开关值。GUI 将显示一个复选框。</li>\n<li>FILEPATH: 磁盘上一个文件的路径。GUI 将打开一个文件对话框。</li>\n<li>PATH: 磁盘上一个目录的路径。GUI 将打开一个目录对话框。</li>\n<li>STRING: 一 行 文 本。GUI 提 供 了 一 个 要 填 充 的 文 本 字 段， 可 以 通 过 调 用<br>set_property(CACHE <variable> STRINGS <values>) 来替换为下拉控件。</li>\n<li>INTERNAL: 一行文本。GUI 将跳过内部条目。内部条目可以用来在运行之间持久存储变量，<br>使用此类型隐式添加 FORCE 关键字。<br><code>&lt;doctring&gt;</code> 值只是一个标签，GUI 将在字段旁边显示它，以便向用户提供此设置的更多细<br>节。如果缓存文件中不存在该变量或指定了可选的 FORCE 参数，该值将持久化</li>\n</ul>\n<h2 id=\"使用列表\"><a href=\"#使用列表\" class=\"headerlink\" title=\"使用列表\"></a>使用列表</h2><ul>\n<li><code>set(myList a list of five elements)</code></li>\n<li><code>set(myList &quot;a;list;of;five;elements&quot;)</code></li>\n<li><code>set(myList a list &quot;of;five;elements&quot;)</code></li>\n</ul>\n<h3 id=\"list命令工具\"><a href=\"#list命令工具\" class=\"headerlink\" title=\"list命令工具\"></a>list命令工具</h3><ul>\n<li>list(LENGTH <list> <out-var>)</li>\n<li>list(GET <list> <element index> [<index> …] <out-var>)</li>\n<li>list(JOIN <list> <glue> <out-var>)</li>\n<li>list(SUBLIST <list> <begin> <length> <out-var>)</li>\n<li>list(FIND <list> <value> <out-var>)</li>\n<li>list(APPEND <list> [<element>…])</li>\n<li>list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)</li>\n<li>list(INSERT <list> <index> [<element>…])</li>\n<li>list(POP_BACK <list> [<out-var>…])</li>\n<li>list(POP_FRONT <list> [<out-var>…])</li>\n<li>list(PREPEND <list> [<element>…])</li>\n<li>list(REMOVE_ITEM <list> <value>…)</li>\n<li>list(REMOVE_AT <list> <index>…)</li>\n<li>list(REMOVE_DUPLICATES <list>)</li>\n<li>list(TRANSFORM <list> <ACTION> […])</li>\n<li>list(REVERSE <list>)</li>\n<li>list(SORT <list> […])</li>\n</ul>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(&lt;condition&gt;)<br>&lt;commands&gt;<br><span class=\"hljs-keyword\">elseif</span>(&lt;condition&gt;) <span class=\"hljs-comment\"># optional block, can be repeated</span><br>&lt;commands&gt;<br><span class=\"hljs-keyword\">else</span>() <span class=\"hljs-comment\"># optional block</span><br>&lt;commands&gt;<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\n<h3 id=\"条件格式\"><a href=\"#条件格式\" class=\"headerlink\" title=\"条件格式\"></a>条件格式</h3><ul>\n<li><code>&lt;condition&gt; AND &lt;condition&gt;</code></li>\n<li><code>&lt;condition&gt; OR &lt;condition&gt;</code></li>\n<li><code>NOT &lt;condition&gt;</code></li>\n<li><code>DEFINED &lt;variable&gt;</code></li>\n<li><code>DEFINED CACHE&lt;variable&gt;</code></li>\n<li><code>DEFINED ENV&lt;variable&gt;</code></li>\n<li><code>if(FOO)</code>:在以下情况才为假:<ul>\n<li>OFF, NO, FALSE, N, IGNORE 或 NOTFOUND</li>\n<li>以-NOTFOUND 结尾的字符串</li>\n<li>空字符串</li>\n<li>零</li>\n</ul>\n</li>\n<li><code>if($(QUX))</code>字符串只有在等于 ON、Y、YES、TRUE 或非零数字，才可视为真（这些比较不区分大小写）。</li>\n<li><code>1 LESS/LESS_EQUAL/GREATER/GREATER_EQUAL/EQUAL 2</code></li>\n<li><code>1.3.4 VERSION_LESS_EQUAL 1.4</code></li>\n<li><code>&quot;str1&quot; STREQUAL &quot;$&#123;B&#125;&quot;</code></li>\n<li><code>&lt;VARIABLE|STRING&gt; MATCHES &lt;regex&gt;</code></li>\n<li><code>&lt;VARIABLE|STRING&gt; IN_LIST &lt;VARIABLE&gt;</code></li>\n<li><code>COMMAND &lt;command-name&gt;</code>是否可以调用某个cmake命令</li>\n<li><code>POLICY &lt;policy-id&gt;</code>是否存在cmake策略</li>\n<li><code>TEST &lt;test-name&gt;</code>是否add_test()添加了CTest测试</li>\n<li><code>TARGET &lt;target-name&gt;</code>是否定义了一个构建目标</li>\n<li><code>EXISTS &lt;path-to-file-or-directory&gt;</code></li>\n<li><code>&lt;file1&gt; IS_NEWER_THAN &lt;file2&gt;:</code></li>\n<li><code>IS_DIRECTORY &lt;path-to-directory&gt;</code></li>\n<li><code>IS_SYMLINK &lt;file-name&gt;</code></li>\n<li><code>IS_ABSOLUTE &lt;path&gt;</code></li>\n</ul>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>循环体支持<code>break()和continue()</code></p>\n<h3 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">while</span>(&lt;condition&gt;)<br>&lt;commands&gt;<br><span class=\"hljs-keyword\">endwhile</span>()<br></code></pre></td></tr></table></figure>\n<h3 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">foreach</span>(&lt;loop_var&gt; RANGE &lt;max&gt;)<span class=\"hljs-comment\">#CMake 将从 0 迭代到 &lt;max&gt;（包括）。</span><br>    &lt;commands&gt;<br><span class=\"hljs-keyword\">endforeach</span>()<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>foreach(&lt;loop_var&gt; RANGE &lt;min&gt; &lt;max&gt; [&lt;step&gt;])</code></li>\n<li><code>foreach(&lt;loop_variable&gt; IN [LISTS &lt;lists&gt;] [ITEMS &lt;items&gt;])</code></li>\n<li><code>foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</code></li>\n</ul>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MyList <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>)<br><span class=\"hljs-keyword\">foreach</span>(VAR IN LISTS MyList ITEMS e f)<span class=\"hljs-comment\">#等价于foreach(VAR 1 2 3 e f)</span><br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;VAR&#125;</span>)<br><span class=\"hljs-keyword\">endforeach</span>()<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(L1 <span class=\"hljs-string\">&quot;one;two;three;four&quot;</span>)<br><span class=\"hljs-keyword\">set</span>(L2 <span class=\"hljs-string\">&quot;1;2;3;4;5&quot;</span>)<br><span class=\"hljs-keyword\">foreach</span>(num IN ZIP_LISTS L1 L2)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;word=$&#123;num_0&#125;, num=$&#123;num_1&#125;&quot;</span>)<br><span class=\"hljs-keyword\">endforeach</span>()<br><span class=\"hljs-comment\"># 等价于下面</span><br><span class=\"hljs-comment\"># foreach(word num IN ZIP_LISTS L1 L2)</span><br><span class=\"hljs-comment\">#    message(&quot;word=$&#123;word&#125;, num=$&#123;num&#125;&quot;)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"function\"></a>function</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">function</span>(&lt;name&gt; [&lt;argument&gt;...])<br>&lt;commands&gt;<br><span class=\"hljs-keyword\">endfunction</span>()<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">function</span>(MyFunction FirstArg)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Function: $&#123;CMAKE_CURRENT_FUNCTION&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;File: $&#123;CMAKE_CURRENT_FUNCTION_LIST_FILE&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;FirstArg: $&#123;FirstArg&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">set</span>(FirstArg <span class=\"hljs-string\">&quot;new value&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;FirstArg again: $&#123;FirstArg&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;ARGV0: $&#123;ARGV0&#125; ARGV1: $&#123;ARGV1&#125; ARGC: $&#123;ARGC&#125;&quot;</span>)<br><span class=\"hljs-keyword\">endfunction</span>()<br><span class=\"hljs-keyword\">set</span>(FirstArg <span class=\"hljs-string\">&quot;first value&quot;</span>)<br>MyFunction(<span class=\"hljs-string\">&quot;Value1&quot;</span> <span class=\"hljs-string\">&quot;Value2&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;FirstArg in global scope: $&#123;FirstArg&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h1><h2 id=\"cmake-minimum-required\"><a href=\"#cmake-minimum-required\" class=\"headerlink\" title=\"cmake_minimum-required\"></a>cmake_minimum-required</h2><ul>\n<li>格式：<code>cmake_minimum_required(VERSION &lt;x.xx&gt;)</code></li>\n<li>意义：设置cmake期望的版本</li>\n</ul>\n<h2 id=\"project\"><a href=\"#project\" class=\"headerlink\" title=\"project\"></a>project</h2><ul>\n<li>格式一：<code>project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])</code></li>\n<li>格式二：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">project</span>(&lt;<span class=\"hljs-keyword\">PROJECT</span>-NAME&gt;<br>    [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]<br>    [DESCRIPTION &lt;<span class=\"hljs-keyword\">project</span>-description-<span class=\"hljs-keyword\">string</span>&gt;]<br>    [HOMEPAGE_URL &lt;url-<span class=\"hljs-keyword\">string</span>&gt;]<br>    [LANGUAGES &lt;language-name&gt;...])<br></code></pre></td></tr></table></figure>\n此命令将设置以下变量:</li>\n<li><code>PROJECT_NAME</code></li>\n<li><code>CMAKE_PROJECT_NAME (only in the top-level CMakeLists.txt)</code></li>\n<li><code>PROJECT_IS_TOP_LEVEL, &lt;PROJECT-NAME&gt;_IS_TOP_LEVEL</code></li>\n<li><code>PROJECT_SOURCE_DIR, &lt;PROJECT-NAME&gt;_SOURCE_DIR</code></li>\n<li><code>PROJECT_BINARY_DIR, &lt;PROJECT-NAME&gt;_BINARY_DIR</code><br>支持语言(仅列常用的)</li>\n<li>C:C</li>\n<li>CXX: C++<br>指定VERSION关键字，将会设置以下变量:</li>\n<li><code>PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSION</code></li>\n<li><code>CMAKE_PROJECT_VERSION (only in the top-level CMakeLists.txt)</code></li>\n<li><code>PROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJOR</code></li>\n<li><code>PROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINOR</code></li>\n<li><code>PROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCH</code></li>\n<li><code>PROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK</code><br>类似设置DESCRIPTION和HOMEPAGE_URL将设置以下变量</li>\n<li><code>PROJECT_DESCRIPTION, &lt;PROJECT-NAME&gt;_DESCRIPTION</code></li>\n<li><code>PROJECT_HOMEPAGE_URL, &lt;PROJECT-NAME&gt;_HOMEPAGE_URL</code></li>\n</ul>\n<h2 id=\"add-subdirectory\"><a href=\"#add-subdirectory\" class=\"headerlink\" title=\"add_subdirectory\"></a>add_subdirectory</h2><ul>\n<li>格式：<code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></li>\n<li>意义：<code>将计算source_dir 路径（相对于当前目录）并解析其中的CMakeLists.txt 文件</code></li>\n<li><strong>[binary_dir]</strong>: 构建的文件将写入该路径，默认是构建树</li>\n<li><strong>[EXCLUDE_FROM_ALL]</strong>: 禁用子目录中定义的目标的自动构建</li>\n</ul>\n<h2 id=\"add-executable\"><a href=\"#add-executable\" class=\"headerlink\" title=\"add_executable\"></a>add_executable</h2><ul>\n<li>格式：<code>add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1 source2...])</code></li>\n<li>[WIN32],[MACOSX_BUNDLE]分别生成win和mac下的gui程序</li>\n<li>[EXCLUDE_FROM_ALL]将使得该目标在默认构建中排除在外，必须-t明确指明</li>\n</ul>\n<h2 id=\"add-library\"><a href=\"#add-library\" class=\"headerlink\" title=\"add_library\"></a>add_library</h2><ul>\n<li>格式：<code>add_library(&lt;name&gt; [STATIC|SHARED|MODULE] [EXCLUDE_FROM_ALL] [source1 source2...])</code></li>\n<li>[STATIC|SHARED|MODULE],分别对应静态，动态，模块</li>\n</ul>\n<h2 id=\"add-custom-target\"><a href=\"#add-custom-target\" class=\"headerlink\" title=\"add_custom_target\"></a>add_custom_target</h2><ul>\n<li>格式：<code>add_custom_target(Name [ALL] [COMMAND command2 [args2...] ...])</code><br>[ALL]与[EXCLUDE_FROM_ALL]含义相反，自定义目标默认不生成,自定义目标通常用于以下场景：</li>\n<li>计算其他二进制文件的校验和</li>\n<li>运行代码消毒器并收集结果</li>\n<li>将编译报告发送到指标通道<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.26</span>)<br><span class=\"hljs-keyword\">project</span>(BankApp CXX)<br><span class=\"hljs-keyword\">add_executable</span>(terminal_app terminal_app.cpp)<br><span class=\"hljs-keyword\">add_executable</span>(gui_app gui_app.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(terminal_app calculations)<br><span class=\"hljs-keyword\">target_link_libraries</span>(gui_app calculations drawing)<br><span class=\"hljs-keyword\">add_library</span>(calculations calculations.cpp)<br><span class=\"hljs-keyword\">add_library</span>(drawing drawing.cpp)<br><span class=\"hljs-keyword\">add_custom_target</span>(checksum ALL<br>    <span class=\"hljs-keyword\">COMMAND</span> sh -c <span class=\"hljs-string\">&quot;cksum terminal_app&gt;terminal.ck&quot;</span><br>    <span class=\"hljs-keyword\">COMMAND</span> sh -c <span class=\"hljs-string\">&quot;cksum gui_app&gt;gui.ck&quot;</span><br>    BYPRODUCTS terminal.ck gui.ck<br>    COMMENT <span class=\"hljs-string\">&quot;Checking the sums...&quot;</span><br>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"find-package\"><a href=\"#find-package\" class=\"headerlink\" title=\"find_package\"></a>find_package</h2><ul>\n<li><code>find_package(&lt;Name&gt; [version] [EXACT] [QUIET] [REQUIRED])</code><br>[version]可以指定一个范围，如<code>1.22...1.40.1</code>,EXACT指定确切版本，而不是更新,QUIET抑制包被找到的信息<br>当找到库后，cmake将会自动设置以下变量：</li>\n<li><code>&lt;PKG_NAME&gt;_FOUND</code>: 这表明是否成功找到了包。</li>\n<li><code>&lt;PKG_NAME&gt;_INCLUDE_DIRS 或 &lt;PKG_NAME&gt;_INCLUDES</code>: 这指向包的头文件所在的目<br>录。</li>\n<li><code>&lt;PKG_NAME&gt;_LIBRARIES 或 &lt;PKG_NAME&gt;_LIBS</code>: 这些是要链接的库的列表。<br>可以设置扫描路径<code>CMAKE_MODULE_PATH</code>，而不是系统默认的</li>\n</ul>\n<h2 id=\"message\"><a href=\"#message\" class=\"headerlink\" title=\"message\"></a>message</h2><ul>\n<li><code>message(&lt;MODE&gt; ”text to print”)</code><br>MODE可选以下：</li>\n<li>FATAL_ERROR: 停止处理和生成。</li>\n<li>SEND_ERROR: 继续处理，但跳过生成。</li>\n<li>WARNING: 继续处理。</li>\n<li>AUTHOR_WARNING: 输出警告，但继续处理。</li>\n<li>DEPRECATION: 如 果 启 用 了 CMAKE_ERROR_DEPRECATED 或 CMAKE_WARN_DEPRECATED，则输出相应地信息。</li>\n<li>NOTICE 或省略模式（默认）: 输出消息到 stderr，以吸引使用者的注意。</li>\n<li>STATUS: 继续处理，推荐用于向用户显示的主要消息。</li>\n<li>VERBOSE: 继续处理，应用于更详细的信息，通常不是非常必要。</li>\n<li>DEBUG: 继续处理，应包含项目出现问题时，对处理问题有帮助的详细信息。</li>\n<li>TRACE: 继续处理，建议在项目开发期间输出消息。通常，这类消息会在发布项目之前移除。</li>\n</ul>\n<h2 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file\"></a>file</h2><ul>\n<li>file(READ <filename> <out-var> […])</li>\n<li>file({WRITE | APPEND} <filename> <content>…)</li>\n<li>file(DOWNLOAD <url> [<file>] […])</li>\n</ul>\n<h2 id=\"execute-process\"><a href=\"#execute-process\" class=\"headerlink\" title=\"execute_process()\"></a>execute_process()</h2><ul>\n<li><code>execute_process(COMMAND &lt;cmd1&gt; [&lt;arguments&gt;]... [OPTIONS])</code><br>可选地 TIMEOUT 参数，用来在进程未在所需限制内完成任务时终止该进程，并且可以根据<br>需要设置 WORKING_DIRECTORY 。<br>所有任务的退出代码可以通过提供 RESULTS_VARIABLE 参数来收集到一个列表中。如果只<br>对最后执行的命令的结果感兴趣，请使用单数形式：RESULT_VARIABLE 。<br>为了收集输出，CMake 提供了两个参数：OUTPUT_VARIABLE 和 ERROR_VARIABLE（用法<br>类似）。如果想合并 stdout 和 stderr，请为这两个参数使用相同的变量。</li>\n</ul>\n<h2 id=\"伪目标\"><a href=\"#伪目标\" class=\"headerlink\" title=\"伪目标\"></a>伪目标</h2><h3 id=\"别名目标\"><a href=\"#别名目标\" class=\"headerlink\" title=\"别名目标\"></a>别名目标</h3><p>别名目标的确切作用就是你所期望的——为目标创建另一个不同的名称引用</p>\n<ul>\n<li><code>add_executable(&lt;name&gt; ALIAS &lt;target&gt;)</code></li>\n<li><code>add_library(&lt;name&gt; ALIAS &lt;target&gt;)</code></li>\n</ul>\n<h3 id=\"接口库\"><a href=\"#接口库\" class=\"headerlink\" title=\"接口库\"></a>接口库</h3><ul>\n<li><code>add_library(&lt;name&gt; INTERFACE [item1 ...])</code><br>有两个作用：一是<strong>代表仅包含头文件的库</strong>,二是<strong>将一堆传播属性打包成一个逻辑单元</strong><br>例子一：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(Eigen INTERFACE<br>  src/eigen.h src/vector.h src/matrix.h<br>)<br><span class=\"hljs-keyword\">target_include_directories</span>(Eigen INTERFACE<br>  $&lt;BUILD_INTERFACE:<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src&gt;<br>  $&lt;INSTALL_INTERFACE:<span class=\"hljs-keyword\">include</span>/Eigen&gt;<br>)<br><span class=\"hljs-keyword\">target_link_libraries</span>(executable Eigen)<br></code></pre></td></tr></table></figure>\n例子二：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(warning_properties INTERFACE)<br><span class=\"hljs-keyword\">target_compile_options</span>(warning_properties INTERFACE<br>    -Wall -Wextra -Wpedantic<br>)<br><span class=\"hljs-number\">5</span> <span class=\"hljs-keyword\">target_link_libraries</span>(executable warning_properties)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"对象库\"><a href=\"#对象库\" class=\"headerlink\" title=\"对象库\"></a>对象库</h2><p>即.o对象文件</p>\n<ul>\n<li><code>add_library(&lt;target&gt; OBJECT &lt;sources&gt;)</code><br>可以使用target_link_libraries()作为依赖添加，抑或是如下：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(... $&lt;TARGET_OBJECTS:objname&gt; ...)<br><span class=\"hljs-keyword\">add_executable</span>(... $&lt;TARGET_OBJECTS:objname&gt; ...)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"target-include-directories\"><a href=\"#target-include-directories\" class=\"headerlink\" title=\"target_include_directories\"></a>target_include_directories</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_include_directories</span>(&lt;<span class=\"hljs-keyword\">target</span>&gt; [SYSTEM] [AFTER|BEFORE]<br>&lt;INTERFACE|PUBLIC|PRIVATE&gt; [item1...]<br>[&lt;INTERFACE|PUBLIC|PRIVATE&gt; [item2...]<br>...])<br></code></pre></td></tr></table></figure>\n<p>SYSTEM 关键字告诉编译器给定的目录应该视为标准系统目录（与尖括号形式一起使用）。<br>BEFORE或AFTER决定是否将这些头文件放在已有的路径之前或之后</p>\n<h2 id=\"target-compile-definitions\"><a href=\"#target-compile-definitions\" class=\"headerlink\" title=\"target_compile_definitions\"></a>target_compile_definitions</h2><ul>\n<li><code>target_compile_definitions(&lt;target&gt; [PRIVATE|PUBLIC|INTERFACE] [var1 &quot;var2=value&quot; ...])</code><br>定义宏变量,相当于-D传递,也可以传递-D选项<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(<span class=\"hljs-keyword\">defined</span> PRIVATE ABC <span class=\"hljs-string\">&quot;DEF=$&#123;VAR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">target_compile_definitions</span>(hello PRIVATE -DFOO)<br><span class=\"hljs-keyword\">target_compile_definitions</span>(hello PRIVATE -D FOO)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"target-compile-options\"><a href=\"#target-compile-options\" class=\"headerlink\" title=\"target_compile_options\"></a>target_compile_options</h2><ul>\n<li>传递编译器参数</li>\n<li><code>target_compile_options(&lt;target&gt; [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...]</code></li>\n</ul>\n<h2 id=\"target-precompile-headers\"><a href=\"#target-precompile-headers\" class=\"headerlink\" title=\"target_precompile_headers\"></a>target_precompile_headers</h2><ul>\n<li>预编译头文件</li>\n<li><code>target_precompile_headers(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [header1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [header2...] ...])</code><br>添加的头文件列表存储在PRECOMPILE_HEADERS属性中,不应该对使用install命令导出的目标执行此操作</li>\n</ul>\n<h1 id=\"目标的属性\"><a href=\"#目标的属性\" class=\"headerlink\" title=\"目标的属性\"></a>目标的属性</h1><ul>\n<li>获取属性值:<code>get_target_property(&lt;var&gt; &lt;target&gt; &lt;property-name&gt;)</code></li>\n<li>设置属性:<code>set_target_properties(&lt;target1&gt; &lt;target2&gt; ...  PROPERTIES &lt;prop1-name&gt; &lt;value1&gt; &lt;prop2-name&gt; &lt;value2&gt; ...)</code>或 <code>set_property(Target &lt;target&gt; PROPERTY &lt;prop-name&gt; &lt;value&gt;)</code></li>\n</ul>\n<h2 id=\"属性传播\"><a href=\"#属性传播\" class=\"headerlink\" title=\"属性传播\"></a>属性传播</h2><ul>\n<li>PRIVATE:设置源目标属性</li>\n<li>INTERFACE:设置使用目标的目标属性</li>\n<li>PUBLIC：设置源目标和使用目标属性<br>当指定 PRIVATE 或 PUBLIC 关键字时，CMake 将在目 标的属性中存储提供的值，COMPILE_DEFINITIONS。此外，关键字是 INTERFACE 或 PUBLIC， 将在具有 INTERFACE_前缀的属性中存储值——INTERFACE_COMPILE_DEFINITIONS。配置阶 段，CMake 将读取源目标的接口属性，并将其内容附加到目标目标。就这样传播属性，或 CMake 所说的传递目标的使用要求。<br>设置属性时需要指定上述关键字，如<code>target_compile_definitions(&lt;source&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...])</code>, <code>target_link_libraries(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item1&gt; [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...])</code>这个命令也需要传播关键字</li>\n</ul>\n<h2 id=\"自定义属性的传播\"><a href=\"#自定义属性的传播\" class=\"headerlink\" title=\"自定义属性的传播\"></a>自定义属性的传播</h2><p>CMake 默认不会传播自定义属性（这个机制只适用 于内置目标属性），必须明确地将自定义属性添加到“兼容”属性列表中。<br>每个目标都有四个这样的列表：</p>\n<ul>\n<li>COMPATIBLE_INTEERFACE_BOOL</li>\n<li>COMPATIBLE_INTERFACE_STRING</li>\n<li>COMPATIBLE_INTERFACE_NUMBER_MAX</li>\n<li>COMPATIBLE_INTERFACE_NUMBER_MIN<br>将属性添加到它们中的任何一个，都会触发传播和兼容性检查。BOOL 列表将检查所有传递到 目标目标的属性是否评估为相同的布尔值。类似地，STRING 将评估为字符串。NUMBER_MAX 和 NUMBER_MIN 略有不同——传递的值不必匹配，但目标目标将只接收最高或最低值。</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.26</span>)<br> <span class=\"hljs-keyword\">project</span>(PropagatedProperties CXX)<br><br><span class=\"hljs-keyword\">add_library</span>(source1 empty.cpp)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> source1 PROPERTY INTERFACE_LIB_VERSION <span class=\"hljs-number\">4</span>)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> source1 APPEND PROPERTY<br>    COMPATIBLE_INTERFACE_STRING LIB_VERSION)<br><br><span class=\"hljs-keyword\">add_library</span>(source2 empty.cpp)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> source2 PROPERTY INTERFACE_LIB_VERSION <span class=\"hljs-number\">4</span>)<br><span class=\"hljs-keyword\">add_library</span>(destination empty.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(destination source1 source2)<br></code></pre></td></tr></table></figure>\n<p>CMake 将这个自定义属性传播到相应目标，并检查所有源目标的版本是否完全匹配（兼容性属性只需在目标目标上设置一次）。</p>\n<h1 id=\"参考连接\"><a href=\"#参考连接\" class=\"headerlink\" title=\"参考连接\"></a>参考连接</h1><p><a href=\"https://kubasejdak.com/19-reasons-why-cmake-is-actually-awesome\">19 reasons why cmake is actually awesome</a><br><a href=\"https://cliutils.gitlab.io/modern-cmake/\">an introduction to modern cmake</a><br><a href=\"https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1\">effective modern cmake</a><br><a href=\"https://github.com/onqtam/awesome-cmake\">awesome cmake</a><br><a href=\"https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/Useful-Variables\">useful variables</a></p>\n<h1 id=\"CTest\"><a href=\"#CTest\" class=\"headerlink\" title=\"CTest\"></a>CTest</h1><p>testing tool(integrated in CMake)</p>\n","excerpt":"","more":"<h1 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h1><ul>\n<li><code>cmake -S . -B build</code>:构建build树</li>\n<li><code>cmake --build</code>:build二进制</li>\n<li><code>cmake --fresh -S &lt;source tree&gt; -B &lt;build tree&gt;</code>:确保重头开始cmake</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">长选项</th>\n<th align=\"center\">短选项</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>--source &lt;dir&gt;</code></td>\n<td align=\"center\"><code>-S &lt;dir&gt;</code></td>\n<td align=\"center\">指定源码路径</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-B &lt;dir&gt;</code></td>\n<td align=\"center\">build树路径，若不存在创建目录</td>\n</tr>\n<tr>\n<td align=\"center\"><code>-build &lt;dir&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">build二进制路径</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--parallel &lt;number-of-jobs&gt;</code></td>\n<td align=\"center\"><code>-j &lt;number-of-jobs&gt;</code></td>\n<td align=\"center\">多核运行</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-G &lt;generator name&gt;</code></td>\n<td align=\"center\">指定生成器，可以–help查看系统上支持的生成器</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-C &lt;initial cache script&gt;</code></td>\n<td align=\"center\">预填充缓存信息</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-D &lt;var&gt;[:&lt;type&gt;]=&lt;value&gt;</code></td>\n<td align=\"center\">指定变量值,type可选以下值：BOOL，FILEPATH，PATH，STRING 或 INTERNAL</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-L</code></td>\n<td align=\"center\">列出缓存变量，-D指定的不会打印, -LH则还会打印变量提供的帮助信息</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-U &lt;globbing_expr&gt;</code></td>\n<td align=\"center\">删除一个变量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--system-information [file]</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">获取关于变量、命令、宏和其他设置的通用信息,可保存在file中</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--log-level=&lt;level&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">可以是ERROR，WARNING，NOTICE，STATUS，VERBOSE，DEBUG，TRACE，输出打印级别</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--trace</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">它会打印每个执行的命令及其文件名、调用它的行号，以及传递的参数列表</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--list-presets</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">列出所有可用的预设</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--fresh</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">清理目录，等价于手动删除</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--target &lt;target&gt;</code></td>\n<td align=\"center\"><code>-t &lt;target&gt;</code></td>\n<td align=\"center\">指定生成的目标（这些目标通常排除在正常构建外）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--clean-first</code></td>\n<td align=\"center\"><code>-t clean</code></td>\n<td align=\"center\">只影响目标产物而不影响其他，如缓存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--config &lt;cfg&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">指定构建类型，只有visual studio等多配置生成器可用，也可以用<code>CMAKE_BUILD_TYPE</code>指定</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--install &lt;build tree&gt; --install-prefix &lt;prefix&gt;</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">指定安装路径，prefix是前缀路径</td>\n</tr>\n<tr>\n<td align=\"center\"><code>--verbose</code></td>\n<td align=\"center\"><code>-v</code></td>\n<td align=\"center\">输出细节</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>-E &lt;command&gt; [options]</code></td>\n<td align=\"center\">以平台无关的方式运行单个命令——例如复制文件或计算校验和</td>\n</tr>\n</tbody></table>\n<h1 id=\"内置变量\"><a href=\"#内置变量\" class=\"headerlink\" title=\"内置变量\"></a>内置变量</h1><p>|变量名|类型|含义|<br>|:-:|:-:|<br>|<code>CMAKE_GENERATOR_TOOLSET</code>||<br>|<code>CMAKE_GENERATOR_PLATFORM</code>||<br>|<code>CMAKE_BUILD_TYPE</code>|可选值Debug,Release,MinSizeRel,RelWithDebInfo|</p>\n<h2 id=\"主机系统变量\"><a href=\"#主机系统变量\" class=\"headerlink\" title=\"主机系统变量\"></a>主机系统变量</h2><table>\n<thead>\n<tr>\n<th align=\"center\">变量名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>CMAKE_SIZEOF_VOID_P</code></td>\n<td align=\"center\">Int</td>\n<td align=\"center\">8代表64位，4代表32位</td>\n</tr>\n<tr>\n<td align=\"center\"><code>CMAKE_&lt;LANG&gt;_BYTE_ORDER</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">Lang可选C，CXX等,存放字节序,值有可能是<code>LITTLE_ENDIAN</code>和<code>BIG_ENDIAN</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>CMAKE_SYSTEM_NAME</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">存放操作系统类型：<code>Linux,Darwin,Windows,AIX</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>ANDROID,APPLE,CYGWIN,UNIX,IOS,WIN32,WINCE,WINDOWS_PHONE</code></td>\n<td align=\"center\">Bool</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"><code>HOSTNAME</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">主机名</td>\n</tr>\n<tr>\n<td align=\"center\"><code>FQDN</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">完全限定域名</td>\n</tr>\n<tr>\n<td align=\"center\"><code>TOTAL_VIRTUAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的虚拟内存总量</td>\n</tr>\n<tr>\n<td align=\"center\"><code>AVAILABLE_VIRTUAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的可用虚拟内存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>TOTAL_PHYSICAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的总物理内存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>AVAILABLE_PHYSICAL_MEMORY</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">以 MiB 为单位的可用物理内存</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_NAME</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">如果存在，则输出 uname -s; 无论是 Windows、Linux，还是 Darwin</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_RELEASE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">操作系统子类型，如 Windows Professional</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_VERSION</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">操作系统构建 ID</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OS_PLATFORM</code></td>\n<td align=\"center\">String</td>\n<td align=\"center\">在 Windows 上和 $ENV{PROCESSOR_ARCHITECTURE} 的值一样. 在 Unix&#x2F;macOS 上和 uname -m 一样</td>\n</tr>\n<tr>\n<td align=\"center\"><code>NUMBER_OF_LOGICAL_CORES</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">逻辑核数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>NUMBER_OF_PHYSICAL_CORES</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">物理核数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SERIAL_NUMBER</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器有序列号，则为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>PROCESSOR_SERIAL_NUMBER</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">处理器序列号</td>\n</tr>\n<tr>\n<td align=\"center\"><code>PROCESSOR_NAME</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">可读的处理器名称</td>\n</tr>\n<tr>\n<td align=\"center\"><code>PROCESSOR_DESCRIPTION</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">可读的完整处理器描述</td>\n</tr>\n<tr>\n<td align=\"center\"><code>IS_64BIT</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器是 64 位的为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_FPU</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器有浮点单元为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_MMX</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 MMX 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_MMX_PLUS</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 Ext. MMX 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE2</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE2 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE_FP</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE FP 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_SSE_MMX</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 SSE MMX 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_AMD_3DNOW</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 3DNow 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_AMD_3DNOW_PLUS</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果处理器支持 3DNow+ 指令为 1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>HAS_IA64</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">如果 IA64 处理器模拟 x86，则为 1</td>\n</tr>\n</tbody></table>\n<h1 id=\"常见操作\"><a href=\"#常见操作\" class=\"headerlink\" title=\"常见操作\"></a>常见操作</h1><h2 id=\"C-标准\"><a href=\"#C-标准\" class=\"headerlink\" title=\"C++标准\"></a>C++标准</h2><ul>\n<li><code>set(CMAKE_CXX_STANDARD &lt;version&gt;)</code></li>\n<li><code>set_property(Target &lt;target&gt; PROPERTY CXX_STANDARD &lt;version&gt;)</code></li>\n<li><code>set_target_properties(&lt;targets&gt; PROPERTIES CXX_STANDARD &lt;version&gt;)</code></li>\n<li><code>target_compile_features(&lt;target&gt; PUBLIC cxx_std_26)</code><br>version可选值有：98,11,14,17,20,23,26<br>使用target_compile_features可选值有cxx_std_14…<br>强制应用标准：<code>set(CMAKE_CXX_STANDARD_REQUIRED ON)</code></li>\n</ul>\n<h2 id=\"检查支持的编译特性\"><a href=\"#检查支持的编译特性\" class=\"headerlink\" title=\"检查支持的编译特性\"></a>检查支持的编译特性</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">list</span>(FIND CMAKE_CXX_COMPILE_FEATURES cxx_variable_templates result)<br><span class=\"hljs-keyword\">if</span>(result <span class=\"hljs-keyword\">EQUAL</span> -<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">message</span>(FATAL_ERROR <span class=\"hljs-string\">&quot;Variable templates are required for compilation.&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\n<p>可以在<a href=\"https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html\">c++支持特性列表里找到特性的完整列表</a></p>\n<h2 id=\"过程间优化-ipo\"><a href=\"#过程间优化-ipo\" class=\"headerlink\" title=\"过程间优化(ipo)\"></a>过程间优化(ipo)</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">include</span>(CheckIPOSupported)<br>check_ipo_supported(RESULT ipo_supported)<br><span class=\"hljs-keyword\">set</span>(CMAKE_INTERPROCEDURAL_OPTIMIZATION <span class=\"hljs-variable\">$&#123;ipo_supported&#125;</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"禁用源内构建\"><a href=\"#禁用源内构建\" class=\"headerlink\" title=\"禁用源内构建\"></a>禁用源内构建</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.26</span>.<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">project</span>(NoInSource CXX)<br><span class=\"hljs-keyword\">if</span>(PROJECT_SOURCE_DIR <span class=\"hljs-keyword\">STREQUAL</span> PROJECT_BINARY_DIR)<br>    <span class=\"hljs-keyword\">message</span>(FATAL_ERROR <span class=\"hljs-string\">&quot;In-source builds are not allowed&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Build successful!&quot;</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"生成目标依赖图\"><a href=\"#生成目标依赖图\" class=\"headerlink\" title=\"生成目标依赖图\"></a>生成目标依赖图</h2><ul>\n<li>使用命令<code>cmake --graphviz=test.dot .</code></li>\n<li>更多信息见官网<strong>CMakeGraphVizOptions</strong>模块,</li>\n<li>默认自定义目标不会出现在图中，可以创建一个<strong>CMakeGraphVizOptions.cmake</strong>文件，里面设置<code>set(GRAPHVIZ_CUSTOM_TARGETS TRUE)</code></li>\n<li>生成的dot文件可以在线查看<a href=\"https://dreampuf.github.io/GraphvizOnline/\">Graphviz</a></li>\n</ul>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li>单行注释：行首添加<code>#</code></li>\n<li>多行注释：以#开始，后跟方括号，任意数量等号&#x3D;可以是0个，以及另一个方括号,并以相同数量等号及方括号关闭<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"> <span class=\"hljs-comment\">#[=[</span><br><span class=\"hljs-number\">2</span> bracket comment<br>    <span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">#[[</span><br><span class=\"hljs-comment\">        4 nested bracket comment</span><br><span class=\"hljs-comment\">    5 #]]</span><br><span class=\"hljs-number\">6</span> <span class=\"hljs-comment\">#]=]</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"括号参数\"><a href=\"#括号参数\" class=\"headerlink\" title=\"括号参数\"></a>括号参数</h3><p>括号参数与多行注释格式类似，但它不能嵌套</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>([[multiline<br>    bracket<br>    argument<br>]])<br><span class=\"hljs-keyword\">message</span>([==[<br>    because we used two <span class=\"hljs-keyword\">equal</span>-signs <span class=\"hljs-string\">&quot;==&quot;</span><br>    this <span class=\"hljs-keyword\">command</span> receives only a single argument<br>    even <span class=\"hljs-keyword\">if</span> it includes two square brackets in a row<br>    &#123; <span class=\"hljs-string\">&quot;petsArray&quot;</span> = [[<span class=\"hljs-string\">&quot;mouse&quot;</span>,<span class=\"hljs-string\">&quot;cat&quot;</span>],[<span class=\"hljs-string\">&quot;dog&quot;</span>]] &#125;<br>]==])<br></code></pre></td></tr></table></figure>\n<h3 id=\"引号参数\"><a href=\"#引号参数\" class=\"headerlink\" title=\"引号参数\"></a>引号参数</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;1. escape sequence: \\&quot; \\n in a quoted argument&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;2. multi...</span><br><span class=\"hljs-string\">line&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;3. and a variable reference: $&#123;CMAKE_VERSION&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"非引号参数\"><a href=\"#非引号参数\" class=\"headerlink\" title=\"非引号参数\"></a>非引号参数</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(a\\ single\\ argument)<br><span class=\"hljs-keyword\">message</span>(two arguments)<br><span class=\"hljs-keyword\">message</span>(three;separated arguments)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;CMAKE_VERSION&#125;</span>) <span class=\"hljs-comment\"># a variable reference</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><ul>\n<li>设置与读取：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MyString1 <span class=\"hljs-string\">&quot;Text1&quot;</span>)<br><span class=\"hljs-keyword\">set</span>([[My String2]] <span class=\"hljs-string\">&quot;Text2&quot;</span>)<br><span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&quot;My String 3&quot;</span> <span class=\"hljs-string\">&quot;Text3&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;MyString1&#125;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;My\\ String2&#125;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;My\\ String\\ 3&#125;</span>)<br></code></pre></td></tr></table></figure></li>\n<li>取消：<code>unset(MyString1)</code></li>\n<li>环境变量：<code>$ENV&#123;&#125;</code></li>\n<li>缓存变量：<code>$CACHE&#123;&#125;</code></li>\n</ul>\n<h3 id=\"缓存变量\"><a href=\"#缓存变量\" class=\"headerlink\" title=\"缓存变量\"></a>缓存变量</h3><ul>\n<li>格式：<code>set(&lt;variable&gt; &lt;value&gt; CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</code></li>\n<li>BOOL: 一个布尔开关值。GUI 将显示一个复选框。</li>\n<li>FILEPATH: 磁盘上一个文件的路径。GUI 将打开一个文件对话框。</li>\n<li>PATH: 磁盘上一个目录的路径。GUI 将打开一个目录对话框。</li>\n<li>STRING: 一 行 文 本。GUI 提 供 了 一 个 要 填 充 的 文 本 字 段， 可 以 通 过 调 用<br>set_property(CACHE <variable> STRINGS <values>) 来替换为下拉控件。</li>\n<li>INTERNAL: 一行文本。GUI 将跳过内部条目。内部条目可以用来在运行之间持久存储变量，<br>使用此类型隐式添加 FORCE 关键字。<br><code>&lt;doctring&gt;</code> 值只是一个标签，GUI 将在字段旁边显示它，以便向用户提供此设置的更多细<br>节。如果缓存文件中不存在该变量或指定了可选的 FORCE 参数，该值将持久化</li>\n</ul>\n<h2 id=\"使用列表\"><a href=\"#使用列表\" class=\"headerlink\" title=\"使用列表\"></a>使用列表</h2><ul>\n<li><code>set(myList a list of five elements)</code></li>\n<li><code>set(myList &quot;a;list;of;five;elements&quot;)</code></li>\n<li><code>set(myList a list &quot;of;five;elements&quot;)</code></li>\n</ul>\n<h3 id=\"list命令工具\"><a href=\"#list命令工具\" class=\"headerlink\" title=\"list命令工具\"></a>list命令工具</h3><ul>\n<li>list(LENGTH <list> <out-var>)</li>\n<li>list(GET <list> <element index> [<index> …] <out-var>)</li>\n<li>list(JOIN <list> <glue> <out-var>)</li>\n<li>list(SUBLIST <list> <begin> <length> <out-var>)</li>\n<li>list(FIND <list> <value> <out-var>)</li>\n<li>list(APPEND <list> [<element>…])</li>\n<li>list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)</li>\n<li>list(INSERT <list> <index> [<element>…])</li>\n<li>list(POP_BACK <list> [<out-var>…])</li>\n<li>list(POP_FRONT <list> [<out-var>…])</li>\n<li>list(PREPEND <list> [<element>…])</li>\n<li>list(REMOVE_ITEM <list> <value>…)</li>\n<li>list(REMOVE_AT <list> <index>…)</li>\n<li>list(REMOVE_DUPLICATES <list>)</li>\n<li>list(TRANSFORM <list> <ACTION> […])</li>\n<li>list(REVERSE <list>)</li>\n<li>list(SORT <list> […])</li>\n</ul>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(&lt;condition&gt;)<br>&lt;commands&gt;<br><span class=\"hljs-keyword\">elseif</span>(&lt;condition&gt;) <span class=\"hljs-comment\"># optional block, can be repeated</span><br>&lt;commands&gt;<br><span class=\"hljs-keyword\">else</span>() <span class=\"hljs-comment\"># optional block</span><br>&lt;commands&gt;<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\n<h3 id=\"条件格式\"><a href=\"#条件格式\" class=\"headerlink\" title=\"条件格式\"></a>条件格式</h3><ul>\n<li><code>&lt;condition&gt; AND &lt;condition&gt;</code></li>\n<li><code>&lt;condition&gt; OR &lt;condition&gt;</code></li>\n<li><code>NOT &lt;condition&gt;</code></li>\n<li><code>DEFINED &lt;variable&gt;</code></li>\n<li><code>DEFINED CACHE&lt;variable&gt;</code></li>\n<li><code>DEFINED ENV&lt;variable&gt;</code></li>\n<li><code>if(FOO)</code>:在以下情况才为假:<ul>\n<li>OFF, NO, FALSE, N, IGNORE 或 NOTFOUND</li>\n<li>以-NOTFOUND 结尾的字符串</li>\n<li>空字符串</li>\n<li>零</li>\n</ul>\n</li>\n<li><code>if($(QUX))</code>字符串只有在等于 ON、Y、YES、TRUE 或非零数字，才可视为真（这些比较不区分大小写）。</li>\n<li><code>1 LESS/LESS_EQUAL/GREATER/GREATER_EQUAL/EQUAL 2</code></li>\n<li><code>1.3.4 VERSION_LESS_EQUAL 1.4</code></li>\n<li><code>&quot;str1&quot; STREQUAL &quot;$&#123;B&#125;&quot;</code></li>\n<li><code>&lt;VARIABLE|STRING&gt; MATCHES &lt;regex&gt;</code></li>\n<li><code>&lt;VARIABLE|STRING&gt; IN_LIST &lt;VARIABLE&gt;</code></li>\n<li><code>COMMAND &lt;command-name&gt;</code>是否可以调用某个cmake命令</li>\n<li><code>POLICY &lt;policy-id&gt;</code>是否存在cmake策略</li>\n<li><code>TEST &lt;test-name&gt;</code>是否add_test()添加了CTest测试</li>\n<li><code>TARGET &lt;target-name&gt;</code>是否定义了一个构建目标</li>\n<li><code>EXISTS &lt;path-to-file-or-directory&gt;</code></li>\n<li><code>&lt;file1&gt; IS_NEWER_THAN &lt;file2&gt;:</code></li>\n<li><code>IS_DIRECTORY &lt;path-to-directory&gt;</code></li>\n<li><code>IS_SYMLINK &lt;file-name&gt;</code></li>\n<li><code>IS_ABSOLUTE &lt;path&gt;</code></li>\n</ul>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>循环体支持<code>break()和continue()</code></p>\n<h3 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">while</span>(&lt;condition&gt;)<br>&lt;commands&gt;<br><span class=\"hljs-keyword\">endwhile</span>()<br></code></pre></td></tr></table></figure>\n<h3 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">foreach</span>(&lt;loop_var&gt; RANGE &lt;max&gt;)<span class=\"hljs-comment\">#CMake 将从 0 迭代到 &lt;max&gt;（包括）。</span><br>    &lt;commands&gt;<br><span class=\"hljs-keyword\">endforeach</span>()<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>foreach(&lt;loop_var&gt; RANGE &lt;min&gt; &lt;max&gt; [&lt;step&gt;])</code></li>\n<li><code>foreach(&lt;loop_variable&gt; IN [LISTS &lt;lists&gt;] [ITEMS &lt;items&gt;])</code></li>\n<li><code>foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</code></li>\n</ul>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MyList <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>)<br><span class=\"hljs-keyword\">foreach</span>(VAR IN LISTS MyList ITEMS e f)<span class=\"hljs-comment\">#等价于foreach(VAR 1 2 3 e f)</span><br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;VAR&#125;</span>)<br><span class=\"hljs-keyword\">endforeach</span>()<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(L1 <span class=\"hljs-string\">&quot;one;two;three;four&quot;</span>)<br><span class=\"hljs-keyword\">set</span>(L2 <span class=\"hljs-string\">&quot;1;2;3;4;5&quot;</span>)<br><span class=\"hljs-keyword\">foreach</span>(num IN ZIP_LISTS L1 L2)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;word=$&#123;num_0&#125;, num=$&#123;num_1&#125;&quot;</span>)<br><span class=\"hljs-keyword\">endforeach</span>()<br><span class=\"hljs-comment\"># 等价于下面</span><br><span class=\"hljs-comment\"># foreach(word num IN ZIP_LISTS L1 L2)</span><br><span class=\"hljs-comment\">#    message(&quot;word=$&#123;word&#125;, num=$&#123;num&#125;&quot;)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"function\"></a>function</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">function</span>(&lt;name&gt; [&lt;argument&gt;...])<br>&lt;commands&gt;<br><span class=\"hljs-keyword\">endfunction</span>()<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">function</span>(MyFunction FirstArg)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Function: $&#123;CMAKE_CURRENT_FUNCTION&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;File: $&#123;CMAKE_CURRENT_FUNCTION_LIST_FILE&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;FirstArg: $&#123;FirstArg&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">set</span>(FirstArg <span class=\"hljs-string\">&quot;new value&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;FirstArg again: $&#123;FirstArg&#125;&quot;</span>)<br>    <span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;ARGV0: $&#123;ARGV0&#125; ARGV1: $&#123;ARGV1&#125; ARGC: $&#123;ARGC&#125;&quot;</span>)<br><span class=\"hljs-keyword\">endfunction</span>()<br><span class=\"hljs-keyword\">set</span>(FirstArg <span class=\"hljs-string\">&quot;first value&quot;</span>)<br>MyFunction(<span class=\"hljs-string\">&quot;Value1&quot;</span> <span class=\"hljs-string\">&quot;Value2&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;FirstArg in global scope: $&#123;FirstArg&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h1><h2 id=\"cmake-minimum-required\"><a href=\"#cmake-minimum-required\" class=\"headerlink\" title=\"cmake_minimum-required\"></a>cmake_minimum-required</h2><ul>\n<li>格式：<code>cmake_minimum_required(VERSION &lt;x.xx&gt;)</code></li>\n<li>意义：设置cmake期望的版本</li>\n</ul>\n<h2 id=\"project\"><a href=\"#project\" class=\"headerlink\" title=\"project\"></a>project</h2><ul>\n<li>格式一：<code>project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])</code></li>\n<li>格式二：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">project</span>(&lt;<span class=\"hljs-keyword\">PROJECT</span>-NAME&gt;<br>    [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]<br>    [DESCRIPTION &lt;<span class=\"hljs-keyword\">project</span>-description-<span class=\"hljs-keyword\">string</span>&gt;]<br>    [HOMEPAGE_URL &lt;url-<span class=\"hljs-keyword\">string</span>&gt;]<br>    [LANGUAGES &lt;language-name&gt;...])<br></code></pre></td></tr></table></figure>\n此命令将设置以下变量:</li>\n<li><code>PROJECT_NAME</code></li>\n<li><code>CMAKE_PROJECT_NAME (only in the top-level CMakeLists.txt)</code></li>\n<li><code>PROJECT_IS_TOP_LEVEL, &lt;PROJECT-NAME&gt;_IS_TOP_LEVEL</code></li>\n<li><code>PROJECT_SOURCE_DIR, &lt;PROJECT-NAME&gt;_SOURCE_DIR</code></li>\n<li><code>PROJECT_BINARY_DIR, &lt;PROJECT-NAME&gt;_BINARY_DIR</code><br>支持语言(仅列常用的)</li>\n<li>C:C</li>\n<li>CXX: C++<br>指定VERSION关键字，将会设置以下变量:</li>\n<li><code>PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSION</code></li>\n<li><code>CMAKE_PROJECT_VERSION (only in the top-level CMakeLists.txt)</code></li>\n<li><code>PROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJOR</code></li>\n<li><code>PROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINOR</code></li>\n<li><code>PROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCH</code></li>\n<li><code>PROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK</code><br>类似设置DESCRIPTION和HOMEPAGE_URL将设置以下变量</li>\n<li><code>PROJECT_DESCRIPTION, &lt;PROJECT-NAME&gt;_DESCRIPTION</code></li>\n<li><code>PROJECT_HOMEPAGE_URL, &lt;PROJECT-NAME&gt;_HOMEPAGE_URL</code></li>\n</ul>\n<h2 id=\"add-subdirectory\"><a href=\"#add-subdirectory\" class=\"headerlink\" title=\"add_subdirectory\"></a>add_subdirectory</h2><ul>\n<li>格式：<code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></li>\n<li>意义：<code>将计算source_dir 路径（相对于当前目录）并解析其中的CMakeLists.txt 文件</code></li>\n<li><strong>[binary_dir]</strong>: 构建的文件将写入该路径，默认是构建树</li>\n<li><strong>[EXCLUDE_FROM_ALL]</strong>: 禁用子目录中定义的目标的自动构建</li>\n</ul>\n<h2 id=\"add-executable\"><a href=\"#add-executable\" class=\"headerlink\" title=\"add_executable\"></a>add_executable</h2><ul>\n<li>格式：<code>add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1 source2...])</code></li>\n<li>[WIN32],[MACOSX_BUNDLE]分别生成win和mac下的gui程序</li>\n<li>[EXCLUDE_FROM_ALL]将使得该目标在默认构建中排除在外，必须-t明确指明</li>\n</ul>\n<h2 id=\"add-library\"><a href=\"#add-library\" class=\"headerlink\" title=\"add_library\"></a>add_library</h2><ul>\n<li>格式：<code>add_library(&lt;name&gt; [STATIC|SHARED|MODULE] [EXCLUDE_FROM_ALL] [source1 source2...])</code></li>\n<li>[STATIC|SHARED|MODULE],分别对应静态，动态，模块</li>\n</ul>\n<h2 id=\"add-custom-target\"><a href=\"#add-custom-target\" class=\"headerlink\" title=\"add_custom_target\"></a>add_custom_target</h2><ul>\n<li>格式：<code>add_custom_target(Name [ALL] [COMMAND command2 [args2...] ...])</code><br>[ALL]与[EXCLUDE_FROM_ALL]含义相反，自定义目标默认不生成,自定义目标通常用于以下场景：</li>\n<li>计算其他二进制文件的校验和</li>\n<li>运行代码消毒器并收集结果</li>\n<li>将编译报告发送到指标通道<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.26</span>)<br><span class=\"hljs-keyword\">project</span>(BankApp CXX)<br><span class=\"hljs-keyword\">add_executable</span>(terminal_app terminal_app.cpp)<br><span class=\"hljs-keyword\">add_executable</span>(gui_app gui_app.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(terminal_app calculations)<br><span class=\"hljs-keyword\">target_link_libraries</span>(gui_app calculations drawing)<br><span class=\"hljs-keyword\">add_library</span>(calculations calculations.cpp)<br><span class=\"hljs-keyword\">add_library</span>(drawing drawing.cpp)<br><span class=\"hljs-keyword\">add_custom_target</span>(checksum ALL<br>    <span class=\"hljs-keyword\">COMMAND</span> sh -c <span class=\"hljs-string\">&quot;cksum terminal_app&gt;terminal.ck&quot;</span><br>    <span class=\"hljs-keyword\">COMMAND</span> sh -c <span class=\"hljs-string\">&quot;cksum gui_app&gt;gui.ck&quot;</span><br>    BYPRODUCTS terminal.ck gui.ck<br>    COMMENT <span class=\"hljs-string\">&quot;Checking the sums...&quot;</span><br>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"find-package\"><a href=\"#find-package\" class=\"headerlink\" title=\"find_package\"></a>find_package</h2><ul>\n<li><code>find_package(&lt;Name&gt; [version] [EXACT] [QUIET] [REQUIRED])</code><br>[version]可以指定一个范围，如<code>1.22...1.40.1</code>,EXACT指定确切版本，而不是更新,QUIET抑制包被找到的信息<br>当找到库后，cmake将会自动设置以下变量：</li>\n<li><code>&lt;PKG_NAME&gt;_FOUND</code>: 这表明是否成功找到了包。</li>\n<li><code>&lt;PKG_NAME&gt;_INCLUDE_DIRS 或 &lt;PKG_NAME&gt;_INCLUDES</code>: 这指向包的头文件所在的目<br>录。</li>\n<li><code>&lt;PKG_NAME&gt;_LIBRARIES 或 &lt;PKG_NAME&gt;_LIBS</code>: 这些是要链接的库的列表。<br>可以设置扫描路径<code>CMAKE_MODULE_PATH</code>，而不是系统默认的</li>\n</ul>\n<h2 id=\"message\"><a href=\"#message\" class=\"headerlink\" title=\"message\"></a>message</h2><ul>\n<li><code>message(&lt;MODE&gt; ”text to print”)</code><br>MODE可选以下：</li>\n<li>FATAL_ERROR: 停止处理和生成。</li>\n<li>SEND_ERROR: 继续处理，但跳过生成。</li>\n<li>WARNING: 继续处理。</li>\n<li>AUTHOR_WARNING: 输出警告，但继续处理。</li>\n<li>DEPRECATION: 如 果 启 用 了 CMAKE_ERROR_DEPRECATED 或 CMAKE_WARN_DEPRECATED，则输出相应地信息。</li>\n<li>NOTICE 或省略模式（默认）: 输出消息到 stderr，以吸引使用者的注意。</li>\n<li>STATUS: 继续处理，推荐用于向用户显示的主要消息。</li>\n<li>VERBOSE: 继续处理，应用于更详细的信息，通常不是非常必要。</li>\n<li>DEBUG: 继续处理，应包含项目出现问题时，对处理问题有帮助的详细信息。</li>\n<li>TRACE: 继续处理，建议在项目开发期间输出消息。通常，这类消息会在发布项目之前移除。</li>\n</ul>\n<h2 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file\"></a>file</h2><ul>\n<li>file(READ <filename> <out-var> […])</li>\n<li>file({WRITE | APPEND} <filename> <content>…)</li>\n<li>file(DOWNLOAD <url> [<file>] […])</li>\n</ul>\n<h2 id=\"execute-process\"><a href=\"#execute-process\" class=\"headerlink\" title=\"execute_process()\"></a>execute_process()</h2><ul>\n<li><code>execute_process(COMMAND &lt;cmd1&gt; [&lt;arguments&gt;]... [OPTIONS])</code><br>可选地 TIMEOUT 参数，用来在进程未在所需限制内完成任务时终止该进程，并且可以根据<br>需要设置 WORKING_DIRECTORY 。<br>所有任务的退出代码可以通过提供 RESULTS_VARIABLE 参数来收集到一个列表中。如果只<br>对最后执行的命令的结果感兴趣，请使用单数形式：RESULT_VARIABLE 。<br>为了收集输出，CMake 提供了两个参数：OUTPUT_VARIABLE 和 ERROR_VARIABLE（用法<br>类似）。如果想合并 stdout 和 stderr，请为这两个参数使用相同的变量。</li>\n</ul>\n<h2 id=\"伪目标\"><a href=\"#伪目标\" class=\"headerlink\" title=\"伪目标\"></a>伪目标</h2><h3 id=\"别名目标\"><a href=\"#别名目标\" class=\"headerlink\" title=\"别名目标\"></a>别名目标</h3><p>别名目标的确切作用就是你所期望的——为目标创建另一个不同的名称引用</p>\n<ul>\n<li><code>add_executable(&lt;name&gt; ALIAS &lt;target&gt;)</code></li>\n<li><code>add_library(&lt;name&gt; ALIAS &lt;target&gt;)</code></li>\n</ul>\n<h3 id=\"接口库\"><a href=\"#接口库\" class=\"headerlink\" title=\"接口库\"></a>接口库</h3><ul>\n<li><code>add_library(&lt;name&gt; INTERFACE [item1 ...])</code><br>有两个作用：一是<strong>代表仅包含头文件的库</strong>,二是<strong>将一堆传播属性打包成一个逻辑单元</strong><br>例子一：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(Eigen INTERFACE<br>  src/eigen.h src/vector.h src/matrix.h<br>)<br><span class=\"hljs-keyword\">target_include_directories</span>(Eigen INTERFACE<br>  $&lt;BUILD_INTERFACE:<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src&gt;<br>  $&lt;INSTALL_INTERFACE:<span class=\"hljs-keyword\">include</span>/Eigen&gt;<br>)<br><span class=\"hljs-keyword\">target_link_libraries</span>(executable Eigen)<br></code></pre></td></tr></table></figure>\n例子二：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(warning_properties INTERFACE)<br><span class=\"hljs-keyword\">target_compile_options</span>(warning_properties INTERFACE<br>    -Wall -Wextra -Wpedantic<br>)<br><span class=\"hljs-number\">5</span> <span class=\"hljs-keyword\">target_link_libraries</span>(executable warning_properties)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"对象库\"><a href=\"#对象库\" class=\"headerlink\" title=\"对象库\"></a>对象库</h2><p>即.o对象文件</p>\n<ul>\n<li><code>add_library(&lt;target&gt; OBJECT &lt;sources&gt;)</code><br>可以使用target_link_libraries()作为依赖添加，抑或是如下：<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(... $&lt;TARGET_OBJECTS:objname&gt; ...)<br><span class=\"hljs-keyword\">add_executable</span>(... $&lt;TARGET_OBJECTS:objname&gt; ...)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"target-include-directories\"><a href=\"#target-include-directories\" class=\"headerlink\" title=\"target_include_directories\"></a>target_include_directories</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_include_directories</span>(&lt;<span class=\"hljs-keyword\">target</span>&gt; [SYSTEM] [AFTER|BEFORE]<br>&lt;INTERFACE|PUBLIC|PRIVATE&gt; [item1...]<br>[&lt;INTERFACE|PUBLIC|PRIVATE&gt; [item2...]<br>...])<br></code></pre></td></tr></table></figure>\n<p>SYSTEM 关键字告诉编译器给定的目录应该视为标准系统目录（与尖括号形式一起使用）。<br>BEFORE或AFTER决定是否将这些头文件放在已有的路径之前或之后</p>\n<h2 id=\"target-compile-definitions\"><a href=\"#target-compile-definitions\" class=\"headerlink\" title=\"target_compile_definitions\"></a>target_compile_definitions</h2><ul>\n<li><code>target_compile_definitions(&lt;target&gt; [PRIVATE|PUBLIC|INTERFACE] [var1 &quot;var2=value&quot; ...])</code><br>定义宏变量,相当于-D传递,也可以传递-D选项<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(<span class=\"hljs-keyword\">defined</span> PRIVATE ABC <span class=\"hljs-string\">&quot;DEF=$&#123;VAR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">target_compile_definitions</span>(hello PRIVATE -DFOO)<br><span class=\"hljs-keyword\">target_compile_definitions</span>(hello PRIVATE -D FOO)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"target-compile-options\"><a href=\"#target-compile-options\" class=\"headerlink\" title=\"target_compile_options\"></a>target_compile_options</h2><ul>\n<li>传递编译器参数</li>\n<li><code>target_compile_options(&lt;target&gt; [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...]</code></li>\n</ul>\n<h2 id=\"target-precompile-headers\"><a href=\"#target-precompile-headers\" class=\"headerlink\" title=\"target_precompile_headers\"></a>target_precompile_headers</h2><ul>\n<li>预编译头文件</li>\n<li><code>target_precompile_headers(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [header1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [header2...] ...])</code><br>添加的头文件列表存储在PRECOMPILE_HEADERS属性中,不应该对使用install命令导出的目标执行此操作</li>\n</ul>\n<h1 id=\"目标的属性\"><a href=\"#目标的属性\" class=\"headerlink\" title=\"目标的属性\"></a>目标的属性</h1><ul>\n<li>获取属性值:<code>get_target_property(&lt;var&gt; &lt;target&gt; &lt;property-name&gt;)</code></li>\n<li>设置属性:<code>set_target_properties(&lt;target1&gt; &lt;target2&gt; ...  PROPERTIES &lt;prop1-name&gt; &lt;value1&gt; &lt;prop2-name&gt; &lt;value2&gt; ...)</code>或 <code>set_property(Target &lt;target&gt; PROPERTY &lt;prop-name&gt; &lt;value&gt;)</code></li>\n</ul>\n<h2 id=\"属性传播\"><a href=\"#属性传播\" class=\"headerlink\" title=\"属性传播\"></a>属性传播</h2><ul>\n<li>PRIVATE:设置源目标属性</li>\n<li>INTERFACE:设置使用目标的目标属性</li>\n<li>PUBLIC：设置源目标和使用目标属性<br>当指定 PRIVATE 或 PUBLIC 关键字时，CMake 将在目 标的属性中存储提供的值，COMPILE_DEFINITIONS。此外，关键字是 INTERFACE 或 PUBLIC， 将在具有 INTERFACE_前缀的属性中存储值——INTERFACE_COMPILE_DEFINITIONS。配置阶 段，CMake 将读取源目标的接口属性，并将其内容附加到目标目标。就这样传播属性，或 CMake 所说的传递目标的使用要求。<br>设置属性时需要指定上述关键字，如<code>target_compile_definitions(&lt;source&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...])</code>, <code>target_link_libraries(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item1&gt; [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...])</code>这个命令也需要传播关键字</li>\n</ul>\n<h2 id=\"自定义属性的传播\"><a href=\"#自定义属性的传播\" class=\"headerlink\" title=\"自定义属性的传播\"></a>自定义属性的传播</h2><p>CMake 默认不会传播自定义属性（这个机制只适用 于内置目标属性），必须明确地将自定义属性添加到“兼容”属性列表中。<br>每个目标都有四个这样的列表：</p>\n<ul>\n<li>COMPATIBLE_INTEERFACE_BOOL</li>\n<li>COMPATIBLE_INTERFACE_STRING</li>\n<li>COMPATIBLE_INTERFACE_NUMBER_MAX</li>\n<li>COMPATIBLE_INTERFACE_NUMBER_MIN<br>将属性添加到它们中的任何一个，都会触发传播和兼容性检查。BOOL 列表将检查所有传递到 目标目标的属性是否评估为相同的布尔值。类似地，STRING 将评估为字符串。NUMBER_MAX 和 NUMBER_MIN 略有不同——传递的值不必匹配，但目标目标将只接收最高或最低值。</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.26</span>)<br> <span class=\"hljs-keyword\">project</span>(PropagatedProperties CXX)<br><br><span class=\"hljs-keyword\">add_library</span>(source1 empty.cpp)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> source1 PROPERTY INTERFACE_LIB_VERSION <span class=\"hljs-number\">4</span>)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> source1 APPEND PROPERTY<br>    COMPATIBLE_INTERFACE_STRING LIB_VERSION)<br><br><span class=\"hljs-keyword\">add_library</span>(source2 empty.cpp)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> source2 PROPERTY INTERFACE_LIB_VERSION <span class=\"hljs-number\">4</span>)<br><span class=\"hljs-keyword\">add_library</span>(destination empty.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(destination source1 source2)<br></code></pre></td></tr></table></figure>\n<p>CMake 将这个自定义属性传播到相应目标，并检查所有源目标的版本是否完全匹配（兼容性属性只需在目标目标上设置一次）。</p>\n<h1 id=\"参考连接\"><a href=\"#参考连接\" class=\"headerlink\" title=\"参考连接\"></a>参考连接</h1><p><a href=\"https://kubasejdak.com/19-reasons-why-cmake-is-actually-awesome\">19 reasons why cmake is actually awesome</a><br><a href=\"https://cliutils.gitlab.io/modern-cmake/\">an introduction to modern cmake</a><br><a href=\"https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1\">effective modern cmake</a><br><a href=\"https://github.com/onqtam/awesome-cmake\">awesome cmake</a><br><a href=\"https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/Useful-Variables\">useful variables</a></p>\n<h1 id=\"CTest\"><a href=\"#CTest\" class=\"headerlink\" title=\"CTest\"></a>CTest</h1><p>testing tool(integrated in CMake)</p>\n"},{"title":"ffmpeg","date":"2024-04-06T20:03:15.000Z","index_img":"/images/ffmpeg.jpeg","banner_img":"/images/ffmpeg.jpeg","_content":"# 视频剪裁\n- 裁剪:`ffmpeg -i xx.mp4 -vcodec copy -acodec copy -ss 00:00:00 -to 01:18:08 output.mp4`\n## 精确剪切\nffmpeg 会在你输入的时间点附近调整到最接近的关键帧处，这会导致时间不准确，可以先转换为帧内编码（每一帧都是关键帧）\n`ffmpeg -i xx.flv -strict -2 -qscale 0 -intra xx2.flv`\n# 合并:\n## 通用\n 先建立个文本文档file,格式如下:\n```bash\nfile '1.mp4'\nfile '2.mp4'\n```\n`ffmpeg -f concat -i file -c copy output.mkv`\n或者支持不好先转换ts\n`ffmpeg -i 1.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 1.ts`\n\n`ffmpeg -i 2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 2.ts`\n\n`ffmpeg -i \"concat:1.ts|2.ts\" -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4`\n## 重新编码合并\n适用不同编码\n`ffmpeg -i input1.mp4 -i input2.webm -i input3.avi -filter_complex '[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] concat=n=3:v=1:a=1 [v] [a]' -map '[v]' -map '[a]' <编码器选项> output.mkv`\n[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] 分别表示第一个输入文件的视频、音频、第二个输入文件的视频、音频、第三个输入文件的视频、音频。concat=n=3:v=1:a=1 表示有三个输入文件，输出一条视频流和一条音频流。[v] [a] 就是得到的视频流和音频流的名字，注意在 bash 等 shell 中需要用引号，防止通配符扩展。\n# 视频倒放\n## 视频倒放，无音频\n`ffmpeg -i 123.mp4 -filter_complex [0:v]reverse[v] -map [v] -preset superfast out.mp4 `\n## 视频倒放，音频不变\n`ffmpeg -i 123.mp4 -vf reverse out.mp4`\n## 音频倒放，视频不变\n`ffmpeg -i 123.mp4 -map 0 -c:v copy -af \"areverse\" out.mp4`\n## 音视频同时倒放\n`fmpeg -i 123.mp4 -vf reverse -af areverse -preset superfast out.mp4`\n\n\n# 视频格式转换\n- rmvb->mp4:\n`ffmpeg -i name1.rmvb -c:v libx264 -strict -2 name2.mp4 `\n# 字幕\n- 添加字幕:\n`ffmpeg -i 2020-07-13\\ 08-20-26.mkv -vf subtitles=test.srt -y output.mkv`\nsrt格式:\n```\n1\n00:00:03,000 --> 00:00:06,000\nHi,I am Nanbert Don De Niro\n\n2\n00:00:06,000 --> 00:00:08,000\nHi,I am Donald Trump\n  \n3\n00:00:08,444 --> 00:00:10,000\nIt's you,Assole!\n```\n# 视频与声音\n- 静音:`ffmpeg -i 10.mp4 -af \"volume=0\" 10Silent.mp4`\n- 静音一部分:`ffmpeg -i 10.mp4 -af \"volume=enable='between(t,0,8)':volume=0\" 10Silent.mp4`\n- 去掉原声:`ffmpeg -i 12.mp4 -c:v copy -an xx.mp4`\n- 合并指定音频:`ffmpeg -i out.mp4 -i xx.mp3 xx.mp4`\n- 指定合成时间：`ffmpeg -i out.mp4 -i xx.mp3 -t 30 xx.mp4`\n- 保留视频原声并添加新音频:`ffmpeg -i xx.mp3 -i 22.mp4 -filter_complex amix=inputs=2 output.mp4`\n- 替换原来的音频：`ffmpeg -i xx.wav -i xx.flv -shortest -c copy xx.flv`\n- 提取音频：`ffmpeg -i xx.flv -vn -acodec copy xx.wav`\n- 调整音量：`ffmpeg -i input.wav -af 'volume=1.5' xx.wav`\n# 流媒体\n- 一边播放一边保存流媒体:`ffmpeg -i host/input.m3u8 -c copy out.mkv -c copy -f matroska - | ffplay - `\n# 音频\n- 波形图模式：`ffplay -showmode 1 xx.mp3`\n- 频谱图模式：`ffplay -showmode 2 xx.mp3`\n- 音频淡出效果: `ffmpeg -i xx.mp3 -filter_complex afade=t=out:st=16:d=4 xx2.mp3`\n# GIF\n## 视频全部转换成gif\n- `ffmpeg -i 123.mp4 out.gif`\n## 截取部分片段\n- `ffmpeg -t 3 -ss 00:00:02 -i xx.mp4 xx.gif`\n## 增加GIF质量\n- `ffmpeg -i  OUTPUT_VIDEO.mp4 -b 2048k OUTPUT_VIDEO.gif`:尽可能高质量转换\n## 将GIF转成视频\n- `ffmpeg -f gif -i xx.gif xx.mp4`:将GIF转换为MP4\n## 设置循环次数\n默认是0,即无限循环\n`ffmpeg -ss 9 -t 5 -i xx.mp4 -loop 2 xx.gif`\n## 设置低分辨率\n`ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf scale=iw/2:-1:flags=lanczos 1.gif`\nscale=iw/2:-1:flags=lanczos（lanczos为缩放算法），将会设置gif图片的宽度为源视频一半，高度为比例缩放\n## 设置fps(每秒帧数)\n`ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf \"scale=iw/2:-1:flags=lanczos,fps=15\" 1.gif`\n## 视频画面的一半设成gif\n`ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf \"scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0\" 1.gif`\n可能我们只需要将视频画面的一部分转成gif图片，可以使用crop，具体为crop=宽度:高度:宽度起始:高度起始，比如crop=200:200:0:0，将会从横向0像素，纵向0像素开始，从画面裁剪200x200的区域。\n## 提高画面的质量\n`fmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf \"scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0,split[s1][s2];[s1]palettegen[p];[s2][p]paletteuse\" 1.gif`\n# 水印\n## 图片水印\n`ffmpeg -i xx.mp4 -vf \"movie=xx.png[wm];[in][wm]overlay=30:10[out]\" output.mp4`\n30:10代表图片的像素位置\n## 左下角添加gif动态水印\n`ffmpeg -y -i test2.mp4 -ignore_loop 0 -i test.gif  -filter_complex overlay=0:H-h test_out2.mp4`\n## 设置显示时间段\n`ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex \"overlay=enable='between(t,5,10)'\" out.mp4 -y`\n让水印在5-10s时间段显示\n## 设置两个水印轮番出现\n`ffmpeg -i big_buck_bunny.mp4 -i doggie1.png -i doggie2.png -filter_complex \"overlay=enable='lte(mod(t,10),4)',overlay=enable='gt(mod(t,10),6)'\" out.mp4 -y`\n上面的命令作用是：第一个水印显示4秒后消失，2秒后第二个水印显示4秒后消失。\n## 水印位置平移\n- `fmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi \"overlay=x=t*20\" -shortest out.mp4 -y`\n让水印每秒向右移动20像素，直到消失\n- `ffmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi \"overlay=enable=\\'mod(t,10)\\':x=\\'100*mod(t,10)-w\\'\" -shortest out.mp4 -y`\n设置水印每隔10秒从左向右移动直至消失\n## gif水印循环播放\n```bash\n第一种：设置gif的-ignore_loop为0，让gif保持循环播放即可，命令如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -filter_complex  overlay -shortest out.mp4 -y\n但是这种方式，只适用于gif格式的图像，如果滤镜是一小段视频就无能为力了。\n\n第二种：使用movie滤镜，同样是让gif循环播放，虽然这种方式复杂点，不过这种解决方案支持视频水印，命令如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -vf \"movie=doggie3.gif:loop=0,setpts=N/FRAME_RATE/TB[out];[0:v][out]overlay=x=main_w-overlay_w:y=0\" -shortest out.mp4 -y\n上面的命令有两个地方比较关键：\n\nloop=0,setpts=N/FRAME_RATE/TB ：设置水印gif无限循环\n-shortest ：将输出文件的时长设置为第一个视频文件的时长，如果不设置，你会发现命令会一直执行根本不会停下来，因为gif图的循环是无限的\n这样gif图/短视频就会一直不停的播放了。\n\n\n希望水印播放一次就不播放了，那就设置上面的eof_action为pass就可以了，如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie3.gif -filter_complex \"overlay=x=0:y=0:eof_action=pass\" out.mp4 -y\n\n如果视频一开始就播放且只播放一次，假如水印比较短可能根本就没被注意就过去了，这时可以设置水印出现的延迟时间，使用-itsoffset选项，如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -itsoffset 3 -i doggie3.gif -filter_complex \"overlay=x=0:y=0:eof_action=pass\" out.mp4 -y\n这样，视频播放3秒后，水印才会出现。\n```\n## 水印旋转\n```bash\n如果想实现旋转的功能，需要使用ffmpeg过滤器的链式功能，即：先把作为水印的图片旋转，再覆盖到视频上。\n\n1. 水印旋转一次\nffmpeg -i buck.mp4 -i s1.jpg -lavfi \"[1:v]format=rgba,rotate='PI/6:c=0x00000000:ow=hypot(iw,ih):oh=ow'[out];[0:v][out]overlay=10:10\" out.mp4 -y\n\n思路是：\n调整水印宽高，根据勾股定律计算图片对角长度(hypot)，将这个值设置为水印的宽高，这样，图片无论如何旋转，都不会超过设定的宽高，也就不会出现图片部分丢失的情况了\n将图片显示的像素格式转换为rgba格式，如果做过前端的小伙伴会很熟悉的，最后的a表示透明度，如此一来，c=0x00000000的作用就是将图片旋转后的背景变为白色且完全透明，这样就不会遮挡视频了\n\n2. 让旋转停不下，具体命令如下：\nffmpeg -i buck.mp4 -loop 1 -i s1.jpg -lavfi \"[1:v]format=rgba,rotate='PI/2*t:c=0x00000000:ow=hypot(iw,ih):oh=ow'[out];[0:v][out]overlay=10:10\" -shortest out.mp4 -y\n这次水印图片前面添加了-loop 1，正常情况下水印图片默认在播放一次后就停下来，保留最后一帧，所以要让水印图片保持循环才行。\n```\n# 录屏及摄像头\n- `ffmpeg -devices`:列出音频设备及摄像头\n## 录屏命令\n`ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 -c:v libx264 output.mp4`\n- -f x11grab 指定使用X11grab设备作为输入。\n- -s [分辨率] 设置录制视频的分辨率，例如 1920x1080。不指定就是全屏\n- -r [帧率] 设置录制视频的帧率，例如 30。\n- -i :0.0 指定要捕获的X11屏幕。:0.0 通常表示第一个屏幕。如果你有多个屏幕或显示设置不同，这个值可能需要调整。\n- -c:v [编码器] 设置视频编码器，例如 libx264 用于H.264编码。\n- output.mp4 是输出文件的名称。\n## 录屏加声音\n`ffmpeg -f x11grab -i :0.0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame -s 1280x720 -r 15 xx.mp4`\nalsa使用于linux alsa声卡，`hw:2`是当前电脑上的设备，可以用`arecord -l`命令来显示设备，card几就hw:几\n## 摄像头\n`ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 xx.mkv`\n可以通过`v4l2-ctl --list-devices`来查看v4l2的设备，\n## 摄像头加声音\n`ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame xx.mkv`\n# 文字水印\n`ffmpeg -i xx.mp4 -vf \"drawtext=fontfile=simhei.ttf: text='hi,Nanbert':x=100:y=1fontsize=24fontcolor=white:shadowy=2\" output.mp4`\n- ontfile:字体类型\n- text:要添加的文字内容\n- fontsize:字体大小\n- fontcolor：字体颜色\n# 各种特效\n- 渐入:`ffmpeg -i in.mp4 -vf fade=in:0:90 out.mp4`\n- 黑白:`ffmpeg -i in.mp4 -vf lutyuv=\"u=128:v=128\" out.mp4`\n- 锐化:`ffmpeg -i in.mp4 -vf unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5 out.mp4`\n- 反锐化:`ffmpeg -i in.mp4 -vf unsharp=7:7:-2:7:7:-2 out.mp4`\n- 渐晕:`ffmpeg -i in.mp4 -vf vignette=PI/4 out.mp4`\n- 闪烁渐晕:`ffmpeg -i in.mp4 -vf vignette='PI/4+random(1)*PI/50':eval=frame out.mp4`\n- 视频颤抖:`ffmpeg -i in.mp4 -vf crop=\"in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2+((in_h-out_h)/2)*sin(n/7)\" out.mp4`\n- 色彩变幻:`ffmpeg -i in.mp4 -vf hue=\"H=2*PI*t:s=sin(2*PI*t)+1\" out.mp4`\n- 模糊处理:`ffmpeg -i in.mp4 -vf boxblur=5:1:cr=0:ar=0 out.mp4`\n- 镜像翻转:`ffmpeg -i in.mp4 -vf crop=iw/2:ih:0:0,split[left][tmp];[tmp]hflip[right];[left]pad=iw*2[a];[a][right]overlay=w out.mp4`\n- 水平翻转:`ffmpeg -i in.mp4 -vf geq=p(W-X\\\\,Y) out.mp4`\n- 垂直翻转:`ffmpeg -i in.mp4 -vf vflip out.mp4`\n- 浮雕效果:`ffmpeg -i in.mp4 -vf format=gray,geq=lum_expr='(p(X,Y)+(256-p(X-4,Y-4)))/2' out.mp4`\n- 均匀噪声:`ffmpeg -i in.mp4 -vf noise=alls=20:allf=t+u out.mp4`\n# 字幕\n- `ffmpeg -i xx.mp4 -vf ass=xx.ass -b:v 3000k xx.mp4`\n# 图片\n- 5秒处截图：`ffmpeg -ss 00:00:05 -i xx.mp4 xx.jpg -r 1 -vframes 1 -an -vodec mjpeg`\n- 每一帧输出图片：`ffmpeg -i xx.mp4 image_%d.jpg`\n- 图片转为视频：`ffmpeg -f image2 -i image_%d.jpg video.mpg`\n# 视频格式的默认编码\n- .avi: Audio Codec: mp3, Video Codec: mpeg4\n- .mkv: Audio Codec: ac3, Video Codec: H.264\n- .mov: Audio Codec: AAC, Video Codec: H.264\n- .mp4: Audio Codec: AAC, Video Codec: H.264\n- .mpg: Audio Codec: mp2, Video Codec: mpeg1video\n- .mxf: Audio Codec: pcm_s16le, Video Codec: mpeg2video\n- .wav: Audio Codec: pcm_s16le (16 bit PCM)\n# 链接\n[ffmprovisr](https://amiaopensource.github.io/ffmprovisr/#SD_HD)\n[ffmpeg中文教程](https://ffmpeg.xianwaizhiyin.net/)\n\n","source":"_posts/ffmpeg.md","raw":"---\ntitle: ffmpeg\ndate: 2024-04-07 04:03:15\ntags:\nindex_img: /images/ffmpeg.jpeg\nbanner_img: /images/ffmpeg.jpeg\n---\n# 视频剪裁\n- 裁剪:`ffmpeg -i xx.mp4 -vcodec copy -acodec copy -ss 00:00:00 -to 01:18:08 output.mp4`\n## 精确剪切\nffmpeg 会在你输入的时间点附近调整到最接近的关键帧处，这会导致时间不准确，可以先转换为帧内编码（每一帧都是关键帧）\n`ffmpeg -i xx.flv -strict -2 -qscale 0 -intra xx2.flv`\n# 合并:\n## 通用\n 先建立个文本文档file,格式如下:\n```bash\nfile '1.mp4'\nfile '2.mp4'\n```\n`ffmpeg -f concat -i file -c copy output.mkv`\n或者支持不好先转换ts\n`ffmpeg -i 1.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 1.ts`\n\n`ffmpeg -i 2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 2.ts`\n\n`ffmpeg -i \"concat:1.ts|2.ts\" -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4`\n## 重新编码合并\n适用不同编码\n`ffmpeg -i input1.mp4 -i input2.webm -i input3.avi -filter_complex '[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] concat=n=3:v=1:a=1 [v] [a]' -map '[v]' -map '[a]' <编码器选项> output.mkv`\n[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] 分别表示第一个输入文件的视频、音频、第二个输入文件的视频、音频、第三个输入文件的视频、音频。concat=n=3:v=1:a=1 表示有三个输入文件，输出一条视频流和一条音频流。[v] [a] 就是得到的视频流和音频流的名字，注意在 bash 等 shell 中需要用引号，防止通配符扩展。\n# 视频倒放\n## 视频倒放，无音频\n`ffmpeg -i 123.mp4 -filter_complex [0:v]reverse[v] -map [v] -preset superfast out.mp4 `\n## 视频倒放，音频不变\n`ffmpeg -i 123.mp4 -vf reverse out.mp4`\n## 音频倒放，视频不变\n`ffmpeg -i 123.mp4 -map 0 -c:v copy -af \"areverse\" out.mp4`\n## 音视频同时倒放\n`fmpeg -i 123.mp4 -vf reverse -af areverse -preset superfast out.mp4`\n\n\n# 视频格式转换\n- rmvb->mp4:\n`ffmpeg -i name1.rmvb -c:v libx264 -strict -2 name2.mp4 `\n# 字幕\n- 添加字幕:\n`ffmpeg -i 2020-07-13\\ 08-20-26.mkv -vf subtitles=test.srt -y output.mkv`\nsrt格式:\n```\n1\n00:00:03,000 --> 00:00:06,000\nHi,I am Nanbert Don De Niro\n\n2\n00:00:06,000 --> 00:00:08,000\nHi,I am Donald Trump\n  \n3\n00:00:08,444 --> 00:00:10,000\nIt's you,Assole!\n```\n# 视频与声音\n- 静音:`ffmpeg -i 10.mp4 -af \"volume=0\" 10Silent.mp4`\n- 静音一部分:`ffmpeg -i 10.mp4 -af \"volume=enable='between(t,0,8)':volume=0\" 10Silent.mp4`\n- 去掉原声:`ffmpeg -i 12.mp4 -c:v copy -an xx.mp4`\n- 合并指定音频:`ffmpeg -i out.mp4 -i xx.mp3 xx.mp4`\n- 指定合成时间：`ffmpeg -i out.mp4 -i xx.mp3 -t 30 xx.mp4`\n- 保留视频原声并添加新音频:`ffmpeg -i xx.mp3 -i 22.mp4 -filter_complex amix=inputs=2 output.mp4`\n- 替换原来的音频：`ffmpeg -i xx.wav -i xx.flv -shortest -c copy xx.flv`\n- 提取音频：`ffmpeg -i xx.flv -vn -acodec copy xx.wav`\n- 调整音量：`ffmpeg -i input.wav -af 'volume=1.5' xx.wav`\n# 流媒体\n- 一边播放一边保存流媒体:`ffmpeg -i host/input.m3u8 -c copy out.mkv -c copy -f matroska - | ffplay - `\n# 音频\n- 波形图模式：`ffplay -showmode 1 xx.mp3`\n- 频谱图模式：`ffplay -showmode 2 xx.mp3`\n- 音频淡出效果: `ffmpeg -i xx.mp3 -filter_complex afade=t=out:st=16:d=4 xx2.mp3`\n# GIF\n## 视频全部转换成gif\n- `ffmpeg -i 123.mp4 out.gif`\n## 截取部分片段\n- `ffmpeg -t 3 -ss 00:00:02 -i xx.mp4 xx.gif`\n## 增加GIF质量\n- `ffmpeg -i  OUTPUT_VIDEO.mp4 -b 2048k OUTPUT_VIDEO.gif`:尽可能高质量转换\n## 将GIF转成视频\n- `ffmpeg -f gif -i xx.gif xx.mp4`:将GIF转换为MP4\n## 设置循环次数\n默认是0,即无限循环\n`ffmpeg -ss 9 -t 5 -i xx.mp4 -loop 2 xx.gif`\n## 设置低分辨率\n`ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf scale=iw/2:-1:flags=lanczos 1.gif`\nscale=iw/2:-1:flags=lanczos（lanczos为缩放算法），将会设置gif图片的宽度为源视频一半，高度为比例缩放\n## 设置fps(每秒帧数)\n`ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf \"scale=iw/2:-1:flags=lanczos,fps=15\" 1.gif`\n## 视频画面的一半设成gif\n`ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf \"scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0\" 1.gif`\n可能我们只需要将视频画面的一部分转成gif图片，可以使用crop，具体为crop=宽度:高度:宽度起始:高度起始，比如crop=200:200:0:0，将会从横向0像素，纵向0像素开始，从画面裁剪200x200的区域。\n## 提高画面的质量\n`fmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf \"scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0,split[s1][s2];[s1]palettegen[p];[s2][p]paletteuse\" 1.gif`\n# 水印\n## 图片水印\n`ffmpeg -i xx.mp4 -vf \"movie=xx.png[wm];[in][wm]overlay=30:10[out]\" output.mp4`\n30:10代表图片的像素位置\n## 左下角添加gif动态水印\n`ffmpeg -y -i test2.mp4 -ignore_loop 0 -i test.gif  -filter_complex overlay=0:H-h test_out2.mp4`\n## 设置显示时间段\n`ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex \"overlay=enable='between(t,5,10)'\" out.mp4 -y`\n让水印在5-10s时间段显示\n## 设置两个水印轮番出现\n`ffmpeg -i big_buck_bunny.mp4 -i doggie1.png -i doggie2.png -filter_complex \"overlay=enable='lte(mod(t,10),4)',overlay=enable='gt(mod(t,10),6)'\" out.mp4 -y`\n上面的命令作用是：第一个水印显示4秒后消失，2秒后第二个水印显示4秒后消失。\n## 水印位置平移\n- `fmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi \"overlay=x=t*20\" -shortest out.mp4 -y`\n让水印每秒向右移动20像素，直到消失\n- `ffmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi \"overlay=enable=\\'mod(t,10)\\':x=\\'100*mod(t,10)-w\\'\" -shortest out.mp4 -y`\n设置水印每隔10秒从左向右移动直至消失\n## gif水印循环播放\n```bash\n第一种：设置gif的-ignore_loop为0，让gif保持循环播放即可，命令如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -filter_complex  overlay -shortest out.mp4 -y\n但是这种方式，只适用于gif格式的图像，如果滤镜是一小段视频就无能为力了。\n\n第二种：使用movie滤镜，同样是让gif循环播放，虽然这种方式复杂点，不过这种解决方案支持视频水印，命令如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -vf \"movie=doggie3.gif:loop=0,setpts=N/FRAME_RATE/TB[out];[0:v][out]overlay=x=main_w-overlay_w:y=0\" -shortest out.mp4 -y\n上面的命令有两个地方比较关键：\n\nloop=0,setpts=N/FRAME_RATE/TB ：设置水印gif无限循环\n-shortest ：将输出文件的时长设置为第一个视频文件的时长，如果不设置，你会发现命令会一直执行根本不会停下来，因为gif图的循环是无限的\n这样gif图/短视频就会一直不停的播放了。\n\n\n希望水印播放一次就不播放了，那就设置上面的eof_action为pass就可以了，如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie3.gif -filter_complex \"overlay=x=0:y=0:eof_action=pass\" out.mp4 -y\n\n如果视频一开始就播放且只播放一次，假如水印比较短可能根本就没被注意就过去了，这时可以设置水印出现的延迟时间，使用-itsoffset选项，如下：\nffmpeg -hide_banner -i big_buck_bunny.mp4 -itsoffset 3 -i doggie3.gif -filter_complex \"overlay=x=0:y=0:eof_action=pass\" out.mp4 -y\n这样，视频播放3秒后，水印才会出现。\n```\n## 水印旋转\n```bash\n如果想实现旋转的功能，需要使用ffmpeg过滤器的链式功能，即：先把作为水印的图片旋转，再覆盖到视频上。\n\n1. 水印旋转一次\nffmpeg -i buck.mp4 -i s1.jpg -lavfi \"[1:v]format=rgba,rotate='PI/6:c=0x00000000:ow=hypot(iw,ih):oh=ow'[out];[0:v][out]overlay=10:10\" out.mp4 -y\n\n思路是：\n调整水印宽高，根据勾股定律计算图片对角长度(hypot)，将这个值设置为水印的宽高，这样，图片无论如何旋转，都不会超过设定的宽高，也就不会出现图片部分丢失的情况了\n将图片显示的像素格式转换为rgba格式，如果做过前端的小伙伴会很熟悉的，最后的a表示透明度，如此一来，c=0x00000000的作用就是将图片旋转后的背景变为白色且完全透明，这样就不会遮挡视频了\n\n2. 让旋转停不下，具体命令如下：\nffmpeg -i buck.mp4 -loop 1 -i s1.jpg -lavfi \"[1:v]format=rgba,rotate='PI/2*t:c=0x00000000:ow=hypot(iw,ih):oh=ow'[out];[0:v][out]overlay=10:10\" -shortest out.mp4 -y\n这次水印图片前面添加了-loop 1，正常情况下水印图片默认在播放一次后就停下来，保留最后一帧，所以要让水印图片保持循环才行。\n```\n# 录屏及摄像头\n- `ffmpeg -devices`:列出音频设备及摄像头\n## 录屏命令\n`ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 -c:v libx264 output.mp4`\n- -f x11grab 指定使用X11grab设备作为输入。\n- -s [分辨率] 设置录制视频的分辨率，例如 1920x1080。不指定就是全屏\n- -r [帧率] 设置录制视频的帧率，例如 30。\n- -i :0.0 指定要捕获的X11屏幕。:0.0 通常表示第一个屏幕。如果你有多个屏幕或显示设置不同，这个值可能需要调整。\n- -c:v [编码器] 设置视频编码器，例如 libx264 用于H.264编码。\n- output.mp4 是输出文件的名称。\n## 录屏加声音\n`ffmpeg -f x11grab -i :0.0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame -s 1280x720 -r 15 xx.mp4`\nalsa使用于linux alsa声卡，`hw:2`是当前电脑上的设备，可以用`arecord -l`命令来显示设备，card几就hw:几\n## 摄像头\n`ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 xx.mkv`\n可以通过`v4l2-ctl --list-devices`来查看v4l2的设备，\n## 摄像头加声音\n`ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame xx.mkv`\n# 文字水印\n`ffmpeg -i xx.mp4 -vf \"drawtext=fontfile=simhei.ttf: text='hi,Nanbert':x=100:y=1fontsize=24fontcolor=white:shadowy=2\" output.mp4`\n- ontfile:字体类型\n- text:要添加的文字内容\n- fontsize:字体大小\n- fontcolor：字体颜色\n# 各种特效\n- 渐入:`ffmpeg -i in.mp4 -vf fade=in:0:90 out.mp4`\n- 黑白:`ffmpeg -i in.mp4 -vf lutyuv=\"u=128:v=128\" out.mp4`\n- 锐化:`ffmpeg -i in.mp4 -vf unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5 out.mp4`\n- 反锐化:`ffmpeg -i in.mp4 -vf unsharp=7:7:-2:7:7:-2 out.mp4`\n- 渐晕:`ffmpeg -i in.mp4 -vf vignette=PI/4 out.mp4`\n- 闪烁渐晕:`ffmpeg -i in.mp4 -vf vignette='PI/4+random(1)*PI/50':eval=frame out.mp4`\n- 视频颤抖:`ffmpeg -i in.mp4 -vf crop=\"in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2+((in_h-out_h)/2)*sin(n/7)\" out.mp4`\n- 色彩变幻:`ffmpeg -i in.mp4 -vf hue=\"H=2*PI*t:s=sin(2*PI*t)+1\" out.mp4`\n- 模糊处理:`ffmpeg -i in.mp4 -vf boxblur=5:1:cr=0:ar=0 out.mp4`\n- 镜像翻转:`ffmpeg -i in.mp4 -vf crop=iw/2:ih:0:0,split[left][tmp];[tmp]hflip[right];[left]pad=iw*2[a];[a][right]overlay=w out.mp4`\n- 水平翻转:`ffmpeg -i in.mp4 -vf geq=p(W-X\\\\,Y) out.mp4`\n- 垂直翻转:`ffmpeg -i in.mp4 -vf vflip out.mp4`\n- 浮雕效果:`ffmpeg -i in.mp4 -vf format=gray,geq=lum_expr='(p(X,Y)+(256-p(X-4,Y-4)))/2' out.mp4`\n- 均匀噪声:`ffmpeg -i in.mp4 -vf noise=alls=20:allf=t+u out.mp4`\n# 字幕\n- `ffmpeg -i xx.mp4 -vf ass=xx.ass -b:v 3000k xx.mp4`\n# 图片\n- 5秒处截图：`ffmpeg -ss 00:00:05 -i xx.mp4 xx.jpg -r 1 -vframes 1 -an -vodec mjpeg`\n- 每一帧输出图片：`ffmpeg -i xx.mp4 image_%d.jpg`\n- 图片转为视频：`ffmpeg -f image2 -i image_%d.jpg video.mpg`\n# 视频格式的默认编码\n- .avi: Audio Codec: mp3, Video Codec: mpeg4\n- .mkv: Audio Codec: ac3, Video Codec: H.264\n- .mov: Audio Codec: AAC, Video Codec: H.264\n- .mp4: Audio Codec: AAC, Video Codec: H.264\n- .mpg: Audio Codec: mp2, Video Codec: mpeg1video\n- .mxf: Audio Codec: pcm_s16le, Video Codec: mpeg2video\n- .wav: Audio Codec: pcm_s16le (16 bit PCM)\n# 链接\n[ffmprovisr](https://amiaopensource.github.io/ffmprovisr/#SD_HD)\n[ffmpeg中文教程](https://ffmpeg.xianwaizhiyin.net/)\n\n","slug":"ffmpeg","published":1,"updated":"2024-10-07T04:23:50.515Z","_id":"clwnyxndf0005qzq27hmldou6","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"视频剪裁\"><a href=\"#视频剪裁\" class=\"headerlink\" title=\"视频剪裁\"></a>视频剪裁</h1><ul>\n<li>裁剪:<code>ffmpeg -i xx.mp4 -vcodec copy -acodec copy -ss 00:00:00 -to 01:18:08 output.mp4</code></li>\n</ul>\n<h2 id=\"精确剪切\"><a href=\"#精确剪切\" class=\"headerlink\" title=\"精确剪切\"></a>精确剪切</h2><p>ffmpeg 会在你输入的时间点附近调整到最接近的关键帧处，这会导致时间不准确，可以先转换为帧内编码（每一帧都是关键帧）<br><code>ffmpeg -i xx.flv -strict -2 -qscale 0 -intra xx2.flv</code></p>\n<h1 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并:\"></a>合并:</h1><h2 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h2><p> 先建立个文本文档file,格式如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">file <span class=\"hljs-string\">&#x27;1.mp4&#x27;</span><br>file <span class=\"hljs-string\">&#x27;2.mp4&#x27;</span><br></code></pre></td></tr></table></figure>\n<p><code>ffmpeg -f concat -i file -c copy output.mkv</code><br>或者支持不好先转换ts<br><code>ffmpeg -i 1.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 1.ts</code></p>\n<p><code>ffmpeg -i 2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 2.ts</code></p>\n<p><code>ffmpeg -i &quot;concat:1.ts|2.ts&quot; -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4</code></p>\n<h2 id=\"重新编码合并\"><a href=\"#重新编码合并\" class=\"headerlink\" title=\"重新编码合并\"></a>重新编码合并</h2><p>适用不同编码<br><code>ffmpeg -i input1.mp4 -i input2.webm -i input3.avi -filter_complex &#39;[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] concat=n=3:v=1:a=1 [v] [a]&#39; -map &#39;[v]&#39; -map &#39;[a]&#39; &lt;编码器选项&gt; output.mkv</code><br>[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] 分别表示第一个输入文件的视频、音频、第二个输入文件的视频、音频、第三个输入文件的视频、音频。concat&#x3D;n&#x3D;3:v&#x3D;1:a&#x3D;1 表示有三个输入文件，输出一条视频流和一条音频流。[v] [a] 就是得到的视频流和音频流的名字，注意在 bash 等 shell 中需要用引号，防止通配符扩展。</p>\n<h1 id=\"视频倒放\"><a href=\"#视频倒放\" class=\"headerlink\" title=\"视频倒放\"></a>视频倒放</h1><h2 id=\"视频倒放，无音频\"><a href=\"#视频倒放，无音频\" class=\"headerlink\" title=\"视频倒放，无音频\"></a>视频倒放，无音频</h2><p><code>ffmpeg -i 123.mp4 -filter_complex [0:v]reverse[v] -map [v] -preset superfast out.mp4 </code></p>\n<h2 id=\"视频倒放，音频不变\"><a href=\"#视频倒放，音频不变\" class=\"headerlink\" title=\"视频倒放，音频不变\"></a>视频倒放，音频不变</h2><p><code>ffmpeg -i 123.mp4 -vf reverse out.mp4</code></p>\n<h2 id=\"音频倒放，视频不变\"><a href=\"#音频倒放，视频不变\" class=\"headerlink\" title=\"音频倒放，视频不变\"></a>音频倒放，视频不变</h2><p><code>ffmpeg -i 123.mp4 -map 0 -c:v copy -af &quot;areverse&quot; out.mp4</code></p>\n<h2 id=\"音视频同时倒放\"><a href=\"#音视频同时倒放\" class=\"headerlink\" title=\"音视频同时倒放\"></a>音视频同时倒放</h2><p><code>fmpeg -i 123.mp4 -vf reverse -af areverse -preset superfast out.mp4</code></p>\n<h1 id=\"视频格式转换\"><a href=\"#视频格式转换\" class=\"headerlink\" title=\"视频格式转换\"></a>视频格式转换</h1><ul>\n<li>rmvb-&gt;mp4:<br><code>ffmpeg -i name1.rmvb -c:v libx264 -strict -2 name2.mp4 </code></li>\n</ul>\n<h1 id=\"字幕\"><a href=\"#字幕\" class=\"headerlink\" title=\"字幕\"></a>字幕</h1><ul>\n<li>添加字幕:<br><code>ffmpeg -i 2020-07-13\\ 08-20-26.mkv -vf subtitles=test.srt -y output.mkv</code><br>srt格式:<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">1</span><br><span class=\"hljs-attribute\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">03</span>,<span class=\"hljs-number\">000</span> --&gt; <span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">06</span>,<span class=\"hljs-number\">000</span><br><span class=\"hljs-attribute\">Hi</span>,I am Nanbert Don De Niro<br><br><span class=\"hljs-attribute\">2</span><br><span class=\"hljs-attribute\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">06</span>,<span class=\"hljs-number\">000</span> --&gt; <span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">08</span>,<span class=\"hljs-number\">000</span><br><span class=\"hljs-attribute\">Hi</span>,I am Donald Trump<br>  <br><span class=\"hljs-attribute\">3</span><br><span class=\"hljs-attribute\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">08</span>,<span class=\"hljs-number\">444</span> --&gt; <span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">000</span><br><span class=\"hljs-attribute\">It</span>&#x27;s you,Assole!<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"视频与声音\"><a href=\"#视频与声音\" class=\"headerlink\" title=\"视频与声音\"></a>视频与声音</h1><ul>\n<li>静音:<code>ffmpeg -i 10.mp4 -af &quot;volume=0&quot; 10Silent.mp4</code></li>\n<li>静音一部分:<code>ffmpeg -i 10.mp4 -af &quot;volume=enable=&#39;between(t,0,8)&#39;:volume=0&quot; 10Silent.mp4</code></li>\n<li>去掉原声:<code>ffmpeg -i 12.mp4 -c:v copy -an xx.mp4</code></li>\n<li>合并指定音频:<code>ffmpeg -i out.mp4 -i xx.mp3 xx.mp4</code></li>\n<li>指定合成时间：<code>ffmpeg -i out.mp4 -i xx.mp3 -t 30 xx.mp4</code></li>\n<li>保留视频原声并添加新音频:<code>ffmpeg -i xx.mp3 -i 22.mp4 -filter_complex amix=inputs=2 output.mp4</code></li>\n<li>替换原来的音频：<code>ffmpeg -i xx.wav -i xx.flv -shortest -c copy xx.flv</code></li>\n<li>提取音频：<code>ffmpeg -i xx.flv -vn -acodec copy xx.wav</code></li>\n<li>调整音量：<code>ffmpeg -i input.wav -af &#39;volume=1.5&#39; xx.wav</code></li>\n</ul>\n<h1 id=\"流媒体\"><a href=\"#流媒体\" class=\"headerlink\" title=\"流媒体\"></a>流媒体</h1><ul>\n<li>一边播放一边保存流媒体:<code>ffmpeg -i host/input.m3u8 -c copy out.mkv -c copy -f matroska - | ffplay - </code></li>\n</ul>\n<h1 id=\"音频\"><a href=\"#音频\" class=\"headerlink\" title=\"音频\"></a>音频</h1><ul>\n<li>波形图模式：<code>ffplay -showmode 1 xx.mp3</code></li>\n<li>频谱图模式：<code>ffplay -showmode 2 xx.mp3</code></li>\n<li>音频淡出效果: <code>ffmpeg -i xx.mp3 -filter_complex afade=t=out:st=16:d=4 xx2.mp3</code></li>\n</ul>\n<h1 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h1><h2 id=\"视频全部转换成gif\"><a href=\"#视频全部转换成gif\" class=\"headerlink\" title=\"视频全部转换成gif\"></a>视频全部转换成gif</h2><ul>\n<li><code>ffmpeg -i 123.mp4 out.gif</code></li>\n</ul>\n<h2 id=\"截取部分片段\"><a href=\"#截取部分片段\" class=\"headerlink\" title=\"截取部分片段\"></a>截取部分片段</h2><ul>\n<li><code>ffmpeg -t 3 -ss 00:00:02 -i xx.mp4 xx.gif</code></li>\n</ul>\n<h2 id=\"增加GIF质量\"><a href=\"#增加GIF质量\" class=\"headerlink\" title=\"增加GIF质量\"></a>增加GIF质量</h2><ul>\n<li><code>ffmpeg -i  OUTPUT_VIDEO.mp4 -b 2048k OUTPUT_VIDEO.gif</code>:尽可能高质量转换</li>\n</ul>\n<h2 id=\"将GIF转成视频\"><a href=\"#将GIF转成视频\" class=\"headerlink\" title=\"将GIF转成视频\"></a>将GIF转成视频</h2><ul>\n<li><code>ffmpeg -f gif -i xx.gif xx.mp4</code>:将GIF转换为MP4</li>\n</ul>\n<h2 id=\"设置循环次数\"><a href=\"#设置循环次数\" class=\"headerlink\" title=\"设置循环次数\"></a>设置循环次数</h2><p>默认是0,即无限循环<br><code>ffmpeg -ss 9 -t 5 -i xx.mp4 -loop 2 xx.gif</code></p>\n<h2 id=\"设置低分辨率\"><a href=\"#设置低分辨率\" class=\"headerlink\" title=\"设置低分辨率\"></a>设置低分辨率</h2><p><code>ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf scale=iw/2:-1:flags=lanczos 1.gif</code><br>scale&#x3D;iw&#x2F;2:-1:flags&#x3D;lanczos（lanczos为缩放算法），将会设置gif图片的宽度为源视频一半，高度为比例缩放</p>\n<h2 id=\"设置fps-每秒帧数\"><a href=\"#设置fps-每秒帧数\" class=\"headerlink\" title=\"设置fps(每秒帧数)\"></a>设置fps(每秒帧数)</h2><p><code>ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf &quot;scale=iw/2:-1:flags=lanczos,fps=15&quot; 1.gif</code></p>\n<h2 id=\"视频画面的一半设成gif\"><a href=\"#视频画面的一半设成gif\" class=\"headerlink\" title=\"视频画面的一半设成gif\"></a>视频画面的一半设成gif</h2><p><code>ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf &quot;scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0&quot; 1.gif</code><br>可能我们只需要将视频画面的一部分转成gif图片，可以使用crop，具体为crop&#x3D;宽度:高度:宽度起始:高度起始，比如crop&#x3D;200:200:0:0，将会从横向0像素，纵向0像素开始，从画面裁剪200x200的区域。</p>\n<h2 id=\"提高画面的质量\"><a href=\"#提高画面的质量\" class=\"headerlink\" title=\"提高画面的质量\"></a>提高画面的质量</h2><p><code>fmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf &quot;scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0,split[s1][s2];[s1]palettegen[p];[s2][p]paletteuse&quot; 1.gif</code></p>\n<h1 id=\"水印\"><a href=\"#水印\" class=\"headerlink\" title=\"水印\"></a>水印</h1><h2 id=\"图片水印\"><a href=\"#图片水印\" class=\"headerlink\" title=\"图片水印\"></a>图片水印</h2><p><code>ffmpeg -i xx.mp4 -vf &quot;movie=xx.png[wm];[in][wm]overlay=30:10[out]&quot; output.mp4</code><br>30:10代表图片的像素位置</p>\n<h2 id=\"左下角添加gif动态水印\"><a href=\"#左下角添加gif动态水印\" class=\"headerlink\" title=\"左下角添加gif动态水印\"></a>左下角添加gif动态水印</h2><p><code>ffmpeg -y -i test2.mp4 -ignore_loop 0 -i test.gif  -filter_complex overlay=0:H-h test_out2.mp4</code></p>\n<h2 id=\"设置显示时间段\"><a href=\"#设置显示时间段\" class=\"headerlink\" title=\"设置显示时间段\"></a>设置显示时间段</h2><p><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=enable=&#39;between(t,5,10)&#39;&quot; out.mp4 -y</code><br>让水印在5-10s时间段显示</p>\n<h2 id=\"设置两个水印轮番出现\"><a href=\"#设置两个水印轮番出现\" class=\"headerlink\" title=\"设置两个水印轮番出现\"></a>设置两个水印轮番出现</h2><p><code>ffmpeg -i big_buck_bunny.mp4 -i doggie1.png -i doggie2.png -filter_complex &quot;overlay=enable=&#39;lte(mod(t,10),4)&#39;,overlay=enable=&#39;gt(mod(t,10),6)&#39;&quot; out.mp4 -y</code><br>上面的命令作用是：第一个水印显示4秒后消失，2秒后第二个水印显示4秒后消失。</p>\n<h2 id=\"水印位置平移\"><a href=\"#水印位置平移\" class=\"headerlink\" title=\"水印位置平移\"></a>水印位置平移</h2><ul>\n<li><code>fmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi &quot;overlay=x=t*20&quot; -shortest out.mp4 -y</code><br>让水印每秒向右移动20像素，直到消失</li>\n<li><code>ffmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi &quot;overlay=enable=\\&#39;mod(t,10)\\&#39;:x=\\&#39;100*mod(t,10)-w\\&#39;&quot; -shortest out.mp4 -y</code><br>设置水印每隔10秒从左向右移动直至消失</li>\n</ul>\n<h2 id=\"gif水印循环播放\"><a href=\"#gif水印循环播放\" class=\"headerlink\" title=\"gif水印循环播放\"></a>gif水印循环播放</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">第一种：设置gif的-ignore_loop为0，让gif保持循环播放即可，命令如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -filter_complex  overlay -shortest out.mp4 -y<br>但是这种方式，只适用于gif格式的图像，如果滤镜是一小段视频就无能为力了。<br><br>第二种：使用movie滤镜，同样是让gif循环播放，虽然这种方式复杂点，不过这种解决方案支持视频水印，命令如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -vf <span class=\"hljs-string\">&quot;movie=doggie3.gif:loop=0,setpts=N/FRAME_RATE/TB[out];[0:v][out]overlay=x=main_w-overlay_w:y=0&quot;</span> -shortest out.mp4 -y<br>上面的命令有两个地方比较关键：<br><br>loop=0,setpts=N/FRAME_RATE/TB ：设置水印gif无限循环<br>-shortest ：将输出文件的时长设置为第一个视频文件的时长，如果不设置，你会发现命令会一直执行根本不会停下来，因为gif图的循环是无限的<br>这样gif图/短视频就会一直不停的播放了。<br><br><br>希望水印播放一次就不播放了，那就设置上面的eof_action为pass就可以了，如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie3.gif -filter_complex <span class=\"hljs-string\">&quot;overlay=x=0:y=0:eof_action=pass&quot;</span> out.mp4 -y<br><br>如果视频一开始就播放且只播放一次，假如水印比较短可能根本就没被注意就过去了，这时可以设置水印出现的延迟时间，使用-itsoffset选项，如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -itsoffset 3 -i doggie3.gif -filter_complex <span class=\"hljs-string\">&quot;overlay=x=0:y=0:eof_action=pass&quot;</span> out.mp4 -y<br>这样，视频播放3秒后，水印才会出现。<br></code></pre></td></tr></table></figure>\n<h2 id=\"水印旋转\"><a href=\"#水印旋转\" class=\"headerlink\" title=\"水印旋转\"></a>水印旋转</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">如果想实现旋转的功能，需要使用ffmpeg过滤器的链式功能，即：先把作为水印的图片旋转，再覆盖到视频上。<br><br>1. 水印旋转一次<br>ffmpeg -i buck.mp4 -i s1.jpg -lavfi <span class=\"hljs-string\">&quot;[1:v]format=rgba,rotate=&#x27;PI/6:c=0x00000000:ow=hypot(iw,ih):oh=ow&#x27;[out];[0:v][out]overlay=10:10&quot;</span> out.mp4 -y<br><br>思路是：<br>调整水印宽高，根据勾股定律计算图片对角长度(hypot)，将这个值设置为水印的宽高，这样，图片无论如何旋转，都不会超过设定的宽高，也就不会出现图片部分丢失的情况了<br>将图片显示的像素格式转换为rgba格式，如果做过前端的小伙伴会很熟悉的，最后的a表示透明度，如此一来，c=0x00000000的作用就是将图片旋转后的背景变为白色且完全透明，这样就不会遮挡视频了<br><br>2. 让旋转停不下，具体命令如下：<br>ffmpeg -i buck.mp4 -loop 1 -i s1.jpg -lavfi <span class=\"hljs-string\">&quot;[1:v]format=rgba,rotate=&#x27;PI/2*t:c=0x00000000:ow=hypot(iw,ih):oh=ow&#x27;[out];[0:v][out]overlay=10:10&quot;</span> -shortest out.mp4 -y<br>这次水印图片前面添加了-loop 1，正常情况下水印图片默认在播放一次后就停下来，保留最后一帧，所以要让水印图片保持循环才行。<br></code></pre></td></tr></table></figure>\n<h1 id=\"录屏及摄像头\"><a href=\"#录屏及摄像头\" class=\"headerlink\" title=\"录屏及摄像头\"></a>录屏及摄像头</h1><ul>\n<li><code>ffmpeg -devices</code>:列出音频设备及摄像头</li>\n</ul>\n<h2 id=\"录屏命令\"><a href=\"#录屏命令\" class=\"headerlink\" title=\"录屏命令\"></a>录屏命令</h2><p><code>ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 -c:v libx264 output.mp4</code></p>\n<ul>\n<li>-f x11grab 指定使用X11grab设备作为输入。</li>\n<li>-s [分辨率] 设置录制视频的分辨率，例如 1920x1080。不指定就是全屏</li>\n<li>-r [帧率] 设置录制视频的帧率，例如 30。</li>\n<li>-i :0.0 指定要捕获的X11屏幕。:0.0 通常表示第一个屏幕。如果你有多个屏幕或显示设置不同，这个值可能需要调整。</li>\n<li>-c:v [编码器] 设置视频编码器，例如 libx264 用于H.264编码。</li>\n<li>output.mp4 是输出文件的名称。</li>\n</ul>\n<h2 id=\"录屏加声音\"><a href=\"#录屏加声音\" class=\"headerlink\" title=\"录屏加声音\"></a>录屏加声音</h2><p><code>ffmpeg -f x11grab -i :0.0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame -s 1280x720 -r 15 xx.mp4</code><br>alsa使用于linux alsa声卡，<code>hw:2</code>是当前电脑上的设备，可以用<code>arecord -l</code>命令来显示设备，card几就hw:几</p>\n<h2 id=\"摄像头\"><a href=\"#摄像头\" class=\"headerlink\" title=\"摄像头\"></a>摄像头</h2><p><code>ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 xx.mkv</code><br>可以通过<code>v4l2-ctl --list-devices</code>来查看v4l2的设备，</p>\n<h2 id=\"摄像头加声音\"><a href=\"#摄像头加声音\" class=\"headerlink\" title=\"摄像头加声音\"></a>摄像头加声音</h2><p><code>ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame xx.mkv</code></p>\n<h1 id=\"文字水印\"><a href=\"#文字水印\" class=\"headerlink\" title=\"文字水印\"></a>文字水印</h1><p><code>ffmpeg -i xx.mp4 -vf &quot;drawtext=fontfile=simhei.ttf: text=&#39;hi,Nanbert&#39;:x=100:y=1fontsize=24fontcolor=white:shadowy=2&quot; output.mp4</code></p>\n<ul>\n<li>ontfile:字体类型</li>\n<li>text:要添加的文字内容</li>\n<li>fontsize:字体大小</li>\n<li>fontcolor：字体颜色</li>\n</ul>\n<h1 id=\"各种特效\"><a href=\"#各种特效\" class=\"headerlink\" title=\"各种特效\"></a>各种特效</h1><ul>\n<li>渐入:<code>ffmpeg -i in.mp4 -vf fade=in:0:90 out.mp4</code></li>\n<li>黑白:<code>ffmpeg -i in.mp4 -vf lutyuv=&quot;u=128:v=128&quot; out.mp4</code></li>\n<li>锐化:<code>ffmpeg -i in.mp4 -vf unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5 out.mp4</code></li>\n<li>反锐化:<code>ffmpeg -i in.mp4 -vf unsharp=7:7:-2:7:7:-2 out.mp4</code></li>\n<li>渐晕:<code>ffmpeg -i in.mp4 -vf vignette=PI/4 out.mp4</code></li>\n<li>闪烁渐晕:<code>ffmpeg -i in.mp4 -vf vignette=&#39;PI/4+random(1)*PI/50&#39;:eval=frame out.mp4</code></li>\n<li>视频颤抖:<code>ffmpeg -i in.mp4 -vf crop=&quot;in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2+((in_h-out_h)/2)*sin(n/7)&quot; out.mp4</code></li>\n<li>色彩变幻:<code>ffmpeg -i in.mp4 -vf hue=&quot;H=2*PI*t:s=sin(2*PI*t)+1&quot; out.mp4</code></li>\n<li>模糊处理:<code>ffmpeg -i in.mp4 -vf boxblur=5:1:cr=0:ar=0 out.mp4</code></li>\n<li>镜像翻转:<code>ffmpeg -i in.mp4 -vf crop=iw/2:ih:0:0,split[left][tmp];[tmp]hflip[right];[left]pad=iw*2[a];[a][right]overlay=w out.mp4</code></li>\n<li>水平翻转:<code>ffmpeg -i in.mp4 -vf geq=p(W-X\\\\,Y) out.mp4</code></li>\n<li>垂直翻转:<code>ffmpeg -i in.mp4 -vf vflip out.mp4</code></li>\n<li>浮雕效果:<code>ffmpeg -i in.mp4 -vf format=gray,geq=lum_expr=&#39;(p(X,Y)+(256-p(X-4,Y-4)))/2&#39; out.mp4</code></li>\n<li>均匀噪声:<code>ffmpeg -i in.mp4 -vf noise=alls=20:allf=t+u out.mp4</code></li>\n</ul>\n<h1 id=\"字幕-1\"><a href=\"#字幕-1\" class=\"headerlink\" title=\"字幕\"></a>字幕</h1><ul>\n<li><code>ffmpeg -i xx.mp4 -vf ass=xx.ass -b:v 3000k xx.mp4</code></li>\n</ul>\n<h1 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h1><ul>\n<li>5秒处截图：<code>ffmpeg -ss 00:00:05 -i xx.mp4 xx.jpg -r 1 -vframes 1 -an -vodec mjpeg</code></li>\n<li>每一帧输出图片：<code>ffmpeg -i xx.mp4 image_%d.jpg</code></li>\n<li>图片转为视频：<code>ffmpeg -f image2 -i image_%d.jpg video.mpg</code></li>\n</ul>\n<h1 id=\"视频格式的默认编码\"><a href=\"#视频格式的默认编码\" class=\"headerlink\" title=\"视频格式的默认编码\"></a>视频格式的默认编码</h1><ul>\n<li>.avi: Audio Codec: mp3, Video Codec: mpeg4</li>\n<li>.mkv: Audio Codec: ac3, Video Codec: H.264</li>\n<li>.mov: Audio Codec: AAC, Video Codec: H.264</li>\n<li>.mp4: Audio Codec: AAC, Video Codec: H.264</li>\n<li>.mpg: Audio Codec: mp2, Video Codec: mpeg1video</li>\n<li>.mxf: Audio Codec: pcm_s16le, Video Codec: mpeg2video</li>\n<li>.wav: Audio Codec: pcm_s16le (16 bit PCM)</li>\n</ul>\n<h1 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h1><p><a href=\"https://amiaopensource.github.io/ffmprovisr/#SD_HD\">ffmprovisr</a><br><a href=\"https://ffmpeg.xianwaizhiyin.net/\">ffmpeg中文教程</a></p>\n","excerpt":"","more":"<h1 id=\"视频剪裁\"><a href=\"#视频剪裁\" class=\"headerlink\" title=\"视频剪裁\"></a>视频剪裁</h1><ul>\n<li>裁剪:<code>ffmpeg -i xx.mp4 -vcodec copy -acodec copy -ss 00:00:00 -to 01:18:08 output.mp4</code></li>\n</ul>\n<h2 id=\"精确剪切\"><a href=\"#精确剪切\" class=\"headerlink\" title=\"精确剪切\"></a>精确剪切</h2><p>ffmpeg 会在你输入的时间点附近调整到最接近的关键帧处，这会导致时间不准确，可以先转换为帧内编码（每一帧都是关键帧）<br><code>ffmpeg -i xx.flv -strict -2 -qscale 0 -intra xx2.flv</code></p>\n<h1 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并:\"></a>合并:</h1><h2 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h2><p> 先建立个文本文档file,格式如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">file <span class=\"hljs-string\">&#x27;1.mp4&#x27;</span><br>file <span class=\"hljs-string\">&#x27;2.mp4&#x27;</span><br></code></pre></td></tr></table></figure>\n<p><code>ffmpeg -f concat -i file -c copy output.mkv</code><br>或者支持不好先转换ts<br><code>ffmpeg -i 1.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 1.ts</code></p>\n<p><code>ffmpeg -i 2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 2.ts</code></p>\n<p><code>ffmpeg -i &quot;concat:1.ts|2.ts&quot; -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4</code></p>\n<h2 id=\"重新编码合并\"><a href=\"#重新编码合并\" class=\"headerlink\" title=\"重新编码合并\"></a>重新编码合并</h2><p>适用不同编码<br><code>ffmpeg -i input1.mp4 -i input2.webm -i input3.avi -filter_complex &#39;[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] concat=n=3:v=1:a=1 [v] [a]&#39; -map &#39;[v]&#39; -map &#39;[a]&#39; &lt;编码器选项&gt; output.mkv</code><br>[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] 分别表示第一个输入文件的视频、音频、第二个输入文件的视频、音频、第三个输入文件的视频、音频。concat&#x3D;n&#x3D;3:v&#x3D;1:a&#x3D;1 表示有三个输入文件，输出一条视频流和一条音频流。[v] [a] 就是得到的视频流和音频流的名字，注意在 bash 等 shell 中需要用引号，防止通配符扩展。</p>\n<h1 id=\"视频倒放\"><a href=\"#视频倒放\" class=\"headerlink\" title=\"视频倒放\"></a>视频倒放</h1><h2 id=\"视频倒放，无音频\"><a href=\"#视频倒放，无音频\" class=\"headerlink\" title=\"视频倒放，无音频\"></a>视频倒放，无音频</h2><p><code>ffmpeg -i 123.mp4 -filter_complex [0:v]reverse[v] -map [v] -preset superfast out.mp4 </code></p>\n<h2 id=\"视频倒放，音频不变\"><a href=\"#视频倒放，音频不变\" class=\"headerlink\" title=\"视频倒放，音频不变\"></a>视频倒放，音频不变</h2><p><code>ffmpeg -i 123.mp4 -vf reverse out.mp4</code></p>\n<h2 id=\"音频倒放，视频不变\"><a href=\"#音频倒放，视频不变\" class=\"headerlink\" title=\"音频倒放，视频不变\"></a>音频倒放，视频不变</h2><p><code>ffmpeg -i 123.mp4 -map 0 -c:v copy -af &quot;areverse&quot; out.mp4</code></p>\n<h2 id=\"音视频同时倒放\"><a href=\"#音视频同时倒放\" class=\"headerlink\" title=\"音视频同时倒放\"></a>音视频同时倒放</h2><p><code>fmpeg -i 123.mp4 -vf reverse -af areverse -preset superfast out.mp4</code></p>\n<h1 id=\"视频格式转换\"><a href=\"#视频格式转换\" class=\"headerlink\" title=\"视频格式转换\"></a>视频格式转换</h1><ul>\n<li>rmvb-&gt;mp4:<br><code>ffmpeg -i name1.rmvb -c:v libx264 -strict -2 name2.mp4 </code></li>\n</ul>\n<h1 id=\"字幕\"><a href=\"#字幕\" class=\"headerlink\" title=\"字幕\"></a>字幕</h1><ul>\n<li>添加字幕:<br><code>ffmpeg -i 2020-07-13\\ 08-20-26.mkv -vf subtitles=test.srt -y output.mkv</code><br>srt格式:<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">1</span><br><span class=\"hljs-attribute\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">03</span>,<span class=\"hljs-number\">000</span> --&gt; <span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">06</span>,<span class=\"hljs-number\">000</span><br><span class=\"hljs-attribute\">Hi</span>,I am Nanbert Don De Niro<br><br><span class=\"hljs-attribute\">2</span><br><span class=\"hljs-attribute\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">06</span>,<span class=\"hljs-number\">000</span> --&gt; <span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">08</span>,<span class=\"hljs-number\">000</span><br><span class=\"hljs-attribute\">Hi</span>,I am Donald Trump<br>  <br><span class=\"hljs-attribute\">3</span><br><span class=\"hljs-attribute\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">08</span>,<span class=\"hljs-number\">444</span> --&gt; <span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">00</span>:<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">000</span><br><span class=\"hljs-attribute\">It</span>&#x27;s you,Assole!<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"视频与声音\"><a href=\"#视频与声音\" class=\"headerlink\" title=\"视频与声音\"></a>视频与声音</h1><ul>\n<li>静音:<code>ffmpeg -i 10.mp4 -af &quot;volume=0&quot; 10Silent.mp4</code></li>\n<li>静音一部分:<code>ffmpeg -i 10.mp4 -af &quot;volume=enable=&#39;between(t,0,8)&#39;:volume=0&quot; 10Silent.mp4</code></li>\n<li>去掉原声:<code>ffmpeg -i 12.mp4 -c:v copy -an xx.mp4</code></li>\n<li>合并指定音频:<code>ffmpeg -i out.mp4 -i xx.mp3 xx.mp4</code></li>\n<li>指定合成时间：<code>ffmpeg -i out.mp4 -i xx.mp3 -t 30 xx.mp4</code></li>\n<li>保留视频原声并添加新音频:<code>ffmpeg -i xx.mp3 -i 22.mp4 -filter_complex amix=inputs=2 output.mp4</code></li>\n<li>替换原来的音频：<code>ffmpeg -i xx.wav -i xx.flv -shortest -c copy xx.flv</code></li>\n<li>提取音频：<code>ffmpeg -i xx.flv -vn -acodec copy xx.wav</code></li>\n<li>调整音量：<code>ffmpeg -i input.wav -af &#39;volume=1.5&#39; xx.wav</code></li>\n</ul>\n<h1 id=\"流媒体\"><a href=\"#流媒体\" class=\"headerlink\" title=\"流媒体\"></a>流媒体</h1><ul>\n<li>一边播放一边保存流媒体:<code>ffmpeg -i host/input.m3u8 -c copy out.mkv -c copy -f matroska - | ffplay - </code></li>\n</ul>\n<h1 id=\"音频\"><a href=\"#音频\" class=\"headerlink\" title=\"音频\"></a>音频</h1><ul>\n<li>波形图模式：<code>ffplay -showmode 1 xx.mp3</code></li>\n<li>频谱图模式：<code>ffplay -showmode 2 xx.mp3</code></li>\n<li>音频淡出效果: <code>ffmpeg -i xx.mp3 -filter_complex afade=t=out:st=16:d=4 xx2.mp3</code></li>\n</ul>\n<h1 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h1><h2 id=\"视频全部转换成gif\"><a href=\"#视频全部转换成gif\" class=\"headerlink\" title=\"视频全部转换成gif\"></a>视频全部转换成gif</h2><ul>\n<li><code>ffmpeg -i 123.mp4 out.gif</code></li>\n</ul>\n<h2 id=\"截取部分片段\"><a href=\"#截取部分片段\" class=\"headerlink\" title=\"截取部分片段\"></a>截取部分片段</h2><ul>\n<li><code>ffmpeg -t 3 -ss 00:00:02 -i xx.mp4 xx.gif</code></li>\n</ul>\n<h2 id=\"增加GIF质量\"><a href=\"#增加GIF质量\" class=\"headerlink\" title=\"增加GIF质量\"></a>增加GIF质量</h2><ul>\n<li><code>ffmpeg -i  OUTPUT_VIDEO.mp4 -b 2048k OUTPUT_VIDEO.gif</code>:尽可能高质量转换</li>\n</ul>\n<h2 id=\"将GIF转成视频\"><a href=\"#将GIF转成视频\" class=\"headerlink\" title=\"将GIF转成视频\"></a>将GIF转成视频</h2><ul>\n<li><code>ffmpeg -f gif -i xx.gif xx.mp4</code>:将GIF转换为MP4</li>\n</ul>\n<h2 id=\"设置循环次数\"><a href=\"#设置循环次数\" class=\"headerlink\" title=\"设置循环次数\"></a>设置循环次数</h2><p>默认是0,即无限循环<br><code>ffmpeg -ss 9 -t 5 -i xx.mp4 -loop 2 xx.gif</code></p>\n<h2 id=\"设置低分辨率\"><a href=\"#设置低分辨率\" class=\"headerlink\" title=\"设置低分辨率\"></a>设置低分辨率</h2><p><code>ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf scale=iw/2:-1:flags=lanczos 1.gif</code><br>scale&#x3D;iw&#x2F;2:-1:flags&#x3D;lanczos（lanczos为缩放算法），将会设置gif图片的宽度为源视频一半，高度为比例缩放</p>\n<h2 id=\"设置fps-每秒帧数\"><a href=\"#设置fps-每秒帧数\" class=\"headerlink\" title=\"设置fps(每秒帧数)\"></a>设置fps(每秒帧数)</h2><p><code>ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf &quot;scale=iw/2:-1:flags=lanczos,fps=15&quot; 1.gif</code></p>\n<h2 id=\"视频画面的一半设成gif\"><a href=\"#视频画面的一半设成gif\" class=\"headerlink\" title=\"视频画面的一半设成gif\"></a>视频画面的一半设成gif</h2><p><code>ffmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf &quot;scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0&quot; 1.gif</code><br>可能我们只需要将视频画面的一部分转成gif图片，可以使用crop，具体为crop&#x3D;宽度:高度:宽度起始:高度起始，比如crop&#x3D;200:200:0:0，将会从横向0像素，纵向0像素开始，从画面裁剪200x200的区域。</p>\n<h2 id=\"提高画面的质量\"><a href=\"#提高画面的质量\" class=\"headerlink\" title=\"提高画面的质量\"></a>提高画面的质量</h2><p><code>fmpeg -ss 9 -t 5 -i 1.mp4 -loop 0 -vf &quot;scale=iw/2:-1:flags=lanczos,fps=15,crop=iw/2:ih:0:0,split[s1][s2];[s1]palettegen[p];[s2][p]paletteuse&quot; 1.gif</code></p>\n<h1 id=\"水印\"><a href=\"#水印\" class=\"headerlink\" title=\"水印\"></a>水印</h1><h2 id=\"图片水印\"><a href=\"#图片水印\" class=\"headerlink\" title=\"图片水印\"></a>图片水印</h2><p><code>ffmpeg -i xx.mp4 -vf &quot;movie=xx.png[wm];[in][wm]overlay=30:10[out]&quot; output.mp4</code><br>30:10代表图片的像素位置</p>\n<h2 id=\"左下角添加gif动态水印\"><a href=\"#左下角添加gif动态水印\" class=\"headerlink\" title=\"左下角添加gif动态水印\"></a>左下角添加gif动态水印</h2><p><code>ffmpeg -y -i test2.mp4 -ignore_loop 0 -i test.gif  -filter_complex overlay=0:H-h test_out2.mp4</code></p>\n<h2 id=\"设置显示时间段\"><a href=\"#设置显示时间段\" class=\"headerlink\" title=\"设置显示时间段\"></a>设置显示时间段</h2><p><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=enable=&#39;between(t,5,10)&#39;&quot; out.mp4 -y</code><br>让水印在5-10s时间段显示</p>\n<h2 id=\"设置两个水印轮番出现\"><a href=\"#设置两个水印轮番出现\" class=\"headerlink\" title=\"设置两个水印轮番出现\"></a>设置两个水印轮番出现</h2><p><code>ffmpeg -i big_buck_bunny.mp4 -i doggie1.png -i doggie2.png -filter_complex &quot;overlay=enable=&#39;lte(mod(t,10),4)&#39;,overlay=enable=&#39;gt(mod(t,10),6)&#39;&quot; out.mp4 -y</code><br>上面的命令作用是：第一个水印显示4秒后消失，2秒后第二个水印显示4秒后消失。</p>\n<h2 id=\"水印位置平移\"><a href=\"#水印位置平移\" class=\"headerlink\" title=\"水印位置平移\"></a>水印位置平移</h2><ul>\n<li><code>fmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi &quot;overlay=x=t*20&quot; -shortest out.mp4 -y</code><br>让水印每秒向右移动20像素，直到消失</li>\n<li><code>ffmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi &quot;overlay=enable=\\&#39;mod(t,10)\\&#39;:x=\\&#39;100*mod(t,10)-w\\&#39;&quot; -shortest out.mp4 -y</code><br>设置水印每隔10秒从左向右移动直至消失</li>\n</ul>\n<h2 id=\"gif水印循环播放\"><a href=\"#gif水印循环播放\" class=\"headerlink\" title=\"gif水印循环播放\"></a>gif水印循环播放</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">第一种：设置gif的-ignore_loop为0，让gif保持循环播放即可，命令如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -filter_complex  overlay -shortest out.mp4 -y<br>但是这种方式，只适用于gif格式的图像，如果滤镜是一小段视频就无能为力了。<br><br>第二种：使用movie滤镜，同样是让gif循环播放，虽然这种方式复杂点，不过这种解决方案支持视频水印，命令如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -vf <span class=\"hljs-string\">&quot;movie=doggie3.gif:loop=0,setpts=N/FRAME_RATE/TB[out];[0:v][out]overlay=x=main_w-overlay_w:y=0&quot;</span> -shortest out.mp4 -y<br>上面的命令有两个地方比较关键：<br><br>loop=0,setpts=N/FRAME_RATE/TB ：设置水印gif无限循环<br>-shortest ：将输出文件的时长设置为第一个视频文件的时长，如果不设置，你会发现命令会一直执行根本不会停下来，因为gif图的循环是无限的<br>这样gif图/短视频就会一直不停的播放了。<br><br><br>希望水印播放一次就不播放了，那就设置上面的eof_action为pass就可以了，如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie3.gif -filter_complex <span class=\"hljs-string\">&quot;overlay=x=0:y=0:eof_action=pass&quot;</span> out.mp4 -y<br><br>如果视频一开始就播放且只播放一次，假如水印比较短可能根本就没被注意就过去了，这时可以设置水印出现的延迟时间，使用-itsoffset选项，如下：<br>ffmpeg -hide_banner -i big_buck_bunny.mp4 -itsoffset 3 -i doggie3.gif -filter_complex <span class=\"hljs-string\">&quot;overlay=x=0:y=0:eof_action=pass&quot;</span> out.mp4 -y<br>这样，视频播放3秒后，水印才会出现。<br></code></pre></td></tr></table></figure>\n<h2 id=\"水印旋转\"><a href=\"#水印旋转\" class=\"headerlink\" title=\"水印旋转\"></a>水印旋转</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">如果想实现旋转的功能，需要使用ffmpeg过滤器的链式功能，即：先把作为水印的图片旋转，再覆盖到视频上。<br><br>1. 水印旋转一次<br>ffmpeg -i buck.mp4 -i s1.jpg -lavfi <span class=\"hljs-string\">&quot;[1:v]format=rgba,rotate=&#x27;PI/6:c=0x00000000:ow=hypot(iw,ih):oh=ow&#x27;[out];[0:v][out]overlay=10:10&quot;</span> out.mp4 -y<br><br>思路是：<br>调整水印宽高，根据勾股定律计算图片对角长度(hypot)，将这个值设置为水印的宽高，这样，图片无论如何旋转，都不会超过设定的宽高，也就不会出现图片部分丢失的情况了<br>将图片显示的像素格式转换为rgba格式，如果做过前端的小伙伴会很熟悉的，最后的a表示透明度，如此一来，c=0x00000000的作用就是将图片旋转后的背景变为白色且完全透明，这样就不会遮挡视频了<br><br>2. 让旋转停不下，具体命令如下：<br>ffmpeg -i buck.mp4 -loop 1 -i s1.jpg -lavfi <span class=\"hljs-string\">&quot;[1:v]format=rgba,rotate=&#x27;PI/2*t:c=0x00000000:ow=hypot(iw,ih):oh=ow&#x27;[out];[0:v][out]overlay=10:10&quot;</span> -shortest out.mp4 -y<br>这次水印图片前面添加了-loop 1，正常情况下水印图片默认在播放一次后就停下来，保留最后一帧，所以要让水印图片保持循环才行。<br></code></pre></td></tr></table></figure>\n<h1 id=\"录屏及摄像头\"><a href=\"#录屏及摄像头\" class=\"headerlink\" title=\"录屏及摄像头\"></a>录屏及摄像头</h1><ul>\n<li><code>ffmpeg -devices</code>:列出音频设备及摄像头</li>\n</ul>\n<h2 id=\"录屏命令\"><a href=\"#录屏命令\" class=\"headerlink\" title=\"录屏命令\"></a>录屏命令</h2><p><code>ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 -c:v libx264 output.mp4</code></p>\n<ul>\n<li>-f x11grab 指定使用X11grab设备作为输入。</li>\n<li>-s [分辨率] 设置录制视频的分辨率，例如 1920x1080。不指定就是全屏</li>\n<li>-r [帧率] 设置录制视频的帧率，例如 30。</li>\n<li>-i :0.0 指定要捕获的X11屏幕。:0.0 通常表示第一个屏幕。如果你有多个屏幕或显示设置不同，这个值可能需要调整。</li>\n<li>-c:v [编码器] 设置视频编码器，例如 libx264 用于H.264编码。</li>\n<li>output.mp4 是输出文件的名称。</li>\n</ul>\n<h2 id=\"录屏加声音\"><a href=\"#录屏加声音\" class=\"headerlink\" title=\"录屏加声音\"></a>录屏加声音</h2><p><code>ffmpeg -f x11grab -i :0.0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame -s 1280x720 -r 15 xx.mp4</code><br>alsa使用于linux alsa声卡，<code>hw:2</code>是当前电脑上的设备，可以用<code>arecord -l</code>命令来显示设备，card几就hw:几</p>\n<h2 id=\"摄像头\"><a href=\"#摄像头\" class=\"headerlink\" title=\"摄像头\"></a>摄像头</h2><p><code>ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 xx.mkv</code><br>可以通过<code>v4l2-ctl --list-devices</code>来查看v4l2的设备，</p>\n<h2 id=\"摄像头加声音\"><a href=\"#摄像头加声音\" class=\"headerlink\" title=\"摄像头加声音\"></a>摄像头加声音</h2><p><code>ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 -f alsa -ac 2 -i hw:2 -vcodec libx264 -acodec libmp3lame xx.mkv</code></p>\n<h1 id=\"文字水印\"><a href=\"#文字水印\" class=\"headerlink\" title=\"文字水印\"></a>文字水印</h1><p><code>ffmpeg -i xx.mp4 -vf &quot;drawtext=fontfile=simhei.ttf: text=&#39;hi,Nanbert&#39;:x=100:y=1fontsize=24fontcolor=white:shadowy=2&quot; output.mp4</code></p>\n<ul>\n<li>ontfile:字体类型</li>\n<li>text:要添加的文字内容</li>\n<li>fontsize:字体大小</li>\n<li>fontcolor：字体颜色</li>\n</ul>\n<h1 id=\"各种特效\"><a href=\"#各种特效\" class=\"headerlink\" title=\"各种特效\"></a>各种特效</h1><ul>\n<li>渐入:<code>ffmpeg -i in.mp4 -vf fade=in:0:90 out.mp4</code></li>\n<li>黑白:<code>ffmpeg -i in.mp4 -vf lutyuv=&quot;u=128:v=128&quot; out.mp4</code></li>\n<li>锐化:<code>ffmpeg -i in.mp4 -vf unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5 out.mp4</code></li>\n<li>反锐化:<code>ffmpeg -i in.mp4 -vf unsharp=7:7:-2:7:7:-2 out.mp4</code></li>\n<li>渐晕:<code>ffmpeg -i in.mp4 -vf vignette=PI/4 out.mp4</code></li>\n<li>闪烁渐晕:<code>ffmpeg -i in.mp4 -vf vignette=&#39;PI/4+random(1)*PI/50&#39;:eval=frame out.mp4</code></li>\n<li>视频颤抖:<code>ffmpeg -i in.mp4 -vf crop=&quot;in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2+((in_h-out_h)/2)*sin(n/7)&quot; out.mp4</code></li>\n<li>色彩变幻:<code>ffmpeg -i in.mp4 -vf hue=&quot;H=2*PI*t:s=sin(2*PI*t)+1&quot; out.mp4</code></li>\n<li>模糊处理:<code>ffmpeg -i in.mp4 -vf boxblur=5:1:cr=0:ar=0 out.mp4</code></li>\n<li>镜像翻转:<code>ffmpeg -i in.mp4 -vf crop=iw/2:ih:0:0,split[left][tmp];[tmp]hflip[right];[left]pad=iw*2[a];[a][right]overlay=w out.mp4</code></li>\n<li>水平翻转:<code>ffmpeg -i in.mp4 -vf geq=p(W-X\\\\,Y) out.mp4</code></li>\n<li>垂直翻转:<code>ffmpeg -i in.mp4 -vf vflip out.mp4</code></li>\n<li>浮雕效果:<code>ffmpeg -i in.mp4 -vf format=gray,geq=lum_expr=&#39;(p(X,Y)+(256-p(X-4,Y-4)))/2&#39; out.mp4</code></li>\n<li>均匀噪声:<code>ffmpeg -i in.mp4 -vf noise=alls=20:allf=t+u out.mp4</code></li>\n</ul>\n<h1 id=\"字幕-1\"><a href=\"#字幕-1\" class=\"headerlink\" title=\"字幕\"></a>字幕</h1><ul>\n<li><code>ffmpeg -i xx.mp4 -vf ass=xx.ass -b:v 3000k xx.mp4</code></li>\n</ul>\n<h1 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h1><ul>\n<li>5秒处截图：<code>ffmpeg -ss 00:00:05 -i xx.mp4 xx.jpg -r 1 -vframes 1 -an -vodec mjpeg</code></li>\n<li>每一帧输出图片：<code>ffmpeg -i xx.mp4 image_%d.jpg</code></li>\n<li>图片转为视频：<code>ffmpeg -f image2 -i image_%d.jpg video.mpg</code></li>\n</ul>\n<h1 id=\"视频格式的默认编码\"><a href=\"#视频格式的默认编码\" class=\"headerlink\" title=\"视频格式的默认编码\"></a>视频格式的默认编码</h1><ul>\n<li>.avi: Audio Codec: mp3, Video Codec: mpeg4</li>\n<li>.mkv: Audio Codec: ac3, Video Codec: H.264</li>\n<li>.mov: Audio Codec: AAC, Video Codec: H.264</li>\n<li>.mp4: Audio Codec: AAC, Video Codec: H.264</li>\n<li>.mpg: Audio Codec: mp2, Video Codec: mpeg1video</li>\n<li>.mxf: Audio Codec: pcm_s16le, Video Codec: mpeg2video</li>\n<li>.wav: Audio Codec: pcm_s16le (16 bit PCM)</li>\n</ul>\n<h1 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h1><p><a href=\"https://amiaopensource.github.io/ffmprovisr/#SD_HD\">ffmprovisr</a><br><a href=\"https://ffmpeg.xianwaizhiyin.net/\">ffmpeg中文教程</a></p>\n"},{"title":"生活Tip","date":"2025-02-10T13:02:23.000Z","index_img":"/images/enjoyLife.jpg","banner_img":"/images/enjoyLife.jpg","_content":"\n# 鸡汤\n## 锻炼大脑(避免痴呆)\n- 快走:每天快走30分钟,每周5次\n- 尝试新鲜事物:学习语言,运动\n- 保持社交\n- 要有生活目标\n- 放松\n- 保护头部\n- 地中海饮食(七份蔬菜和水果),坚果,核桃,杏仁,豆类,花生等等\n- 积极\n## 提高沟通能力\n- 不要三心二意\n- 不要说教\n- 开放式问题而不是一般疑问句\n- 顺其自然，进行到哪讲哪\n- 不知道就不知道\n- 不要把自己经历类比，即使相同也不行，每个人经历都不同\n- 别重复自己的话\n- 少说废话，各种细枝末节\n- 对他人感兴趣，做好大吃一惊其经历的准备\n- listen\n\n## 21个小习惯\n- 写下三个你感激的事情\n- 每周拒绝一次\n- 晨起锻炼1分钟\n- 投资经历\n- 收拾房间\n- 扔无用东西\n- 理财\n- 每小时站起来\n- 相信简单的谚语(每天花20min学习,5年后你会成为该领域专家)\n- 多提开放性问题\n- 关掉通知\n- 准备好衣服\n- 少看新闻(两天一次)\n- 多喝水\n- 每个月发现新东西,事物，知识\n- 叠床\n- 每天一分钟独处\n- 问问自己做的事，是否值得\n- 立刻去做某些只要两分钟的事\n- 注意姿势\n- 每天阅读15min\n\n## 戒掉7种说话习惯\n- 不要说“只”：我只是想做更好->我想做更好\n- 不要说我想要干嘛\n- 夸奖式介绍朋友,显得自己自信\n- 少用无意义的恩，啊。。等填充词\n- 道歉就真正道歉，不要用但是\n- 猜测某人不喜欢但是还推荐(You probbably don't care(but))\n- 不要说某某人使你做某事，显得自己是仆人\n\n## 个小习惯\n- 说到做到\n- 每天写日记\n- 不说谎\n- 抽时间陪朋友\n- 联系技能\n- 去健身房\n- 融入你想要成为的群体\n- 读书\n- 制定而复习计划\n- 不要单独吃饭\n- 注重衣着\n- 冥想和反思\n- 传授知识给他人\n- 玩耍\n- 健康饮食\n- 和不同年龄的人保持交流\n- 欣赏艺术\n- 说起床就起床\n- 大声读出你的梦想\n\n## 10种处理焦虑的方法\n- 写下你的焦虑\n- 锻炼\n- 冥想\n- 少使用互联网\n- 不要让你的手空着\n- 使用精油\n- 说出你的担忧\n- 在脑中重复忧虑\n- 考虑外部因素\n- 分析并分类你的担忧\n\n## 梦的解析\n- 考试考0分,找不到考场，漏写->生活中正接受考验，让你对未来感到焦虑\n- 掉牙齿->没有安全感，觉得自己不够好，不吸引人，害怕别人批评你，自己尴尬\n- 高处坠落或溺水->不满足现状，害怕跌到，需要开辟新道路来发现人生意义\n\n## 8个改善心理健康的小习惯\n- 挺直腰杆站起来\n- 练习乐观思考\n- 走到大自然中\n- 拥抱某人\n- 养宠物\n- 运动\n- 充足的睡眠\n- 写感恩日记\n\n## 6个更好生活\n- 相信你值得\n- 世界是你的ATM,善待世界\n- 给自己时间去思考和做梦\n- 减少有害输入\n- 立刻行动\n- 明白真正的裁判是谁\n\n## 自律\n- 冥想\n- 工作15min\n- 每天做\n- 迈出第一步\n- 倒数让自己行动起来\n- 志同道合的朋友\n- 稳定规律的生活\n\n## 成功的关键点\n- 专注自己的进步，而非他人的成就\n- 学会在危机中寻机\n- 当你坚持不下去时，更努力些\n- 切忌骄傲自满，虚心找不足,求精进\n\n## 7个要掌握的心理学技巧\n- 藏拙\n- 抵抗群体思维\n- 别在意他人的看法\n- 别责怪\n- 不要抢着说话\n- 别被欲望操纵\n- 别太较真(那些你帮不上的国家大事,和社会新闻)\n\n## 训练大脑\n- 打破常规，做些新颖的事\n- 另辟蹊径\n- 使用非惯用手\n- 玩观察游戏\n- 讲故事\n- 记住你的清单\n- 停止依赖科技\n- 练习解决问题\n- 大声朗读\n- 在纸上写作\n- 从一个新的角度看\n\n## 五条晨间习惯\n- 为逆境做好准备\n- 为美好的一天作计划\n- 专注你的目标\n- 提醒自己控制二分法(专注自己可以控制的事)\n- 记住生命有限\n\n## 杂谈\n其实，人类社会的意义不过四个：延续种族 、掌控心智、掌控环境、增进我们的满足感。\n但人类历史的车轮滚滚向前，谁的生命不是微不足道的呢？即便是苏格拉底、莎士比亚或爱因斯坦，对着漫长的人类社会的河流所作出的贡献都是微不足道的。\n但我们无需从个体的维度去考虑生命的意义，而是要从全人类的维度去考虑个体的贡献。你会发现，那么，今天赚了点钱，照顾了孩子，收拾了房子，都是有意义的。每个个体都在人类文明这一进程中划上了痕迹\n# 出境注意\n- 遭遇盘查莫慌张，妥善应对寻帮助。出国（境）人员如遇他国执法人员盘查，要沉着冷静，理性配合，妥善应对。如语言不通，应寻求翻译协助，切勿随意回答；如提问涉及我国家秘密，应当向其申明并拒绝回答；如遇开箱查验，本人务必在场，以防有人暗中动手脚；如遇到境外间谍情报机关或其他执法部门约谈、攀拉、策反，应坚决表明立场，不到对方指定场所，不签署任何文件，坚持要求联系我驻外使领馆寻求领事保护。\n- 交友搭讪需谨慎，防范意识不可少。出国（境）人员在旅游期间约伙搭伴，应注意辨别对方人员情况，警惕无端打听个人隐私、索要相关敏感信息的可疑人员，不收取对方提供的任何财物，不透露任何内部信息，不给境外间谍情报机关套取信息、诱导胁迫的可乘之机。此外，出国（境）人员应拒绝为陌生人携带来源不明的物品，并谨慎对待任何过于亲密或异常的行为。\n- 时刻绷紧保密弦，严防大意失泄密。出国（境）人员应尽量避免在境外使用公共Wi-Fi登录重要账户或传输敏感数据，严禁在公开网络环境中处理国家秘密和工作秘密事项，个人电子设备应提前设置安全防护措施，防止被非法入侵。此外，涉密岗位工作人员出国（境）前要仔细核对携带出国（境）物品是否含有秘密载体，未经有关主管部门批准，任何组织和个人不得携带、传递国家秘密载体出国（境）。出国（境）后更需绷紧保密纪律这根弦，不谈论敏感内容，防止敏感信息外泄。\n- 言行举止需注意，切勿轻信被利用。境外敌对组织常向我出国（境）人员传播涉我虚假信息、政治谣言、失实报道等，丑化我国国家形象，进行意识形态渗透。出国（境）人员如遇到涉我敏感话题活动时，应保持冷静和理性，客观阐释我经济社会发展成就、展现我良好国际形象，切勿随意传播未经核实的信息，更不能参与、协助可能损害我国家利益的活动。\n# 举报骚扰电话\n微信搜索##12321举报##\n# 报案注意点\n- 报案一定要留下痕迹，比如要求有报案回执，如果不立案要有不予立案通知书，以及报案前先打110留记录\n- 去国务院小程序投诉要语言精炼，逻辑清晰\n# 待业交社保\n- ![p1](/images/sheBao1.jpg) \n- ![p2](/images/sheBao2.jpg) \n- ![p3](/images/sheBao3.jpg) \n","source":"_posts/生活Tip.md","raw":"---\ntitle: 生活Tip\ndate: 2025-02-10 21:02:23\ntags:\nindex_img: /images/enjoyLife.jpg\nbanner_img: /images/enjoyLife.jpg\n---\n\n# 鸡汤\n## 锻炼大脑(避免痴呆)\n- 快走:每天快走30分钟,每周5次\n- 尝试新鲜事物:学习语言,运动\n- 保持社交\n- 要有生活目标\n- 放松\n- 保护头部\n- 地中海饮食(七份蔬菜和水果),坚果,核桃,杏仁,豆类,花生等等\n- 积极\n## 提高沟通能力\n- 不要三心二意\n- 不要说教\n- 开放式问题而不是一般疑问句\n- 顺其自然，进行到哪讲哪\n- 不知道就不知道\n- 不要把自己经历类比，即使相同也不行，每个人经历都不同\n- 别重复自己的话\n- 少说废话，各种细枝末节\n- 对他人感兴趣，做好大吃一惊其经历的准备\n- listen\n\n## 21个小习惯\n- 写下三个你感激的事情\n- 每周拒绝一次\n- 晨起锻炼1分钟\n- 投资经历\n- 收拾房间\n- 扔无用东西\n- 理财\n- 每小时站起来\n- 相信简单的谚语(每天花20min学习,5年后你会成为该领域专家)\n- 多提开放性问题\n- 关掉通知\n- 准备好衣服\n- 少看新闻(两天一次)\n- 多喝水\n- 每个月发现新东西,事物，知识\n- 叠床\n- 每天一分钟独处\n- 问问自己做的事，是否值得\n- 立刻去做某些只要两分钟的事\n- 注意姿势\n- 每天阅读15min\n\n## 戒掉7种说话习惯\n- 不要说“只”：我只是想做更好->我想做更好\n- 不要说我想要干嘛\n- 夸奖式介绍朋友,显得自己自信\n- 少用无意义的恩，啊。。等填充词\n- 道歉就真正道歉，不要用但是\n- 猜测某人不喜欢但是还推荐(You probbably don't care(but))\n- 不要说某某人使你做某事，显得自己是仆人\n\n## 个小习惯\n- 说到做到\n- 每天写日记\n- 不说谎\n- 抽时间陪朋友\n- 联系技能\n- 去健身房\n- 融入你想要成为的群体\n- 读书\n- 制定而复习计划\n- 不要单独吃饭\n- 注重衣着\n- 冥想和反思\n- 传授知识给他人\n- 玩耍\n- 健康饮食\n- 和不同年龄的人保持交流\n- 欣赏艺术\n- 说起床就起床\n- 大声读出你的梦想\n\n## 10种处理焦虑的方法\n- 写下你的焦虑\n- 锻炼\n- 冥想\n- 少使用互联网\n- 不要让你的手空着\n- 使用精油\n- 说出你的担忧\n- 在脑中重复忧虑\n- 考虑外部因素\n- 分析并分类你的担忧\n\n## 梦的解析\n- 考试考0分,找不到考场，漏写->生活中正接受考验，让你对未来感到焦虑\n- 掉牙齿->没有安全感，觉得自己不够好，不吸引人，害怕别人批评你，自己尴尬\n- 高处坠落或溺水->不满足现状，害怕跌到，需要开辟新道路来发现人生意义\n\n## 8个改善心理健康的小习惯\n- 挺直腰杆站起来\n- 练习乐观思考\n- 走到大自然中\n- 拥抱某人\n- 养宠物\n- 运动\n- 充足的睡眠\n- 写感恩日记\n\n## 6个更好生活\n- 相信你值得\n- 世界是你的ATM,善待世界\n- 给自己时间去思考和做梦\n- 减少有害输入\n- 立刻行动\n- 明白真正的裁判是谁\n\n## 自律\n- 冥想\n- 工作15min\n- 每天做\n- 迈出第一步\n- 倒数让自己行动起来\n- 志同道合的朋友\n- 稳定规律的生活\n\n## 成功的关键点\n- 专注自己的进步，而非他人的成就\n- 学会在危机中寻机\n- 当你坚持不下去时，更努力些\n- 切忌骄傲自满，虚心找不足,求精进\n\n## 7个要掌握的心理学技巧\n- 藏拙\n- 抵抗群体思维\n- 别在意他人的看法\n- 别责怪\n- 不要抢着说话\n- 别被欲望操纵\n- 别太较真(那些你帮不上的国家大事,和社会新闻)\n\n## 训练大脑\n- 打破常规，做些新颖的事\n- 另辟蹊径\n- 使用非惯用手\n- 玩观察游戏\n- 讲故事\n- 记住你的清单\n- 停止依赖科技\n- 练习解决问题\n- 大声朗读\n- 在纸上写作\n- 从一个新的角度看\n\n## 五条晨间习惯\n- 为逆境做好准备\n- 为美好的一天作计划\n- 专注你的目标\n- 提醒自己控制二分法(专注自己可以控制的事)\n- 记住生命有限\n\n## 杂谈\n其实，人类社会的意义不过四个：延续种族 、掌控心智、掌控环境、增进我们的满足感。\n但人类历史的车轮滚滚向前，谁的生命不是微不足道的呢？即便是苏格拉底、莎士比亚或爱因斯坦，对着漫长的人类社会的河流所作出的贡献都是微不足道的。\n但我们无需从个体的维度去考虑生命的意义，而是要从全人类的维度去考虑个体的贡献。你会发现，那么，今天赚了点钱，照顾了孩子，收拾了房子，都是有意义的。每个个体都在人类文明这一进程中划上了痕迹\n# 出境注意\n- 遭遇盘查莫慌张，妥善应对寻帮助。出国（境）人员如遇他国执法人员盘查，要沉着冷静，理性配合，妥善应对。如语言不通，应寻求翻译协助，切勿随意回答；如提问涉及我国家秘密，应当向其申明并拒绝回答；如遇开箱查验，本人务必在场，以防有人暗中动手脚；如遇到境外间谍情报机关或其他执法部门约谈、攀拉、策反，应坚决表明立场，不到对方指定场所，不签署任何文件，坚持要求联系我驻外使领馆寻求领事保护。\n- 交友搭讪需谨慎，防范意识不可少。出国（境）人员在旅游期间约伙搭伴，应注意辨别对方人员情况，警惕无端打听个人隐私、索要相关敏感信息的可疑人员，不收取对方提供的任何财物，不透露任何内部信息，不给境外间谍情报机关套取信息、诱导胁迫的可乘之机。此外，出国（境）人员应拒绝为陌生人携带来源不明的物品，并谨慎对待任何过于亲密或异常的行为。\n- 时刻绷紧保密弦，严防大意失泄密。出国（境）人员应尽量避免在境外使用公共Wi-Fi登录重要账户或传输敏感数据，严禁在公开网络环境中处理国家秘密和工作秘密事项，个人电子设备应提前设置安全防护措施，防止被非法入侵。此外，涉密岗位工作人员出国（境）前要仔细核对携带出国（境）物品是否含有秘密载体，未经有关主管部门批准，任何组织和个人不得携带、传递国家秘密载体出国（境）。出国（境）后更需绷紧保密纪律这根弦，不谈论敏感内容，防止敏感信息外泄。\n- 言行举止需注意，切勿轻信被利用。境外敌对组织常向我出国（境）人员传播涉我虚假信息、政治谣言、失实报道等，丑化我国国家形象，进行意识形态渗透。出国（境）人员如遇到涉我敏感话题活动时，应保持冷静和理性，客观阐释我经济社会发展成就、展现我良好国际形象，切勿随意传播未经核实的信息，更不能参与、协助可能损害我国家利益的活动。\n# 举报骚扰电话\n微信搜索##12321举报##\n# 报案注意点\n- 报案一定要留下痕迹，比如要求有报案回执，如果不立案要有不予立案通知书，以及报案前先打110留记录\n- 去国务院小程序投诉要语言精炼，逻辑清晰\n# 待业交社保\n- ![p1](/images/sheBao1.jpg) \n- ![p2](/images/sheBao2.jpg) \n- ![p3](/images/sheBao3.jpg) \n","slug":"生活Tip","published":1,"updated":"2025-02-10T14:05:25.797Z","_id":"cm6z49wxs0000r4q2gmedf4ux","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"鸡汤\"><a href=\"#鸡汤\" class=\"headerlink\" title=\"鸡汤\"></a>鸡汤</h1><h2 id=\"锻炼大脑-避免痴呆\"><a href=\"#锻炼大脑-避免痴呆\" class=\"headerlink\" title=\"锻炼大脑(避免痴呆)\"></a>锻炼大脑(避免痴呆)</h2><ul>\n<li>快走:每天快走30分钟,每周5次</li>\n<li>尝试新鲜事物:学习语言,运动</li>\n<li>保持社交</li>\n<li>要有生活目标</li>\n<li>放松</li>\n<li>保护头部</li>\n<li>地中海饮食(七份蔬菜和水果),坚果,核桃,杏仁,豆类,花生等等</li>\n<li>积极</li>\n</ul>\n<h2 id=\"提高沟通能力\"><a href=\"#提高沟通能力\" class=\"headerlink\" title=\"提高沟通能力\"></a>提高沟通能力</h2><ul>\n<li>不要三心二意</li>\n<li>不要说教</li>\n<li>开放式问题而不是一般疑问句</li>\n<li>顺其自然，进行到哪讲哪</li>\n<li>不知道就不知道</li>\n<li>不要把自己经历类比，即使相同也不行，每个人经历都不同</li>\n<li>别重复自己的话</li>\n<li>少说废话，各种细枝末节</li>\n<li>对他人感兴趣，做好大吃一惊其经历的准备</li>\n<li>listen</li>\n</ul>\n<h2 id=\"21个小习惯\"><a href=\"#21个小习惯\" class=\"headerlink\" title=\"21个小习惯\"></a>21个小习惯</h2><ul>\n<li>写下三个你感激的事情</li>\n<li>每周拒绝一次</li>\n<li>晨起锻炼1分钟</li>\n<li>投资经历</li>\n<li>收拾房间</li>\n<li>扔无用东西</li>\n<li>理财</li>\n<li>每小时站起来</li>\n<li>相信简单的谚语(每天花20min学习,5年后你会成为该领域专家)</li>\n<li>多提开放性问题</li>\n<li>关掉通知</li>\n<li>准备好衣服</li>\n<li>少看新闻(两天一次)</li>\n<li>多喝水</li>\n<li>每个月发现新东西,事物，知识</li>\n<li>叠床</li>\n<li>每天一分钟独处</li>\n<li>问问自己做的事，是否值得</li>\n<li>立刻去做某些只要两分钟的事</li>\n<li>注意姿势</li>\n<li>每天阅读15min</li>\n</ul>\n<h2 id=\"戒掉7种说话习惯\"><a href=\"#戒掉7种说话习惯\" class=\"headerlink\" title=\"戒掉7种说话习惯\"></a>戒掉7种说话习惯</h2><ul>\n<li>不要说“只”：我只是想做更好-&gt;我想做更好</li>\n<li>不要说我想要干嘛</li>\n<li>夸奖式介绍朋友,显得自己自信</li>\n<li>少用无意义的恩，啊。。等填充词</li>\n<li>道歉就真正道歉，不要用但是</li>\n<li>猜测某人不喜欢但是还推荐(You probbably don’t care(but))</li>\n<li>不要说某某人使你做某事，显得自己是仆人</li>\n</ul>\n<h2 id=\"个小习惯\"><a href=\"#个小习惯\" class=\"headerlink\" title=\"个小习惯\"></a>个小习惯</h2><ul>\n<li>说到做到</li>\n<li>每天写日记</li>\n<li>不说谎</li>\n<li>抽时间陪朋友</li>\n<li>联系技能</li>\n<li>去健身房</li>\n<li>融入你想要成为的群体</li>\n<li>读书</li>\n<li>制定而复习计划</li>\n<li>不要单独吃饭</li>\n<li>注重衣着</li>\n<li>冥想和反思</li>\n<li>传授知识给他人</li>\n<li>玩耍</li>\n<li>健康饮食</li>\n<li>和不同年龄的人保持交流</li>\n<li>欣赏艺术</li>\n<li>说起床就起床</li>\n<li>大声读出你的梦想</li>\n</ul>\n<h2 id=\"10种处理焦虑的方法\"><a href=\"#10种处理焦虑的方法\" class=\"headerlink\" title=\"10种处理焦虑的方法\"></a>10种处理焦虑的方法</h2><ul>\n<li>写下你的焦虑</li>\n<li>锻炼</li>\n<li>冥想</li>\n<li>少使用互联网</li>\n<li>不要让你的手空着</li>\n<li>使用精油</li>\n<li>说出你的担忧</li>\n<li>在脑中重复忧虑</li>\n<li>考虑外部因素</li>\n<li>分析并分类你的担忧</li>\n</ul>\n<h2 id=\"梦的解析\"><a href=\"#梦的解析\" class=\"headerlink\" title=\"梦的解析\"></a>梦的解析</h2><ul>\n<li>考试考0分,找不到考场，漏写-&gt;生活中正接受考验，让你对未来感到焦虑</li>\n<li>掉牙齿-&gt;没有安全感，觉得自己不够好，不吸引人，害怕别人批评你，自己尴尬</li>\n<li>高处坠落或溺水-&gt;不满足现状，害怕跌到，需要开辟新道路来发现人生意义</li>\n</ul>\n<h2 id=\"8个改善心理健康的小习惯\"><a href=\"#8个改善心理健康的小习惯\" class=\"headerlink\" title=\"8个改善心理健康的小习惯\"></a>8个改善心理健康的小习惯</h2><ul>\n<li>挺直腰杆站起来</li>\n<li>练习乐观思考</li>\n<li>走到大自然中</li>\n<li>拥抱某人</li>\n<li>养宠物</li>\n<li>运动</li>\n<li>充足的睡眠</li>\n<li>写感恩日记</li>\n</ul>\n<h2 id=\"6个更好生活\"><a href=\"#6个更好生活\" class=\"headerlink\" title=\"6个更好生活\"></a>6个更好生活</h2><ul>\n<li>相信你值得</li>\n<li>世界是你的ATM,善待世界</li>\n<li>给自己时间去思考和做梦</li>\n<li>减少有害输入</li>\n<li>立刻行动</li>\n<li>明白真正的裁判是谁</li>\n</ul>\n<h2 id=\"自律\"><a href=\"#自律\" class=\"headerlink\" title=\"自律\"></a>自律</h2><ul>\n<li>冥想</li>\n<li>工作15min</li>\n<li>每天做</li>\n<li>迈出第一步</li>\n<li>倒数让自己行动起来</li>\n<li>志同道合的朋友</li>\n<li>稳定规律的生活</li>\n</ul>\n<h2 id=\"成功的关键点\"><a href=\"#成功的关键点\" class=\"headerlink\" title=\"成功的关键点\"></a>成功的关键点</h2><ul>\n<li>专注自己的进步，而非他人的成就</li>\n<li>学会在危机中寻机</li>\n<li>当你坚持不下去时，更努力些</li>\n<li>切忌骄傲自满，虚心找不足,求精进</li>\n</ul>\n<h2 id=\"7个要掌握的心理学技巧\"><a href=\"#7个要掌握的心理学技巧\" class=\"headerlink\" title=\"7个要掌握的心理学技巧\"></a>7个要掌握的心理学技巧</h2><ul>\n<li>藏拙</li>\n<li>抵抗群体思维</li>\n<li>别在意他人的看法</li>\n<li>别责怪</li>\n<li>不要抢着说话</li>\n<li>别被欲望操纵</li>\n<li>别太较真(那些你帮不上的国家大事,和社会新闻)</li>\n</ul>\n<h2 id=\"训练大脑\"><a href=\"#训练大脑\" class=\"headerlink\" title=\"训练大脑\"></a>训练大脑</h2><ul>\n<li>打破常规，做些新颖的事</li>\n<li>另辟蹊径</li>\n<li>使用非惯用手</li>\n<li>玩观察游戏</li>\n<li>讲故事</li>\n<li>记住你的清单</li>\n<li>停止依赖科技</li>\n<li>练习解决问题</li>\n<li>大声朗读</li>\n<li>在纸上写作</li>\n<li>从一个新的角度看</li>\n</ul>\n<h2 id=\"五条晨间习惯\"><a href=\"#五条晨间习惯\" class=\"headerlink\" title=\"五条晨间习惯\"></a>五条晨间习惯</h2><ul>\n<li>为逆境做好准备</li>\n<li>为美好的一天作计划</li>\n<li>专注你的目标</li>\n<li>提醒自己控制二分法(专注自己可以控制的事)</li>\n<li>记住生命有限</li>\n</ul>\n<h2 id=\"杂谈\"><a href=\"#杂谈\" class=\"headerlink\" title=\"杂谈\"></a>杂谈</h2><p>其实，人类社会的意义不过四个：延续种族 、掌控心智、掌控环境、增进我们的满足感。<br>但人类历史的车轮滚滚向前，谁的生命不是微不足道的呢？即便是苏格拉底、莎士比亚或爱因斯坦，对着漫长的人类社会的河流所作出的贡献都是微不足道的。<br>但我们无需从个体的维度去考虑生命的意义，而是要从全人类的维度去考虑个体的贡献。你会发现，那么，今天赚了点钱，照顾了孩子，收拾了房子，都是有意义的。每个个体都在人类文明这一进程中划上了痕迹</p>\n<h1 id=\"出境注意\"><a href=\"#出境注意\" class=\"headerlink\" title=\"出境注意\"></a>出境注意</h1><ul>\n<li>遭遇盘查莫慌张，妥善应对寻帮助。出国（境）人员如遇他国执法人员盘查，要沉着冷静，理性配合，妥善应对。如语言不通，应寻求翻译协助，切勿随意回答；如提问涉及我国家秘密，应当向其申明并拒绝回答；如遇开箱查验，本人务必在场，以防有人暗中动手脚；如遇到境外间谍情报机关或其他执法部门约谈、攀拉、策反，应坚决表明立场，不到对方指定场所，不签署任何文件，坚持要求联系我驻外使领馆寻求领事保护。</li>\n<li>交友搭讪需谨慎，防范意识不可少。出国（境）人员在旅游期间约伙搭伴，应注意辨别对方人员情况，警惕无端打听个人隐私、索要相关敏感信息的可疑人员，不收取对方提供的任何财物，不透露任何内部信息，不给境外间谍情报机关套取信息、诱导胁迫的可乘之机。此外，出国（境）人员应拒绝为陌生人携带来源不明的物品，并谨慎对待任何过于亲密或异常的行为。</li>\n<li>时刻绷紧保密弦，严防大意失泄密。出国（境）人员应尽量避免在境外使用公共Wi-Fi登录重要账户或传输敏感数据，严禁在公开网络环境中处理国家秘密和工作秘密事项，个人电子设备应提前设置安全防护措施，防止被非法入侵。此外，涉密岗位工作人员出国（境）前要仔细核对携带出国（境）物品是否含有秘密载体，未经有关主管部门批准，任何组织和个人不得携带、传递国家秘密载体出国（境）。出国（境）后更需绷紧保密纪律这根弦，不谈论敏感内容，防止敏感信息外泄。</li>\n<li>言行举止需注意，切勿轻信被利用。境外敌对组织常向我出国（境）人员传播涉我虚假信息、政治谣言、失实报道等，丑化我国国家形象，进行意识形态渗透。出国（境）人员如遇到涉我敏感话题活动时，应保持冷静和理性，客观阐释我经济社会发展成就、展现我良好国际形象，切勿随意传播未经核实的信息，更不能参与、协助可能损害我国家利益的活动。</li>\n</ul>\n<h1 id=\"举报骚扰电话\"><a href=\"#举报骚扰电话\" class=\"headerlink\" title=\"举报骚扰电话\"></a>举报骚扰电话</h1><p>微信搜索##12321举报##</p>\n<h1 id=\"报案注意点\"><a href=\"#报案注意点\" class=\"headerlink\" title=\"报案注意点\"></a>报案注意点</h1><ul>\n<li>报案一定要留下痕迹，比如要求有报案回执，如果不立案要有不予立案通知书，以及报案前先打110留记录</li>\n<li>去国务院小程序投诉要语言精炼，逻辑清晰</li>\n</ul>\n<h1 id=\"待业交社保\"><a href=\"#待业交社保\" class=\"headerlink\" title=\"待业交社保\"></a>待业交社保</h1><ul>\n<li><img src=\"/images/sheBao1.jpg\" alt=\"p1\"> </li>\n<li><img src=\"/images/sheBao2.jpg\" alt=\"p2\"> </li>\n<li><img src=\"/images/sheBao3.jpg\" alt=\"p3\"></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"鸡汤\"><a href=\"#鸡汤\" class=\"headerlink\" title=\"鸡汤\"></a>鸡汤</h1><h2 id=\"锻炼大脑-避免痴呆\"><a href=\"#锻炼大脑-避免痴呆\" class=\"headerlink\" title=\"锻炼大脑(避免痴呆)\"></a>锻炼大脑(避免痴呆)</h2><ul>\n<li>快走:每天快走30分钟,每周5次</li>\n<li>尝试新鲜事物:学习语言,运动</li>\n<li>保持社交</li>\n<li>要有生活目标</li>\n<li>放松</li>\n<li>保护头部</li>\n<li>地中海饮食(七份蔬菜和水果),坚果,核桃,杏仁,豆类,花生等等</li>\n<li>积极</li>\n</ul>\n<h2 id=\"提高沟通能力\"><a href=\"#提高沟通能力\" class=\"headerlink\" title=\"提高沟通能力\"></a>提高沟通能力</h2><ul>\n<li>不要三心二意</li>\n<li>不要说教</li>\n<li>开放式问题而不是一般疑问句</li>\n<li>顺其自然，进行到哪讲哪</li>\n<li>不知道就不知道</li>\n<li>不要把自己经历类比，即使相同也不行，每个人经历都不同</li>\n<li>别重复自己的话</li>\n<li>少说废话，各种细枝末节</li>\n<li>对他人感兴趣，做好大吃一惊其经历的准备</li>\n<li>listen</li>\n</ul>\n<h2 id=\"21个小习惯\"><a href=\"#21个小习惯\" class=\"headerlink\" title=\"21个小习惯\"></a>21个小习惯</h2><ul>\n<li>写下三个你感激的事情</li>\n<li>每周拒绝一次</li>\n<li>晨起锻炼1分钟</li>\n<li>投资经历</li>\n<li>收拾房间</li>\n<li>扔无用东西</li>\n<li>理财</li>\n<li>每小时站起来</li>\n<li>相信简单的谚语(每天花20min学习,5年后你会成为该领域专家)</li>\n<li>多提开放性问题</li>\n<li>关掉通知</li>\n<li>准备好衣服</li>\n<li>少看新闻(两天一次)</li>\n<li>多喝水</li>\n<li>每个月发现新东西,事物，知识</li>\n<li>叠床</li>\n<li>每天一分钟独处</li>\n<li>问问自己做的事，是否值得</li>\n<li>立刻去做某些只要两分钟的事</li>\n<li>注意姿势</li>\n<li>每天阅读15min</li>\n</ul>\n<h2 id=\"戒掉7种说话习惯\"><a href=\"#戒掉7种说话习惯\" class=\"headerlink\" title=\"戒掉7种说话习惯\"></a>戒掉7种说话习惯</h2><ul>\n<li>不要说“只”：我只是想做更好-&gt;我想做更好</li>\n<li>不要说我想要干嘛</li>\n<li>夸奖式介绍朋友,显得自己自信</li>\n<li>少用无意义的恩，啊。。等填充词</li>\n<li>道歉就真正道歉，不要用但是</li>\n<li>猜测某人不喜欢但是还推荐(You probbably don’t care(but))</li>\n<li>不要说某某人使你做某事，显得自己是仆人</li>\n</ul>\n<h2 id=\"个小习惯\"><a href=\"#个小习惯\" class=\"headerlink\" title=\"个小习惯\"></a>个小习惯</h2><ul>\n<li>说到做到</li>\n<li>每天写日记</li>\n<li>不说谎</li>\n<li>抽时间陪朋友</li>\n<li>联系技能</li>\n<li>去健身房</li>\n<li>融入你想要成为的群体</li>\n<li>读书</li>\n<li>制定而复习计划</li>\n<li>不要单独吃饭</li>\n<li>注重衣着</li>\n<li>冥想和反思</li>\n<li>传授知识给他人</li>\n<li>玩耍</li>\n<li>健康饮食</li>\n<li>和不同年龄的人保持交流</li>\n<li>欣赏艺术</li>\n<li>说起床就起床</li>\n<li>大声读出你的梦想</li>\n</ul>\n<h2 id=\"10种处理焦虑的方法\"><a href=\"#10种处理焦虑的方法\" class=\"headerlink\" title=\"10种处理焦虑的方法\"></a>10种处理焦虑的方法</h2><ul>\n<li>写下你的焦虑</li>\n<li>锻炼</li>\n<li>冥想</li>\n<li>少使用互联网</li>\n<li>不要让你的手空着</li>\n<li>使用精油</li>\n<li>说出你的担忧</li>\n<li>在脑中重复忧虑</li>\n<li>考虑外部因素</li>\n<li>分析并分类你的担忧</li>\n</ul>\n<h2 id=\"梦的解析\"><a href=\"#梦的解析\" class=\"headerlink\" title=\"梦的解析\"></a>梦的解析</h2><ul>\n<li>考试考0分,找不到考场，漏写-&gt;生活中正接受考验，让你对未来感到焦虑</li>\n<li>掉牙齿-&gt;没有安全感，觉得自己不够好，不吸引人，害怕别人批评你，自己尴尬</li>\n<li>高处坠落或溺水-&gt;不满足现状，害怕跌到，需要开辟新道路来发现人生意义</li>\n</ul>\n<h2 id=\"8个改善心理健康的小习惯\"><a href=\"#8个改善心理健康的小习惯\" class=\"headerlink\" title=\"8个改善心理健康的小习惯\"></a>8个改善心理健康的小习惯</h2><ul>\n<li>挺直腰杆站起来</li>\n<li>练习乐观思考</li>\n<li>走到大自然中</li>\n<li>拥抱某人</li>\n<li>养宠物</li>\n<li>运动</li>\n<li>充足的睡眠</li>\n<li>写感恩日记</li>\n</ul>\n<h2 id=\"6个更好生活\"><a href=\"#6个更好生活\" class=\"headerlink\" title=\"6个更好生活\"></a>6个更好生活</h2><ul>\n<li>相信你值得</li>\n<li>世界是你的ATM,善待世界</li>\n<li>给自己时间去思考和做梦</li>\n<li>减少有害输入</li>\n<li>立刻行动</li>\n<li>明白真正的裁判是谁</li>\n</ul>\n<h2 id=\"自律\"><a href=\"#自律\" class=\"headerlink\" title=\"自律\"></a>自律</h2><ul>\n<li>冥想</li>\n<li>工作15min</li>\n<li>每天做</li>\n<li>迈出第一步</li>\n<li>倒数让自己行动起来</li>\n<li>志同道合的朋友</li>\n<li>稳定规律的生活</li>\n</ul>\n<h2 id=\"成功的关键点\"><a href=\"#成功的关键点\" class=\"headerlink\" title=\"成功的关键点\"></a>成功的关键点</h2><ul>\n<li>专注自己的进步，而非他人的成就</li>\n<li>学会在危机中寻机</li>\n<li>当你坚持不下去时，更努力些</li>\n<li>切忌骄傲自满，虚心找不足,求精进</li>\n</ul>\n<h2 id=\"7个要掌握的心理学技巧\"><a href=\"#7个要掌握的心理学技巧\" class=\"headerlink\" title=\"7个要掌握的心理学技巧\"></a>7个要掌握的心理学技巧</h2><ul>\n<li>藏拙</li>\n<li>抵抗群体思维</li>\n<li>别在意他人的看法</li>\n<li>别责怪</li>\n<li>不要抢着说话</li>\n<li>别被欲望操纵</li>\n<li>别太较真(那些你帮不上的国家大事,和社会新闻)</li>\n</ul>\n<h2 id=\"训练大脑\"><a href=\"#训练大脑\" class=\"headerlink\" title=\"训练大脑\"></a>训练大脑</h2><ul>\n<li>打破常规，做些新颖的事</li>\n<li>另辟蹊径</li>\n<li>使用非惯用手</li>\n<li>玩观察游戏</li>\n<li>讲故事</li>\n<li>记住你的清单</li>\n<li>停止依赖科技</li>\n<li>练习解决问题</li>\n<li>大声朗读</li>\n<li>在纸上写作</li>\n<li>从一个新的角度看</li>\n</ul>\n<h2 id=\"五条晨间习惯\"><a href=\"#五条晨间习惯\" class=\"headerlink\" title=\"五条晨间习惯\"></a>五条晨间习惯</h2><ul>\n<li>为逆境做好准备</li>\n<li>为美好的一天作计划</li>\n<li>专注你的目标</li>\n<li>提醒自己控制二分法(专注自己可以控制的事)</li>\n<li>记住生命有限</li>\n</ul>\n<h2 id=\"杂谈\"><a href=\"#杂谈\" class=\"headerlink\" title=\"杂谈\"></a>杂谈</h2><p>其实，人类社会的意义不过四个：延续种族 、掌控心智、掌控环境、增进我们的满足感。<br>但人类历史的车轮滚滚向前，谁的生命不是微不足道的呢？即便是苏格拉底、莎士比亚或爱因斯坦，对着漫长的人类社会的河流所作出的贡献都是微不足道的。<br>但我们无需从个体的维度去考虑生命的意义，而是要从全人类的维度去考虑个体的贡献。你会发现，那么，今天赚了点钱，照顾了孩子，收拾了房子，都是有意义的。每个个体都在人类文明这一进程中划上了痕迹</p>\n<h1 id=\"出境注意\"><a href=\"#出境注意\" class=\"headerlink\" title=\"出境注意\"></a>出境注意</h1><ul>\n<li>遭遇盘查莫慌张，妥善应对寻帮助。出国（境）人员如遇他国执法人员盘查，要沉着冷静，理性配合，妥善应对。如语言不通，应寻求翻译协助，切勿随意回答；如提问涉及我国家秘密，应当向其申明并拒绝回答；如遇开箱查验，本人务必在场，以防有人暗中动手脚；如遇到境外间谍情报机关或其他执法部门约谈、攀拉、策反，应坚决表明立场，不到对方指定场所，不签署任何文件，坚持要求联系我驻外使领馆寻求领事保护。</li>\n<li>交友搭讪需谨慎，防范意识不可少。出国（境）人员在旅游期间约伙搭伴，应注意辨别对方人员情况，警惕无端打听个人隐私、索要相关敏感信息的可疑人员，不收取对方提供的任何财物，不透露任何内部信息，不给境外间谍情报机关套取信息、诱导胁迫的可乘之机。此外，出国（境）人员应拒绝为陌生人携带来源不明的物品，并谨慎对待任何过于亲密或异常的行为。</li>\n<li>时刻绷紧保密弦，严防大意失泄密。出国（境）人员应尽量避免在境外使用公共Wi-Fi登录重要账户或传输敏感数据，严禁在公开网络环境中处理国家秘密和工作秘密事项，个人电子设备应提前设置安全防护措施，防止被非法入侵。此外，涉密岗位工作人员出国（境）前要仔细核对携带出国（境）物品是否含有秘密载体，未经有关主管部门批准，任何组织和个人不得携带、传递国家秘密载体出国（境）。出国（境）后更需绷紧保密纪律这根弦，不谈论敏感内容，防止敏感信息外泄。</li>\n<li>言行举止需注意，切勿轻信被利用。境外敌对组织常向我出国（境）人员传播涉我虚假信息、政治谣言、失实报道等，丑化我国国家形象，进行意识形态渗透。出国（境）人员如遇到涉我敏感话题活动时，应保持冷静和理性，客观阐释我经济社会发展成就、展现我良好国际形象，切勿随意传播未经核实的信息，更不能参与、协助可能损害我国家利益的活动。</li>\n</ul>\n<h1 id=\"举报骚扰电话\"><a href=\"#举报骚扰电话\" class=\"headerlink\" title=\"举报骚扰电话\"></a>举报骚扰电话</h1><p>微信搜索##12321举报##</p>\n<h1 id=\"报案注意点\"><a href=\"#报案注意点\" class=\"headerlink\" title=\"报案注意点\"></a>报案注意点</h1><ul>\n<li>报案一定要留下痕迹，比如要求有报案回执，如果不立案要有不予立案通知书，以及报案前先打110留记录</li>\n<li>去国务院小程序投诉要语言精炼，逻辑清晰</li>\n</ul>\n<h1 id=\"待业交社保\"><a href=\"#待业交社保\" class=\"headerlink\" title=\"待业交社保\"></a>待业交社保</h1><ul>\n<li><img src=\"/images/sheBao1.jpg\" alt=\"p1\"> </li>\n<li><img src=\"/images/sheBao2.jpg\" alt=\"p2\"> </li>\n<li><img src=\"/images/sheBao3.jpg\" alt=\"p3\"></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clq1yvi6s0004gwq2b0ingkra","category_id":"clq1yvi6t0006gwq2h3en0fay","_id":"clq1yvi6w000dgwq2d97e3ybt"},{"post_id":"clq1yvi6s0005gwq2hypud0ma","category_id":"clq1yvi6t0006gwq2h3en0fay","_id":"clq1yvi6x000igwq26j6d4n9n"},{"post_id":"clq1yvi6v000bgwq23mfgg2zk","category_id":"clq1yvi6w000egwq2gjb3bhsk","_id":"clq1yvi6y000pgwq2hdif3rvr"},{"post_id":"clq1yvi6v000cgwq243c82psb","category_id":"clq1yvi6w000egwq2gjb3bhsk","_id":"clq1yvi71000tgwq22udwcj5o"},{"post_id":"clq1yvi730013gwq2d9uge3px","category_id":"clq1yvi730015gwq2cifbe99j","_id":"clq1yvi75001bgwq2673sbnoz"},{"post_id":"clq1yvi77001pgwq218wf9njb","category_id":"clq1yvi6w000egwq2gjb3bhsk","_id":"clq1yvi78001ugwq2eqepgipe"},{"post_id":"clq1yvi77001ogwq2by3qewbi","category_id":"clq1yvi77001qgwq2fo4e8zsh","_id":"clq1yvi78001zgwq2aqhwcsex"},{"post_id":"clq1yvi78001wgwq23oocfw2u","category_id":"clq1yvi77001qgwq2fo4e8zsh","_id":"clq1yvi790023gwq25itodrl2"},{"post_id":"clq1yvi790021gwq29djbecoa","category_id":"clq1yvi6t0006gwq2h3en0fay","_id":"clq1yvi7a0028gwq21emden6n"}],"PostTag":[{"post_id":"clq1yvi6v000bgwq23mfgg2zk","tag_id":"clq1yvi6w000fgwq24edu623f","_id":"clq1yvi6x000mgwq2hrnihdib"},{"post_id":"clq1yvi6v000cgwq243c82psb","tag_id":"clq1yvi6x000lgwq26k6q9mgd","_id":"clq1yvi6z000rgwq27vdv91x6"},{"post_id":"clq1yvi78001wgwq23oocfw2u","tag_id":"clq1yvi6w000fgwq24edu623f","_id":"clq1yvi790020gwq25sac5n18"},{"post_id":"clq1yvi790021gwq29djbecoa","tag_id":"clq1yvi790024gwq245zu2t8e","_id":"clq1yvi7a002agwq2fo9w46vr"}],"Tag":[{"name":"命令","_id":"clq1yvi6w000fgwq24edu623f"},{"name":"文件","_id":"clq1yvi6x000lgwq26k6q9mgd"},{"name":"字符","_id":"clq1yvi790024gwq245zu2t8e"}]}}