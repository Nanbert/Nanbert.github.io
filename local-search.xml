<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/12/hello-world/"/>
    <url>/2023/12/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>定时器</title>
    <link href="/2023/10/31/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/2023/10/31/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SIGALRM信号"><a href="#SIGALRM信号" class="headerlink" title="SIGALRM信号"></a>SIGALRM信号</h1><h2 id="配合setitimer"><a href="#配合setitimer" class="headerlink" title="配合setitimer"></a>配合setitimer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timer_isr</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timer_isr: press &#x27;c&#x27; and enter to exit:\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">itimerval</span> mtimer;<br>mtimer.it_value.tv_sec = <span class="hljs-number">5</span>;<br>mtimer.it_value.tv_usec = <span class="hljs-number">0</span>;<br>mtimer.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>mtimer.it_interval.tv_usec = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">signal</span>(SIGALRM, timer_isr);<br><span class="hljs-built_in">setitimer</span>(ITIMER_REAL, &amp;mtimer, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>c = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">if</span> (c ==<span class="hljs-string">&#x27;c&#x27;</span> || c == <span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2023/09/03/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/09/03/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="7进程环境"><a href="#7进程环境" class="headerlink" title="7进程环境"></a>7进程环境</h1><h2 id="main函数的启动"><a href="#main函数的启动" class="headerlink" title="main函数的启动"></a>main函数的启动</h2><p>当内核执行c程序时，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址（连接器指定）,启动例程从内核取得命令行参数和环境变量值，然后调用main函数</p><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><h3 id="8种终止方式"><a href="#8种终止方式" class="headerlink" title="8种终止方式"></a>8种终止方式</h3><ol><li>从main返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从其启动例程返回</li><li>最后一个线程调用pthread_exit<br>异常终止:</li><li>调用abort</li><li>接到一个信号</li><li>最后一个线程对取消请求做出响应</li></ol><h3 id="atexit函数"><a href="#atexit函数" class="headerlink" title="atexit函数"></a>atexit函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">atexit</span><span class="hljs-params">(<span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-comment">// 登记成功返回0</span><br></code></pre></td></tr></table></figure><p>终止处理函数，一个进程可以登记最多32个函数<br><img src="/images/exit.png"></p><h2 id="内存空间分布"><a href="#内存空间分布" class="headerlink" title="内存空间分布"></a>内存空间分布</h2><p><img src="/images/memory_struct.png"><br>磁盘上的可执行文件并不存放bss内容，内核在程序开始运行前将它们都设为0。磁盘可执行文件只存取text和初始化段<br><code>size /path/bin</code>可查看某执行文件的各个段的长度</p><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>gcc默认使用共享库，可使用-static阻止使用共享库</p><h2 id="内存分配函数"><a href="#内存分配函数" class="headerlink" title="内存分配函数"></a>内存分配函数</h2><ul><li>malloc: 分配指定字节数的存储区。初始值不确定</li><li>calloc: 为指定数量指定长度的对象分配存储空间,初始化为0</li><li>realloc: 增加或减少以前分配区的长度。增加时新增区的初始值不确定<br>它们都是调用sbrk的系统调用，sbrk可扩充或缩小进程的存储空间，但是大多数的malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配<br>这三个函数都有debug版本，进行附加检错，通过设置环境变量支持<br><strong>alloca</strong>函数分配的空间在栈上</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>全局变量environ(char**)，指向环境表，一般不对它进行直接操作<br><img src="/images/environ.png"></p><ul><li><code>char* getenv(const char* name)</code></li><li><code>int putenv(char *str)</code>str是类似<code>name = value</code>, 会直接将该值的地址放到环境表中,所以str不能是栈上的</li><li><code>int setenv(const char *name, const char* value, int rewrite)</code> rewrite为0,则不删除现有定义</li><li><code>int unsetenv(const char* name)</code><br>环境表和环境字符串通常位于进程空间的顶部，所以如果增加环境变量或值字符串变长，系统会调用malloc在堆上分配空间</li></ul><h2 id="setjmp和longjmp函数间的跳转"><a href="#setjmp和longjmp函数间的跳转" class="headerlink" title="setjmp和longjmp函数间的跳转"></a>setjmp和longjmp函数间的跳转</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setjmp</span><span class="hljs-params">(jmp_buf env)</span><span class="hljs-comment">//若直接调用，返回0；若从longjmp返回，则非0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">longjmp</span><span class="hljs-params">(jmp_Buf env, <span class="hljs-type">int</span> val)</span><br></code></pre></td></tr></table></figure><p>在函数之间的跳转，会舍弃中间的帧，无法确保变量的值，在同一个系统中，要想获得可靠的值，则要加上volatile关键字，这并不能保证(p218仔细看把)</p><h2 id="getrlimit和setrlimit资源限制函数"><a href="#getrlimit和setrlimit资源限制函数" class="headerlink" title="getrlimit和setrlimit资源限制函数"></a>getrlimit和setrlimit资源限制函数</h2><p>(todo,目前感觉用处不大)</p><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><ul><li>进程0：调度进程，也叫交换进程，内核的一部分，不执行任何磁盘上的程序</li><li>进程1：init进程，自举过程结束，由内核调用，永不会终止，以超级用户特权运行的普通用户进程</li></ul><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>fork完文件表项如下图<br><img src="/images/fd.png"></p><h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><ul><li>僵尸进程：子进程终止，父进程未wait回收其资源</li><li>孤儿进程：子进程未结束，父进程终止了，此时，成为孤儿进程，之后由内核的进程1托管成为父进程</li></ul><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>用磁盘上的一个新程序替换当前进程的正文段、数据段、堆和栈</p><h2 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h2><p>wait函数会回收子进程的结束状态，但有些wait函数是只读，这可以再次wait，读取其状态</p><h2 id="setuid"><a href="#setuid" class="headerlink" title="setuid"></a>setuid</h2><p>set-user-id就是ls -l权限中的s权限<br><img src="/images/uid.png"></p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>该函数其实调用了fork-&gt;exec-&gt;waitpid函数，有设置用户id的程序最后不用该函数，可能使得system执行的程序权限提升，正确做法fork前设置适当的有效用户id</p><h2 id="设置priority函数"><a href="#设置priority函数" class="headerlink" title="设置priority函数"></a>设置priority函数</h2><p>nice、getpriority、setpriority</p><h2 id="进程会计–pacct命令"><a href="#进程会计–pacct命令" class="headerlink" title="进程会计–pacct命令"></a>进程会计–pacct命令</h2><h2 id="进程时间–times"><a href="#进程时间–times" class="headerlink" title="进程时间–times"></a>进程时间–times</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式_观察者模式</title>
    <link href="/2023/07/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/07/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/observer_normal.png"><br><img src="/images/observer_exp.png"></p><h1 id="松耦合设计"><a href="#松耦合设计" class="headerlink" title="松耦合设计"></a>松耦合设计</h1><p>尽量做到交互对象之间的松耦合，这允许我们建造能够应对变化的，有弹性的OO系统，因为对象之间的依赖降到最低</p><h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><p>订阅模式是个更复杂的模式，常常用在中间件，注意与之区别</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li>观察者模式定义对象之间的一对多关系</li><li>主题使用通用接口更新观察者</li><li>任何具体类型的观察者都可以参与该模式，只要它们实现观察者接口</li><li>观察者是松耦合的，除了知道它们实现观察者接口之外，主题对它们的事情不知</li><li>使用该模式时，可以从主题推或拉数据</li><li>观察者模式在MVC中经常用到</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式_装饰者模式</title>
    <link href="/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="开放-关闭原则"><a href="#开放-关闭原则" class="headerlink" title="开放-关闭原则"></a>开放-关闭原则</h1><p>类应该对扩展开放，但对修改关闭</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/decorator.jpg"></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li>继承是扩展形式之一，但未必是达到弹性设计的最佳方式</li><li>组合和委托经常可以用来在运行时添加新行为</li><li>装饰者模式提供了子类化扩展行为的替代品</li><li>装饰者模式涉及一群装饰者类，这些类用来包装具体组件</li><li>装饰者类反映了他们所装饰的组件类型</li><li>装饰者通过在对组件的方法调用之前或之后添加功能改变组件的行为</li><li>可以用任意数目的装饰者来包裹一个组件</li><li>装饰者一般对组件的客户是透明的，除非客户依赖于组件的具体类型</li><li>装饰者或导致设计中出现许多小对象，过度使用会让代码复杂</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式_工厂模式</title>
    <link href="/2023/06/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/06/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p><img src="/images/simpleFactory.png"></p><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><ul><li>定义： 一个创建对象的接口，但让子类决定哪个类要实力化。工厂方法让一个类延迟实例化到子类<br><img src="/images/factoryMethodNormal.png"><br><img src="/images/factoryMethodExp.png"></li></ul><h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><ul><li>定义：依赖抽象，不依赖具体类</li><li>精髓：低层组件依赖于更高层的抽象</li><li>原则：<ul><li>变量不应该持有到具体类的引用</li><li>类不应该派生自具体类</li><li>方法不应该覆盖其任何基类的已实现方法</li></ul></li></ul><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><ul><li>定义：提供一个接口，用于创建相关或依赖对象的家族，而不必指定它们具体类<br><img src="/images/abstractFactory.png"></li></ul><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li>所有工厂都封装对象的创建</li><li>工厂方法靠继承：对象创建被委托给子类，子类实现工厂方法来创建对象</li><li>抽象工厂靠对象组合：对象创建在工厂接口暴露的方法中实现</li><li>所有工厂模式都通过减少应用对具体类的依赖，促进松耦合</li><li>工厂方法的意图，是允许一个类延迟实例化到其子类</li><li>抽象工厂的意图，是创建相关对象家族，不必依赖具体类</li><li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP</title>
    <link href="/2022/10/03/TCP-IP/"/>
    <url>/2022/10/03/TCP-IP/</url>
    
    <content type="html"><![CDATA[<h1 id="UDP存在的意义"><a href="#UDP存在的意义" class="headerlink" title="UDP存在的意义"></a>UDP存在的意义</h1><p><img src="/images/UDP.png"></p><ul><li>无需建立连接，不会引入建立连接的时延</li><li>无连接状态，tcp需要维护接发缓存、拥塞控制参数、序号及确认号的参数</li><li>分组首部更小</li><li>无拥塞控制，对于不希望过分延迟报文段的传送并且容忍数据丢失的场景适用</li></ul><h1 id="校验和的计算"><a href="#校验和的计算" class="headerlink" title="校验和的计算"></a>校验和的计算</h1><ul><li>发送方对UDP报文段中的所有16比特字进行累加，溢出将回卷，并取反得到校验和。</li><li>接收方将所有16比特字(包括校验和)进行累加,无错即得到全1</li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p><img src="/images/TCP.png"></p><h2 id="涉及概念"><a href="#涉及概念" class="headerlink" title="涉及概念"></a>涉及概念</h2><ul><li>ACK:肯定确认,在TCP头部中表示当前对确认字段中的值是有效的,明显第一次握手时，该值置为0</li><li>NAK:否定确儿（TCP中没有，只需确认最后一次接收到的分组即可）</li><li>GBN:回退N步</li><li>SR:选择重传</li><li>MSS:最大报文长度,不包括头40字节</li><li>MTU:最大传输单元，链路层的最大帧长度(以太网中为1500字节)，MSS&#x3D;MTU-40(TCP+IP首部长度)</li><li>RTT:往返时间</li></ul><h2 id="六比特标识位"><a href="#六比特标识位" class="headerlink" title="六比特标识位"></a>六比特标识位</h2><ul><li>URG:用于指示报文段里存在着被发送端的上层实体置为紧急的数据(一般不用)</li><li>ACK:用于指示确认字段的值是有效的</li><li>PSH:用于指示接收方应立即将数据交给上层(一般不用)</li><li>RST:用于告诉源：我没有那个报文段的套接字(即端口号未开)，不要再发送该报文,udp遇到这种情况会发送一个ICMP的数据报</li><li>SYN:用于建立连接</li><li>FIN:用于拆除连接</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li>rwnd(接受窗口)&#x3D;RcvBuffer-[LastByteRcvd-LastByteRead]</li></ul><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/images/handshake.png"></p><ul><li>第一次：SYN为1,ACK为0,随机初始化一个seq(client_isn)</li><li>第二次：SYN为1,ACK为1,随机初始化一个seq(server_isn),并设置确认号ack(client_isn+1)，此时服务器可能分配缓存和变量（此时分配会受到SYN洪泛攻击）</li><li>第三次：SYN为1,ACK为1,客户分配缓存和变量，并可以携带有效数据</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/images/byebye.png"></p><ul><li>第一次(假设客户端先手)：FIN为1，ACK&#x3D;0,随机一个seq,此时不发送有效数据，仍然可以接受数据</li><li>第二次：ACK&#x3D;1,ackNum为seq+1,此时服务器仍然可以发送数据</li><li>第三次：FIN为1，ACK&#x3D;0,随机一个seq，此时服务器不发送有效数据</li><li>第四次：ACK&#x3D;1,ackNum为seq+1</li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ul><li>发送方跟踪额外的变量:拥塞窗口(cwnd),注意这与流量控制不同，<strong>不体现在tcp头部中</strong></li><li>LastByteSent-LastByteAcked&lt;&#x3D;min{cwnd,rwnd}</li><li>初始化时，cwnd通常为1个MSS，然后进入慢启动(指数增长),遇到拥塞，cwnd减半，并设置ssthresh&#x3D;cwnd&#x2F;2(慢启动阈值),结束慢启动</li><li>TCP的拥塞控制：每个RTT内cwnd线性增加1个MSS，出现3个冗余ACK时，cwnd减半（加性增、乘性减）</li></ul><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h2><p><img src="/images/IP.png"></p><h3 id="关键字段"><a href="#关键字段" class="headerlink" title="关键字段"></a>关键字段</h3><ul><li>版本号：4比特，定义是ipv4还是ipv6</li><li>首部长度：4比特，定义首部长度</li><li>服务类型：8比特，服务类型(延时低，高吞吐等)</li><li>数据包长度：ip数据报总长度（首部+数据）</li><li>标识、标志、偏移：ip分片有关</li><li>寿命：8字节，没经过一个路由减1,为0时丢弃</li><li>协议：表示上层协议（UDP还是）</li><li>首部校验和：只针对头部计算，注意由于寿命会变，所以需要不断的更新</li><li>源和目的ip地址：没啥好说</li><li>选项：很少使用，ipv6中就没有</li><li>有效数据</li></ul><h3 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h3><p><img src="/images/IP_fra.png"></p><ul><li>之前提到过，一个链路层帧能承载的最大数据量叫做<strong>最大传送单元（MTU）</strong></li><li>广域网和局域网可能MTU不同所以要分片</li><li>分片的重组放在端系统中，路由器不负责重组</li><li>最后一片标志被置为0</li></ul><h3 id="ipv4编址"><a href="#ipv4编址" class="headerlink" title="ipv4编址"></a>ipv4编址</h3><ul><li>接口：主机与物理链路之间的边界叫做接口</li><li>ip地址：IP协议要求每台主机和路由器的接口拥有自己的IP地址<br><strong>从技术上来讲一个ip地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联</strong></li><li>子网掩码：a.b.c.d&#x2F;x,x最高比特构成了IP地址的网络部分，为网络前缀</li><li>CIDR：无类别域间路由选择，这种更灵活</li><li>分类编址（不灵活）：A类子网(8bit)，B类子网(16bit)，C类子网(24bit),会有c类太少，b类太大的烦恼</li></ul><h3 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h3><p>性质：基于UDP的应用层协议,默认端口67<br>作用： 除了分配IP地址外，DHCP还允许获取其他信息子网掩码，默认网关（第一跳路由器），本地DNS服务器地址<br><img src="/images/DHCP.png"></p><h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换-NAT"></a>网络地址转换-NAT</h3><ul><li>会改写IP地址和端口号<br><img src="/images/NAT.png"></li></ul><h2 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h2><p><img src="/images/IPV6.png"></p><ul><li>版本：显然设为6</li><li>流量类型：与ipv4服务类型类似</li><li>流标签：标识一条数据报的流，还未完全确定</li><li>有效载荷长度</li><li>跳限制：计数为0丢弃</li></ul><h3 id="ipv4-ipv6-隧道"><a href="#ipv4-ipv6-隧道" class="headerlink" title="ipv4-&gt;ipv6:隧道"></a>ipv4-&gt;ipv6:隧道</h3><p><img src="/images/tunneling.png"></p><h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><ul><li>OpenFLow标准</li><li>SDN</li><li>就是根据各层的头信息执行特定转发，有更大灵活性，跳出IP转发的局限性</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2022/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h1><ul><li>定义: 将端系统物理连接到<strong>边缘路由器</strong>的网络，<strong>边缘路由器</strong>就是端系统到任何其他远程端系统的路径上的第一台路由器</li></ul><h2 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h2><h3 id="数字用户线-DSL"><a href="#数字用户线-DSL" class="headerlink" title="数字用户线(DSL)"></a>数字用户线(DSL)</h3><p><img src="/images/dsl.png"></p><ul><li>涉及概念：DSL调制解调器，数字用户线接入复用器（DSLAM）</li></ul><h3 id="电缆英特网接入"><a href="#电缆英特网接入" class="headerlink" title="电缆英特网接入"></a>电缆英特网接入</h3><p><img src="/images/CIA.png"></p><ul><li>涉及概念：电缆调制解调器端接系统(CMTS),混合光纤同轴（HFC）系统</li></ul><h3 id="光纤到户（FTTH）"><a href="#光纤到户（FTTH）" class="headerlink" title="光纤到户（FTTH）"></a>光纤到户（FTTH）</h3><ul><li>涉及概念：光纤网络端接器（ONT）,光纤线路端接器（OLT）</li></ul><h2 id="企业-家庭-接入"><a href="#企业-家庭-接入" class="headerlink" title="企业(&#x2F;家庭)接入"></a>企业(&#x2F;家庭)接入</h2><h3 id="以太网（LAN局域网的一种）"><a href="#以太网（LAN局域网的一种）" class="headerlink" title="以太网（LAN局域网的一种）"></a>以太网（LAN局域网的一种）</h3><p><img src="/images/LAN.png"></p><h3 id="wifi-无线局域网wlan"><a href="#wifi-无线局域网wlan" class="headerlink" title="wifi(无线局域网wlan)"></a>wifi(无线局域网wlan)</h3><p><img src="/images/wireless.png"></p><h2 id="广域接入"><a href="#广域接入" class="headerlink" title="广域接入"></a>广域接入</h2><p>2G,3G,4G…,LTE</p><h1 id="物理媒介"><a href="#物理媒介" class="headerlink" title="物理媒介"></a>物理媒介</h1><p><img src="/images/tp.png" alt="双绞铜线"><br><img src="/images/cable.png" alt="同轴电缆"><br><img src="/images/fiber.png" alt="光纤"><br>陆地&#x2F;卫星无线电通道</p><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><h2 id="电路交换（过时）"><a href="#电路交换（过时）" class="headerlink" title="电路交换（过时）"></a>电路交换（过时）</h2><ul><li>涉及概念：频分复用(FDM)、时分复用(TDM)</li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>端到端交换<strong>报文(message)</strong>,需要将报文划分较小的数据块，称之为<strong>分组(packet)<strong>，每个分组由</strong>比特</strong>衡量大小</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img src="/images/delay.png"></p><ul><li>处理时延：检查分组首部和决定该分组导向何处所需要的时间，由路由处理及选择有关,&lt;&#x3D;微秒量级</li><li>排队时延：一个特定分组的排队时延取决于先期到达的正在排队的分组数量,毫秒量级-微秒量级</li><li>传输时延：一个分组的所有比特到达后才可以传输，一个L比特的分组在速率为R的链路上的传输时延是L&#x2F;R，与路由之间的距离无关，毫秒-微妙</li><li>传播时延：从链路的起点到某路由器传播所需要的时间是传播时延，与距离相关：d&#x2F;s，s解近光速，毫秒级别</li></ul><h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><ul><li>流量强度：La&#x2F;R,a为分组&#x2F;秒，表示分组到达队列的平均速率,流量强度必须小于1,否则队列无限增长，时延趋向无限大，但实际中容量有限，此时会导致丢包</li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="/images/througput.png"><br>取决于链路中的最小传输速率，及公共链路中其他干扰流量,忽略干扰流量就是min(R1,R2,R3…)</p><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="病毒和蠕虫"><a href="#病毒和蠕虫" class="headerlink" title="病毒和蠕虫"></a>病毒和蠕虫</h3><h3 id="拒绝服务攻击-DoS"><a href="#拒绝服务攻击-DoS" class="headerlink" title="拒绝服务攻击-DoS"></a>拒绝服务攻击-DoS</h3><ul><li>弱点攻击：向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文</li><li>带宽洪泛：攻击者向目标主机发送大量的分组，使链路拥塞</li><li>连接洪泛：在目标主机中创建大量半开或全开TCP连接</li></ul><h3 id="嗅探分组wireshark"><a href="#嗅探分组wireshark" class="headerlink" title="嗅探分组wireshark"></a>嗅探分组wireshark</h3><h3 id="ip哄骗"><a href="#ip哄骗" class="headerlink" title="ip哄骗"></a>ip哄骗</h3><h2 id="网络层模型"><a href="#网络层模型" class="headerlink" title="网络层模型"></a>网络层模型</h2><p><img src="/images/layer.png"></p><ul><li>message:报文</li><li>segment:报文段</li><li>datagram:数据报</li><li>frame:帧</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tokio</title>
    <link href="/2022/06/27/tokio/"/>
    <url>/2022/06/27/tokio/</url>
    
    <content type="html"><![CDATA[<h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><ul><li>并行运行CPU密集型的任务（并行计算）</li><li>读取大量的文件</li><li>发送少量HTTP请求</li></ul><h2 id="async-main"><a href="#async-main" class="headerlink" title="async main"></a>async main</h2><p>异步main函数的意义：</p><ul><li>.await只能在async函数中使用</li><li>异步运行时本身需要初始化，<code>#[tokio::main]</code>宏将<code>async fn main</code>隐式转换为<code>fn main</code>，同时还对整个异步运行时进行了初始化：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>转化为：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">rt</span> = tokio::runtime::Runtime::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    rt.<span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——异步</title>
    <link href="/2022/06/20/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5/"/>
    <url>/2022/06/20/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="基本知识与背景"><a href="#基本知识与背景" class="headerlink" title="基本知识与背景"></a>基本知识与背景</h2><ul><li>异步编程是一个并发编程模型，允许我们同时并发运行大量的任务，却仅仅需要几个甚至一个os线程或cpu核心</li><li>几个并发模型:<ul><li>多线程：最原始，上下文切换损耗大，线程池有所缓解，不适用于io密集型</li><li>事件驱动：回调-callback，javascript使用，存在回调地狱（非线性的控制流和结果处理导致了数据流向和错误传播变得难以掌控，可维护性和可读性大幅降低）</li><li>协程：go语言使用，抽象层次过高，无法接触底层细节,自定义程度低</li><li>actor模型：erlang使用，容易实现，通过消息传递进行通信和数据传递，和分布式系统概念相似，但遇到流控制、失败重试场景就不好用</li><li>async：性能高，支持底层，又有一定抽象，内部机制过于复杂，使用起来不够简单</li></ul></li></ul><h3 id="rust中的async"><a href="#rust中的async" class="headerlink" title="rust中的async"></a>rust中的async</h3><ul><li>future在rust中是惰性的，future可以简单理解为在未来某个时间点被执行的任务</li><li>rust没有内置异步调用所必须的运行时，需要三方库，如tokio</li><li>运行时同时支持单线程和多线程</li></ul><h3 id="原始多线程与async的选择"><a href="#原始多线程与async的选择" class="headerlink" title="原始多线程与async的选择"></a>原始多线程与async的选择</h3><p>原始多线程适用于：</p><ul><li>少量任务并发</li><li>cpu密集型任务，如并行计算</li><li>部分io任务，可以用线程池</li><li>无所谓时，使用简单<br>async适用于：</li><li>io密集型，高并发</li></ul><h3 id="async的库支持"><a href="#async的库支持" class="headerlink" title="async的库支持"></a>async的库支持</h3><ul><li>所必须的特征(例如Future)、类型和函数，由标准库提供实现</li><li>关键字async&#x2F;await由Rust语言提供，并进行了编译器层面的支持</li><li>众多实用的类型、宏和函数由官方开发的futures包提供(不是标准库)，它们可以用于任何async应用中。</li><li>async代码的执行、IO操作、任务创建和调度等等复杂功能由社区的async运行时提供，例如tokio和async-std</li></ul><h3 id="一个例子认识async"><a href="#一个例子认识async" class="headerlink" title="一个例子认识async"></a>一个例子认识async</h3><p>未改前(虽然用到async函数，但完全是同步)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::executor::block_on;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Song</span> &#123;<br>    author: <span class="hljs-type">String</span>,<br>    name: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">learn_song</span>() <span class="hljs-punctuation">-&gt;</span> Song &#123;<br>    Song &#123;<br>        author: <span class="hljs-string">&quot;曲婉婷&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;《我的歌声里》&quot;</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sing_song</span>(song: Song) &#123;<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;给大家献上一首&#123;&#125;的&#123;&#125; ~ &#123;&#125;&quot;</span>,<br>        song.author, song.name, <span class="hljs-string">&quot;你存在我深深的脑海里~ ~&quot;</span><br>    );<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dance</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;唱到情深处，身体不由自主的动了起来~ ~&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">song</span> = <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">learn_song</span>());<br>    <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">sing_song</span>(song));<br>    <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">dance</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>改之后:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::executor::block_on;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Song</span> &#123;<br>    author: <span class="hljs-type">String</span>,<br>    name: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">learn_song</span>() <span class="hljs-punctuation">-&gt;</span> Song &#123;<br>    Song &#123;<br>        author: <span class="hljs-string">&quot;曲婉婷&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;《我的歌声里》&quot;</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sing_song</span>(song: Song) &#123;<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;给大家献上一首&#123;&#125;的&#123;&#125; ~ &#123;&#125;&quot;</span>,<br>        song.author, song.name, <span class="hljs-string">&quot;你存在我深深的脑海里~ ~&quot;</span><br>    );<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dance</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;唱到情深处，身体不由自主的动了起来~ ~&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">learn_and_sing</span>() &#123;<br>    <span class="hljs-comment">// 这里使用`.await`来等待学歌的完成，但是并不会阻塞当前线程，该线程在学歌的任务`.await`后，完全可以去执行跳舞的任务</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">song</span> = <span class="hljs-title function_ invoke__">learn_song</span>().<span class="hljs-keyword">await</span>;<br><br>    <span class="hljs-comment">// 唱歌必须要在学歌之后</span><br>    <span class="hljs-title function_ invoke__">sing_song</span>(song).<span class="hljs-keyword">await</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f1</span> = <span class="hljs-title function_ invoke__">learn_and_sing</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f2</span> = <span class="hljs-title function_ invoke__">dance</span>();<br><br>    <span class="hljs-comment">// `join!`可以并发的处理和等待多个`Future`，若`learn_and_sing Future`被阻塞，那`dance Future`可以拿过线程的所有权继续执行。若`dance`也变成阻塞状态，那`learn_and_sing`又可以再次拿回线程所有权，继续执行。</span><br>    <span class="hljs-comment">// 若两个都被阻塞，那么`async main`会变成阻塞状态，然后让出线程所有权，并将其交给`main`函数中的`block_on`执行器</span><br>    futures::join!(f1, f2);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">async_main</span>());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>async标记的语法块会转成实现了Future特征的状态机，当Future执行并遇到阻塞时，它会让出当前线程的控制权，其他的future就可以在该线程中运行</li><li>需要在Cargo.toml中添加内容:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">[dependencies]<br>futures = <span class="hljs-string">&quot;0.3&quot;</span><br></code></pre></td></tr></table></figure></li><li><code>async fn</code>创建一个异步函数，异步函数的返回值是一个Future,Future直接调用不会输出任何结果，需要一个执行器（上面例子就是block_on）</li><li>block_on执行器简单粗暴，会阻塞当前线程直到任务完成</li><li>.await不会阻塞当前线程，而是异步等待future完成，该线程还可以执行其他future</li></ul><h2 id="future特征"><a href="#future特征" class="headerlink" title="future特征"></a>future特征</h2><p>抽象化定义：它是一个能产出值的异步计算（值可能为空<code>()</code>）<br>简化版：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">SimpleFuture</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, wake: <span class="hljs-title function_ invoke__">fn</span>()) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Poll</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ready</span>(T),<br>    Pending,<br>&#125;<br></code></pre></td></tr></table></figure><p>若当前poll中，future可以被完成，则返回Poll::Ready,反之则返回Pending,并且安排一个wake函数，，当future准备好时，wake通知执行器执行</p><h3 id="Unpin"><a href="#Unpin" class="headerlink" title="Unpin"></a>Unpin</h3><p>绝大多数标准库类型都实现了Unpin,但生成的Future没有实现Unpin,默认是!Unpin的，具体实践吧</p><h2 id="async的生命周期"><a href="#async的生命周期" class="headerlink" title="async的生命周期"></a>async的生命周期</h2><p>如果拥有引用类型的参数，那么返回的Future的生命周期就会被这些参数的生命周期所限制，引用参数必须活得比future长</p><h2 id="async-move"><a href="#async-move" class="headerlink" title="async move"></a>async move</h2><p>就是移到future内，不可以共享了</p><h2 id="await与多线程"><a href="#await与多线程" class="headerlink" title=".await与多线程"></a>.await与多线程</h2><p>async语句块中的变量必须可以在线程间传递，所以必须实现Send和Sync特征，<br>不能使用Mutex锁，而是要四用futures::lock</p><h2 id="Stream特征"><a href="#Stream特征" class="headerlink" title="Stream特征"></a>Stream特征</h2><p>该特征类似于Future特征，也与迭代器类似，future包中的mpsc就实现了Stream特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send_recv</span>() &#123;<br>    <span class="hljs-keyword">const</span> BUFFER_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> tx, <span class="hljs-keyword">mut</span> rx) = mpsc::channel::&lt;<span class="hljs-type">i32</span>&gt;(BUFFER_SIZE);<br><br>    tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>    tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">2</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-title function_ invoke__">drop</span>(tx);<br><br>    <span class="hljs-comment">// `StreamExt::next` 类似于 `Iterator::next`, 但是前者返回的不是值，而是一个 `Future&lt;Output = Option&lt;T&gt;&gt;`，</span><br>    <span class="hljs-comment">// 因此还需要使用`.await`来获取具体的值</span><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>), rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>), rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>next返回一个<strong>future</strong>特征，因此还需要await取</li></ul><h2 id="join-宏"><a href="#join-宏" class="headerlink" title="join!宏"></a>join!宏</h2><p>join!宏会返回一个元组，里面对应future执行结束后的值，宏中的future是并发：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::join;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">enjoy_book_and_music</span>() <span class="hljs-punctuation">-&gt;</span> (Book, Music) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">book_fut</span> = <span class="hljs-title function_ invoke__">enjoy_book</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">music_fut</span> = <span class="hljs-title function_ invoke__">enjoy_music</span>();<br>    join!(book_fut, music_fut)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="try-join"><a href="#try-join" class="headerlink" title="try_join!"></a>try_join!</h2><p>由于join!必须等待它管理的所有 Future 完成后才能完成，如果你希望在某一个 Future 报错后就立即停止所有 Future 的执行，可以使用 try_join!，特别是当 Future 返回 Result 时:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;<br>    future::TryFutureExt,<br>    try_join,<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Book, ()&gt; &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-title function_ invoke__">Ok</span>(Book) &#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_music</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Music, <span class="hljs-type">String</span>&gt; &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-title function_ invoke__">Ok</span>(Music) &#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book_and_music</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(Book, Music), <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">book_fut</span> = <span class="hljs-title function_ invoke__">get_book</span>().<span class="hljs-title function_ invoke__">map_err</span>(|()| <span class="hljs-string">&quot;Unable to get book&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">music_fut</span> = <span class="hljs-title function_ invoke__">get_music</span>();<br>    try_join!(book_fut, music_fut)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有一点需要注意，传给 try_join! 的所有 Future 都必须拥有相同的<strong>错误类型</strong>。如果错误类型不同，可以考虑使用来自 futures::future::TryFutureExt 模块的 map_err和err_info方法将错误进行转换</li></ul><h2 id="select"><a href="#select" class="headerlink" title="select!"></a>select!</h2><p>join!必须等所有Future结束后，才能集中处理结果，但是select!任意一个future结束，都可以立即被处理:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;<br>    future::FutureExt, <span class="hljs-comment">// for `.fuse()`</span><br>    pin_mut,<br>    select,<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">task_one</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">task_two</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">race_tasks</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t1</span> = <span class="hljs-title function_ invoke__">task_one</span>().<span class="hljs-title function_ invoke__">fuse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t2</span> = <span class="hljs-title function_ invoke__">task_two</span>().<span class="hljs-title function_ invoke__">fuse</span>();<br><br>    pin_mut!(t1, t2);<br><br>    <span class="hljs-built_in">select!</span> &#123;<br>        () = t1 =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;任务1率先完成&quot;</span>),<br>        () = t2 =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;任务2率先完成&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="default和complete"><a href="#default和complete" class="headerlink" title="default和complete"></a>default和complete</h3><ul><li>complete分支当所有的Future和Stream完成后才会被执行，它往往配合loop使用，loop用于循环完成所有的Future</li><li>default分支，若没有任何Future或Stream处于Ready状态，则该分支会被立即执行<br>(ps:我这里有个疑惑，当所有future都执行完了，不就没有符合ready状态的，此时两分支不就是相同，但这个疑惑可以从另一角度避开，complete就是所有future都执行完了才匹配，default就是某个时刻没有ready的future来匹配，毕竟你自己还不懂底层，谁知道这两个是不是等价的,且只有这两个状态，所以下面代码，default我猜一般应该是continue语句搭配)<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::future;<br><span class="hljs-keyword">use</span> futures::select;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a_fut</span> = future::<span class="hljs-title function_ invoke__">ready</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b_fut</span> = future::<span class="hljs-title function_ invoke__">ready</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">total</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">select!</span> &#123;<br>            a = a_fut =&gt; total += a,<br>            b = b_fut =&gt; total += b,<br>            complete =&gt; <span class="hljs-keyword">break</span>,<br>            default =&gt; <span class="hljs-built_in">panic!</span>(), <span class="hljs-comment">// 该分支永远不会运行，因为`Future`会先运行，然后是`complete`</span><br>        &#125;;<br>    &#125;<br>    <span class="hljs-built_in">assert_eq!</span>(total, <span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="FusedFuture和Unpin特征"><a href="#FusedFuture和Unpin特征" class="headerlink" title="FusedFuture和Unpin特征"></a>FusedFuture和Unpin特征</h3><p>这两个特征是使用select所必须的，在本小节第一段代码中，分别用<code>.fuse()</code>和<code>pin_mut!</code>来为Future添加,以下是为什么：</p><ul><li>Unpin，由于 select 不会通过拿走所有权的方式使用Future，而是通过可变引用的方式去使用，这样当 select 结束后，该 Future 若没有被完成，它的所有权还可以继续被其它代码使用。</li><li>FusedFuture的原因跟上面类似，当 Future 一旦完成后，那 select 就不能再对其进行轮询使用。Fuse意味着熔断，相当于 Future 一旦完成，再次调用poll会直接返回Poll::Pending。</li><li>Stream使用的是FusedStream,对其调用next可以获取实现了FusedFuture特征的Future</li></ul><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;<br>    future::&#123;Fuse, FusedFuture, FutureExt&#125;,<br>    stream::&#123;FusedStream, Stream, StreamExt&#125;,<br>    pin_mut,<br>    select,<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_new_num</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-number">5</span> &#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_on_new_num</span>(_: <span class="hljs-type">u8</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_loop</span>(<br>    <span class="hljs-keyword">mut</span> interval_timer: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Stream</span>&lt;Item = ()&gt; + FusedStream + Unpin,<br>    starting_num: <span class="hljs-type">u8</span>,<br>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">run_on_new_num_fut</span> = <span class="hljs-title function_ invoke__">run_on_new_num</span>(starting_num).<span class="hljs-title function_ invoke__">fuse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">get_new_num_fut</span> = Fuse::<span class="hljs-title function_ invoke__">terminated</span>();<br>    pin_mut!(run_on_new_num_fut, get_new_num_fut);<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">select!</span> &#123;<br>            () = interval_timer.<span class="hljs-title function_ invoke__">select_next_some</span>() =&gt; &#123;<br>                <span class="hljs-comment">// 定时器已结束，若`get_new_num_fut`没有在运行，就创建一个新的</span><br>                <span class="hljs-keyword">if</span> get_new_num_fut.<span class="hljs-title function_ invoke__">is_terminated</span>() &#123;<br>                    get_new_num_fut.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-title function_ invoke__">get_new_num</span>().<span class="hljs-title function_ invoke__">fuse</span>());<br>                &#125;<br>            &#125;,<br>            new_num = get_new_num_fut =&gt; &#123;<br>                <span class="hljs-comment">// 收到新的数字 -- 创建一个新的`run_on_new_num_fut`并丢弃掉旧的</span><br>                run_on_new_num_fut.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-title function_ invoke__">run_on_new_num</span>(new_num).<span class="hljs-title function_ invoke__">fuse</span>());<br>            &#125;,<br>            <span class="hljs-comment">// 运行 `run_on_new_num_fut`</span><br>            () = run_on_new_num_fut =&gt; &#123;&#125;,<br>            <span class="hljs-comment">// 若所有任务都完成，直接 `panic`， 原因是 `interval_timer` 应该连续不断的产生值，而不是结束</span><br>            <span class="hljs-comment">//后，执行到 `complete` 分支</span><br>            complete =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;`interval_timer` completed unexpectedly&quot;</span>),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>fuse返回类型的set()方法好像是一个换值操作，就是这个变量重新赋值一个future</li><li>Fuse::terminated()是一个空的Future</li><li>FuturesUnordered类型：它会将 run_on_new_num_fut 的每一个拷贝都运行到完成，而不是像之前那样一旦创建新的就终止旧的，例子大体类似如下：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;<br>    future::&#123;Fuse, FusedFuture, FutureExt&#125;,<br>    stream::&#123;FusedStream, FuturesUnordered, Stream, StreamExt&#125;,<br>    pin_mut,<br>    select,<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_new_num</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-number">5</span> &#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_on_new_num</span>(_: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-number">5</span> &#125;<br><br><br><span class="hljs-comment">// 使用从 `get_new_num` 获取的最新数字 来运行 `run_on_new_num`</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 每当计时器结束后，`get_new_num` 就会运行一次，它会立即取消当前正在运行的`run_on_new_num` ,</span><br><span class="hljs-comment">// 并且使用新返回的值来替换</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_loop</span>(<br>    <span class="hljs-keyword">mut</span> interval_timer: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Stream</span>&lt;Item = ()&gt; + FusedStream + Unpin,<br>    starting_num: <span class="hljs-type">u8</span>,<br>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">run_on_new_num_futs</span> = FuturesUnordered::<span class="hljs-title function_ invoke__">new</span>();<br>    run_on_new_num_futs.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">run_on_new_num</span>(starting_num));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">get_new_num_fut</span> = Fuse::<span class="hljs-title function_ invoke__">terminated</span>();<br>    pin_mut!(get_new_num_fut);<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">select!</span> &#123;<br>            () = interval_timer.<span class="hljs-title function_ invoke__">select_next_some</span>() =&gt; &#123;<br>                 <span class="hljs-comment">// 定时器已结束，若`get_new_num_fut`没有在运行，就创建一个新的</span><br>                <span class="hljs-keyword">if</span> get_new_num_fut.<span class="hljs-title function_ invoke__">is_terminated</span>() &#123;<br>                    get_new_num_fut.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-title function_ invoke__">get_new_num</span>().<span class="hljs-title function_ invoke__">fuse</span>());<br>                &#125;<br>            &#125;,<br>            new_num = get_new_num_fut =&gt; &#123;<br>                 <span class="hljs-comment">// 收到新的数字 -- 创建一个新的`run_on_new_num_fut` (并没有像之前的例子那样丢弃掉旧值)</span><br>                run_on_new_num_futs.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">run_on_new_num</span>(new_num));<br>            &#125;,<br>            <span class="hljs-comment">// 运行 `run_on_new_num_futs`, 并检查是否有已经完成的</span><br>            res = run_on_new_num_futs.<span class="hljs-title function_ invoke__">select_next_some</span>() =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;run_on_new_num_fut returned &#123;:?&#125;&quot;</span>, res);<br>            &#125;,<br>            <span class="hljs-comment">// 若所有任务都完成，直接 `panic`， 原因是 `interval_timer` 应该连续不断的产生值，而不是结束</span><br>            <span class="hljs-comment">//后，执行到 `complete` 分支</span><br>            complete =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;`interval_timer` completed unexpectedly&quot;</span>),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="一些疑难解决方法"><a href="#一些疑难解决方法" class="headerlink" title="一些疑难解决方法"></a>一些疑难解决方法</h2><h3 id="在async语句块中使用"><a href="#在async语句块中使用" class="headerlink" title="在async语句块中使用?"></a>在async语句块中使用?</h3><p>在async fn中使用?是没问题的，因为可以指明返回值，但在语句块中要指明返回值，需要像下面这么做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u8</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u8</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-title function_ invoke__">foo</span>().<span class="hljs-keyword">await</span>?;<br>        <span class="hljs-title function_ invoke__">bar</span>().<span class="hljs-keyword">await</span>?;<br>Ok::&lt;(), <span class="hljs-type">String</span>&gt;(())<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="async与send"><a href="#async与send" class="headerlink" title="async与send"></a>async与send</h3><p>async中并不是一定不能包含send，但它不能影响.await,可以加大括号提前drop掉，但是目前<code>std::mem::drop</code>是不能解决的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() &#123;<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = NotSend::<span class="hljs-title function_ invoke__">default</span>();<br>    &#125;<br>    <span class="hljs-title function_ invoke__">bar</span>().<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="async-fn递归"><a href="#async-fn递归" class="headerlink" title="async fn递归"></a>async fn递归</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::future::&#123;BoxFuture, FutureExt&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">recursive</span>() <span class="hljs-punctuation">-&gt;</span> BoxFuture&lt;<span class="hljs-symbol">&#x27;static</span>, ()&gt; &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>        <span class="hljs-title function_ invoke__">recursive</span>().<span class="hljs-keyword">await</span>;<br>        <span class="hljs-title function_ invoke__">recursive</span>().<span class="hljs-keyword">await</span>;<br>    &#125;.<span class="hljs-title function_ invoke__">boxed</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特征中使用async"><a href="#特征中使用async" class="headerlink" title="特征中使用async"></a>特征中使用async</h3><p>每一次特征中的async函数被调用时，都会产生一次堆内存分配,具有一定的开销</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> async_trait::async_trait;<br><br><span class="hljs-meta">#[async_trait]</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Advertisement</span> &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Modal</span>;<br><br><span class="hljs-meta">#[async_trait]</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Advertisement</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Modal</span> &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">render_fullscreen</span>().<span class="hljs-keyword">await</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4u16</span> &#123;<br>            <span class="hljs-title function_ invoke__">remind_user_to_join_mailing_list</span>().<span class="hljs-keyword">await</span>;<br>        &#125;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">hide_for_now</span>().<span class="hljs-keyword">await</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AutoplayingVideo</span> &#123;<br>    media_url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[async_trait]</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Advertisement</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AutoplayingVideo</span> &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = <span class="hljs-title function_ invoke__">connect</span>(&amp;<span class="hljs-keyword">self</span>.media_url).<span class="hljs-keyword">await</span>;<br>        stream.<span class="hljs-title function_ invoke__">play</span>().<span class="hljs-keyword">await</span>;<br><br>        <span class="hljs-comment">// 用视频说服用户加入我们的邮件列表</span><br>        Modal.<span class="hljs-title function_ invoke__">run</span>().<span class="hljs-keyword">await</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——测试</title>
    <link href="/2022/06/18/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/06/18/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>lib型的项目会生产出以下代码，这就是一个基本的test demo</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中的 #[cfg(test)] 标注(本质是条件编译)可以告诉 Rust 只有在 cargo test 时才编译和运行模块 tests，其它时候当这段代码是空气即可</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试目标是测试某一个代码单元(一般都是函数)，验证该单元是否能按照预期进行工作，例如测试一个 add 函数，验证当给予两个输入时，最终返回的和是否符合预期。 在 Rust 中，单元测试的惯例是将测试代码的模块跟待测试的正常代码放入同一个文件中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_two</span>(a: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">add_two</span>(<span class="hljs-number">2</span>), <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>集成测试的代码在一个单独目录tests下，cargo会自动在此目录下寻找集成测试文件，cargo会对该文件夹下每个文件进行自动编译。</p><ul><li>需要将待测试的包引入到当前包的作用域</li><li>无需再使用<code>#[cfg(test)]</code></li><li>可以通过选项–test来运行指定的集成测试用例</li><li>tests文件夹下每一个文件都是一个独立的包</li><li>tests文件夹下的子目录中的文件，不会被当作独立的包，通常用来作共享模块(如：不是创建<code>tests/common.rs</code>,而是<code>tests/common/mod.rs</code>)</li><li>目前来说只支持lib类型的包集成测试</li></ul><h3 id="基准测试benchmark"><a href="#基准测试benchmark" class="headerlink" title="基准测试benchmark"></a>基准测试benchmark</h3><p>目前只有nightly版支持：<code>rustup install nightly</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(test)]</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> test;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fibonacci_u64</span>(number: <span class="hljs-type">u64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u64</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">last</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">current</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buffer</span>: <span class="hljs-type">u64</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">position</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">if</span> position == number &#123;<br>            <span class="hljs-keyword">break</span> current;<br>        &#125;<br><br>        buffer = last;<br>        last = current;<br>        current = buffer + current;<br>        position += <span class="hljs-number">1</span>;<br>    &#125;;<br>&#125;<br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br>    <span class="hljs-keyword">use</span> test::Bencher;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>       <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">fibonacci_u64</span>(<span class="hljs-number">1</span>), <span class="hljs-number">0</span>);<br>       <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">fibonacci_u64</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>);<br>       <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">fibonacci_u64</span>(<span class="hljs-number">12</span>), <span class="hljs-number">89</span>);<br>       <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">fibonacci_u64</span>(<span class="hljs-number">30</span>), <span class="hljs-number">514229</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[bench]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bench_u64</span>(b: &amp;<span class="hljs-keyword">mut</span> Bencher) &#123;<br>        b.<span class="hljs-title function_ invoke__">iter</span>(|| &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">100</span>..<span class="hljs-number">200</span> &#123;<br>                test::<span class="hljs-title function_ invoke__">black_box</span>(<span class="hljs-title function_ invoke__">fibonacci_u64</span>(i));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>cargo bench运行<br>必须使用black_box,否则编译器会优化掉（因为结果没有用到），结果就会0ns</p><h4 id="三方库criterion-rs"><a href="#三方库criterion-rs" class="headerlink" title="三方库criterion.rs"></a>三方库criterion.rs</h4><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><ul><li>assert!,assert_eq!,assert_ne!,它们会在所有模式下运行</li><li>debug_assert!,debug_assert_eq!,debug_assert_ne!,它们只会在Debug模式下运行</li></ul><h3 id="assert-eq！"><a href="#assert-eq！" class="headerlink" title="assert_eq！"></a>assert_eq！</h3><p>判断两个表达式返回的值是否相等</p><ul><li><code>assert_eq!(a,b)</code></li><li><code>assert_eq!(a, b, &quot;我们在测试两个数之和&#123;&#125; + &#123;&#125;，这是额外的错误信息&quot;, a, b)</code></li></ul><h3 id="assert-ne"><a href="#assert-ne" class="headerlink" title="assert_ne!"></a>assert_ne!</h3><p>判断两个表达式是否不等</p><h3 id="assert"><a href="#assert" class="headerlink" title="assert!"></a>assert!</h3><p>用于判断bool表达式是否为true</p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="should-panic"><a href="#should-panic" class="headerlink" title="[should_panic]"></a>[should_panic]</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[should_panic]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">s</span>()&#123;<br><span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;sk&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以接受报错信息，与报错信息不一样的认为失败，只要前缀匹配即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Guess</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<br>                <span class="hljs-string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,<br>                value<br>            );<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<br>                <span class="hljs-string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,<br>                value<br>            );<br>        &#125;<br><br>        Guess &#123; value &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">greater_than_100</span>() &#123;<br>        Guess::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ignore"><a href="#ignore" class="headerlink" title="[ignore]"></a>[ignore]</h3><p>必须使用<code>--ignored</code>选项才运行的测试</p><h2 id="自定义Result"><a href="#自定义Result" class="headerlink" title="自定义Result&lt;T,E&gt;"></a>自定义Result&lt;T,E&gt;</h2><p>可以手动写</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span> &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;two plus two does not equal four&quot;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cargo-test命令"><a href="#cargo-test命令" class="headerlink" title="cargo test命令"></a>cargo test命令</h2><p>该命令可以运行单元测试，集成测试，文档测试</p><h3 id="–分割命令行参数"><a href="#–分割命令行参数" class="headerlink" title="–分割命令行参数"></a>–分割命令行参数</h3><ul><li>第一种是提供给 cargo test 命令本身的，这些参数在 – 之前指定,<code>cargo test --help</code>来查看帮助列表</li><li>第二种是提供给编译后的可执行文件的，在 – 之后指定,可以用<code>cargo test -- --help</code>来查看帮助列表</li></ul><h3 id="第一种选项"><a href="#第一种选项" class="headerlink" title="第一种选项"></a>第一种选项</h3><ul><li>–no-run:只生成编译文件，不运行</li><li>–test:指定运行集成测试</li></ul><h4 id="指定测试函数"><a href="#指定测试函数" class="headerlink" title="指定测试函数"></a>指定测试函数</h4><ul><li>当运行指定一个测试时，直接跟函数名</li><li>名称过滤,如<code>cargo test add</code>运行所有前缀为add的测试函数，同时可以通过模块名进行过滤：如<code>cargo test tests::add</code></li></ul><h3 id="第二种选项"><a href="#第二种选项" class="headerlink" title="第二种选项"></a>第二种选项</h3><ul><li>test-threads:指定运行测试的线程数，当你想顺序执行测试可以指定为1</li><li>show-output:默认情况test函数里println不输出，指定该选项才能看到输出</li><li>ignored:运行被忽略的测试函数</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——unsafe</title>
    <link href="/2022/06/18/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94unsafe/"/>
    <url>/2022/06/18/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94unsafe/</url>
    
    <content type="html"><![CDATA[<p>unsafe的主要功能提供以下五个标题功能，不能关闭rust的任何其他安全检查（会关闭内存安全方面的检查）,unsafe也只应该用于这5方面，其他尽可能用安全代码</p><h2 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h2><ul><li>创建裸指针是安全的行为，而解引用裸指针才是不安全的行为 </li><li>可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</li><li>并不能保证指向合法的内存</li><li>可以是 null</li><li>没有实现任何自动回收</li><li>标准库的智能指针都可以通过into_raw转成裸指针<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span>= &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span><br><span class="hljs-keyword">unsafe</span>&#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r1 is: &#123;&#125;&quot;</span>,*r1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="调用一个unsafe或外部函数"><a href="#调用一个unsafe或外部函数" class="headerlink" title="调用一个unsafe或外部函数"></a>调用一个unsafe或外部函数</h2><ul><li>一个函数内部含有unsafe内容，这个函数无需是unsafe声明，即安全抽象包裹unsafe代码</li></ul><h3 id="调用c标准库"><a href="#调用c标准库" class="headerlink" title="调用c标准库"></a>调用c标准库</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">abs</span>(input: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">abs</span>(-<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写可以被调用的rust"><a href="#编写可以被调用的rust" class="headerlink" title="编写可以被调用的rust"></a>编写可以被调用的rust</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_from_c</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Just called a Rust function from C!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将其编译成一个共享库，然后链接到 C 语言中。</li><li><code>#[no_mangle]</code>它用于告诉 Rust 编译器：不要乱改函数的名称。</li></ul><h2 id="访问或修改一个可变的静态变量"><a href="#访问或修改一个可变的静态变量" class="headerlink" title="访问或修改一个可变的静态变量"></a>访问或修改一个可变的静态变量</h2><h2 id="实现了一个unsafe特征"><a href="#实现了一个unsafe特征" class="headerlink" title="实现了一个unsafe特征"></a>实现了一个unsafe特征</h2><h2 id="访问union中字段"><a href="#访问union中字段" class="headerlink" title="访问union中字段"></a>访问union中字段</h2><h2 id="一些实用库"><a href="#一些实用库" class="headerlink" title="一些实用库"></a>一些实用库</h2><p>rust-bindgen,cbindgen,cxx,Miri,Clippy,Prusti,模糊测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——智能指针</title>
    <link href="/2022/06/05/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2022/06/05/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="deref特征"><a href="#deref特征" class="headerlink" title="deref特征"></a>deref特征</h2><ul><li>在表达式中必须显式的解引用，并且不会发生递归的解引用，当指明时，有几层就解几层,并且本质上是<code>*y</code>&#x3D;&gt;<code>*(y.deref())</code>,y.deref()返回一个引用，返回值会产生所有权问题</li><li>函数和方法中只有引用类型的实参才能触发自动解引用</li><li>隐式的解引用，会递归，直到类型匹配</li><li>当 T: Deref&lt;Target&#x3D;U&gt;，可以将 &amp;T 转换成 &amp;U</li><li>当 T: DerefMut&lt;Target&#x3D;U&gt;，可以将 &amp;mut T 转换成 &amp;mut U</li><li>当 T: Deref&lt;Target&#x3D;U&gt;，可以将 &amp;mut T 转换成 &amp;U</li><li>要实现 erefMut必须要先实现Deref特征：<code>pub trait DerefMut: Deref</code></li></ul><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    v: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        MyBox &#123; v: x &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">self</span>.v<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> std::ops::DerefMut;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; DerefMut <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.v<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello, &quot;</span>));<br>    <span class="hljs-title function_ invoke__">display</span>(&amp;<span class="hljs-keyword">mut</span> s)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;world&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Rc与Arc"><a href="#Rc与Arc" class="headerlink" title="Rc与Arc"></a>Rc与Arc</h2><p>Rc用于单线程，Arc用于多线程，都是通过引用计数，允许一个数据资源同时拥有多个所有者。<strong>本质上是指向底层数据的不可变的引用，无法通过它来修改数据,需要通过其他类型的配合，比如Mutex,RefCell</strong></p><ul><li>分别通过<code>use std::sync::Arc;</code>,<code>use std::rc::Rc</code>,引入</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><code>let a = Rc::new(String::from(&quot;hello&quot;));</code></p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><code>let b = Rc::clone(&amp;a)</code></p><h3 id="查看计数"><a href="#查看计数" class="headerlink" title="查看计数"></a>查看计数</h3><p><code>Rc::strong_count(&amp;a)</code></p><h2 id="Cell与RefCell"><a href="#Cell与RefCell" class="headerlink" title="Cell与RefCell"></a>Cell与RefCell</h2><ul><li>这两个可以在拥有不可变引用的同时修改目标数据。</li><li>Cell和RefCell的区别在于，Cell<T>使用于T实现了Copy的情况,</li><li>这个只是跳过编译阶段的检查（貌似就这个功能），运行阶段如果违反（可变引用与不可变引用同时存在）该报错还报错</li><li>常和Rc一起用，类似于多线程的Arc和MUtex结合</li><li><code>use std::cell::Cell</code>,<code>use std::cell::RefCell</code></li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><code>let c = Cell::new(&quot;hello&quot;)</code></li><li><code>let s = RefCell::new(String::from(&quot;hello&quot;))</code></li></ul><h3 id="复制获得"><a href="#复制获得" class="headerlink" title="复制获得"></a>复制获得</h3><ul><li><code>let one = c.get()</code></li><li><code>let s1 = s.borrow()</code></li></ul><h3 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h3><ul><li><code>c.set(&quot;你好&quot;)</code></li><li><code>let s1 = s.borrow_mut()</code></li></ul><h3 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h3><p>简而言之，方法中self不可变，但是该方法内部可以调用RefCell达到改变的目的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Messenger</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    msg_cache: RefCell&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Messenger</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.msg_cache.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mq</span> = MsgQueue &#123;<br>        msg_cache: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()),<br>    &#125;;<br>    mq.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-string">&quot;hello, world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="from-mut解决借用冲突"><a href="#from-mut解决借用冲突" class="headerlink" title="from_mut解决借用冲突"></a>from_mut解决借用冲突</h3><ul><li><code>Cell::from_mut</code>,将<code>&amp;mut T</code>转为<code>&amp;Cell&lt;T&gt;</code></li><li><code>Cell::as_slice_of_cells</code>,将<code>&amp;Cell&lt;[T]&gt;</code>转为<code>&amp;[Cell&lt;T&gt;]</code></li></ul><h2 id="Weak与循环引用"><a href="#Weak与循环引用" class="headerlink" title="Weak与循环引用"></a>Weak与循环引用</h2><ul><li>它无法阻止所引用的内存值被释放掉，不增加计数</li><li>weak是个弱引用，不保证引用关系依然存在，如果不存在返回None</li><li>Rc<T>调用downgrade转换成Weak<T></li><li>Weak<T>可调用upgrade转成Option&lt;Rc<T>&gt;</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——多线程</title>
    <link href="/2022/06/04/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/06/04/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="thread-spawn创建线程"><a href="#thread-spawn创建线程" class="headerlink" title="thread::spawn创建线程"></a>thread::spawn创建线程</h2><ul><li>线程内部的代码使用闭包来执行</li><li>main线程结束，子孙线程也会结束</li><li>如果父线程不是main线程，<strong>那么该子线程不会因为父线程的结束而结束</strong><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h3 id="等待子线程结束"><a href="#等待子线程结束" class="headerlink" title="等待子线程结束"></a>等待子线程结束</h3><p><code>handle.join.unwrap()</code></p><ul><li>让当前线程阻塞，等待子线程的结束</li></ul><h2 id="消息通道mpsc"><a href="#消息通道mpsc" class="headerlink" title="消息通道mpsc"></a>消息通道mpsc</h2><ul><li>异步通道channel，发送时不会阻塞</li><li>同步通道sync_channel,发送是阻塞的，只有消息被接受后才解除阻塞</li><li>当所有发送者或所有接收者被drop后，通道会自动关闭</li></ul><h3 id="异步通道channel"><a href="#异步通道channel" class="headerlink" title="异步通道channel"></a>异步通道channel</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span><br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-comment">// 创建线程，并发送消息</span><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-comment">// 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span><br>        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>        <span class="hljs-comment">// 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span><br>        <span class="hljs-comment">// tx.send(Some(1)).unwrap()</span><br>    &#125;);<br><br>    <span class="hljs-comment">// 在主线程中接收子线程发送的消息并输出</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><p>会阻塞当前线程，直到读取到值，或通道关闭</p><h3 id="try-recv"><a href="#try-recv" class="headerlink" title="try_recv"></a>try_recv</h3><p>该方法不会阻塞线程，当通道中没消息时会立刻返回错误</p><h3 id="多发送者clone"><a href="#多发送者clone" class="headerlink" title="多发送者clone"></a>多发送者clone</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tx1</span> = tx.<span class="hljs-title function_ invoke__">clone</span>();<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi from raw tx&quot;</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        tx1.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi from cloned tx&quot;</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sync-channel"><a href="#sync-channel" class="headerlink" title="sync_channel"></a>sync_channel</h3><p>与channel类似,不过发送会阻塞,但可以传递一个数字</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>当设定为N时，发送者可以无阻塞的往通道中发送N条消息，当满后，会被阻塞</p><h2 id="线程屏障Barrier"><a href="#线程屏障Barrier" class="headerlink" title="线程屏障Barrier"></a>线程屏障Barrier</h2><p>Barrier让多个线程执行到某个点后，才继续一起往后执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Barrier&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">barrier</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Barrier::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">6</span>));<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">6</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = barrier.<span class="hljs-title function_ invoke__">clone</span>();<br>        handles.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;before wait&quot;</span>);<br>            b.<span class="hljs-title function_ invoke__">wait</span>();<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;after wait&quot;</span>);<br>        &#125;));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mpmc"><a href="#mpmc" class="headerlink" title="mpmc"></a>mpmc</h2><p>第三方库：<strong>crossbeam-channel</strong>,<strong>flume</strong></p><h2 id="thread-local线程局部变量"><a href="#thread-local线程局部变量" class="headerlink" title="thread_local线程局部变量"></a>thread_local线程局部变量</h2><ul><li>该线程局部变量，每个新线程访问它，都会使用它的初始值作为开始，各个线程间彼此互不干扰<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">use</span> std::thread;<br><br>thread_local!(<span class="hljs-keyword">static</span> FOO: RefCell&lt;<span class="hljs-type">u32</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));<br><br>FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">1</span>);<br>    *f.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">2</span>;<br>&#125;);<br><br><span class="hljs-comment">// 每个线程开始时都会拿到线程局部变量的FOO的初始值</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>    FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">1</span>);<br>        *f.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">3</span>;<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 等待线程完成</span><br>t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2</span><br>FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">2</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="锁Mutex"><a href="#锁Mutex" class="headerlink" title="锁Mutex"></a>锁Mutex</h2><ul><li><code>m.lock()</code>返回一个智能指针<code>MutexGuard&lt;T&gt;</code></li><li>try_lock会尝试取锁，如果无法立刻获取会返回一个错误，不会发生阻塞</li><li>常和<code>Arc&lt;T&gt;</code>一起用,单线程是（Rc<T>和RefCell<T>结合）<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>            *num += <span class="hljs-number">1</span>;<br>        &#125;);<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="读写锁RwLock"><a href="#读写锁RwLock" class="headerlink" title="读写锁RwLock"></a>读写锁RwLock</h2><ul><li>同时允许多个读，但最多只能有一个写</li><li>读和写不能同时存在，否则会panic</li><li>读可以使用read、try_read，写write、try_write,用try更多写<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::RwLock;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = RwLock::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 同一时间允许多个读</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = lock.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = lock.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">assert_eq!</span>(*r1, <span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(*r2, <span class="hljs-number">5</span>);<br>    &#125; <span class="hljs-comment">// 读锁在此处被drop</span><br><br>    <span class="hljs-comment">// 同一时间只允许一个写</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">w</span> = lock.<span class="hljs-title function_ invoke__">write</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *w += <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(*w, <span class="hljs-number">6</span>);<br><br>        <span class="hljs-comment">// 以下代码会panic，因为读和写不允许同时存在</span><br>        <span class="hljs-comment">// 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中</span><br>        <span class="hljs-comment">// let r1 = lock.read();</span><br>        <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;,r1);</span><br>    &#125;<span class="hljs-comment">// 写锁在此处被drop</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="条件变量Condvar"><a href="#条件变量Condvar" class="headerlink" title="条件变量Condvar"></a>条件变量Condvar</h2><p>经常和Mutex一起使用,用来控制多线程的顺序问题</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex, Condvar&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span> = Arc::<span class="hljs-title function_ invoke__">new</span>((Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>), Condvar::<span class="hljs-title function_ invoke__">new</span>()));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair2</span> = pair.<span class="hljs-title function_ invoke__">clone</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>        <span class="hljs-keyword">let</span> &amp;(<span class="hljs-keyword">ref</span> lock, <span class="hljs-keyword">ref</span> cvar) = &amp;*pair2;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;changing started&quot;</span>);<br>        *started = <span class="hljs-literal">true</span>;<br>        cvar.<span class="hljs-title function_ invoke__">notify_one</span>();<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> &amp;(<span class="hljs-keyword">ref</span> lock, <span class="hljs-keyword">ref</span> cvar) = &amp;*pair;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">while</span> !*started &#123;<br>        started = cvar.<span class="hljs-title function_ invoke__">wait</span>(started).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;started changed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>main线程首先进入while循环，调用wait方法挂起等待子线程的通知，并释放了锁started</li><li>子线程获取到锁，并将其修改为true，然后调用条件变量的notify_one方法来通知主线程继续执行</li></ul><h2 id="信号量tokio-Semaphore"><a href="#信号量tokio-Semaphore" class="headerlink" title="信号量tokio::Semaphore"></a>信号量tokio::Semaphore</h2><ul><li>控制当前正在运行的任务最大数量</li></ul><h2 id="Atomic原子类型数据"><a href="#Atomic原子类型数据" class="headerlink" title="Atomic原子类型数据"></a>Atomic原子类型数据</h2><ul><li><code>std::sync::atomic</code>仅提供了数值类型的原子操作</li><li>常用于无锁数据结构，全局变量，跨线程计数器<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Sub;<br><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicU64, Ordering&#125;;<br><span class="hljs-keyword">use</span> std::thread::&#123;<span class="hljs-keyword">self</span>, JoinHandle&#125;;<br><span class="hljs-keyword">use</span> std::time::Instant;<br><br><span class="hljs-keyword">const</span> N_TIMES: <span class="hljs-type">u64</span> = <span class="hljs-number">10000000</span>;<br><span class="hljs-keyword">const</span> N_THREADS: <span class="hljs-type">usize</span> = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">static</span> R: AtomicU64 = AtomicU64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_n_times</span>(n: <span class="hljs-type">u64</span>) <span class="hljs-punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n &#123;<br>            R.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::Relaxed);<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">threads</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(N_THREADS);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..N_THREADS &#123;<br>        threads.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">add_n_times</span>(N_TIMES));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">thread</span> <span class="hljs-keyword">in</span> threads &#123;<br>        thread.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">assert_eq!</span>(N_TIMES * N_THREADS <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>, R.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed));<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,Instant::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">sub</span>(s));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="lazy-static"><a href="#lazy-static" class="headerlink" title="lazy_static"></a>lazy_static</h3><p>一般的static变量是在编译时初始化，但是这不满足有一些场景需求，例如函数初始化，这时就可以使用lazy_static，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><span class="hljs-keyword">use</span> lazy_static::lazy_static;<br>lazy_static! &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> NAMES: Mutex&lt;<span class="hljs-type">String</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Sunface, Jack, Allen&quot;</span>));<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = NAMES.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    v.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, Myth&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,v);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>lazy_static宏匹配但是static ref,所以定义的都是不可变引用</li><li>直到用的时候才初始化</li></ul><h2 id="Box-leak"><a href="#Box-leak" class="headerlink" title="Box::leak"></a>Box::leak</h2><p>该方法可以使局部变量的生命周期变为全局：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> &#123;<br>    a: <span class="hljs-type">String</span>,<br>    b: <span class="hljs-type">String</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> CONFIG: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> Config&gt; = <span class="hljs-literal">None</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Config &#123;<br>        a: <span class="hljs-string">&quot;A&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        b: <span class="hljs-string">&quot;B&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>    &#125;);<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-comment">// 将`c`从内存中泄漏，变成`&#x27;static`生命周期</span><br>        CONFIG = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(c));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从函数中返回全局变量"><a href="#从函数中返回全局变量" class="headerlink" title="从函数中返回全局变量"></a>从函数中返回全局变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> &#123;<br>    a: <span class="hljs-type">String</span>,<br>    b: <span class="hljs-type">String</span>,<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> CONFIG: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> Config&gt; = <span class="hljs-literal">None</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> Config&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Config &#123;<br>        a: <span class="hljs-string">&quot;A&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        b: <span class="hljs-string">&quot;B&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>    &#125;);<br><br>    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(c))<br>&#125;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        CONFIG = <span class="hljs-title function_ invoke__">init</span>();<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, CONFIG)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="OnceCell"><a href="#OnceCell" class="headerlink" title="OnceCell"></a>OnceCell</h2><p>有<code>lazy::OnceCell</code>和<code>lazy::SyncOnceCell</code>两种，用来存储堆上的信息，只能赋值一次的特性，如下使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(once_cell)]</span><br><br><span class="hljs-keyword">use</span> std::&#123;lazy::SyncOnceCell, thread&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 子线程中调用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">logger</span> = Logger::<span class="hljs-title function_ invoke__">global</span>();<br>        logger.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;thread message&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>    &#125;);<br><br>    <span class="hljs-comment">// 主线程调用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">logger</span> = Logger::<span class="hljs-title function_ invoke__">global</span>();<br>    logger.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;some message&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">logger2</span> = Logger::<span class="hljs-title function_ invoke__">global</span>();<br>    logger2.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;other message&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Logger</span>;<br><br><span class="hljs-keyword">static</span> LOGGER: SyncOnceCell&lt;Logger&gt; = SyncOnceCell::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">global</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> Logger &#123;<br>        <span class="hljs-comment">// 获取或初始化 Logger</span><br>        LOGGER.<span class="hljs-title function_ invoke__">get_or_init</span>(|| &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Logger is being created...&quot;</span>); <span class="hljs-comment">// 初始化打印</span><br>            Logger<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">log</span>(&amp;<span class="hljs-keyword">self</span>, message: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="只被调用一次的函数"><a href="#只被调用一次的函数" class="headerlink" title="只被调用一次的函数"></a>只被调用一次的函数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::sync::Once;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> VAL: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> INIT: Once = Once::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        INIT.<span class="hljs-title function_ invoke__">call_once</span>(|| &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                VAL = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        INIT.<span class="hljs-title function_ invoke__">call_once</span>(|| &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                VAL = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;);<br>    &#125;);<br><br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; VAL &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="send与sync的特征"><a href="#send与sync的特征" class="headerlink" title="send与sync的特征"></a>send与sync的特征</h2><ul><li>只是标记特征:<code>unsafe impl Send for MyBox &#123;&#125;</code></li><li>实现Send类型可以传递所有权</li><li>实现Sync类型可以通过引用安全共享</li><li>若类型T的引用&amp;T是Send,则T是Sync</li><li>rust大多数类型都实现了这两个特征，除了裸指针，cell,refcell,rc</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——闭包与迭代器</title>
    <link href="/2022/06/03/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/06/03/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="IntoIterator特征"><a href="#IntoIterator特征" class="headerlink" title="IntoIterator特征"></a>IntoIterator特征</h3><p>对于数组的循环实质上是：<code>for v in arr.into_iter()</code>，一个编译器语法糖<br>也可以使用<code>IntoIterator::into_iter</code>方法调用</p><ul><li>into_iter会夺走所有权</li><li>iter是借用</li><li>iter_mut是可变借用</li></ul><h3 id="Iterator特征"><a href="#Iterator特征" class="headerlink" title="Iterator特征"></a>Iterator特征</h3><p>特征原型如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br><br>    <span class="hljs-comment">// 省略其余有默认实现的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>next 方法返回的是 Option 类型，当有值时返回 Some(i32)，无值时返回 None</li></ul><h3 id="消费者与适配器"><a href="#消费者与适配器" class="headerlink" title="消费者与适配器"></a>消费者与适配器</h3><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>消费者是迭代器上的方法，会消耗迭代器中的元素</p><ul><li>sum:会拿走迭代器所有权，求和</li><li>fold:类似sum,提供个初始值：<code>v.iter().fold(0,|sum,acm| sum+acm)</code></li></ul><h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>适配器会返回一个新的迭代器，是惰性的，需要一个消费者爱收尾</p><ul><li>map:接受一个闭包，映射每个值，<code>v1.iter().map(|x| x+1).sum()</code></li><li>zip:把两个迭代器压缩到一起，形成类似<code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code>，<code>let folks: HashMap&lt;_, _&gt; = names.into_iter().zip(ages.into_iter()).collect();</code></li><li>collect:将一个迭代器中的元素收集到指定类型中，<code>let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();</code></li><li>filter:对每个值进行过滤，<code>hoes.into_iter().filter(|s| s.size == shoe_size).collect()</code></li><li>enumerate:返回一个元组（索引，值）</li></ul><h3 id="手动实现迭代器特征"><a href="#手动实现迭代器特征" class="headerlink" title="手动实现迭代器特征"></a>手动实现迭代器特征</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;<br>    count: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Counter &#123;<br>        Counter &#123; count: <span class="hljs-number">0</span> &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.count &lt; <span class="hljs-number">5</span> &#123;<br>            <span class="hljs-keyword">self</span>.count += <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.count)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>闭包的参数类型可以不标注，由编译器自行推导，但是为了可读性，最好标注</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>|param1, param2,...| &#123;<br>    语句<span class="hljs-number">1</span>;<br>    语句<span class="hljs-number">2</span>;<br>    返回表达式<br>&#125;<br></code></pre></td></tr></table></figure><p>只有一个返回表达式可以不加大括号</p><h3 id="三种Fn特征"><a href="#三种Fn特征" class="headerlink" title="三种Fn特征"></a>三种Fn特征</h3><ul><li>一个闭包实现了哪种Fn特征取决于闭包如何使用被捕获的变量,而不是取决于如何使用它们(可能同时实现了FnOnce和Fn特征)</li><li>所有的闭包都自动实现了 FnOnce 特征，因此任何一个闭包都至少可以被调用一次</li><li>没有移出所捕获变量的所有权的闭包自动实现了 FnMut 特征</li><li>不需要对捕获变量进行改变的闭包自动实现了 Fn 特征</li></ul><h4 id="Fn"><a href="#Fn" class="headerlink" title="Fn"></a>Fn</h4><p>以不可变借用捕获变量</p><h4 id="FnOnce"><a href="#FnOnce" class="headerlink" title="FnOnce"></a>FnOnce</h4><p>该类型闭包表明拿走被捕获变量的所有权。只能运行一次。</p><h4 id="move关键字"><a href="#move关键字" class="headerlink" title="move关键字"></a>move关键字</h4><p>move会取得捕获变量的所有权，这种用法常用于闭包的生命周期大于捕获变量的生命周期</p><h4 id="FnMut"><a href="#FnMut" class="headerlink" title="FnMut"></a>FnMut</h4><p>以可变借用的方式捕获变量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——生命周期</title>
    <link href="/2022/05/26/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/26/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="生命周期几个注意点"><a href="#生命周期几个注意点" class="headerlink" title="生命周期几个注意点"></a>生命周期几个注意点</h2><ul><li>在存在多个<strong>引用</strong>时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查分析</li><li>标记生命周期只是为了取悦编译器，让编译器不要难为我们</li></ul><h2 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h2><ul><li>函数参数的手动标注的生命周期表示：参数至少活得和<code>&#39;a</code>一样久，至于谁更久，无法得知</li><li>函数的返回值如果是一个引用类型，那么它的生命周期只会来源于：<ul><li>函数参数的生命周期</li><li>函数体中的某个新建引用的生命周期<br>第二种情况明显是错误，典型的悬垂引用</li></ul></li></ul><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li>格式：<code>fn func&lt;&#39;a&gt; (para1: &amp;&#39;a type,para2: &amp;&#39;a type)-&gt; &amp;&#39;a type&#123;&#125;</code></li><li>说明：<strong>在通过函数签名指定生命周期参数时，我们并没有改变传入引用或者返回引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过。</strong></li><li>含义：当传递具体值时，’a的生命周期等于para1和para2(取两个参数的交集)，返回的生命周期也等于’a,若不满足条件就报错</li></ul><h3 id="三条默认添加生命周期规则"><a href="#三条默认添加生命周期规则" class="headerlink" title="三条默认添加生命周期规则"></a>三条默认添加生命周期规则</h3><p>函数或方法中，参数的生命周期被称为输入生命周期，返回值的生命周期被称为输出生命周期。rust有以下三条规则(你可以手动标注生命周期改变一下规则):</p><ul><li>每一个引用参数都会获得独自的生命周期<br><code>fn foo(a:&amp; i32,y:&amp; i32)</code>编译器自动转成<code>foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code></li><li>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期<br><code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>会转为<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code></li><li>若存在多个输入生命周期，且其中一个是 &amp;self 或 &amp;mut self，则 &amp;self 的生命周期被赋给所有的输出生命周期</li></ul><h2 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h2><ul><li>结构体中存在引用，就必须手动标注生命周期</li><li>格式：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcerpt</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">level</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>含义：结构体ImportantExcerpt所引用的字符串str必须比改结构体活得长</li></ul><h2 id="生命周期约束"><a href="#生命周期约束" class="headerlink" title="生命周期约束"></a>生命周期约束</h2><ul><li><code>&#39;a:&#39;b</code>：a的生命周期大于等于b<br>例子:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>: <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;b</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">announce_and_return_part</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>等价于：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">announce_and_return_part</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-symbol">&#x27;a</span>: <span class="hljs-symbol">&#x27;b</span>,<br>    &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>T:&#39;a</code>：类型T必须比a生命周期大</li></ul><h2 id="再借用"><a href="#再借用" class="headerlink" title="再借用"></a>再借用</h2><p>可变引用和不可变引用不能同时存在(即作用域不重叠)，但再借用可以避免,但是你不能在它的生命周期内再使用原来的借用，如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = &amp;<span class="hljs-keyword">mut</span> p;<br>    <span class="hljs-comment">// reborrow! 此时对`r`的再借用不会导致跟上面的借用冲突</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rr</span>: &amp;Point = &amp;*r;<br><br>    <span class="hljs-comment">// 再借用`rr`最后一次使用发生在这里，在它的生命周期中，我们并没有使用原来的借用`r`，因此不会报错</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, rr);<br><br>    <span class="hljs-comment">// 再借用结束后，才去使用原来的借用`r`</span><br>    r.<span class="hljs-title function_ invoke__">move_to</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><p>圣经那本书，最后一个复杂例子中方法中使用引用，会自动推断参数引用的生命周期的和引用内容生命周期一样(第一个例子，更是返回类型来推断参数类型！！！),可能生命周期交集的算法只适用于函数,最后一个例子也叫我们可以直接给&amp;mut self一个不等于实际本身内容的生命周期解决,感觉是手动标注来决定它们的生命周期，与函数的相矛盾。</p><h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><ul><li><code>&amp;&#39;static</code>生命周期针对的仅仅是引用，而不是持有该引用的变量，变量仍要遵循相应的作用域规则，例子如下：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;slice::from_raw_parts, <span class="hljs-type">str</span>::from_utf8_unchecked&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_memory_location</span>() <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>) &#123;<br>  <span class="hljs-comment">// “Hello World” 是字符串字面量，因此它的生命周期是 `&#x27;static`.</span><br>  <span class="hljs-comment">// 但持有它的变量 `string` 的生命周期就不一样了，它完全取决于变量作用域，对于该例子来说，也就是当前的函数范围</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">pointer</span> = string.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = string.<span class="hljs-title function_ invoke__">len</span>();<br>  (pointer, length)<br>  <span class="hljs-comment">// `string` 在这里被 drop 释放</span><br>  <span class="hljs-comment">// 虽然变量被释放，无法再被访问，但是数据依然还会继续存活</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str_at_location</span>(pointer: <span class="hljs-type">usize</span>, length: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>  <span class="hljs-comment">// 使用裸指针需要 `unsafe&#123;&#125;` 语句块</span><br>  <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-title function_ invoke__">from_utf8_unchecked</span>(<span class="hljs-title function_ invoke__">from_raw_parts</span>(pointer <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>, length)) &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> (pointer, length) = <span class="hljs-title function_ invoke__">get_memory_location</span>();<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span> = <span class="hljs-title function_ invoke__">get_str_at_location</span>(pointer, length);<br>  <span class="hljs-built_in">println!</span>(<br>    <span class="hljs-string">&quot;The &#123;&#125; bytes at 0x&#123;:X&#125; stored: &#123;&#125;&quot;</span>,<br>    length, pointer, message<br>  );<br>  <span class="hljs-comment">// 如果大家想知道为何处理裸指针需要 `unsafe`，可以试着反注释以下代码</span><br>  <span class="hljs-comment">// let message = get_str_at_location(1000, 10);</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>T:&#39;static</code>意味着接收方可以安全地持有T（即使用引用）,因为任何都是总是小于全局生命周期的,不存在悬垂引用,一般用如下用法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_it</span>&lt;T: <span class="hljs-built_in">Debug</span> + <span class="hljs-symbol">&#x27;static</span>&gt;( input: &amp;T) &#123;<br>    <span class="hljs-built_in">println!</span>( <span class="hljs-string">&quot;&#x27;static value passed in is: &#123;:?&#125;&quot;</span>, input );<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-title function_ invoke__">print_it</span>(&amp;i);<br>&#125;<br></code></pre></td></tr></table></figure><strong>这里使用&amp;T,函数体内更本没有直接使用T,因此就没去检查T的生命周期约束，他只要确保&amp;T生命周期符合即可（肯定符合,确保不会出现悬垂引用？）</strong><br>而不是下面的用法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_it</span>&lt;T: <span class="hljs-built_in">Debug</span> + <span class="hljs-symbol">&#x27;static</span>&gt;( input: T) &#123;<br>    <span class="hljs-built_in">println!</span>( <span class="hljs-string">&quot;&#x27;static value passed in is: &#123;:?&#125;&quot;</span>, input );<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_it1</span>( input: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Debug</span> + <span class="hljs-symbol">&#x27;static</span> ) &#123;<br>    <span class="hljs-built_in">println!</span>( <span class="hljs-string">&quot;&#x27;static value passed in is: &#123;:?&#125;&quot;</span>, input );<br>&#125;<br><br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">5</span>;<br><span class="hljs-comment">//这里会报错</span><br>    <span class="hljs-title function_ invoke__">print_it</span>(&amp;i);<br>    <span class="hljs-title function_ invoke__">print_it1</span>(&amp;i);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——错误处理</title>
    <link href="/2022/05/22/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/2022/05/22/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="unwrap和expect"><a href="#unwrap和expect" class="headerlink" title="unwrap和expect"></a>unwrap和expect</h3><ul><li>unwrap如果成功，就将Ok(T)中的值取出来，如果失败就直接panic</li><li>expect和unwrap类似，但遇到错误可以自定义提示信息</li></ul><h3 id="Option和Result组合器方法"><a href="#Option和Result组合器方法" class="headerlink" title="Option和Result组合器方法"></a>Option和Result组合器方法</h3><h4 id="or-和and"><a href="#or-和and" class="headerlink" title="or()和and()"></a>or()和and()</h4><ul><li>s1.or(s2),若s1为some,则表达式为s1。。。</li><li>s1.and(s2),若其中有一个为None,则表达式为None</li></ul><h4 id="or-else-和and-then"><a href="#or-else-和and-then" class="headerlink" title="or_else()和and_then()"></a>or_else()和and_then()</h4><p>和or()及and()类似，但接受一个闭包。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">fn_some</span> = |_| <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;some2&quot;</span>); <span class="hljs-comment">// 类似于: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; &#123; Some(&quot;some2&quot;) &#125;;</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">n</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt; = <span class="hljs-literal">None</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">fn_none</span> = |_| <span class="hljs-literal">None</span>;<br><br><span class="hljs-built_in">assert_eq!</span>(s1.<span class="hljs-title function_ invoke__">and_then</span>(fn_some), s2); <span class="hljs-comment">// Some1 and_then Some2 = Some2</span><br><span class="hljs-built_in">assert_eq!</span>(s1.<span class="hljs-title function_ invoke__">and_then</span>(fn_none), n);  <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>接受一个返回bool的闭包，为None或返回false则为None</p><ul><li><code>s1.filter(fn_is_even),n</code></li></ul><h4 id="map-和map-err"><a href="#map-和map-err" class="headerlink" title="map()和map_err()"></a>map()和map_err()</h4><p>将值映射为另一个，map()是用来映射Ok或Some,map_err()是用来映射Err,</p><h4 id="map-or-和map-or-else"><a href="#map-or-和map-or-else" class="headerlink" title="map_or()和map_or_else()"></a>map_or()和map_or_else()</h4><p>和map差不多，不同的是map_or()遇到None返回一个默认值,map_or_else()则接受一个闭包</p><h4 id="ok-or-和ok-or-else"><a href="#ok-or-和ok-or-else" class="headerlink" title="ok_or()和ok_or_else()"></a>ok_or()和ok_or_else()</h4><p>将Option类型转换成Result类型，ok_or()接受一个错误作为默认类型，ok_or_else()则接受一个闭包</p><h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播?"></a>错误传播<code>?</code></h2><ul><li><code>?</code>需要一个变量来承载正确的值，只有错误值是直接返回，正确值不行，所以如下代码是不对的<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first</span>(arr: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt; &#123;<br>   arr.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>)?<br>&#125;<br></code></pre></td></tr></table></figure>只有以下两种使用形式：<ul><li><code>let v = xxx()?;</code></li><li><code>xxx()?.yyy()?;</code></li></ul></li><li>一个例子理解：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br><span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br><span class="hljs-comment">//向上传播</span><br><span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e),<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>可以链式调用</li><li>可以应用于Option</li></ul><h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><ul><li>最高层次抽象错误，可以使用特征对象<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code></li><li>自定义错误类型只需实现Debug和Display特征</li></ul><h3 id="std-error-Error特征"><a href="#std-error-Error特征" class="headerlink" title="std::error::Error特征"></a>std::error::Error特征</h3><h3 id="使用From特征将标准库错误转成自定义"><a href="#使用From特征将标准库错误转成自定义" class="headerlink" title="使用From特征将标准库错误转成自定义"></a>使用From特征将标准库错误转成自定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Read&#125;;<br><span class="hljs-keyword">use</span> std::num;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppError</span> &#123;<br>    kind: <span class="hljs-type">String</span>,<br>    message: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;io::Error&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppError</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(error: io::Error) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        AppError &#123;<br>            kind: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;io&quot;</span>),<br>            message: error.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;num::ParseIntError&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppError</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(error: num::ParseIntError) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        AppError &#123;<br>            kind: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;parse&quot;</span>),<br>            message: error.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), AppError&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">file</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello_world.txt&quot;</span>)?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">content</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    file.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> content)?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_number</span>: <span class="hljs-type">usize</span>;<br>    _number = content.<span class="hljs-title function_ invoke__">parse</span>()?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="thiserror便捷的库"><a href="#thiserror便捷的库" class="headerlink" title="thiserror便捷的库"></a>thiserror便捷的库</h4><p>该库可以便捷的转换标准库的错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::read_to_string;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), MyError&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">html</span> = <span class="hljs-title function_ invoke__">render</span>()?;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, html);<br>  <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">render</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, MyError&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = std::env::<span class="hljs-title function_ invoke__">var</span>(<span class="hljs-string">&quot;MARKDOWN&quot;</span>)?;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">source</span> = <span class="hljs-title function_ invoke__">read_to_string</span>(file)?;<br>  <span class="hljs-title function_ invoke__">Ok</span>(source)<br>&#125;<br><br><span class="hljs-meta">#[derive(thiserror::Error, Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyError</span> &#123;<br>  <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Environment variable not found&quot;</span>)]</span><br>  <span class="hljs-title function_ invoke__">EnvironmentVariableNotFound</span>(<span class="hljs-meta">#[from]</span> std::env::VarError),<br>  <span class="hljs-meta">#[error(transparent)]</span><br>  <span class="hljs-title function_ invoke__">IOError</span>(<span class="hljs-meta">#[from]</span> std::io::Error),<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——泛型与特征</title>
    <link href="/2022/05/21/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%89%B9%E5%BE%81/"/>
    <url>/2022/05/21/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>泛型函数：<code>fn largest&lt;T&gt; (list:&amp;[T]) -&gt; T</code></li><li>泛型结构体：<code>struct Point&lt;T&gt;&#123;&#125;</code></li><li>泛型枚举：<code>enum Option&lt;T&gt;&#123;&#125;</code></li><li>泛型方法：<code>impl&lt;T&gt; Point&lt;T&gt;</code></li><li>多重泛型：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T, U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mixup</span>&lt;V, W&gt;(<span class="hljs-keyword">self</span>, other: Point&lt;V, W&gt;) <span class="hljs-punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x,<br>            y: other.y,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>为具体泛型实现方法：<code>impl Point&lt;f32&gt;&#123;&#125;</code></li></ul><h3 id="const泛型"><a href="#const泛型" class="headerlink" title="const泛型"></a>const泛型</h3><ul><li>语法：<code>fn display_array&lt;T: std::fmt::Debug,const N: usize&gt;(arr:[T;N])</code></li><li>限制大小：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 目前只能在nightly版本下使用</span><br><span class="hljs-meta">#![allow(incomplete_features)]</span><br><span class="hljs-meta">#![feature(generic_const_exprs)]</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">something</span>&lt;T&gt;(val: T)<br><span class="hljs-keyword">where</span><br>    Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; <span class="hljs-number">768</span> &#125;&gt;: IsTrue,<br>    <span class="hljs-comment">//       ^-----------------------------^ 这里是一个 const 表达式，换成其它的 const 表达式也可以</span><br>&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">something</span>([<span class="hljs-number">0u8</span>; <span class="hljs-number">0</span>]); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">something</span>([<span class="hljs-number">0u8</span>; <span class="hljs-number">512</span>]); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">something</span>([<span class="hljs-number">0u8</span>; <span class="hljs-number">1024</span>]); <span class="hljs-comment">// 编译错误，数组长度是1024字节，超过了768字节的参数长度限制</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li><strong>如果你想要为类型A实现特征T,那么A或T至少一个在当前作用域中定义</strong></li><li><strong>如果使用一个特征的方法，那么需要引入该特征到当前作用域</strong></li></ul><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span>&#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为某个类型实现特征"><a href="#为某个类型实现特征" class="headerlink" title="为某个类型实现特征"></a>为某个类型实现特征</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-keyword">pub</span> title: <span class="hljs-type">String</span>, <span class="hljs-comment">// 标题</span><br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>, <span class="hljs-comment">// 作者</span><br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>, <span class="hljs-comment">// 内容</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.title, <span class="hljs-keyword">self</span>.author)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;(Read more...)&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Post</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="特征多个方法混用"><a href="#特征多个方法混用" class="headerlink" title="特征多个方法混用"></a>特征多个方法混用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize_author</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br><span class="hljs-comment">//可以调用其他方法</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">summarize_author</span>())<br>    &#125;<br>&#125;<br><span class="hljs-comment">//只需实现一个特征即可</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Weibo</span>&#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize_author</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;@&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特征用作函数参数"><a href="#特征用作函数参数" class="headerlink" title="特征用作函数参数"></a>特征用作函数参数</h3><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><ul><li><code>pub fn notify(item1: &amp;impl Summary,item2: &amp;impl Summary)</code></li><li><code>pub fn notify&lt;T: Summary&gt;(item1:&amp;T,item2:&amp;T)</code><br><strong>以上两种是有区别的，第一个item1和item2可以是不同类型，第二个必须是一个类型</strong></li></ul><h4 id="多个约束"><a href="#多个约束" class="headerlink" title="多个约束"></a>多个约束</h4><ul><li><code>pub fn notify(item:&amp;(impl Summary+Display)) &#123;&#125;</code></li><li><code>pub fn notify&lt;T: Summary+Display&gt;(item:&amp;T)</code></li></ul><h4 id="使用where简化"><a href="#使用where简化" class="headerlink" title="使用where简化"></a>使用where简化</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>    <span class="hljs-keyword">where</span> T: Display + <span class="hljs-built_in">Clone</span>,<br>          U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span><br>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有条件的实现方法或特征"><a href="#有条件的实现方法或特征" class="headerlink" title="有条件的实现方法或特征"></a>有条件的实现方法或特征</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T, y: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            x,<br>            y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Display + <span class="hljs-built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp_display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.x &gt;= <span class="hljs-keyword">self</span>.y &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回特征"><a href="#返回特征" class="headerlink" title="返回特征"></a>返回特征</h3><p><code>fn returns_summarizable() -&gt; impl Summary</code><br><strong>该形式返回的值只能是某个具体的类型，即所有return值必须相同类型，如果要使用不同类型但实现同一特征的，需要使用特征对象</strong></p><h3 id="常用手动实现标准库特征"><a href="#常用手动实现标准库特征" class="headerlink" title="常用手动实现标准库特征"></a>常用手动实现标准库特征</h3><h4 id="std-ops-Add–自定义加操作"><a href="#std-ops-Add–自定义加操作" class="headerlink" title="std::ops::Add–自定义加操作"></a>std::ops::Add–自定义加操作</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-comment">// 为Point结构体派生Debug特征，用于格式化输出</span><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T: Add&lt;T, Output = T&gt;&gt; &#123; <span class="hljs-comment">//限制类型T必须实现了Add特征，否则无法进行+操作。</span><br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt;&gt; Add <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Point&lt;T&gt;;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, p: Point&lt;T&gt;) <span class="hljs-punctuation">-&gt;</span> Point&lt;T&gt; &#123;<br>        Point&#123;<br>            x: <span class="hljs-keyword">self</span>.x + p.x,<br>            y: <span class="hljs-keyword">self</span>.y + p.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = Point&#123;x: <span class="hljs-number">1.1f32</span>, y: <span class="hljs-number">1.1f32</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = Point&#123;x: <span class="hljs-number">2.1f32</span>, y: <span class="hljs-number">2.1f32</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(p1, p2));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p3</span> = Point&#123;x: <span class="hljs-number">1i32</span>, y: <span class="hljs-number">1i32</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p4</span> = Point&#123;x: <span class="hljs-number">2i32</span>, y: <span class="hljs-number">2i32</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(p3, p4));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h2><p>通过<code>&amp;</code>引用或<code>Box&lt;T&gt;</code>智能指针来创建特征对象</p><ul><li><code>fn draw1(x:Box&lt;dyn Draw&gt;)</code></li><li><code>fn draw2(x:&amp;dyn Draw)</code><br><strong>dyn关键子只用在类型声明，创建具体类型时无需使用dyn，如<code>Vec&lt;Box&lt;dyn Draw&gt;&gt;</code>,直接v.push(Box::new(x))</strong></li><li>特征对象占用两个指针空间大小，一个ptr,一个vptr（相当于c++的虚函数多态,c++我也不懂，嘎嘎,简单就是该特征对应具体实例类型的同一方法的不同实现）</li></ul><h3 id="特征对象的限制"><a href="#特征对象的限制" class="headerlink" title="特征对象的限制"></a>特征对象的限制</h3><p>只有对象安全的特征才能拥有特征对象，</p><ul><li>特征方法的返回类型不是Self</li><li>方法没有任何泛型参数<br>如果误用会报错<code>the trait xxx cannot be made into an object</code></li></ul><h2 id="特征冷门概念"><a href="#特征冷门概念" class="headerlink" title="特征冷门概念"></a>特征冷门概念</h2><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>就是在特征定义的语句块中，申明一个自定义类型，如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-comment">// --snip--</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Counter&#123;..&#125;<br>    c.<span class="hljs-title function_ invoke__">next</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>如上不使用如下泛型的原因，纯粹可读性更好</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&lt;Item&gt;&#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时type不仅可以指类型，还可以指代特征，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">CacheableItem</span>: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Default</span> + fmt::<span class="hljs-built_in">Debug</span> + Decodable + Encodable &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Address</span>: <span class="hljs-built_in">AsRef</span>&lt;[<span class="hljs-type">u8</span>]&gt; + <span class="hljs-built_in">Clone</span> + fmt::<span class="hljs-built_in">Debug</span> + <span class="hljs-built_in">Eq</span> + Hash;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_null</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Container</span>&lt;A,B&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>,a: A,b: B) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">difference</span>&lt;A,B,C&gt;(container: &amp;C) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>  <span class="hljs-keyword">where</span><br>    C : Container&lt;A,B&gt; &#123;...&#125;<br><br><span class="hljs-comment">//简单方法</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Container</span>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">A</span>;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">B</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, a: &amp;<span class="hljs-keyword">Self</span>::A, b: &amp;<span class="hljs-keyword">Self</span>::B) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">difference</span>&lt;C: Container&gt;(container: &amp;C) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="默认泛型类型参数"><a href="#默认泛型类型参数" class="headerlink" title="默认泛型类型参数"></a>默认泛型类型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Add</span>&lt;RHS=<span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, rhs: RHS) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Output;<br>&#125;<br><span class="hljs-comment">//使用默认参数,注意这和不使用泛型一样，因此这一般用来扩展而无需改变原代码</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Point;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + other.x,<br>            y: <span class="hljs-keyword">self</span>.y + other.y,<br>        &#125;<br>    &#125;<br>&#125;<br>不使用默认参数<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span>&lt;Meters&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Millimeters</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Millimeters;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Meters) <span class="hljs-punctuation">-&gt;</span> Millimeters &#123;<br>        <span class="hljs-title function_ invoke__">Millimeters</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> + (other.<span class="hljs-number">0</span> * <span class="hljs-number">1000</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同名方法"><a href="#同名方法" class="headerlink" title="同名方法"></a>同名方法</h3><h4 id="特征方法与本身方法重名"><a href="#特征方法与本身方法重名" class="headerlink" title="特征方法与本身方法重名"></a>特征方法与本身方法重名</h4><p>假设Human类型有两个特征Pilot和Wizard,并这两个特征都有fly方法，Human类型本身也有fly方法。假设有个实例person:</p><ul><li>person.fly():调用的是类型本身的方法</li><li>Pilot::fly(&amp;person):调用Pilot特征上的方法</li><li>Wizard::fly(&amp;person):调用Wizard特征上的方法</li></ul><h4 id="特征方法与关联函数重名"><a href="#特征方法与关联函数重名" class="headerlink" title="特征方法与关联函数重名"></a>特征方法与关联函数重名</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Spot&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;puppy&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::<span class="hljs-title function_ invoke__">baby_name</span>());<span class="hljs-comment">//Spot</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="hljs-keyword">as</span> Animal&gt;::<span class="hljs-title function_ invoke__">baby_name</span>());<span class="hljs-comment">//puppy</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用了完全限定语法<code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code><br>第一个receiver只有方法才有，有三种（self,&amp;self,&amp;mut self）,一般不这么写，编译器帮我们做了，只有分不清时才这么写</p><h3 id="特征的特征约束"><a href="#特征的特征约束" class="headerlink" title="特征的特征约束"></a>特征的特征约束</h3><p>即你要实现特征A必须先实现B:<code>trait A:B&#123;&#125;</code></p><h3 id="newtype–绕过特征或类型必须在当前作用域"><a href="#newtype–绕过特征或类型必须在当前作用域" class="headerlink" title="newtype–绕过特征或类型必须在当前作用域"></a>newtype–绕过特征或类型必须在当前作用域</h3><ul><li>rust中无法直接为外部类型实现外部特征，可以使用<code>newtype</code>:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Array</span>(<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;);<br><br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;数组是：&#123;:?&#125;&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, arr);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Sized特征"><a href="#Sized特征" class="headerlink" title="Sized特征"></a>Sized特征</h3><p>使用泛型时，编译器会为泛型自动加上约束Sized,即编译时就知道其大小,可以手动使用<code>?Sized</code>特征表示不定大小（str,[T],dyn Trait）,如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt;(t: &amp;T) &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——标准库</title>
    <link href="/2022/05/19/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/2022/05/19/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Vec"><a href="#Vec" class="headerlink" title="Vec"></a>Vec</h2><h3 id="两种初始化"><a href="#两种初始化" class="headerlink" title="两种初始化"></a>两种初始化</h3><ul><li><code>let v = vec![1,2,3];</code></li><li><code>let mut v = Vec::new();v.push(1);</code></li></ul><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul><li><code>v.push(1)</code></li></ul><h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><ul><li>下标：<code>let third= &amp;v[2]</code></li><li>get方法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(third) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第三个元素是 &#123;&#125;&quot;</span>, third),<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;去你的第三个元素，根本没有！&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><p>和数组一样<br><code>for i in &amp;mut v</code></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>要引入<code>use std::collections::HashMap</code></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><code>let mut my_gems:HashMap&lt;&amp;str,i32&gt; = HashMap::new()</code></li><li>从其他类型转换：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">teams_list</span> = <span class="hljs-built_in">vec!</span>[<br>    (<span class="hljs-string">&quot;中国队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">100</span>),<br>    (<span class="hljs-string">&quot;美国队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">10</span>),<br>    (<span class="hljs-string">&quot;日本队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">50</span>),<br>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">teams_map</span>: HashMap&lt;_,_&gt; = teams_list.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,teams_map)<br></code></pre></td></tr></table></figure></li></ul><h3 id="所有权问题"><a href="#所有权问题" class="headerlink" title="所有权问题"></a>所有权问题</h3><p>key和value若没实现Copy特征，所有权将转移到HashMap中</p><h3 id="插入更新值"><a href="#插入更新值" class="headerlink" title="插入更新值"></a>插入更新值</h3><ul><li>插入或更新：<code>kv.insert(key,value)</code></li><li>查询，不存在则插入,返回的是&amp;mut引用：<code>let v = scores.entry(key).or_insert(value)</code></li></ul><h3 id="通过get方法获取元素"><a href="#通过get方法获取元素" class="headerlink" title="通过get方法获取元素"></a>通过get方法获取元素</h3><ul><li>返回一个Option&lt;&amp;xx&gt;类型</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> (key,value) <span class="hljs-keyword">in</span> &amp;scores&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="键的限制"><a href="#键的限制" class="headerlink" title="键的限制"></a>键的限制</h3><p>只有实现<code>std::cmp::Eq</code>特证的类型才能用作键</p><h2 id="std-mem"><a href="#std-mem" class="headerlink" title="std::mem"></a>std::mem</h2><h3 id="std-mem-drop"><a href="#std-mem-drop" class="headerlink" title="std::mem::drop"></a>std::mem::drop</h3><p>手动将某值从内存中移除</p><h3 id="std-mem-size-of-val"><a href="#std-mem-size-of-val" class="headerlink" title="std::mem::size_of_val()"></a>std::mem::size_of_val()</h3><p>取得所占内存大小,也可以获得动态的切片大小</p><h3 id="mem-transmute"><a href="#mem-transmute" class="headerlink" title="mem::transmute&lt;T,U&gt;"></a>mem::transmute&lt;T,U&gt;</h3><p>将类型T直接转换成类型U,只要他们字节数相同</p><ul><li>应用举例:<ul><li>将裸指针转变成函数指针:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br><span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">pointer</span> = foo <span class="hljs-keyword">as</span> *<span class="hljs-title function_ invoke__">const</span> ();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">function</span> = <span class="hljs-keyword">unsafe</span> &#123; <br><span class="hljs-comment">// 将裸指针转换为函数指针</span><br>std::mem::transmute::&lt;*<span class="hljs-title function_ invoke__">const</span> (), <span class="hljs-title function_ invoke__">fn</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt;(pointer) <br>&#125;;<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">function</span>(), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li>延长生命周期，或缩短一个静态生命周期寿命<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">R</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>);<br><br><span class="hljs-comment">// 将 &#x27;b 生命周期延长至 &#x27;static 生命周期</span><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">extend_lifetime</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(r: R&lt;<span class="hljs-symbol">&#x27;b</span>&gt;) <span class="hljs-punctuation">-&gt;</span> R&lt;<span class="hljs-symbol">&#x27;static</span>&gt; &#123;<br>std::mem::transmute::&lt;R&lt;<span class="hljs-symbol">&#x27;b</span>&gt;, R&lt;<span class="hljs-symbol">&#x27;static</span>&gt;&gt;(r)<br>&#125;<br><br><span class="hljs-comment">// 将 &#x27;static 生命周期缩短至 &#x27;c 生命周期</span><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">shorten_invariant_lifetime</span>&lt;<span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;c</span>&gt;(r: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> R&lt;<span class="hljs-symbol">&#x27;static</span>&gt;) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> R&lt;<span class="hljs-symbol">&#x27;c</span>&gt; &#123;<br>std::mem::transmute::&lt;&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> R&lt;<span class="hljs-symbol">&#x27;static</span>&gt;, &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> R&lt;<span class="hljs-symbol">&#x27;c</span>&gt;&gt;(r)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>###&#96;mem::transmute_copy&lt;T,U&gt;<br>从T中拷贝出U类型所需的字节数，然后转换成U</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p><code>let a = i8::MAX</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——所有权及引用</title>
    <link href="/2022/05/15/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%89%80%E6%9C%89%E6%9D%83%E5%8F%8A%E5%BC%95%E7%94%A8/"/>
    <url>/2022/05/15/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%89%80%E6%9C%89%E6%9D%83%E5%8F%8A%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>获取变量的引用，称之为借用<br>如下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>=&amp;s1;<br>&#125;<br></code></pre></td></tr></table></figure><p>本质如下图所示：<br><img src="/images/rust_borrow.jpg"><br><code>&amp;s1</code>创建了一个指向s1的引用，但是并不拥有它,所以引用离开作用域后，不会被丢弃</p><h2 id="一些tips"><a href="#一些tips" class="headerlink" title="一些tips"></a>一些tips</h2><ul><li>引用的作用域的结束位置为最后一次使用的位置</li><li>同一作用域，特定数据只能有一个可变引用</li><li>可变引用与不可变引用不能同时存在</li><li>同一时刻，你只能拥有一个可变引用，要么任意多个不可变引用</li></ul><h2 id="Copy特征"><a href="#Copy特征" class="headerlink" title="Copy特征"></a>Copy特征</h2><p>如果一个类型拥有Copy特征，一个旧的变量在被赋值给其他变量后仍然可用，任何基本类型的组合可以Copy,不需要分配内存或某种形式资源的类型是可以Copy的。如下类型是可以Copy:</p><ul><li>所有整数类型，比如u32。</li><li>布尔类型，bool，它的值是true和false。</li><li>所有浮点数类型，比如f64。</li><li>字符类型，char。</li><li>元组，当且仅当其包含的类型也都是Copy的时候。比如，(i32,i32)是Copy的，但 (i32,String)就不是。</li><li>不可变引用 &amp;T ，例如转移所有权中的最后一个例子，但是注意:<strong>可变引用&amp;mut T是不可以Copy的</strong></li></ul><h2 id="Clone特征"><a href="#Clone特征" class="headerlink" title="Clone特征"></a>Clone特征</h2><ul><li>所有引用都实现了Clone特征</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——迭代器.md</title>
    <link href="/2022/05/13/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8-md/"/>
    <url>/2022/05/13/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8-md/</url>
    
    <content type="html"><![CDATA[<h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h3><p>可以访问下标，本质上是第几次迭代<br><code>for (i,record) in records.enumerate()</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——输入输出</title>
    <link href="/2022/04/13/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2022/04/13/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="从标准输入读取"><a href="#从标准输入读取" class="headerlink" title="从标准输入读取"></a>从标准输入读取</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// 读取控制台的输出</span><br>io::<span class="hljs-title function_ invoke__">stdin</span>()<br>    .<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> index)<br>    .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h2><ul><li>print!:将格式化文本输出到标准输出，不带换行符</li><li>println!:同上，但是添加换行符</li><li>format!:将格式化文本输出到String<code>let s1 = format!(&quot;&#123;&#125;,world&quot;,s)</code></li><li>eprint!:不带换行符的标准错误</li><li>eprintln!:带换行符的标准错误</li></ul><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ul><li><code>&#123;&#125;</code>用于实现了<code>std::fmt::Display</code>特征的类型</li><li><code>&#123;:?&#125;</code>用于实现了<code>std::fmt::Debug</code>特征的类型</li><li><code>&#123;:#?&#125;</code>和<code>&#123;:?&#125;</code>基本一样，只不过更美观</li><li><strong>位置参数:</strong><code>println!(&quot;&#123;1&#125;&#123;&#125;&#123;0&#125;&#123;&#125;&quot;,1,2);//=&gt;2112</code></li><li><strong>具名参数:</strong><code>println!(&quot;&#123;a&#125;&#123;c&#125;&quot;,c=3,a=&quot;a&quot;)//=&gt;a3</code></li><li>转义左大括号:<code>&#123;&#123;`,不是用反斜杠- 转义右大括号:`&#125;&#125;</code>,不是用反斜杠</li></ul><h3 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h3><ul><li>带名参数必须放在不带名称参数的后面，如下会报错：<code>println!(&quot;&#123;abc&#125; &#123;1&#125;&quot;,abc=&quot;def&quot;,2);</code></li><li>正确用法：<code>println!(&quot;&#123;name&#125; &#123;&#125;&quot;, 1, name = 2);</code></li></ul><h3 id="格式化参数"><a href="#格式化参数" class="headerlink" title="格式化参数"></a>格式化参数</h3><p>以下以<code>&#123;&#125;</code>为例，<code>&#123;:?&#125;</code>就是在各个例子最后加个问号</p><h4 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h4><p>字符串格式化默认使用空格进行填充，若想自定义填充符，需要指明对齐，并且进行左对齐。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">//-----------------------------------</span><br>    <span class="hljs-comment">// 以下全部输出 &quot;Hello x    !&quot;</span><br>    <span class="hljs-comment">// 为&quot;x&quot;后面填充空格，补齐宽度5</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>    <span class="hljs-comment">// 使用参数5来指定宽度</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:1$&#125;!&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 使用x作为占位符输出内容，同时使用5作为宽度</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;1:0$&#125;!&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>    <span class="hljs-comment">// 使用有名称的参数作为宽度</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:width$&#125;!&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, width = <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//-----------------------------------</span><br><br>    <span class="hljs-comment">// 使用参数5为参数x指定宽度，同时在结尾输出参数5 =&gt; Hello x    !5</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:1$&#125;!&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数字填充和正负号"><a href="#数字填充和正负号" class="headerlink" title="数字填充和正负号"></a>数字填充和正负号</h4><p>数字格式化默认也是使用空格进行填充，若想自定义填充符，需要指明对齐，但与字符串左对齐不同的是，数字是右对齐。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 宽度是5 =&gt; Hello     5!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 显式的输出正号 =&gt; Hello +5!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:+&#125;!&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 宽度5，使用0进行填充 =&gt; Hello 00005!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:05&#125;!&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 负号也要占用一位宽度 =&gt; Hello -0005!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:05&#125;!&quot;</span>, -<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="精度和字符串长度"><a href="#精度和字符串长度" class="headerlink" title="精度和字符串长度"></a>精度和字符串长度</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-comment">// 保留小数点后两位 =&gt; 3.14</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:.2&#125;&quot;</span>, v);<br>    <span class="hljs-comment">// 带符号保留小数点后两位 =&gt; +3.14</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:+.2&#125;&quot;</span>, v);<br>    <span class="hljs-comment">// 不带小数 =&gt; 3</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:.0&#125;&quot;</span>, v);<br>    <span class="hljs-comment">// 通过参数来设定精度 =&gt; 3.1416，相当于&#123;:.4&#125;</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:.1$&#125;&quot;</span>, v, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hi我是Sunface孙飞&quot;</span>;<br>    <span class="hljs-comment">// 保留字符串前三个字符 =&gt; hi我</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:.3&#125;&quot;</span>, s);<br>    <span class="hljs-comment">// &#123;:.*&#125;接收两个参数，第一个是精度，第二个是被格式化的值 =&gt; Hello abc!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:.*&#125;!&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;abcdefg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 以下全部都会补齐5个字符的长度</span><br>    <span class="hljs-comment">// 左对齐 =&gt; Hello x    !</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:&lt;5&#125;!&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>    <span class="hljs-comment">// 右对齐 =&gt; Hello     x</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:&gt;5&#125;!&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>    <span class="hljs-comment">// 居中对齐 =&gt; Hello   x  !</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:^5&#125;!&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br><br>    <span class="hljs-comment">// 对齐并使用指定符号填充 =&gt; Hello x&amp;&amp;&amp;&amp;!</span><br>    <span class="hljs-comment">// 指定符号填充的前提条件是必须有对齐字符</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><ul><li><code>#b</code>:二进制</li><li><code>#o</code>:八进制</li><li><code>#x</code>:小写十六进制</li><li><code>#X</code>:大写十六进制</li><li><code>x</code>:不带前缀的小写十六进制<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 二进制 =&gt; 0b11011!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#b&#125;!&quot;</span>, <span class="hljs-number">27</span>);<br>    <span class="hljs-comment">// 八进制 =&gt; 0o33!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#o&#125;!&quot;</span>, <span class="hljs-number">27</span>);<br>    <span class="hljs-comment">// 十进制 =&gt; 27!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>, <span class="hljs-number">27</span>);<br>    <span class="hljs-comment">// 小写十六进制 =&gt; 0x1b!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#x&#125;!&quot;</span>, <span class="hljs-number">27</span>);<br>    <span class="hljs-comment">// 大写十六进制 =&gt; 0x1B!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#X&#125;!&quot;</span>, <span class="hljs-number">27</span>);<br><br>    <span class="hljs-comment">// 不带前缀的十六进制 =&gt; 1b!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:x&#125;!&quot;</span>, <span class="hljs-number">27</span>);<br><br>    <span class="hljs-comment">// 使用0填充二进制，宽度为10 =&gt; 0b00011011!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#010b&#125;!&quot;</span>, <span class="hljs-number">27</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:2e&#125;&quot;</span>, <span class="hljs-number">1000000000</span>); <span class="hljs-comment">// =&gt; 1e9</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:2E&#125;&quot;</span>, <span class="hljs-number">1000000000</span>); <span class="hljs-comment">// =&gt; 1E9</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指针地址"><a href="#指针地址" class="headerlink" title="指针地址"></a>指针地址</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>= <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:p&#125;&quot;</span>, v.<span class="hljs-title function_ invoke__">as_ptr</span>()) <span class="hljs-comment">// =&gt; 0x600002324050</span><br></code></pre></td></tr></table></figure><h3 id="rust1-58捕获环境中的值"><a href="#rust1-58捕获环境中的值" class="headerlink" title="rust1.58捕获环境中的值"></a>rust1.58捕获环境中的值</h3><p>该功能反人类,直接捕获变量名,只能是普通的变量，更复杂的类型(比如表达式)不行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> (width, precision) = <span class="hljs-title function_ invoke__">get_format</span>();<br><span class="hljs-keyword">for</span> (name, score) <span class="hljs-keyword">in</span> <span class="hljs-title function_ invoke__">get_scores</span>() &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;name&#125;: &#123;score:width$.precision$&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Debug特征"><a href="#Debug特征" class="headerlink" title="Debug特征"></a>Debug特征</h2><p>大多数rust类型都实现了Debug特征或支持派生该特征:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u8</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person&#123;name: <span class="hljs-string">&quot;sunface&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), age: <span class="hljs-number">18</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, i, s, v, p);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手动实现Display特征"><a href="#手动实现Display特征" class="headerlink" title="手动实现Display特征"></a>手动实现Display特征</h2><p>标准库Display特征实现没那么多,可以自己实现:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(<br>            f,<br>            <span class="hljs-string">&quot;大佬在上，请受我一拜，小弟姓名&#123;&#125;，年芳&#123;&#125;，家里无田又无车，生活苦哈哈&quot;</span>,<br>            <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person &#123;<br>        name: <span class="hljs-string">&quot;sunface&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        age: <span class="hljs-number">18</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, p);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——杂项</title>
    <link href="/2022/04/13/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/"/>
    <url>/2022/04/13/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>文档注释需要位于lib类型的包中，如<code>src/lib.rs</code></li><li>文档注释可以使用markdown语法</li><li>被注释的对象需要使用pub对外可见</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>针对函数和结构体：行注释<code>///</code>和块注释<code>/** ... */</code></li><li>针对包和模块级别：行注释<code>//!</code>和块注释<code>/*! ... */</code></li><li>包和模块级别的必须加到最上方</li></ul><h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><p><code>cargo test</code>命令可以运行包含在文档注释中的代码块，当然得包含assert等相关语句。</p><ul><li>得使用完整的路径来调用函数，因为是在独立线程中运行的</li><li>如果测试用例造成panic,且这panic是预期结果，得使用如下:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// ```rust,should_panic</span><br><span class="hljs-comment">/// // panics on division by zero</span><br><span class="hljs-comment">/// world_hello::compute::div(10,0);</span><br><span class="hljs-comment">/// ```</span><br></code></pre></td></tr></table></figure></li><li>隐藏测试内容：当我们不想在文档中展示测试内容时可以使用<code>#</code>来隐藏<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// ```</span><br><span class="hljs-comment">/// # //该行被隐藏</span><br><span class="hljs-comment">/// 该行正常</span><br><span class="hljs-comment">/// ```</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="文档跳转"><a href="#文档跳转" class="headerlink" title="文档跳转"></a>文档跳转</h3><p>该功能可以实现对外部项的链接或本地代码的跳转</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 跳转到标准库[`Option`],[`std::future`]</span><br><span class="hljs-comment">/// 跳转到自己的结构体[`crate::MySpecialFormatter`]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MySpecialFormatter</span>;<br></code></pre></td></tr></table></figure><ul><li>同名项的跳转<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 跳转到结构体  [`Foo`](struct@Foo)</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span>;<br><br><span class="hljs-comment">/// 跳转到同名函数 [`Foo`](fn@Foo)</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;&#125;<br><br><span class="hljs-comment">/// 跳转到同名宏 [`foo!`]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">Foo</span>() &#123;&#125;<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> foo &#123;<br>  () =&gt; &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="文档搜索别名"><a href="#文档搜索别名" class="headerlink" title="文档搜索别名"></a>文档搜索别名</h3><p>在搜索时，会跳到相应的位置</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[doc(alias = <span class="hljs-string">&quot;x&quot;</span>)]</span><br><span class="hljs-meta">#[doc(alias = <span class="hljs-string">&quot;big&quot;</span>)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigX</span>;<br><br><span class="hljs-meta">#[doc(alias(<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;big&quot;</span>))]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigY</span>;<br></code></pre></td></tr></table></figure><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><code>cargo doc</code>直接生成HTML文件，放在target&#x2F;doc目录下</li><li><code>cargo doc --open</code>在浏览器中查看</li></ul><h2 id="函数中mut位置"><a href="#函数中mut位置" class="headerlink" title="函数中mut位置"></a>函数中mut位置</h2><ul><li><code>fn do1(c: String) &#123;&#125;</code>：表示实参会将所有权传递给c</li><li><code>fn do2(c: &amp;String) &#123;&#125;</code>：表示实参的不可变引用（指针）传递给c，实参需带&amp; 声明</li><li><code>fn do3(c: &amp;mut String) &#123;&#125;</code>：表示实参可变引用（指针）传递给c，实参需带let mut声明，且传入需带&amp;mut</li><li><code>fn do4(mut c: String) &#123;&#125;</code>：表示实参会将所有权传递给c，且在函数体内c是可读可写的，实参无需mut声明</li><li><code>fn do5(mut c: &amp;mut String) &#123;&#125;</code>：表示实参可变引用指向的值传递给c，且c在函数体内部是可读可写的，实参需带let mut声明，且传入需带&amp;mut<br> 一句话总结：在函数参数中，冒号左边的部分，如：mut c，这个 mut 是对函数体内部有效；冒号右边的部分，如：&amp;mut String，这个&amp;mut是针对外部实参传入时的形式（声明）说明。<br>例子:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d1</span> = <span class="hljs-string">&quot;str&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-title function_ invoke__">do1</span>(d1);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d2</span> = <span class="hljs-string">&quot;str&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-title function_ invoke__">do2</span>(&amp;d2);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">d3</span> = <span class="hljs-string">&quot;str&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-title function_ invoke__">do3</span>(&amp;<span class="hljs-keyword">mut</span> d3);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d4</span> = <span class="hljs-string">&quot;str&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-title function_ invoke__">do4</span>(d4);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">d5</span> = <span class="hljs-string">&quot;str&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-title function_ invoke__">do5</span>(&amp;<span class="hljs-keyword">mut</span> d5);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do1</span>(c: <span class="hljs-type">String</span>) &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do2</span>(c: &amp;<span class="hljs-type">String</span>) &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do3</span>(c: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do4</span>(<span class="hljs-keyword">mut</span> c: <span class="hljs-type">String</span>) &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do5</span>(<span class="hljs-keyword">mut</span> c: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="方法中的self"><a href="#方法中的self" class="headerlink" title="方法中的self"></a>方法中的self</h2><ul><li>在impl中<code>&amp;self</code>是<code>self:&amp;Self</code>的简写</li><li>Self指代被实现方法或特征的结构体类型，self指代此类型的实例</li></ul><h2 id="cfg"><a href="#cfg" class="headerlink" title="cfg!"></a>cfg!</h2><h3 id="debug-assertions"><a href="#debug-assertions" class="headerlink" title="debug_assertions"></a>debug_assertions</h3><p><code>if cfg!(debug_assertions)</code>debug模式下为true</p><h2 id="常用编译器属性标记"><a href="#常用编译器属性标记" class="headerlink" title="常用编译器属性标记"></a>常用编译器属性标记</h2><ul><li><code>#![allow(unused_variables)]</code></li><li><code>#[allow(dead_code)]</code></li></ul><h2 id="有用冷门宏"><a href="#有用冷门宏" class="headerlink" title="有用冷门宏"></a>有用冷门宏</h2><h3 id="unimplemented"><a href="#unimplemented" class="headerlink" title="unimplemented!()"></a>unimplemented!()</h3><p>告诉编译器该函数尚未实现，还有todo!(),如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read</span>(f: &amp;<span class="hljs-keyword">mut</span> File, save_to: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-built_in">unimplemented!</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dbg"><a href="#dbg" class="headerlink" title="dbg!()"></a>dbg!()</h3><p>接受一个表达式，并取走所有权，然后打印文件名，行号等debug信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">scale</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: dbg!(<span class="hljs-number">30</span> * scale),<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    dbg!(&amp;rect1);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——模式匹配</title>
    <link href="/2022/04/11/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/04/11/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><ul><li>match的匹配必须要穷举所有可能，用<code>_</code>来代表未列出的所有可能</li><li>match的每一个分支必须是一个表达式，并且所有分支的表达式最终返回值的类型必须相同</li><li><code>X|Y</code>用来表示逻辑或</li><li>match本身也是表达式可以用来赋值</li><li>match匹配不成功是不会发生所有权的转移</li><li><code>_</code>不会取走所得权</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> target &#123;<br>    模式<span class="hljs-number">1</span> =&gt; 表达式<span class="hljs-number">1</span>,<br>    模式<span class="hljs-number">2</span> =&gt; &#123;<br>        语句<span class="hljs-number">1</span>;<br>        语句<span class="hljs-number">2</span>;<br>        表达式<span class="hljs-number">2</span><br>    &#125;,<br>    _ =&gt; 表达式<span class="hljs-number">3</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从模式中提取绑定值"><a href="#从模式中提取绑定值" class="headerlink" title="从模式中提取绑定值"></a>从模式中提取绑定值</h3><p>假设action为一个绑定值的枚举类型，可以像下面这么使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> action &#123;<br>Action::<span class="hljs-title function_ invoke__">Say</span>(s) =&gt; &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;,<br>Action::<span class="hljs-title function_ invoke__">MoveTo</span>(x, y) =&gt; &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point from (0, 0) move to (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);<br>&#125;,<br>Action::<span class="hljs-title function_ invoke__">ChangeColorRGB</span>(r, g, _) =&gt; &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;change color into &#x27;(r:&#123;&#125;, g:&#123;&#125;, b:0)&#x27;, &#x27;b&#x27; has been ignored&quot;</span>,<br>r, g,<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-let匹配"><a href="#if-let匹配" class="headerlink" title="if let匹配"></a>if let匹配</h3><ul><li>当只要匹配一个条件,且忽略其他条件时就用if let,否则都用match<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3u8</span>);<br><span class="hljs-keyword">match</span> v&#123;<br><span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>_ =&gt;(),<br>&#125;<br></code></pre></td></tr></table></figure>等价于<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-number">3</span>) = v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>提取Option值<br><code>let Some(x) = some_option_value;</code>会编译出错，因为没覆盖None<br><code>if let Some(x) = some_option_value&#123;&#125;</code>应该这样，但是x的作用域仅限花括号内</li></ul><h3 id="while-let匹配"><a href="#while-let匹配" class="headerlink" title="while let匹配"></a>while let匹配</h3><p>和if let类似,一个十分有用的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(top) = stack.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, top);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="matches-宏"><a href="#matches-宏" class="headerlink" title="matches!宏"></a>matches!宏</h3><p>该宏将一个表达式跟模式进行匹配，然后返回true或false<br><code>v.iter().filter(|x| x == MyEnum::Foo);</code>：无法编译通过，无法将x直接跟一个枚举成员进行比较,应该如下：<br><code>v.iter().filter(|x| matches!(x,MyEnum::Foo));</code><br>更多例子:<br><code>assert!(matches!(foo, &#39;A&#39;..=&#39;Z&#39; | &#39;a&#39;..=&#39;z&#39;));</code><br><code>assert!(matches!(bar, Some(x) if x &gt; 2));</code></p><h2 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h2><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> p = Point &#123;x:<span class="hljs-number">0</span>,y:<span class="hljs-number">7</span>&#125;;<br><span class="hljs-comment">//更常用 let Point &#123;x,y&#125; = p;</span><br><span class="hljs-keyword">let</span> Point &#123;x:a,y:b&#125; = p;<br><span class="hljs-keyword">assert</span><span class="hljs-number">_</span>eq!(<span class="hljs-number">0</span>,a);<br><span class="hljs-keyword">assert</span><span class="hljs-number">_</span>eq!(<span class="hljs-number">7</span>,b);<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="_"></a><code>_</code></h2><ul><li>任何模式匹配的结构赋值都可能发生所有权的转移，但<code>_</code>不会发生</li></ul><h2 id="忽略剩余的值"><a href="#忽略剩余的值" class="headerlink" title="..忽略剩余的值"></a><code>..</code>忽略剩余的值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">match</span> origin &#123;<br>    Point &#123; x, .. &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is &#123;&#125;&quot;</span>, x),<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匹配守卫-额外的if条件"><a href="#匹配守卫-额外的if条件" class="headerlink" title="匹配守卫-额外的if条件"></a>匹配守卫-额外的if条件</h2><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">match</span> num &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(x) <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;less than five: &#123;&#125;&quot;</span>, x),<br>    <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x),<br>    <span class="hljs-literal">None</span> =&gt; (),<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>匹配守卫条件会作用于所有的模式，无法使用括号来改变优先级，因为这不是运算符<br><code>4 | 5 | 6 if y</code>用括号(这仅是方便理解，无法用括号改变优先级)表示就是<code>(4| 5 | 6) if y</code></li></ul><h2 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h2><h3 id="绑定部分字段"><a href="#绑定部分字段" class="headerlink" title="绑定部分字段"></a>绑定部分字段</h3><ul><li>匹配到的模式绑定到一个变量中,允许为一个字段绑定到另外一个变量<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Hello &#123; id: <span class="hljs-type">i32</span> &#125;,<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = Message::Hello &#123; id: <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">match</span> msg &#123;<br>    Message::Hello &#123; id: id_variable @ <span class="hljs-number">3</span>..=<span class="hljs-number">7</span> &#125; =&gt; &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)<br>&#125;,<br>_ =&gt;&#123;...&#125;,<br></code></pre></td></tr></table></figure>上例可以这么理解通过在<code>3..=7</code>之前指定<code>id_variable @</code>,我们捕获了任何匹配此范围的值并同时将该值绑定到变量id_variable</li></ul><h3 id="前绑定后结构"><a href="#前绑定后结构" class="headerlink" title="前绑定后结构"></a>前绑定后结构</h3><ul><li>下例字段都是基本形没发生所有权转移，所以这么用,没有copy特性的用起来还挺蛋疼</li><li>可以在绑定新变量的同时，对目标进行解构<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> @ Point &#123;x: px, y: py &#125; = Point &#123;x: <span class="hljs-number">10</span>, y: <span class="hljs-number">23</span>&#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, px, py);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, p);<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-53版本后新增"><a href="#1-53版本后新增" class="headerlink" title="1.53版本后新增"></a>1.53版本后新增</h3><p>绑定可以使用括号，下例不加括号会没有绑定到所有模式，只绑定到了1,编译不通过:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-number">1</span> &#123;<br>        num @ (<span class="hljs-number">1</span> | <span class="hljs-number">2</span>) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br>        &#125;<br>        _ =&gt; &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>使用下划线开头可以使编译器忽略未使用的变量</li><li>可以使用序列</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——控制</title>
    <link href="/2022/04/11/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/04/11/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li>if语句块是表达式</li><li>赋值时，每个分支返回的类型要一样</li></ul><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul><li>不声明一个变量，循环指定次数<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>&#123;<br> <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><ul><li>loop也是一个表达式(见break示例)</li></ul><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><ul><li>break可以单独使用，也可以带一个返回值，有些类似return<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>        counter += <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h2><ul><li>break和continue都支持循环标签,用于控制多层循环<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-symbol">&#x27;counting_up</span>: <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count = &#123;&#125;&quot;</span>, count);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">remaining</span> = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;remaining = &#123;&#125;&quot;</span>, remaining);<br>            <span class="hljs-keyword">if</span> remaining == <span class="hljs-number">9</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> count == <span class="hljs-number">2</span> &#123;<br>                <span class="hljs-keyword">break</span> <span class="hljs-symbol">&#x27;counting_up</span>;<br>            &#125;<br>            remaining -= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        count += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;End count = &#123;&#125;&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——字符串</title>
    <link href="/2022/04/10/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/04/10/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串的性质"><a href="#字符串的性质" class="headerlink" title="字符串的性质"></a>字符串的性质</h2><ul><li>rust的字符是Unicode类型，因此字符占据4个字节，但是字符串（无论String还是&amp;str）是UTF-8编码，也就是字符串中的字符所占的字节数是变化的(1-4)</li><li>对字符串的切片操作一定落在utf-8字符的边界上，例如中文在utf-8占用3个字节，一定取3的整数，否则会崩溃</li><li>由于是utf-8无法像其他语言一样使用中括号索引单个字符</li><li>&amp;str是硬编码，String为可变、可增长，在作用域结束自动调用drop,释放堆上空间</li></ul><h2 id="String与-str的转换"><a href="#String与-str的转换" class="headerlink" title="String与&amp;str的转换"></a>String与&amp;str的转换</h2><h3 id="str-String"><a href="#str-String" class="headerlink" title="&amp;str-&gt;String"></a>&amp;str-&gt;String</h3><ul><li><code>String::from(&quot;hello,world&quot;)</code></li><li><code>&quot;hello,world&quot;.to_string()</code></li></ul><h3 id="String-str"><a href="#String-str" class="headerlink" title="String-&gt;&amp;str"></a>String-&gt;&amp;str</h3><ul><li>取引用<code>&amp;s</code></li><li><code>s.as_str()</code></li><li>取个新的切片：<code>let slice= &amp;s[0..len]</code></li></ul><h2 id="String的常用操作"><a href="#String的常用操作" class="headerlink" title="String的常用操作"></a>String的常用操作</h2><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p>改变原本字符</p><ul><li>追加字符：<code>s.push(&#39;r&#39;)</code></li><li>追加字符串：<code>s.push_str(&quot;ust&quot;)</code></li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>改变原本字符</p><ul><li>插入字符：<code>s.insert(5,&#39;,&#39;)</code></li><li>插入字符串：<code>s.insert_str(5,&quot;i like&quot;)</code></li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><ul><li>适用于String和&amp;str，替换所有匹配的，返回新的字符串</li><li><code>s.replace(&quot;old pattern&quot;,&quot;new pattern&quot;)</code></li></ul><h4 id="replacen"><a href="#replacen" class="headerlink" title="replacen"></a>replacen</h4><ul><li>适用于String和&amp;str，指定替换的个数，返回新的字符串</li><li><code>s.replacen(&quot;old pattern&quot;,&quot;new pattern&quot;,2)</code></li></ul><h4 id="replace-range"><a href="#replace-range" class="headerlink" title="replace_range"></a>replace_range</h4><ul><li>该方法改变原来字符串，第一个参数指定范围，第二个是新串</li><li><code>s.replace_range(7..8,&quot;R&quot;)</code></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><ul><li>删除并返回字符串的最后一个字符的Option类型（若字符串为空，返回None），改变原来字符串</li><li>会自动定位最后一个字符的起始字节</li><li><code>s.pop()</code></li></ul><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><ul><li>删除指定位置的字符，返回是该字符的字符串，如果不是合法的字符边界，会出错</li><li>会改变原来的字符串</li><li><code>s.remove(3)</code></li></ul><h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><ul><li>截断指定位置开始到最后的所有内容，如果位置不是合法边界会出错，会改变原内容</li><li><code>s.truncate(3)</code></li></ul><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><ul><li>清空原来的字符串</li><li><code>s.clear()</code></li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h3 id="或"><a href="#或" class="headerlink" title="+或+="></a><code>+</code>或<code>+=</code></h3><ul><li>本质上是调用<code>fn add(self, s: &amp;str)-&gt;String</code></li><li>所以操作符左边为String,会发生所有权转移(离开函数实际上就丢失了)，右边只能是&amp;str类型</li><li><code>+=</code>会发生原来的字符串会丢失所有权，绑定到一个新的字符串上</li></ul><h3 id="format"><a href="#format" class="headerlink" title="format!"></a>format!</h3><ul><li>适用于String和&amp;str</li><li><code>let s = format!(&quot;&#123;&#125; &#123;&#125;!&quot;,s1,s2)</code></li></ul><h2 id="UTF-8字符串的遍历"><a href="#UTF-8字符串的遍历" class="headerlink" title="UTF-8字符串的遍历"></a>UTF-8字符串的遍历</h2><h3 id="chars–直观意义上的字符遍历"><a href="#chars–直观意义上的字符遍历" class="headerlink" title="chars–直观意义上的字符遍历"></a>chars–直观意义上的字符遍历</h3><ul><li>该方法以Unicode字符方式遍历，是人类直观的映像<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//会分别输出&quot;中国人&quot;三个字</span><br><span class="hljs-keyword">for</span> c in <span class="hljs-string">&quot;中国人&quot;</span>.chars() &#123;<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="bytes–按底层字节遍历"><a href="#bytes–按底层字节遍历" class="headerlink" title="bytes–按底层字节遍历"></a>bytes–按底层字节遍历</h3><ul><li>按底层字节数组遍历<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">fn <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> b in <span class="hljs-string">&quot;中国人&quot;</span>.bytes() &#123;<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="str-lines"><a href="#str-lines" class="headerlink" title="str.lines()"></a>str.lines()</h3><p>以<code>\n</code>或<code>\r\n</code>分隔字符串，返回一个迭代器</p><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>你懂的，返回一个迭代器</p><h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>你懂的，去除首尾空白字符</p><h3 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h3><p>类型转换</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">four</span>: <span class="hljs-type">u32</span>=<span class="hljs-string">&quot;4&quot;</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">four</span> = <span class="hljs-string">&quot;4&quot;</span>.parse::&lt;<span class="hljs-type">u32</span>&gt;();<br></code></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>String类型的深拷贝</p><h2 id="取消转义"><a href="#取消转义" class="headerlink" title="取消转义"></a>取消转义</h2><p>双引号之间若还有转义字符，会被转义，若想取消转义，有以下方法：</p><ul><li><code>let raw_str=r&quot;Escapes don&#39;t work here: \x3F \u&#123;211D&#125;&quot;</code></li><li>若包含双引号可以：<code> let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</code></li><li>若还是有歧义继续加<code>#</code>:<code>let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###</code></li></ul><h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box<str></h2><p>&amp;str包含了内存位置及长度信息，而str是不定长类型，Box<str>要想正常使用，也需要包含这些信息，通常如下：<code>let s1:Box&lt;str&gt; = &quot;hello&quot;.into()</code></p><h2 id="通过Box-leak转成static生命周期"><a href="#通过Box-leak转成static生命周期" class="headerlink" title="通过Box::leak转成static生命周期"></a>通过Box::leak转成static生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(s.<span class="hljs-title function_ invoke__">into_boxed_str</span>())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——变量</title>
    <link href="/2022/04/09/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F/"/>
    <url>/2022/04/09/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li>常量值的类型必须标注</li></ul><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><ul><li>rust默认使用i32</li></ul><h3 id="浮点形"><a href="#浮点形" class="headerlink" title="浮点形"></a>浮点形</h3><ul><li>rust默认使用f64</li><li>保留指定位数：<code>13.14_f32.round()</code>默认取整,必须下划线指定类型</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>round():<code>13.13_f32.round()</code>,必须指明f32类型,取整</li></ul><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><ul><li>所有跟NaN交互的操作，会返回一个NaN</li><li>可以用<code>x.is_nan()</code>来判读</li></ul><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><ul><li>序列支持字符或整形数字</li><li><code>1..5</code>1到4</li><li><code>1..=5</code>1到5</li><li><code>(1..5).rev</code>逆序</li></ul><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><ul><li>字符只能用<code>&#39;&#39;</code>括起来，占4个字节，可以表示所有Unicode值</li></ul><h2 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h2><ul><li>单元类型就是<code>()</code>，main函数,prinln!()就返回该类型</li><li>没有返回值的函数与这个不同，它们被称为发散函数</li><li>可以用作map的值，用来占位</li><li>表达式如果不返回任何值，会隐式的返回一个<code>()</code></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>格式:<code>fn funcname(i:type,j:type) -&gt; type&#123;&#125;</code></li><li>发散函数用来定义导致程序崩溃的函数或死循环的函数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">fn dead_end() -&gt; !&#123;<br>panic!(<span class="hljs-string">&quot;dead!!&quot;</span>);<br>&#125;<br>fn forever() -&gt;!&#123;<br>loop&#123;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><p>谨记一下两点规则：</p><ul><li>Rust中每一个值都有且只有一个所有者（变量）</li><li>当所有者（变量）离开作用域范围时，这个值将被丢弃</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>基本类型的赋值都是深拷贝，在栈上占用新空间,因为它们拥有<code>Copy</code>特性</p><h3 id="堆上的数据"><a href="#堆上的数据" class="headerlink" title="堆上的数据"></a>堆上的数据</h3><p>堆上的数据要想不发生所有权转移，就需要深拷贝，需要调用<code>clone</code>特性</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>不可变引用<code>&amp;T</code>含有<code>Copy</code>特性</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>可变引用同一作用域只能存在一个</li><li>可变引用与不可变引用不能同时存在</li><li>引用的作用域为最后一次使用的位置</li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>,<span class="hljs-number">65.4</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>:(<span class="hljs-type">i32</span>,<span class="hljs-type">f64</span>,<span class="hljs-type">u8</span>)=(<span class="hljs-number">500</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">five_hundred</span>=x.<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li>结构体不支持结构体内部某个字段标记为可变，只能结构体的实例可以标记为可变</li><li>结构体必须有名称</li><li>在模块中，结构体本身设置为pub,字段不指明仍为私有，不可见</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><h4 id="标准的做法"><a href="#标准的做法" class="headerlink" title="标准的做法"></a>标准的做法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user1</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>active: <span class="hljs-literal">true</span>,<br>sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="从现有的实例进行部分赋值，其余重新赋值："><a href="#从现有的实例进行部分赋值，其余重新赋值：" class="headerlink" title="从现有的实例进行部分赋值，其余重新赋值："></a>从现有的实例进行部分赋值，其余重新赋值：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>..user1<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>..user1</code>必须在结构体的尾部使用</li><li>这个user1某些字段可能发生所有权转移，导致user1无法使用，但是其他字段可以继续使用访问</li></ul><h3 id="构建函数"><a href="#构建函数" class="headerlink" title="构建函数"></a>构建函数</h3><ul><li>当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h3><ul><li>结构体必须要有名称，但是字段可以没名称,字段没名称的称为元组结构体</li><li>可以像元组一样通过<code>.x</code>来访问各个字段<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span>=<span class="hljs-title function_ invoke__">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="引用类型的字段"><a href="#引用类型的字段" class="headerlink" title="引用类型的字段"></a>引用类型的字段</h3><ul><li>结构体的字段借用其他数据，必须注明生命周期</li></ul><h3 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a>单元结构体</h3><ul><li>没有字段和属性，只关心行为的结构体<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlwaysEqual</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">subject</span> = AlwaysEqual;<br><br><span class="hljs-comment">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SomeTrait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AlwaysEqual</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="结构体的输出"><a href="#结构体的输出" class="headerlink" title="结构体的输出"></a>结构体的输出</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">scale</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: dbg!(<span class="hljs-number">30</span> * scale),<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    dbg!(&amp;rect1);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,rect1)<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,rect1)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>任何类型的数据都可以放入枚举成员中</li><li>枚举也可以通过<code>impl</code>定义自己的函数</li><li>枚举在模块中，若枚举本身pub,则所有类型都可见，这点与结构体不同<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">enum Message &#123;<br>    Quit,<br>    Move &#123; x: i32, y: i32 &#125;,<br>    Write(String),<br>    ChangeColor(i32, i32, i32),<br>&#125;<br><br>fn <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">let</span> m1 = Message::Quit;<br>    <span class="hljs-built_in">let</span> m2 = Message::Move&#123;x:1,y:1&#125;;<br>    <span class="hljs-built_in">let</span> m3 = Message::ChangeColor(255,255,0);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>可以直接赋值，自动推断类型与数组长度</li><li>完整定义<ul><li><code>let a: [类型;长度]=...</code></li><li><code>let b = [初始化值;长度]</code></li></ul></li><li>数组切片类型为<code>&amp;[类型]</code>，数组本身类型为<code>[类型;长度]</code></li><li>遍历<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//不变引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;container&#123;...&#125;<br><span class="hljs-comment">//可变引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> container&#123;...&#125;<br><span class="hljs-comment">//获取元素的索引</span><br><span class="hljs-keyword">for</span> (i,v) <span class="hljs-keyword">in</span> array.iter.<span class="hljs-title function_ invoke__">enumerate</span>()&#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>,i+<span class="hljs-number">1</span>,v);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>由于数组本身类型包含长度，所以泛型需要使用const泛型(一般直接使用数组切片即可，不需要这么烦):<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_array</span>&lt;T: std::fmt::<span class="hljs-built_in">Debug</span>, <span class="hljs-keyword">const</span> N: <span class="hljs-type">usize</span>&gt;(arr: [T; N]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br>&#125;<br></code></pre></td></tr></table></figure>其中N就是泛型，usize表示它基于值类型usize</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="as转换"><a href="#as转换" class="headerlink" title="as转换"></a>as转换</h3><ul><li>as转换不具有传递性，<code>e as U1 as U2</code>合法，但是<code>e as U2</code>可能不合法</li><li>只能用在数值类型或字符</li><li>常用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">3.1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">i8</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">100_i8</span> <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> =  <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br></code></pre></td></tr></table></figure></li><li>内存地址与指针的转换<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">values</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span>: *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span> = values.<span class="hljs-title function_ invoke__">as_mut_ptr</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">first_address</span> = p1 <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>; <span class="hljs-comment">// 将p1内存地址转换为一个整数</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">second_address</span> = first_address + <span class="hljs-number">4</span>; <span class="hljs-comment">// 4 == std::mem::size_of::&lt;i32&gt;()，i32类型占用4个字节，因此将内存地址 + 4</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = second_address <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>; <span class="hljs-comment">// 访问该地址指向的下一个整数p2</span><br><span class="hljs-keyword">unsafe</span> &#123;<br>    *p2 += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">assert_eq!</span>(values[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="TryInto"><a href="#TryInto" class="headerlink" title="TryInto"></a>TryInto</h3><ul><li>TryInto相较于as提供了错误捕获</li><li>只能用在数值类型或字符<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: <span class="hljs-type">i16</span> = <span class="hljs-number">1500</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b_</span>: <span class="hljs-type">u8</span> = <span class="hljs-keyword">match</span> b.<span class="hljs-title function_ invoke__">try_into</span>() &#123;<br><span class="hljs-title function_ invoke__">Ok</span>(b1) =&gt; b1,<br><span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, e.<span class="hljs-title function_ invoke__">to_string</span>());<br><span class="hljs-number">0</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>rust可能进行隐式强制转换，但这不适用于特征，如T可以强制转换U,不代表impl T可以强制转换为impl U,但方法可以</li></ul><h4 id="点操作符"><a href="#点操作符" class="headerlink" title="点操作符"></a>点操作符</h4><ul><li>rust可能在点操作时，自动进行类型转换</li><li>假设类型有个T,T有个方法foo,它有接收器(self、&amp;self、&amp;mut self)，当使用T的一个实例value,进行value.foo()操作时，rust会按照以下优先级匹配:<ol><li>首先，编译器检查他是否可以直接调用T::foo(value),称为值方法调用</li><li>编译器会尝试<code>&lt;&amp;T&gt;::foo(value)</code>和<code>&lt;&amp;mut T&gt;::foo(value)</code>,称为引用方法调用</li><li>编译器尝试解引用,这里使用Deref特征,若<code>T:Deref&lt;Target = U&gt;</code>(T可以被解引用为U)，则会使用U类型进行尝试</li><li>若还不行，且T是个定长类型，编译器将会转为不定长类型，如<code>[i32;2]</code>转为<code>[i32]</code></li></ol></li></ul><h3 id="使用std-mem-transmute"><a href="#使用std-mem-transmute" class="headerlink" title="使用std::mem::transmute"></a>使用std::mem::transmute</h3><p>见标准库那博文</p><h3 id="枚举与整数的转换"><a href="#枚举与整数的转换" class="headerlink" title="枚举与整数的转换"></a>枚举与整数的转换</h3><p>直接例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::convert::TryFrom;<br><span class="hljs-keyword">use</span> std::convert::TryInto;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span> &#123;<br>    A = <span class="hljs-number">1</span>,<br>    B,<br>    C,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TryFrom</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyEnum</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Error</span> = ();<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_from</span>(v: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::Error&gt; &#123;<br>        <span class="hljs-keyword">match</span> v &#123;<br>            x <span class="hljs-keyword">if</span> x == MyEnum::A <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> =&gt; <span class="hljs-title function_ invoke__">Ok</span>(MyEnum::A),<br>            x <span class="hljs-keyword">if</span> x == MyEnum::B <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> =&gt; <span class="hljs-title function_ invoke__">Ok</span>(MyEnum::B),<br>            x <span class="hljs-keyword">if</span> x == MyEnum::C <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> =&gt; <span class="hljs-title function_ invoke__">Ok</span>(MyEnum::C),<br>            _ =&gt; <span class="hljs-title function_ invoke__">Err</span>(()),<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = MyEnum::C <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">match</span> x.<span class="hljs-title function_ invoke__">try_into</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(MyEnum::A) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Ok</span>(MyEnum::B) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Ok</span>(MyEnum::C) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;c&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-built_in">eprintln!</span>(<span class="hljs-string">&quot;unknown number&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型别名-type"><a href="#类型别名-type" class="headerlink" title="类型别名-type"></a>类型别名-type</h2><p>类型别名不是一个独立的全新类型，而是一个类型的别名，可以用来简化。<br><code>type Thunk = Box&lt;dyn Fn() + Send + &#39;static&gt;;</code></p><h2 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h2><ul><li>数字字面量可插入下划线提高可读性：<code>const MAX_POINTS: u32 = 100_000;</code></li><li>数字字面量也可以用下划线表面类型：<code>let a=23_u32</code></li><li>获得类型的大小:std::mem::size_of_val(&amp;x)</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust学习——Cargo</title>
    <link href="/2022/04/09/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Cargo/"/>
    <url>/2022/04/09/rust%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Cargo/</url>
    
    <content type="html"><![CDATA[<h2 id="Package-项目-、Crate-包-和Module-模块"><a href="#Package-项目-、Crate-包-和Module-模块" class="headerlink" title="Package(项目)、Crate(包)和Module(模块)"></a>Package(项目)、Crate(包)和Module(模块)</h2><ul><li>Package项目:包含独立的Cargo.toml文件，包含多个包，但只能包含一个库类型的包，可以包含多个二进制可执行类型的包</li><li>Crate包:是个独立的可编译单元，编译后会生成一个可执行文件或一个库,是一个模块树</li></ul><h3 id="cargo-new到底干了啥"><a href="#cargo-new到底干了啥" class="headerlink" title="cargo new到底干了啥"></a>cargo new到底干了啥</h3><ul><li>不加任何选项，cargo为我们创建了一个名称是<code>my-project</code>的package,同时创建了Cargo.toml,虽然该文件没有提到<code>src/main.rs</code>为程序的入口，但Cargo有个惯例:<strong>src&#x2F;main.rs是二进制包的根文件，该二进制包的包名跟所属Package相同，这里都是my-project</strong>,所有代码执行都从该文件中的main函数开始</li><li>与<code>src/main.rs</code>一样，如果一个Package包含src&#x2F;lib.rs,意味这包含一个库类型的同名包，该包的根文件为<code>src/lib.rs</code></li></ul><h3 id="rust工程项目结构"><a href="#rust工程项目结构" class="headerlink" title="rust工程项目结构"></a>rust工程项目结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<br>├── Cargo.lock<br>├── Cargo.toml<br>├── src/<br>│   ├── lib.rs<br>│   ├── main.rs<br>│   └── bin/<br>│       ├── named-executable.rs<br>│       ├── another-executable.rs<br>│       └── multi-file-executable/<br>│           ├── main.rs<br>│           └── some_module.rs<br>├── benches/<br>│   ├── large-input.rs<br>│   └── multi-file-bench/<br>│       ├── main.rs<br>│       └── bench_module.rs<br>├── examples/<br>│   ├── simple.rs<br>│   └── multi-file-example/<br>│       ├── main.rs<br>│       └── ex_module.rs<br>└── tests/<br>    ├── some-integration-tests.rs<br>    └── multi-file-test/<br>        ├── main.rs<br>        └── test_module.rs<br></code></pre></td></tr></table></figure><ul><li>唯一库包：<code>src/lib.rs</code></li><li>默认二进制包：<code>src/main.rs</code>，编译后生成的可执行文件与Package同名</li><li>其余二进制包：<code>src/bin/main1.rs...</code>它们会生成与文件同名的二进制可执行文件</li><li>集成测试文件：tests目录</li><li>基准性能测试文件:benches目录</li><li>项目示例：examples目录</li></ul><h3 id="包根crate-root"><a href="#包根crate-root" class="headerlink" title="包根crate root"></a>包根crate root</h3><p>src&#x2F;main.rs和src&#x2F;lib.rs被成为包根，这是由于两个文件的内容形成了一个模块<strong>crate</strong>，假设lib.rs的内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    <span class="hljs-comment">// 绝对路径</span><br>    crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br><br>    <span class="hljs-comment">// 相对路径</span><br>    front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>则模块树则如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">crate<br> └── eat_at_restaurant<br> └── front_of_house<br>     ├── hosting<br>     │   ├── add_to_waitlist<br>     │   └── seat_at_table<br>     └── serving<br>         ├── take_order<br>         ├── serve_order<br>         └── take_payment<br></code></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>父模块完全无法访问子模块的私有项，但是子模块却可以访问父模块，爷爷。。。的模块私有项</li><li>绝对路径，从包根开始以crate(<code>/</code>)为开头</li><li>相对路径，从当前模块开始以self(<code>.</code>),super(<code>..</code>),或当前模块标识符开头</li></ul><h3 id="模块与文件分离"><a href="#模块与文件分离" class="headerlink" title="模块与文件分离"></a>模块与文件分离</h3><p>src&#x2F;lib.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    <span class="hljs-comment">// 绝对路径</span><br>    crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br><br>    <span class="hljs-comment">// 相对路径</span><br>    front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>与下面其实等价：<br>src&#x2F;front_of_house.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting&#123;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>src&#x2F;lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><code>mod front_of_house</code>把该文件中模块内容加载进来，我们可以认为模块front_of_house的定义还在src&#x2F;lib.rs,只不过具体内容在src&#x2F;front_of_house.rs</p><h3 id="模块可见性"><a href="#模块可见性" class="headerlink" title="模块可见性"></a>模块可见性</h3><ul><li><code>pub</code>可见性无限制</li><li><code>pub(crate)</code>表示在当前包可见</li><li><code>pub(self)</code>在当前模块可见</li><li><code>pub(super)</code>在父模块可见</li><li><code>pub(in &lt;path&gt;)</code>表示在某个路径代表的模块中可见，其中path必须是父模块或祖先模块</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>创建项目:<code>cargo new &lt;项目名&gt;</code></li><li>编译并运行项目：<code>cargo run</code></li><li>编译项目：<code>cargo build</code></li><li>检查项目是否编译通过:<code>cargo check</code></li></ul><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><ul><li>–release:编译优化，可能增加编译时间</li></ul><h2 id="Cargo-toml"><a href="#Cargo-toml" class="headerlink" title="Cargo.toml"></a>Cargo.toml</h2><ul><li>作用：是项目数据描述文件。存储了项目的所有元配置信息。</li></ul><h3 id="package"><a href="#package" class="headerlink" title="[package]"></a>[package]</h3><p>|关键字|作用|例子|<br>|name|项目名|<code>name = &quot;world_hello&quot;</code>|<br>|version|项目版本|<code>version = &quot;0.1.0&quot;</code>|<br>|edition|rust大版本|<code>edition = &quot;2021&quot;</code>|</p><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="[dependencies]"></a>[dependencies]</h3><ul><li>主要有三种依赖：<ol><li>基于Rust官方仓库<code>crates.io</code>,通过版本来说明：<code>rand = &quot;0.3&quot;</code>或<code>hammer = &#123; version = &quot;0.5.0&quot; &#125;</code></li><li>基于项目源代码的git仓库地址，通过url：<code>color = &#123; git = &quot;https://github.com/bjz/color-rs&quot; &#125;</code></li><li>基于本项目的绝对路径或相对路径：<code>geometry = &#123; path = &quot;crates/geometry&quot; &#125;</code></li></ol></li></ul><h3 id="source-更换镜像"><a href="#source-更换镜像" class="headerlink" title="[source]更换镜像"></a>[source]更换镜像</h3><ul><li>更改中科大<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[source.crates-io]<br>replace-with = <span class="hljs-string">&#x27;ustc&#x27;</span><br><br>[source.ustc]<br>registry = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="Cargo-lock"><a href="#Cargo-lock" class="headerlink" title="Cargo.lock"></a>Cargo.lock</h2><ul><li>功能作用：根据toml文件生成的项目依赖详细清单,锁住构建时的版本信息</li><li>该不该上传git：一个可运行项目就上传，一个依赖库则添加到<code>.gitignore</code></li></ul><h2 id="cargo命令"><a href="#cargo命令" class="headerlink" title="cargo命令"></a>cargo命令</h2><h3 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h3><ul><li>更新所有依赖:<code>cargo update</code></li><li>只更新<code>regex</code>:<code>cargo update-p regex</code></li></ul><h3 id="测试cargo-test"><a href="#测试cargo-test" class="headerlink" title="测试cargo test"></a>测试<code>cargo test</code></h3><ul><li>功能：他会在<code>src/</code>底下寻找单元测试，也会在<code>tests/</code>目录下寻找集成测试,同时还会编译<code>examples/</code>下的示例文件，以及文档中的示例</li></ul><h2 id="cargo缓存"><a href="#cargo缓存" class="headerlink" title="cargo缓存"></a>cargo缓存</h2><ul><li>构建时，cargo会将已下载的依赖放在<code>CARGO_HOME</code>目录下，默认是<code>$HOME/.cargo/</code></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>config.toml:全局配置文件</li><li>credentials.toml:提供私有化登陆证书，用于package注册中心，例如crates.io</li><li>.crates.toml,.crates2.json:包含了cargo install安装包的package信息</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>bin:包含了通过cargo install或rustup下载的包编译出的可执行文件。</li><li>git存储了<code>Git</code>的资源文件<ul><li>git&#x2F;db:当一个包依赖某个git仓库时，Cargo会将该仓库克隆到git&#x2F;db目录下，如果未来需要还会对其进行更新</li><li>git&#x2F;checkouts:若指定了git源和commit，那相应的仓库就会从git&#x2F;db中checkout到该目录下，因此同一个仓库的不同checkout共存成为了可能性</li></ul></li><li>registry:包含了注册中心（如crates.io）的元数据和packages<ul><li>registry&#x2F;index:一个git仓库，包含了注册中心的所有可用包的元数据（版本、依赖等）</li><li>registry&#x2F;cache:保存了已下载的依赖，以gzip的压缩格式，后缀名<code>.crate</code></li><li>registry&#x2F;src:若一个已下载的<code>.crate</code>档案被一个package所需要，该档案会被解压到<code>registry/src</code>文件夹下，最终rustc在其中找到所需要的.rs文件</li></ul></li></ul><h3 id="ci的考虑"><a href="#ci的考虑" class="headerlink" title="ci的考虑"></a>ci的考虑</h3><p>应该保留缓存下列目录：</p><ul><li>bin</li><li>registry&#x2F;index</li><li>registry&#x2F;cache</li><li>git&#x2F;db</li></ul><h2 id="构建缓存-target目录"><a href="#构建缓存-target目录" class="headerlink" title="构建缓存-target目录"></a>构建缓存-target目录</h2><ul><li>target目录结构取决于是否使用–target标志为特定的平台构建，不使用则使用宿主机架构</li><li>target下的每个子目录包含了相应的发布配置profile的构建结果，release和debug是自带的profile，见下表</li></ul><table><thead><tr><th align="center">目录</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">target&#x2F;debug&#x2F;</td><td align="center">包含了 dev profile 的构建输出(cargo build 或 cargo build –debug)</td></tr><tr><td align="center">target&#x2F;release&#x2F;</td><td align="center">release profile 的构建输出，cargo build –release</td></tr><tr><td align="center">target&#x2F;foo&#x2F;</td><td align="center">自定义 foo profile 的构建输出，cargo build –profile&#x3D;foo</td></tr></tbody></table><p>出于历史原因：</p><ul><li>dev和test profile的构建结果都放在debug下</li><li>release和bench profile则放在release目录下</li></ul><h3 id="常见目录说明"><a href="#常见目录说明" class="headerlink" title="常见目录说明"></a>常见目录说明</h3><table><thead><tr><th align="center">目录</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">target&#x2F;debug&#x2F;</td><td align="center">包含编译后的输出，例如二进制可执行文件、库对象</td></tr><tr><td align="center">target&#x2F;debug&#x2F;examples&#x2F;</td><td align="center">包含示例对象</td></tr><tr><td align="center">target&#x2F;doc&#x2F;</td><td align="center">包含cargo doc生成的文档</td></tr><tr><td align="center">target&#x2F;package&#x2F;</td><td align="center">cargo package或cargo publish生成的输出</td></tr><tr><td align="center">target&#x2F;debug&#x2F;deps</td><td align="center">依赖和其他输出成果</td></tr><tr><td align="center">target&#x2F;debug&#x2F;incremental</td><td align="center">rustc增量编译的输出，该缓存可以用于提升后续的编译速度</td></tr><tr><td align="center">target&#x2F;debug&#x2F;build&#x2F;</td><td align="center">构建脚本的输出</td></tr></tbody></table><h3 id="依赖信息文件"><a href="#依赖信息文件" class="headerlink" title="依赖信息文件"></a>依赖信息文件</h3><p>每个编译成果旁边有个依赖信息文件，文件后缀是<code>.d</code>。类似Makefile</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile</title>
    <link href="/2022/04/04/Dockerfile/"/>
    <url>/2022/04/04/Dockerfile/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dockerfile是一个文本文件，其内包含了一条条指令，<strong>每条指令构建一层</strong></p><ul><li><code>#</code>进行注释</li><li><code>\</code>末尾进行换行，RUN执行多条命令十分有用</li></ul><h2 id="docker-build–构建镜像"><a href="#docker-build–构建镜像" class="headerlink" title="docker build–构建镜像"></a>docker build–构建镜像</h2><ul><li><strong>格式：</strong><code>docker build [选项] [上下文路径/URL/-]</code></li></ul><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-t [reposity:tag]</td><td align="center">指明镜像名称和tag</td></tr><tr><td align="center">-f [dockerfile]</td><td align="center">指定dockerfile，非主流，默认文件名为<code>Dockerfile</code>，且位于上下文路径中</td></tr><tr><td align="center">–target &lt;some img&gt;</td><td align="center">多阶段构建时，指定只构建某个镜像，而不是默认的最后一个</td></tr></tbody></table><h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><ul><li>docker build命令其实是与服务器（即docker.service）通信，它会将上下文路径下的所有内容上传，而不是在本地进行构建的</li><li>支持<code>.dockerignore</code>文件，剔除不需要的内容</li></ul><h3 id="其他构建法"><a href="#其他构建法" class="headerlink" title="其他构建法"></a>其他构建法</h3><ul><li>Git repo:<code>docker build -t hello-world https://github.com/docker-library/hello-world.git</code></li><li>tar包:<code>docker build http://server/context.tar.gz</code></li><li>标准输入：<code>docker build - &lt; Dockerfile</code>或<code>cat Dockerfile| docker build -</code>(直接从标准输入读取，没有上下文，不可用依赖上下文的命令COPY等等)</li><li>标准输入+tar包：<code>docker build - &lt; context.tar.gz</code>会自动解压，将里面视为上下文</li></ul><h2 id="docker-import-从rootfs压缩包导入-无需Dockerfile"><a href="#docker-import-从rootfs压缩包导入-无需Dockerfile" class="headerlink" title="docker import-从rootfs压缩包导入(无需Dockerfile)"></a>docker import-从rootfs压缩包导入(无需Dockerfile)</h2><ul><li><strong>格式：</strong><code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></li><li><strong>例子：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker import \<br>    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \<br>    openvz/ubuntu:16.04<br></code></pre></td></tr></table></figure></li></ul><h2 id="docker-save和docker-load"><a href="#docker-save和docker-load" class="headerlink" title="docker save和docker load"></a>docker save和docker load</h2><p>是一种古老的保存和加载镜像的方法，已经非主流，实在没网，使用内网私有的Registry</p><h3 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h3><ul><li>本质上是建立归档文件:<code>docker save [some image] -o [some file]</code></li><li>使用压缩：<code>docker save [some image] | gzip &gt; xx.tar.gz</code></li></ul><h3 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h3><p><code>docker load -i some_file.tar.gz</code></p><h2 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h2><ul><li><strong>格式：</strong><code>FROM [image]</code></li><li>FROM是必备的指令，且必须是第一条</li><li>如果你想以空白镜像为基础，你可以这样<code>FROM scratch</code></li><li>尽量小尺寸（推荐Alpine）</li></ul><h2 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h2><ul><li><strong>格式：</strong><code>RUN [command]</code></li><li>执行多条命令：使用<code>\</code>和<code>&amp;&amp;</code>，如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">RUN apt-get update \<br>&amp;&amp; apt-get install vim<br></code></pre></td></tr></table></figure></li><li>永远不要<code>apt upgrade</code>，而是使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">RUN apt-get update &amp;&amp; apt-get install -y \<br>    aufs-tools \<br>    s3cmd=1.1.* \<br> &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*<br></code></pre></td></tr></table></figure></li></ul><h2 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h2><ul><li><strong>格式：</strong><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><strong>作用：</strong>将从构建上下文目录中的路径复制的新的一层的镜像内的目标路径的位置，支持通配符，如果目录不存在会创建缺失的目录</li><li>如果源路径为文件夹，复制的时候不是复制该文件夹，而是将文件夹中的内容复制到目标路径</li><li><code>--from=[some]</code>:多阶段构建时，指定从某个镜像获取，而不是当前上下文</li><li>不要一次copy多个文件，这会使一层的缓存过大</li></ul><h2 id="ADD更高级的复制文件"><a href="#ADD更高级的复制文件" class="headerlink" title="ADD更高级的复制文件"></a>ADD更高级的复制文件</h2><ul><li><strong>说明：</strong>和COPY格式和性质基本一致,但是功能更多(不代表更好，只有自动解压缩时，使用该命令)：</li></ul><ol><li>源路径可以是以个URL,文件权限自动设置为600,更改权限需要再加一层调整,另外如果下载是个压缩包，需要再加一层解压缩</li><li>如果源路径是个tar压缩文件(gzip,bzip2,xz)，会自动解压缩文件</li></ol><h2 id="CMD容器启动命令"><a href="#CMD容器启动命令" class="headerlink" title="CMD容器启动命令"></a>CMD容器启动命令</h2><ul><li><strong>格式1：</strong><code>CMD [&quot;可执行文件&quot;，&quot;参数1&quot;，&quot;参数2&quot;...]</code>(推荐使用这个，也支持bash格式，但会包装一层<code>sh -c</code>)</li><li><strong>格式2：</strong><code>CMD [&quot;参数1&quot;,&quot;参数2&quot;]</code>,在指定了<code>ENTRYPOINT</code>后，可以直接指定参数</li><li><strong>作用：</strong>容器就是进程，该命令就是指定容器所运行默认的程序及参数,例如ubuntu的CMD就是<code>/bin/bash</code>,当然可以在命令行中用其他命令替换。</li><li><strong>注意：</strong></li></ul><ol><li>启动程序就是容器的应用进程，容器就是为了主进程存在的，主进程退出，容器就会退出，辅助进程不是它所关心的。所以必须是前台进程，例如<code>CMD service nginx start</code>被理解为<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;service nginx start&quot;]</code>,因此当sh进程结束，它就会结束。当然即使你用格式1清楚指明service为可执行程序也是不行的，正确做法是指明前台形式运行： <code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></li><li>整个Dockerfile应该只出现一次该命令</li></ol><h2 id="ENTRYPOINT入口点"><a href="#ENTRYPOINT入口点" class="headerlink" title="ENTRYPOINT入口点"></a>ENTRYPOINT入口点</h2><p><strong>说明：</strong>该命令和CMD一样，都是指定容器启动程序及参数，不过有下面几点需要注意：</p><ol><li>在运行时也可以替代，不过要加个<code>--entrypoint</code>指定</li><li>当指定了<code>ENTRYPOINT</code>后，CMD的内容将作为参数传给<code>ENTRYPOINT</code></li><li>整个Dockerfile应该只出现一次该命令<br><strong>应用场景：</strong></li><li>让镜像变成像命令一样使用:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM ubuntu:18.04<br>RUN apt-get update \<br>    &amp;&amp; apt-get install -y curl \<br>    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*<br>CMD [ <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;http://myip.ipip.net&quot;</span> ]<br></code></pre></td></tr></table></figure>如果我们希望显示http头信息，需要加上-i参数,<code>docker run myip -i</code>是行不通的，而必须用<code>$ docker run myip curl -s http://myip.ipip.net -i</code>，显然很繁琐，如果把上面内容的CMD改成ENTRYPOINT，就可以使用<code>docker run myip -i</code>，此时CMD的内容是<code>-i</code></li><li>应用运行前的准备工作。</li></ol><h2 id="ENV设置环境变量-容器运行时，这些环境变量保持有效"><a href="#ENV设置环境变量-容器运行时，这些环境变量保持有效" class="headerlink" title="ENV设置环境变量(容器运行时，这些环境变量保持有效)"></a>ENV设置环境变量(容器运行时，这些环境变量保持有效)</h2><ul><li><strong>格式：</strong><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li>如果key或value有空格，用<code>&quot;</code>括起来,可以用<code>\</code>换行</li><li>下列指令可以支持环境变量展开：<code>ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。</code></li></ul><h2 id="ARG构建参数-容器运行时，这些参数无效"><a href="#ARG构建参数-容器运行时，这些参数无效" class="headerlink" title="ARG构建参数(容器运行时，这些参数无效)"></a>ARG构建参数(容器运行时，这些参数无效)</h2><ul><li><strong>格式：</strong><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li><li><strong>说明：</strong>定义参数名称及其默认值，该默认值可以在构建命令中用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖</li><li>ARG指令有生效范围，如果在FROM指令之前指定，那么只能用于每个FROM指令中。多阶段中使用这些变量必须在每个阶段分别指定</li></ul><h2 id="VOLUME定义匿名卷"><a href="#VOLUME定义匿名卷" class="headerlink" title="VOLUME定义匿名卷"></a>VOLUME定义匿名卷</h2><ul><li><strong>格式：</strong><code>VOLUME [&quot;&lt;路径1&gt;&quot;,&quot;&lt;路径2&gt;&quot;...]</code></li><li><strong>说明：</strong>路径1等目录会在容器运行时默认自动挂载为匿名卷，任何向指定路径中写入的信息都不会记录进容器存储层。</li><li>运行容器时可以覆盖这个挂载配置<code>$ docker run -d -v mydata:/data xxxx</code>，这里就用了mydata这个命名卷挂载到了&#x2F;data这个位置，替代了Dockerfile中定义的匿名卷挂载配置</li></ul><h2 id="EXPOSE声明端口"><a href="#EXPOSE声明端口" class="headerlink" title="EXPOSE声明端口"></a>EXPOSE声明端口</h2><ul><li><strong>格式：</strong><code>EXPOSE &lt;端口1&gt; &lt;端口2&gt; ...</code></li><li><strong>作用：</strong>这只是个声明，并不会开启这个端口的服务，主要帮助镜像使用者理解这个镜像服务的守护端口，方便映射，另外-P选项，会自动随机映射EXPOSE的端口，要想映射端口请使用-p选项</li></ul><h2 id="WORKDIR指定工作目录"><a href="#WORKDIR指定工作目录" class="headerlink" title="WORKDIR指定工作目录"></a>WORKDIR指定工作目录</h2><ul><li><strong>格式：</strong><code>WORKDIR &lt;工作目录路径&gt;</code></li><li><strong>作用：</strong>指定当前目录，以后各层的当前目录就改为指定目录，如果目录不存在，会自动建立，若指定相对路径，则是在之前工作目录的基础上的。</li><li><strong>注意：</strong>单独一层cd不会影响之后的一层，因为一层一层是独立的，应该用WORKDIR</li></ul><h2 id="USER指定当前用户"><a href="#USER指定当前用户" class="headerlink" title="USER指定当前用户"></a>USER指定当前用户</h2><ul><li><strong>格式：</strong><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></li><li><strong>作用：</strong>改变之后层的命令执行的身份，这个用户身份必须存在</li></ul><h2 id="HEALTHCHECK健康检查"><a href="#HEALTHCHECK健康检查" class="headerlink" title="HEALTHCHECK健康检查"></a>HEALTHCHECK健康检查</h2><ul><li><strong>格式1：</strong><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>设置检查容器健康状况的命令</li><li><strong>格式2：</strong><code>HEALTHCHECK NONE</code>如果基础镜像有健康检查指令，使用这个可以屏蔽其健康检查指令</li><li><strong>历史原因：</strong>在没有该命令之前，docker通过主进程是否退出来判断是否异常，这忽略了一种情形，如果程序进入死锁或死循环，就不会检查出错误</li><li><strong>功能作用：</strong>当一个镜像指定了HEALTHCHECK指令后，启动容器的初始状态会是starting,在HEALTHCHECK指令检查成功后变为healthy,如果连续一定次数失败，则为unhealthy,<strong>整个Dockerfile应该只出现一次该命令</strong></li><li><strong>选项：</strong></li></ul><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">–interval&#x3D;&lt;间隔&gt;</td><td align="center">两次健康检查的间隔，默认为30秒</td></tr><tr><td align="center">–timeout&#x3D;&lt;时长&gt;</td><td align="center">健康检查命令运行超时时间，默认为30秒</td></tr><tr><td align="center">–retries&#x3D;&lt;次数&gt;</td><td align="center">当连续失败指定次数后，则将认定为unhealthy，默认为3次</td></tr></tbody></table><h2 id="LABEL指令"><a href="#LABEL指令" class="headerlink" title="LABEL指令"></a>LABEL指令</h2><ul><li><strong>格式：</strong><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li><li><strong>作用：</strong>给镜像以键值对的形式添加些元数据，如镜像的作者、文档地址等<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">LABEL org.opencontainers.image.authors=<span class="hljs-string">&quot;yeasy&quot;</span><br>LABEL org.opencontainers.image.documentation=<span class="hljs-string">&quot;https://yeasy.gitbooks.io&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="SHELL指令"><a href="#SHELL指令" class="headerlink" title="SHELL指令"></a>SHELL指令</h2><ul><li><strong>格式：</strong><code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></li><li><strong>作用：</strong>指定RUN、ENTRYPOINT、CMD指令的shell,默认为<code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code>,其中ENTRYPOINT,CMD只有以shell格式指定时，才起作用</li></ul><h2 id="ONBUILD为他人做嫁衣"><a href="#ONBUILD为他人做嫁衣" class="headerlink" title="ONBUILD为他人做嫁衣"></a>ONBUILD为他人做嫁衣</h2><ul><li><strong>格式：</strong><code>ONBUILD &lt;其他指令&gt;</code></li><li><strong>作用：</strong>它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</li><li>这常常应用于基础镜像，例如npm包管理</li></ul><h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><ol><li>之前多阶段构建一种方式把所有东西放在一个Dockerfile中，但这会造成层次太多，镜像体积过大，部署时间变长，源代码存在泄露问题，如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM golang:alpine<br><br>RUN apk --no-cache add git ca-certificates<br><br>WORKDIR /go/src/github.com/go/helloworld/<br><br>COPY app.go .<br><br>RUN go get -d -v github.com/go-sql-driver/mysql \<br>  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \<br>  &amp;&amp; <span class="hljs-built_in">cp</span> /go/src/github.com/go/helloworld/app /root<br><br>WORKDIR /root/<br><br>CMD [<span class="hljs-string">&quot;./app&quot;</span>]<br></code></pre></td></tr></table></figure></li><li>第二种方式分散多个Dockerfile，然后再写脚本整合，虽然镜像体积较小，但过程较复杂：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 构建dockerfile--&gt;Dockerfile.build</span><br>FROM golang:alpine<br><br>RUN apk --no-cache add git<br><br>WORKDIR /go/src/github.com/go/helloworld<br><br>COPY app.go .<br><br>RUN go get -d -v github.com/go-sql-driver/mysql \<br>  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .<br><span class="hljs-comment"># 部署dockerfile--&gt;Dockerfile.copy</span><br>FROM alpine:latest<br><br>RUN apk --no-cache add ca-certificates<br><br>WORKDIR /root/<br><br>COPY app .<br><br>CMD [<span class="hljs-string">&quot;./app&quot;</span>]<br><span class="hljs-comment"># 整合脚本--&gt; build.sh</span><br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> Building go/helloworld:build<br><br>docker build -t go/helloworld:build . -f Dockerfile.build<br><br>docker create --name extract go/helloworld:build<br>docker <span class="hljs-built_in">cp</span> extract:/go/src/github.com/go/helloworld/app ./app<br>docker <span class="hljs-built_in">rm</span> -f extract<br><br><span class="hljs-built_in">echo</span> Building go/helloworld:2<br><br>docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy<br><span class="hljs-built_in">rm</span> ./app<br></code></pre></td></tr></table></figure></li><li>更加高效的方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM golang:alpine as builder<br><br>RUN apk --no-cache add git<br><br>WORKDIR /go/src/github.com/go/helloworld/<br><br>RUN go get -d -v github.com/go-sql-driver/mysql<br><br>COPY app.go .<br><br>RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .<br><br>FROM alpine:latest as prod<br><br>RUN apk --no-cache add ca-certificates<br><br>WORKDIR /root/<br><br><span class="hljs-comment"># 这里的0代表上个阶段的镜像,当然可以指定其他镜像如`--from=nginx:latest`</span><br>COPY --from=0 /go/src/github.com/go/helloworld/app .<br><br>CMD [<span class="hljs-string">&quot;./app&quot;</span>]<br></code></pre></td></tr></table></figure>可以只构建某个阶段的镜像<code>$ docker build --target builder -t username/imagename:tag .</code></li></ol><h2 id="docker-manifest–多系统架构支持"><a href="#docker-manifest–多系统架构支持" class="headerlink" title="docker manifest–多系统架构支持"></a>docker manifest–多系统架构支持</h2><ul><li><strong>背景：</strong>使用镜像创建一个容器，该镜像必须与Docker宿主机架构一致（Windows、macOS除外，在x86_64系统上，这两个系统可以运行arm等其他架构），为了支持多个架构，必须提供两个架构版本的镜像，manifest命令就是支持自动识别宿主机架构，然后拉取合适的镜像。</li></ul><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在两个架构上构建两个镜像</p><h3 id="创建manifest列表"><a href="#创建manifest列表" class="headerlink" title="创建manifest列表"></a>创建manifest列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># $ docker manifest create MANIFEST_LIST MANIFEST [MANIFEST...]</span><br>$ docker manifest create username/test \<br>      username/x8664-<span class="hljs-built_in">test</span> \<br>      username/arm64v8-<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>当需要修改时加个-a或–amend参数</p><h3 id="设置manifest列表"><a href="#设置manifest列表" class="headerlink" title="设置manifest列表"></a>设置manifest列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># $ docker manifest annotate [OPTIONS] MANIFEST_LIST MANIFEST</span><br>$ docker manifest annotate username/test \<br>      username/x8664-<span class="hljs-built_in">test</span> \<br>      --os linux --<span class="hljs-built_in">arch</span> x86_64<br><br>$ docker manifest annotate username/test \<br>      username/arm64v8-<span class="hljs-built_in">test</span> \<br>      --os linux --<span class="hljs-built_in">arch</span> arm64 --variant v8<br></code></pre></td></tr></table></figure><h3 id="查看manifest支持列表"><a href="#查看manifest支持列表" class="headerlink" title="查看manifest支持列表"></a>查看manifest支持列表</h3><p><code>docker manifest inspect username/test</code></p><h3 id="推送manifest列表"><a href="#推送manifest列表" class="headerlink" title="推送manifest列表"></a>推送manifest列表</h3><p><code>docker manifest push username/test</code></p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>如果想以root临时执行一个命令，不要使用su、sudo,而是使用gosu,见如下例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis<br><span class="hljs-comment"># 下载 gosu</span><br>RUN wget -O /usr/local/bin/gosu <span class="hljs-string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \<br>    &amp;&amp; <span class="hljs-built_in">chmod</span> +x /usr/local/bin/gosu \<br>    &amp;&amp; gosu nobody <span class="hljs-literal">true</span><br><span class="hljs-comment"># 设置 CMD，并以另外的用户执行</span><br>CMD [ <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;gosu&quot;</span>, <span class="hljs-string">&quot;redis&quot;</span>, <span class="hljs-string">&quot;redis-server&quot;</span> ]<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2022/04/04/docker/"/>
    <url>/2022/04/04/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="各个文件位置"><a href="#各个文件位置" class="headerlink" title="各个文件位置"></a>各个文件位置</h2><ul><li>本地资源的默认总目录：<code>/var/lib/docker/</code>,<strong>迁移</strong>docker就是复制该文件夹，<strong>重置</strong>就是删除该文件夹</li><li>容器信息：<code>containers</code></li><li>镜像信息：<code>image</code></li><li>镜像层文件：<code>overlay2</code></li></ul><h3 id="修改文件位置"><a href="#修改文件位置" class="headerlink" title="修改文件位置"></a>修改文件位置</h3><ul><li>方式1：为默认位置建立软链接</li><li>方式2：daemon启动时指定-g选项</li><li>方式3：修改&#x2F;etc&#x2F;docker&#x2F;daemon.json的”data-root”项</li></ul><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><ul><li>查看是否在docker.service文件中配置过镜像地址：<code>$ systemctl cat docker | grep &#39;\-\-registry\-mirror&#39;</code></li><li>上一步如果出现输出内容，修改文件去掉内容<code>--registry-mirror</code>，按接下来步骤配置</li><li>在&#x2F;etc&#x2F;docker&#x2F;daemon.json中写入下面内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>重启服务：<code>sudo systemctl daemon-reload;sudo systemctl restart docker</code></li><li>检查是否生效：<code>docker info</code></li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><ul><li>格式:<code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></li><li>默认地址是<code>docker.io</code>,仓库名默认为<code>library</code>,即官方镜像，标签默认是<code>latest</code></li><li>简化版：<code>docker pull ubuntu</code></li></ul><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><ul><li>一般命令：<code>docker image ls</code></li></ul><table><thead><tr><th align="center">选项</th><th align="center">含义</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示包括中间层镜像在内的所有镜像</td><td align="center"></td></tr><tr><td align="center">-f&#x2F;–fliter</td><td align="center">过滤参数,见下</td><td align="center"></td></tr><tr><td align="center">–format</td><td align="center">自定义格式，见</td><td align="center"><code>docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</code></td></tr></tbody></table><h4 id="f选项"><a href="#f选项" class="headerlink" title="-f选项"></a>-f选项</h4><ul><li>since&#x2F;before: <code>docker image ls -f since=mongo:3.2</code>,列出mongo:3.2之后建立的镜像</li><li>label: <code>docker image ls -f label=com.example.version=0.1</code></li></ul><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="&lt;none&gt;虚悬镜像"></a><code>&lt;none&gt;</code>虚悬镜像</h4><ul><li>原因：docker pull或docker build导致镜像名被转移到最新版</li><li>只列出虚悬镜像：<code>docker image ls -f dangling=true</code></li><li>删除虚悬镜像：<code>docker image prune</code></li></ul><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><ul><li>格式：<code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code>,镜像可以是长&#x2F;短id,镜像名或镜像摘要</li></ul><h4 id="untagged和deleted"><a href="#untagged和deleted" class="headerlink" title="untagged和deleted"></a>untagged和deleted</h4><p>镜像对应多个tag,，只有所有tag都为untagged时，才真正删除，如果一个容器依赖一个镜像，要先删除容器，才能再删除镜像</p><h3 id="docker-commit-添加一层形成新的镜像（慎用）"><a href="#docker-commit-添加一层形成新的镜像（慎用）" class="headerlink" title="docker commit-添加一层形成新的镜像（慎用）"></a>docker commit-添加一层形成新的镜像（慎用）</h3><ul><li>说明：该命令会使一个容器形成一个新的镜像,最好不要这样，而是使用Dockerfile</li><li>格式：<code>docker commit [选项] &lt;容器ID或容器名&gt; [仓库名:标签]</code></li></ul><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">–author</td><td align="center">说明作者</td></tr><tr><td align="center">–message</td><td align="center">添加说明信息</td></tr></tbody></table><h4 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h4><ul><li>说明：该命令用来查看某个镜像的提交历史</li><li>示例：<code>docker history [仓库名:标签]</code></li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器运行流程"><a href="#容器运行流程" class="headerlink" title="容器运行流程"></a>容器运行流程</h3><ol><li>检查本地是否存在指定的镜像，不存在就从registry下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个ip地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol><h3 id="运行容器docker-run"><a href="#运行容器docker-run" class="headerlink" title="运行容器docker run"></a>运行容器<code>docker run</code></h3><ul><li><strong>格式：</strong><code>docker run [OPTIONS] image</code></li></ul><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-c&#x2F;–cpu-shares</td><td align="center">调整容器使用cpu的权重</td></tr><tr><td align="center">-d</td><td align="center">后台运行，此时容器不会把输出的结果打印到宿主机上面，<code>docker container logs &lt;container id or name&gt;</code>可以查看结果</td></tr><tr><td align="center">–dns&#x3D;[ip_address]</td><td align="center">设置dns服务器</td></tr><tr><td align="center">–dns-search&#x3D;[DOMAIN]</td><td align="center">设定容器搜索域</td></tr><tr><td align="center">–env [VAR&#x3D;value]</td><td align="center">传递环境变量</td></tr><tr><td align="center">–env-file [file]</td><td align="center">从file中引入环境变量</td></tr><tr><td align="center">-h&#x2F;–hostname&#x3D;[HOSTNAME]</td><td align="center">设定容器主机名，比较鸡肋，只能在容器内部显示</td></tr><tr><td align="center">-i</td><td align="center">交互式操作,让容器的标准输入保持打开</td></tr><tr><td align="center">-m</td><td align="center">–memory[&#x3D;MEMORY]</td></tr><tr><td align="center">–mount</td><td align="center">挂载数据卷或主机目录</td></tr><tr><td align="center">–name [name]</td><td align="center">指定容器的名字</td></tr><tr><td align="center">–network [my-net]</td><td align="center">见连接容器</td></tr><tr><td align="center">-p</td><td align="center">见端口映射</td></tr><tr><td align="center">-P</td><td align="center">随机映射镜像的端口</td></tr><tr><td align="center">–rm</td><td align="center">容器退出后随之将其删除</td></tr><tr><td align="center">-t</td><td align="center">代表终端，让Docker分配一个伪终端并邦到标准输入</td></tr><tr><td align="center">-u&#x3D;[username]</td><td align="center">设置进程用户名</td></tr><tr><td align="center">-v [宿主机路径]:[容器路径]</td><td align="center">映射路径</td></tr><tr><td align="center">–volumes-from</td><td align="center">从别的容器中挂载卷</td></tr></tbody></table><h3 id="查看容器的信息–docker-container-ls"><a href="#查看容器的信息–docker-container-ls" class="headerlink" title="查看容器的信息–docker container ls"></a>查看容器的信息–docker container ls</h3><ul><li><strong>格式：</strong><code>docker container ls</code></li><li>-a:列出终止状态的容器</li></ul><h3 id="终止容器–docker-container-stop"><a href="#终止容器–docker-container-stop" class="headerlink" title="终止容器–docker container stop"></a>终止容器–docker container stop</h3><ul><li><strong>格式：</strong><code>docker container stop [container id or names]</code></li></ul><h3 id="启动已终止容器–docker-container-start"><a href="#启动已终止容器–docker-container-start" class="headerlink" title="启动已终止容器–docker container start"></a>启动已终止容器–docker container start</h3><ul><li><strong>格式：</strong><code>docker container start [container id or names]</code></li></ul><h3 id="重启容器–docker-container-restart"><a href="#重启容器–docker-container-restart" class="headerlink" title="重启容器–docker container restart"></a>重启容器–docker container restart</h3><ul><li><strong>格式：</strong><code>docker container restart [container id or names]</code></li></ul><h3 id="查看容器的日志–docker-container-logs"><a href="#查看容器的日志–docker-container-logs" class="headerlink" title="查看容器的日志–docker container logs"></a>查看容器的日志–docker container logs</h3><ul><li><strong>格式：</strong><code>docker container logs [container ID or NAMES]</code></li></ul><h3 id="进入后台运行的容器–docker-attach-exec"><a href="#进入后台运行的容器–docker-attach-exec" class="headerlink" title="进入后台运行的容器–docker attach&#x2F;exec"></a>进入后台运行的容器–docker attach&#x2F;exec</h3><ul><li>建议使用exec,使用attach,从stdin退出，会导致容器的停止，exec就没这个问题</li><li>attach格式：<code>docker attach [id or names]</code></li></ul><h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h4><ul><li><strong>格式：</strong><code>docker exec -it [id or names]</code></li><li>-it选项和docker run一样</li></ul><h3 id="导出、导入容器–docker-export-import"><a href="#导出、导入容器–docker-export-import" class="headerlink" title="导出、导入容器–docker export&#x2F;import"></a>导出、导入容器–docker export&#x2F;import</h3><ul><li>导出容器：<code>docker export [id] &gt; xx.tar</code></li><li>导入容器快照成镜像：<code>cat xx.tar | docker import - test/ubuntu:v1.0</code>,支持url:<code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></li><li>docker load和docker import:docker import会丢弃所有历史记录和元数据信息，docker load则会保留完整记录</li></ul><h3 id="删除容器–docker-container-rm"><a href="#删除容器–docker-container-rm" class="headerlink" title="删除容器–docker container rm"></a>删除容器–docker container rm</h3><ul><li><strong>格式：</strong><code>docker container rm [container id or names]</code></li><li>-f:删除一个运行中的容器</li></ul><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><ul><li>注册：在官网<a href="https://hub.docker.com免费注册一个docker帐号/">https://hub.docker.com免费注册一个Docker帐号</a></li><li>登录：<code>docker login</code>命令交互式输入用户名和密码</li><li>搜索：<code>docker search [关键字]</code>支持<code>--filter=stars=N</code>仅显示收藏数量N以上的镜像</li><li>拉取：见镜像拉取</li><li>推送：推送前先标记下<code>dockeer tag [image:tag] [username/xx:xx]</code>，<code>docker push username/xx:xx</code></li></ul><h3 id="私有仓库–-docker-registry"><a href="#私有仓库–-docker-registry" class="headerlink" title="私有仓库–&gt;docker-registry"></a>私有仓库–&gt;docker-registry</h3><ul><li>使用官方registry镜像：<code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></li><li>默认情况下仓库会在容器中的<code>/var/lib/registry</code>目录下,可以用-v选项映射</li><li>标记镜像<code>git tag</code>:<code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></li><li>推送：<code>docker push 127.0.0.1:5000/ubuntu:latest</code></li><li>拉取：<code>docker pull 127.0.0.1:5000/ubuntu:latest</code></li><li>取消非https限制：默认情况下docker不允许非https方式推送，对于使用systemd的系统，可以在&#x2F;etc&#x2F;docker&#x2F;daemon.json中写入如下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirror&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;insecure-registries&quot;</span>: [<br>    <span class="hljs-string">&quot;192.168.199.100:5000&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>私有仓库删除镜像可能不会回收空间，可以使用Nexus3.x软件搭配</li></ul><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><ul><li>特性<ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷会默认一直存在，即使容器被删除</li></ul></li><li>创建一个数据卷：<code>docker volume create my-vol</code></li><li>查看数据卷：<code>docker volume ls</code></li><li>查看指定数据卷信息：<code>docker volume inspect my-vol</code></li><li>挂载数据卷<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v my-vol:/usr/share/nginx/html \</span><br>    --mount <span class="hljs-built_in">source</span>=my-vol,target=/usr/share/nginx/html \<br>    nginx:alpine<br></code></pre></td></tr></table></figure></li><li>删除数据卷：<code>docker volume rm my-vol</code></li></ul><h3 id="挂载主机目录为数据卷"><a href="#挂载主机目录为数据卷" class="headerlink" title="挂载主机目录为数据卷"></a>挂载主机目录为数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 可以不加readonly,那样权限就是读写</span><br>docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v /src/webapp:/usr/share/nginx/html:ro \</span><br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="hljs-built_in">readonly</span> \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><p>可以挂载指定文件，把上面source和target换成文件即可</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>使用-p选项</p><ul><li>映射所有接口地址：<code>-p hostPort:containerPort</code></li><li>映射到指定地址的指定端口：<code>-p ip:hostPort:containerPort</code></li><li>映射到指定地址的任意端口：<code>-p ip::containerPort</code></li><li>标记udp: <code>-p xxport:xxport/udp</code></li><li>查看容器的端口映射：<code>docker port [id or name] [containerPort]</code></li></ul><h3 id="容器互联-两个容器"><a href="#容器互联-两个容器" class="headerlink" title="容器互联(两个容器)"></a>容器互联(两个容器)</h3><p>如果大于两个容器的互联建议使用Docker Compose</p><ul><li>新建网络：<code>docker network create -d bridge my-net</code>,-d选项有bridge和overlay(见swarm mode)</li><li>连接容器：<code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code>,<code>$ docker run -it --rm --name busybox1 --network my-net busybox2 sh</code></li><li>在各个容器中ping：<code>ping busybox2</code></li></ul><h3 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h3><p>容器的DNS设置跟随宿主主机，默认使用主机上的&#x2F;etc&#x2F;resolv.conf(–dns-search –dns会改变默认设置),如果配置全部容器的DNS可以在<code>/etc/docker/daemon.json</code>增加以下内容设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;dns&quot;</span> : [<br>    <span class="hljs-string">&quot;114.114.114.114&quot;</span>,<br>    <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="docker命令汇总"><a href="#docker命令汇总" class="headerlink" title="docker命令汇总"></a>docker命令汇总</h2><h3 id="客户端选项"><a href="#客户端选项" class="headerlink" title="客户端选项"></a>客户端选项</h3><ul><li>–config&#x3D;””：指定客户端配置文件，默认为 ~&#x2F;.docker；</li><li>-D&#x3D;true|false：是否使用 debug 模式。默认不开启；</li><li>-H, –host&#x3D;[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket，文件句柄 fd:&#x2F;&#x2F;socketfd 或 tcp 套接字 tcp:&#x2F;&#x2F;[host[:port]]，默认为 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock；</li><li>-l, –log-level&#x3D;”debug|info|warn|error|fatal”：指定日志输出级别；</li><li>–tls&#x3D;true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li><li>–tlscacert&#x3D;&#x2F;.docker&#x2F;ca.pem：TLS CA 签名的可信证书文件路径；</li><li>–tlscert&#x3D;&#x2F;.docker&#x2F;cert.pem：TLS 可信证书文件路径；</li><li>–tlscert&#x3D;&#x2F;.docker&#x2F;key.pem：TLS 密钥文件路径；</li><li>–tlsverify&#x3D;true|false：启用 TLS 校验，默认为否。</li></ul><h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><ul><li>attach：依附到一个正在运行的容器中；</li><li>build：从一个 Dockerfile 创建一个镜像；</li><li>commit：从一个容器的修改中创建一个新的镜像；</li><li>cp：在容器和本地宿主系统之间复制文件中；</li><li>create：创建一个新容器，但并不运行它；</li><li>diff：检查一个容器内文件系统的修改，包括修改和增加；</li><li>events：从服务端获取实时的事件；</li><li>exec：在运行的容器内执行命令；</li><li>export：导出容器内容为一个 tar 包；</li><li>history：显示一个镜像的历史信息；</li><li>images：列出存在的镜像；</li><li>import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；</li><li>info：显示一些相关的系统信息；</li><li>inspect：显示一个容器的具体配置信息；</li><li>kill：关闭一个运行中的容器 (包括进程和所有相关资源)；</li><li>load：从一个 tar 包中加载一个镜像；</li><li>login：注册或登录到一个 Docker 的仓库服务器；</li><li>logout：从 Docker 的仓库服务器登出；</li><li>logs：获取容器的 log 信息；</li><li>network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li><li>node：管理 swarm 集群中的节点，包括查看、更新、删除、提升&#x2F;取消管理节点等；</li><li>pause：暂停一个容器中的所有进程；</li><li>port：查找一个 nat 到一个私有网口的公共口；</li><li>ps：列出主机上的容器；</li><li>pull：从一个Docker的仓库服务器下拉一个镜像或仓库；</li><li>push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li><li>rename：重命名一个容器；</li><li>restart：重启一个运行中的容器；</li><li>rm：删除给定的若干个容器；</li><li>rmi：删除给定的若干个镜像；</li><li>run：创建一个新容器，并在其中运行给定命令；</li><li>save：保存一个镜像为 tar 包文件；</li><li>search：在 Docker index 中搜索一个镜像；</li><li>service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li><li>start：启动一个容器；</li><li>stats：输出（一个或多个）容器的资源使用统计信息；</li><li>stop：终止一个运行中的容器；</li><li>swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li><li>tag：为一个镜像打标签；</li><li>top：查看一个容器中的正在运行的进程信息；</li><li>unpause：将一个容器内所有的进程从暂停状态中恢复；</li><li>update：更新指定的若干容器的配置信息；</li><li>version：输出 Docker 的版本信息；</li><li>volume：管理 Docker volume，包括查看、创建、删除等；</li><li>wait：阻塞直到一个容器终止，然后输出它的退出符。</li></ul><h3 id="服务端命令选项"><a href="#服务端命令选项" class="headerlink" title="服务端命令选项"></a>服务端命令选项</h3><ul><li>–api-cors-header&#x3D;””：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 <code>*</code>；</li><li>–authorization-plugin&#x3D;””：载入认证的插件；</li><li>-b&#x3D;””：将容器挂载到一个已存在的网桥上。指定为 none 时则禁用容器的网络，与 –bip 选项互斥；</li><li>–bip&#x3D;””：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；</li><li>–cgroup-parent&#x3D;””：指定 cgroup 的父组，默认 fs cgroup 驱动为 &#x2F;docker，systemd cgroup 驱动为 system.slice；</li><li>–cluster-store&#x3D;””：构成集群（如 Swarm）时，集群键值数据库服务地址；</li><li>–cluster-advertise&#x3D;””：构成集群时，自身的被访问地址，可以为 host:port 或 interface:port；</li><li>–cluster-store-opt&#x3D;””：构成集群时，键值数据库的配置选项；</li><li>–config-file&#x3D;”&#x2F;etc&#x2F;docker&#x2F;daemon.json”：daemon 配置文件路径；</li><li>–containerd&#x3D;””：containerd 文件的路径；</li><li>-D, –debug&#x3D;true|false：是否使用 Debug 模式。缺省为 false；</li><li>–default-gateway&#x3D;””：容器的 IPv4 网关地址，必须在网桥的子网段内；</li><li>–default-gateway-v6&#x3D;””：容器的 IPv6 网关地址；</li><li>–default-ulimit&#x3D;[]：默认的 ulimit 值；</li><li>–disable-legacy-registry&#x3D;true|false：是否允许访问旧版本的镜像仓库服务器；</li><li>–dns&#x3D;””：指定容器使用的 DNS 服务器地址；</li><li>–dns-opt&#x3D;””：DNS 选项；</li><li>–dns-search&#x3D;[]：DNS 搜索域；</li><li>–exec-opt&#x3D;[]：运行时的执行选项；</li><li>–exec-root&#x3D;””：容器执行状态文件的根路径，默认为 &#x2F;var&#x2F;run&#x2F;docker；</li><li>–fixed-cidr&#x3D;””：限定分配 IPv4 地址范围；</li><li>–fixed-cidr-v6&#x3D;””：限定分配 IPv6 地址范围；</li><li>-G, –group&#x3D;””：分配给 unix 套接字的组，默认为 docker；</li><li>-g, –graph&#x3D;””：Docker 运行时的根路径，默认为 &#x2F;var&#x2F;lib&#x2F;docker；</li><li>-H, –host&#x3D;[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket，文件句柄 fd:&#x2F;&#x2F;socketfd 或 tcp 套接字 tcp:&#x2F;&#x2F;[host[:port]]，默认为 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock；</li><li>–icc&#x3D;true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li><li>–insecure-registry&#x3D;[]：允许访问给定的非安全仓库服务；</li><li>–ip&#x3D;””：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；</li><li>–ip-forward&#x3D;true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li><li>–ip-masq&#x3D;true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；</li><li>–iptables&#x3D;true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；</li><li>–ipv6&#x3D;true|false：是否启用 IPv6 支持，默认关闭；</li><li>-l, –log-level&#x3D;”debug|info|warn|error|fatal”：指定日志输出级别；</li><li>–label&#x3D;”[]”：添加指定的键值对标注；</li><li>–log-driver&#x3D;”json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none”：指定日志后端驱动，默认为 json-file；</li><li>–log-opt&#x3D;[]：日志后端的选项；</li><li>–mtu&#x3D;VALUE：指定容器网络的 mtu；</li><li>-p&#x3D;””：指定 daemon 的 PID 文件路径。缺省为 &#x2F;var&#x2F;run&#x2F;docker.pid；</li><li>–raw-logs：输出原始，未加色彩的日志信息；</li><li>–registry-mirror&#x3D;<scheme>:&#x2F;&#x2F;<host>：指定 docker pull 时使用的注册服务器镜像地址；</li><li>-s, –storage-driver&#x3D;””：指定使用给定的存储后端；</li><li>–selinux-enabled&#x3D;true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li><li>–storage-opt&#x3D;[]：驱动后端选项；</li><li>–tls&#x3D;true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li><li>–tlscacert&#x3D;&#x2F;.docker&#x2F;ca.pem：TLS CA 签名的可信证书文件路径；</li><li>–tlscert&#x3D;&#x2F;.docker&#x2F;cert.pem：TLS 可信证书文件路径；</li><li>–tlscert&#x3D;&#x2F;.docker&#x2F;key.pem：TLS 密钥文件路径；</li><li>–tlsverify&#x3D;true|false：启用 TLS 校验，默认为否；</li><li>–userland-proxy&#x3D;true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li><li>–userns-remap&#x3D;default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li></ul><h2 id="调试docker"><a href="#调试docker" class="headerlink" title="调试docker"></a>调试docker</h2><ul><li>开启debug模式：在&#x2F;etc&#x2F;docker&#x2F;daemon.json中添加：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br><span class="hljs-string">&quot;debug&quot;</span>:<span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>重启守护进程<code>sudo kill -SIGHUP $(pidof dockerd)</code></li><li>检查内核日志<code>sudo dmesg | grep dockerd</code>,<code>sudo dmesg|grep runc</code></li><li>不响应时，杀死进程查看堆栈：<code>sudo kill -SIGUSR1 $(pidof dockerd)</code></li></ul><h2 id="高级网络"><a href="#高级网络" class="headerlink" title="高级网络"></a>高级网络</h2><h2 id="集群–Swarm-mod"><a href="#集群–Swarm-mod" class="headerlink" title="集群–Swarm mod"></a>集群–Swarm mod</h2><h2 id="Docker-Buildx–-未来docker-build"><a href="#Docker-Buildx–-未来docker-build" class="headerlink" title="Docker Buildx–&gt;未来docker build"></a>Docker Buildx–&gt;未来docker build</h2><h2 id="常用命令及问题"><a href="#常用命令及问题" class="headerlink" title="常用命令及问题"></a>常用命令及问题</h2><ul><li><code>docker system df</code>查看镜像、容器、数据卷所占用空间</li><li><code>docker image prune</code>批量清理临时镜像</li><li><code>docker container prune</code>删除所有终止状态的容器</li><li><code>docker volume prune</code>删除无主的数据卷</li><li><code>docker run [image] env</code>查看镜像支持的环境变量</li><li><code>docker stop $(docker container ls -q)</code>停止所有正在运行的容器</li><li><code>docker inspect --format &#39;&#123;&#123; .State.Pid &#125;&#125;&#39; &lt;CONTAINER ID or NAME&gt;</code>获取某个容器的PID信息</li><li><code>docker inspect --format &#39;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#39; &lt;CONTAINER ID or NAME&gt;</code>获取某个容器的ip地址</li><li>给容器指定一个固定ip地址<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create -d bridge --subnet 172.25.0.0/16 my-net<br>docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox<br></code></pre></td></tr></table></figure></li><li>退出一个交互的终端而不终止，按<code>ctrl-p ctrl-q</code></li><li>Error:No public port 80 published for xxx<ul><li>创建镜像时 Dockerfile 要通过 EXPOSE 指定正确的开放端口；</li><li>容器启动时指定 PublishAllPort &#x3D; true。</li></ul></li><li>WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.<br>这是因为系统默认没有开启对内存和swap使用的统计功能，该功能会降低性能，可以通过以下方式开启：<ul><li>编辑<code>/etc/default/grub</code>配置<code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</code></li><li>更新grub:<code>sudo update-grub</code></li><li>重启</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文本处理瑞士军刀-扩展</title>
    <link href="/2022/03/22/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-%E6%89%A9%E5%B1%95/"/>
    <url>/2022/03/22/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h2 id="csvkit"><a href="#csvkit" class="headerlink" title="csvkit"></a>csvkit</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>pip install csvkit</code></p><h3 id="csvlook"><a href="#csvlook" class="headerlink" title="csvlook"></a>csvlook</h3><p>使csv看起来更加人性化</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-H</td><td align="center">csvlook默认第一行为头，该选项取消该默认，认为无头</td></tr><tr><td align="center">-I</td><td align="center">不区分类型，不为数字的可读性加逗号等等</td></tr></tbody></table><h3 id="in2csv"><a href="#in2csv" class="headerlink" title="in2csv"></a>in2csv</h3><p>转换xlsx为csv,默认为第一个表单</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">–names</td><td align="center">打印所有表单名</td></tr><tr><td align="center">–sheet [name]</td><td align="center">转换指定的表单名</td></tr></tbody></table><h3 id="csvgrep"><a href="#csvgrep" class="headerlink" title="csvgrep"></a>csvgrep</h3><p>csv的抓取</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">–columns [column]</td><td align="center">指定某一列名</td></tr><tr><td align="center">–regex [regex]</td><td align="center">指定正则</td></tr></tbody></table><h3 id="sql2csv"><a href="#sql2csv" class="headerlink" title="sql2csv"></a>sql2csv</h3><p>把数据库中的内容转换成csv</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">–db [URL]</td><td align="center">数据库的URL</td></tr><tr><td align="center">–query</td><td align="center">输入SQL语句</td></tr></tbody></table><h3 id="csvsql"><a href="#csvsql" class="headerlink" title="csvsql"></a>csvsql</h3><p>应用sql语句到csv,主要使用SQLite的语法</p><h3 id="csvjoin"><a href="#csvjoin" class="headerlink" title="csvjoin"></a>csvjoin</h3><p>整合多个csv</p><h3 id="csvstat"><a href="#csvstat" class="headerlink" title="csvstat"></a>csvstat</h3><p>分析csv的命令</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">–freq</td><td align="center">每个值出现的频率</td></tr><tr><td align="center">–len</td><td align="center">不知道啥玩意</td></tr><tr><td align="center">–max</td><td align="center">每列最大值</td></tr><tr><td align="center">–min</td><td align="center">每列最小值</td></tr><tr><td align="center">–mean</td><td align="center">每列平均数</td></tr><tr><td align="center">–median</td><td align="center">每列中位数</td></tr><tr><td align="center">–nulls</td><td align="center">每列是否含null</td></tr><tr><td align="center">–stdev</td><td align="center">每列标准差</td></tr><tr><td align="center">–sum</td><td align="center">每列和</td></tr><tr><td align="center">–unique</td><td align="center">统计每一列不同的值</td></tr></tbody></table><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><code>seq 5 | header -a val | csvsql --query &quot;SELECT SUM(val) AS sum FROM stdin&quot;</code></p><h3 id="csvcut"><a href="#csvcut" class="headerlink" title="csvcut"></a>csvcut</h3><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">指定想要的列名,也可以指定数字，表示第几列，从1开始,以逗号分隔</td></tr><tr><td align="center">-C</td><td align="center">剔除某些列名，和-c相反</td></tr></tbody></table><h2 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h2><p>linux发行版直接安装，使json格式可读性更好</p><h2 id="sample-stream"><a href="#sample-stream" class="headerlink" title="sample-stream"></a>sample-stream</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><code>pip install sample-stream</code></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>这是一个处理流的命令</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-s</td><td align="center">10s后关闭该流</td></tr></tbody></table><h2 id="rush"><a href="#rush" class="headerlink" title="rush"></a>rush</h2><p>一个小仓库<a href="https://github.com/jeroenjanssens/rush%EF%BC%8C%E7%94%A8%E6%9D%A5%E7%94%BB%E5%9B%BE">https://github.com/jeroenjanssens/rush，用来画图</a></p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><ol><li>安装R语言<br><code>sudo pacman -S r</code></li><li>进入R命令端<br><code>sudo R</code></li><li>安装remote包<br><code>install.packages(&quot;remotes&quot;)</code></li><li>安装rush包,该步骤我运行两次才成功，要花费大量编译时间<br><code>remotes::install_github(&quot;jeroenjanssens/rush&quot;)</code></li></ol><h2 id="pup"><a href="#pup" class="headerlink" title="pup"></a>pup</h2><p>html可读性提升工具</p><h2 id="moreutils"><a href="#moreutils" class="headerlink" title="moreutils"></a>moreutils</h2><p>是一个工具集</p><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><p><code>sudo pacman -S moreutils</code></p><h3 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h3><p>在没一行前面加上当前时间戳</p><h2 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h2><ul><li>json2csv:<a href="https://github.com/jehiah/json2csv">https://github.com/jehiah/json2csv</a></li><li>xml2json:pacman官方库有两个版本</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>curl和https</title>
    <link href="/2022/03/15/curl%E5%92%8Chttps/"/>
    <url>/2022/03/15/curl%E5%92%8Chttps/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>HTTP&#x2F;2和HTTP&#x2F;3的头部通常会被curl压缩发送，但是-v选项总是把它们解压成HTTP&#x2F;1.1的样子</li><li>HTTP默认端口：80，HTTPS默认端口：443</li><li>HTTP有4种方法：GET，POST，HEAD，PUT,OPTIONS</li><li>curl默认的http版本为HTTP&#x2F;1.1,默认的https版本为HTTP&#x2F;2</li></ul><h3 id="返回码"><a href="#返回码" class="headerlink" title="返回码"></a>返回码</h3><ul><li>1XX：瞬态响应，更多内容即将发生</li><li>2XX：成功</li><li>3XX：重定向<ul><li>301:永久重定向，当一个url第一次返回该值时，重定向的内容将被浏览器缓存，下次该url不起作用，直接访问重定向内容(浏览器总是使用GET，即使第一次访问时用的是POST),curl永远不会缓存</li><li>302:暂时重定向，不会缓存,重定向总是使用GET</li><li>303:同302,但是更接近于间接访问的概念</li><li>307:暂时重定向，不会缓存，区别在于它会保持第一次访问的方法</li><li>308:永久重定向，区别在于它会保持第一次访问的方法</li></ul></li><li>4XX：服务器无法提供或不会提供要求的内容<ul><li>401:服务器需要一个认证，通常包含头<code>WWW-Authenticate:</code>,包含了服务器支持的认证方法(Basic)</li><li>407:代理服务器需要一个认证，通常包含头<code>Proxy-Authenticate:</code>,包含了代理支持的认证方法</li></ul></li><li>5XX：服务器出现问题</li></ul><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>通过URL来形成HTTP头<br><img src="/images/httpRequest.png"><br><strong>request例子</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET / HTTP/1.1<br>User-agent: curl/2000<br>Host: example.com<br></code></pre></td></tr></table></figure><p><strong>response例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 200 OK<br>Server: example-server/1.1<br>Content-Length: 5<br>Content-Type: plain/text<br><br>hello<br></code></pre></td></tr></table></figure><h3 id="Transfer-Encoding-chunked"><a href="#Transfer-Encoding-chunked" class="headerlink" title="Transfer-Encoding: chunked"></a>Transfer-Encoding: chunked</h3><p>有时response可能没有Content-Length，而是<strong>Transfer-Encoding: chunked</strong>，这只有HTTP1.1服务才有，它表示内容是一系列的块，每块开头有显示该块的十六进制大小，结束时，也会有表示结束的0块。curl会自动解码</p><h3 id="Content-Encoding-gzip"><a href="#Content-Encoding-gzip" class="headerlink" title="Content-Encoding: gzip"></a>Content-Encoding: gzip</h3><p>body是经过压缩的,curl会自动解压</p><h3 id="Expect-100-continue"><a href="#Expect-100-continue" class="headerlink" title="Expect:100-continue"></a>Expect:100-continue</h3><p>很少有服务器支持这一特性，且HTTP&#x2F;2及以上支持在没关闭连接的情况下停止持续传输,这使得该特性无意义。(该特性到底是啥不懂)post时，curl会默认</p><h3 id="透明压缩"><a href="#透明压缩" class="headerlink" title="透明压缩"></a>透明压缩</h3><p>过于老式，不常用，可以使用–tr-encoding来使用，前提是服务器支持</p><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><p>服务器通过<strong>Etag</strong>来标识一个资源的版本，这样便于客户判断是否资源更新</p><h3 id="Multipart-formposts"><a href="#Multipart-formposts" class="headerlink" title="Multipart formposts"></a>Multipart formposts</h3><p>这对应html中form的enctype&#x3D;multiparg&#x2F;form-data,可以通过-F选项指定form:<br><code>curl -F person=anonymous -F secret=@file.txt http://example.com/submit.cgi</code><br><strong>Header内容：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST /submit.cgi HTTP/1.1<br>Host: example.com<br>User-Agent: curl/7.46.0<br>Accept: */*<br>Content-Length: 313<br>Expect: 100-<span class="hljs-built_in">continue</span><br>Content-Type: multipart/form-data; boundary=------------------------d74496d66958873e<br></code></pre></td></tr></table></figure><p><strong>Body内容：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">--------------------------d74496d66958873e<br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;person&quot;</span><br><br>anonymous<br>--------------------------d74496d66958873e<br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;secret&quot;</span>; filename=<span class="hljs-string">&quot;file.txt&quot;</span><br>Content-Type: text/plain<br><br>contents of the file<br>--------------------------d74496d66958873e--<br></code></pre></td></tr></table></figure><p>html的form表单中enctype默认为<code>application/x-www-form-urlencoded</code>,此时只需要-d选项即可</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li>有时服务器不会直接返回内容，而是告诉你该资源所在位置，此时响应中包含关键字<code>Location:</code></li><li>有时重定向会指向不同主机，此时用户名密码或证书等可能无法使用，无论如何信任的话，可以使用–location-trusted</li><li>浏览器支持更多的重定向方式，curl不支持他们，比如html里meta元素，javascript的动态重定向</li></ul><h3 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h3><p>cookie设置的一个头</p><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p>强制升级http版本的头，过老的服务器可能会出错</p><h3 id="Alt-Svc"><a href="#Alt-Svc" class="headerlink" title="Alt-Svc"></a>Alt-Svc</h3><p>响应体中的头，告诉客户还有哪些主机可以获得同样资源,只能在https中使用，并且这是使用http3的唯一方法（截至2019）</p><h3 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h3><p>http3是实验版本，是为了适应QUIC协议（一个基于UDP的可靠安全的协议），只能通过https,curl没有针对http3连结失败时作自动降级处理，而是直接返回错误</p><h2 id="代理-就是web缓存服务器"><a href="#代理-就是web缓存服务器" class="headerlink" title="代理(就是web缓存服务器)"></a>代理(就是web缓存服务器)</h2><ul><li>HTTP代理为了安全，使用<strong>CONNECT</strong>方法</li><li>HTTP代理可以代理FTP,此时curl将认为就是HTTP,FTP所有特性无效</li><li>MITM代理可以监控加密的流量</li><li>代理认证失败，拒绝代理，会返回407</li><li>HTTPS代理的默认端口为443</li><li>curl中与代理相关的环境变量<ul><li>[scheme]_proxy:指定某个协议的默认代理,等价于-x选项,除了http_proxy只能全部小写(CGI的原因),其他形式可以用全部大写<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_proxy=http://proxy.example.com:80<br>curl -v www.example.com<br></code></pre></td></tr></table></figure></li><li>ALL_PROXY:所有url都走该代理</li><li>NO_PROXY:某些url不走该代理，用<code>,</code>分隔多个url，等效于–noproxy</li></ul></li></ul><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><ul><li>FTP协议使用两个tcp连接，一个用来建立认证，并进入到正确的文件夹内(控制连接)，一个用来传输文件，curl默认是被动连接（即客户端发送PASV或EPSV命令给服务器,服务器新开个端口，curl用该端口连接传输）,主动连接见-P，被动连接见–ftp-pasv</li><li>curl传输文件时有三种方法(见–ftp-method)：</li><li>FTPS的默认端口是990,可以通过<code>scheme:ftps://</code>指定，抑或使用<code>--ssl,--ssl-reqd</code></li><li>FTPS无法推广的原因是，FTP的第二个连接是新建的tcp连接，防火墙和其他网络工具检查辨别是FTP传输并采取一些规则或设置应用到该连接,但如果加密，防火墙等就无法判断，并无法应用一些规则</li></ul><h2 id="URLs-URIs"><a href="#URLs-URIs" class="headerlink" title="URLs(URIs)"></a>URLs(URIs)</h2><p>需要注意的是现代浏览器的地址栏里支持IRIs,一个URLs的超集(更强大，支持空白字符等等)</p><h3 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h3><p>scheme就是分隔符前面的内容,是协议吗？不可以包含任何空格</p><ul><li>分隔符:<code>://</code>curl只支持双斜杠的，有标准是单斜杠的</li><li>curl会自动纠错一些scheme格式以及自动推测(通过选项–proto-default设置)</li></ul><h3 id="Name-and-password-非主流"><a href="#Name-and-password-非主流" class="headerlink" title="Name and password(非主流)"></a>Name and password(非主流)</h3><p>scheme及分隔符之后可能跟着用户名和密码,不过这风险很大,正慢慢淘汰,同时你也可以通过选项等方式来指定。一般格式如下：<br><code>curl ftp://user:password@example.com/</code></p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host就是主机，可以是数字地址本身或简单的域名</p><ul><li>ipv4:<code>curl http://127.0.0.1/</code></li><li>ipv6:<code>curl http://[::1]/</code></li></ul><h3 id="port-number"><a href="#port-number" class="headerlink" title="port number"></a>port number</h3><p>如果端口号没指明，那么就会使用各个协议的默认端口。<br>通常在主机名后指明,用冒号和数字。为十进制数范围在[0-65535]</p><ul><li>ipv4:<code>curl http://example.com:8080/</code></li><li>ipv6:<code>curl http://[fdea::1]:8080/</code></li></ul><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>每个url包含路径,如果没指明则是根目录<code>/</code>,如下是等价的<br><code>https://example.com</code>&#x3D;&#x3D;&gt;<code>https://example.com/</code></p><h3 id="FTP-type-FTP特有很少用的特性"><a href="#FTP-type-FTP特有很少用的特性" class="headerlink" title="FTP type(FTP特有很少用的特性)"></a>FTP type(FTP特有很少用的特性)</h3><p>该特性可以让你指明文件类型,指定不同的类型ftp协议相应的用不同传输,curl默认以二进制格式传递FTP协议</p><ul><li>A:指明传输类型为ASCII<br><code>curl &quot;ftp://example.com/foo;type=A&quot;</code></li><li>I:指明传输类型为二进制<br><code>curl &quot;ftp://example.com/foo;type=I&quot;</code></li><li>D:指明传输类型为目录(此时不要以斜杠结尾)<br><code>curl &quot;ftp://example.com/foo;type=D&quot;</code></li></ul><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p>由<code>#</code>标识</p><ul><li>URLs提供fragment，但curl传递时，会忽略它,(就是浏览器中的定位,跟网页屏幕位置有关)</li><li>有时<code>#</code>处于路径中,为了方便你可用<code>%23</code>来代替<code>#</code><br><code>https://www.example.com/info.html#the-plot</code>&#x3D;&#x3D;&gt;<code>curl https://www.example.com/info.html%23the-plot</code></li></ul><h3 id="curl与URLs"><a href="#curl与URLs" class="headerlink" title="curl与URLs"></a>curl与URLs</h3><p>curl支持许多选项，不是可选项内容的都是URLs，可以支持多个URLs,从左到右一个个解析</p><ul><li>curl总是返回最后一个URL的错误代码(可以用–fail-early改变),</li><li>curl的选项总是应用所有URLs(当然存在例外(-o、-O)),要想应用不同的URL不同的option,可以使用<code>--next、-:</code></li><li>指定多个URLs,可以节省时间(如果多个URLs有相同主机，TCP将会一直保持链接)</li><li>默认是串行,可以指定并行(-Z),并行时的进度条和串行时有区别，该进度条是所有当前运行的并行任务的实时情况</li></ul><h4 id="globbing"><a href="#globbing" class="headerlink" title="globbing"></a>globbing</h4><p>有时想传递同一主机下的一系列资源，可以用<code>&#123;&#125;</code>和<code>[]</code>来指定，处于它们之间的内容称为[globbing],并且他们可以混用，此时为防止shell的副作用，应该用引号括起来URL，</p><ul><li><code>[]</code><ul><li><code>curl -O &quot;http://example.com/[1-100].png&quot;</code></li><li><code>curl -O &quot;http://example.com/[001-100].png&quot;</code>支持前导0</li><li><code>curl -O &quot;http://example.com/[001-100:2].png&quot;</code>取奇数</li><li><code>curl -O &quot;http://example.com/[a-z].png&quot;</code>支持字母</li></ul></li><li><code>&#123;&#125;</code><ul><li><code>curl -O &quot;http://example.com/&#123;one,two,three,alpha,beta&#125;.html&quot;</code></li></ul></li><li>-o选项里面可以通过<code>#[num]</code>来代表globbing内容,num从1开始编号<ul><li><code>curl &quot;http://&#123;one,two&#125;.example.com&quot; -o &quot;file_#1.txt&quot;</code></li><li><code>curl &quot;http://&#123;site,host&#125;.host[1-5].example.com&quot; -o &quot;subdir/#1_#2&quot;</code><br>globbing有时还可以用于-T选项，上传多个文件:<br><code>curl -T &#39;image[1-99].jpg&#39; ftp://ftp.example.com/upload/</code></li></ul></li></ul><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h3 id="配置文件curlrc"><a href="#配置文件curlrc" class="headerlink" title="配置文件curlrc"></a>配置文件curlrc</h3><p>按以下优先级读取文件：</p><ol><li>“$CURL_HOME&#x2F;.curlrc”</li><li>“$XDG_CONFIG_HOME&#x2F;.curlrc”</li><li>“$HOME&#x2F;.curlrc”</li></ol><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="A-–user-agent"><a href="#A-–user-agent" class="headerlink" title="-A&#x2F;–user-agent"></a>-A&#x2F;–user-agent</h3><p>指明<code>User-Agent:</code>的值</p><h3 id="–alt-svc-cacheFile"><a href="#–alt-svc-cacheFile" class="headerlink" title="–alt-svc [cacheFile]"></a>–alt-svc [cacheFile]</h3><p>会尝试cacheFile定义中的可获得同样资源的主机地址，如果server响应并更新了<code>Alt-Svc:</code>,则也会自动更新到cacheFile中。</p><h3 id="–anyauth"><a href="#–anyauth" class="headerlink" title="–anyauth"></a>–anyauth</h3><p>curl首先不使用认证，如果服务器需要，curl将会尝试使用认证</p><h3 id="B"><a href="#B" class="headerlink" title="-B"></a>-B</h3><p>以二进制形式传输，curl默认就是二进制</p><h3 id="b-cookiesFile"><a href="#b-cookiesFile" class="headerlink" title="-b [cookiesFile]"></a>-b [cookiesFile]</h3><p>从文件中读取cookie，-c选项是写cookie</p><h3 id="–basic"><a href="#–basic" class="headerlink" title="–basic"></a>–basic</h3><p>使用Basic认证方法，默认的认证方法</p><h3 id="c-cookieFile"><a href="#c-cookieFile" class="headerlink" title="-c [cookieFile]"></a>-c [cookieFile]</h3><p>写入cookie到一个文件中</p><h3 id="C-–continue-at-num"><a href="#C-–continue-at-num" class="headerlink" title="-C&#x2F;–continue-at [num&#x2F;-]"></a>-C&#x2F;–continue-at [num&#x2F;-]</h3><p>指明从num byte offset开始继续下载或<code>-</code>curl根据已有的下载文件确定从哪开始继续下载。<br><strong>例1</strong>:<code>curl --continue-at 100 ftp://example.com/bigfile</code><br><strong>例2</strong>:<code>curl --continue-at - http://example.com/bigfile -O</code></p><h3 id="–cacert-path"><a href="#–cacert-path" class="headerlink" title="–cacert [path]"></a>–cacert [path]</h3><p>设置CA证书路径</p><h3 id="–cert-file-passwd"><a href="#–cert-file-passwd" class="headerlink" title="–cert [file:passwd]"></a>–cert [file:passwd]</h3><p>TLS指定客户端的证书文件,待学习相关知识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --cert mycert:mypassword https://example.com<br>curl --cert mycert:mypassword --key mykey https://example.com<br>curl --cert mycert:mypassword --cert-type PEM \<br>     --key mykey --key-type PEM https://example.com<br></code></pre></td></tr></table></figure><h3 id="–cert-type"><a href="#–cert-type" class="headerlink" title="–cert-type"></a>–cert-type</h3><p>见–cert例子</p><h3 id="–cert-status"><a href="#–cert-status" class="headerlink" title="–cert-status"></a>–cert-status</h3><p>这个TLS特性为OCSP stapling,比较新，目前仅有openssl,gnutls,nss支持，一般不使用</p><h3 id="–ciphers"><a href="#–ciphers" class="headerlink" title="–ciphers"></a>–ciphers</h3><p>TLS中ciphers,除非你知道你在干啥，否则慎用。</p><h3 id="–connect-to-source-name-source-port-destination-name-destination-port"><a href="#–connect-to-source-name-source-port-destination-name-destination-port" class="headerlink" title="–connect-to [source name:source port:destination name:destination port]"></a>–connect-to [source name:source port:destination name:destination port]</h3><p>有时负载均衡，一个host name其实由多个服务提供，有时你只想测试其中一个服务，可以用此选项，如下：<br><code>curl --connect-to www.example.com:80:load1.example.com:80 http://www.example.com</code></p><h3 id="–connect-timeout-num"><a href="#–connect-timeout-num" class="headerlink" title="–connect-timeout [num]"></a>–connect-timeout [num]</h3><p>指定tcp连接多长时间没反应算失败，单位秒，可以给出float类型数字</p><h3 id="–compressed"><a href="#–compressed" class="headerlink" title="–compressed"></a>–compressed</h3><p>http&#x2F;https,请求服务器提供压缩版本的内容，curl会在数据到达后自动解压，这只是加快传输速度，注意不能和另一个–tr-encoding混用，因为两者采用不同压缩</p><h3 id="d-–data-string-or-num"><a href="#d-–data-string-or-num" class="headerlink" title="-d&#x2F;–data [string or num]"></a>-d&#x2F;–data [string or num]</h3><p>发送的数据,simple POST,一下两种方式等价</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;name=admin&amp;shoesize=12&#x27;</span> http://example.com/<br>curl -d name=admin -d shoesize=12 http://example.com/<br><span class="hljs-comment">#从某个文件读取</span><br>curl -d @filename http://example.com<br></code></pre></td></tr></table></figure><p>从文件中读取时，会去除回车和换行，如果不想这样见–data-binary</p><h3 id="–data-binary"><a href="#–data-binary" class="headerlink" title="–data-binary"></a>–data-binary</h3><p>该选项从文件读取时，不会去除回车和换行</p><h3 id="–data-raw"><a href="#–data-raw" class="headerlink" title="–data-raw"></a>–data-raw</h3><p>-d选项的补充，主要是为了下面的情况:<br><code>curl --data-raw &#39;@string&#39; https://example.com</code></p><h3 id="–data-urlencode"><a href="#–data-urlencode" class="headerlink" title="–data-urlencode"></a>–data-urlencode</h3><p>把post内容使用url的安全编码(即把空格和一些不安全字符使用%xx%编码)，接受以下形式(只对内容进行编码):</p><ul><li>content</li><li>&#x3D;content</li><li>name&#x3D;content</li><li>@filename</li><li>name@filename</li></ul><h3 id="–digest"><a href="#–digest" class="headerlink" title="–digest"></a>–digest</h3><p>digest的认证方式</p><h3 id="–dns-interface"><a href="#–dns-interface" class="headerlink" title="–dns-interface"></a>–dns-interface</h3><p>指定dns走的网卡？</p><h3 id="–dns-ipv4-addr"><a href="#–dns-ipv4-addr" class="headerlink" title="–dns-ipv4-addr"></a>–dns-ipv4-addr</h3><p>指定ipv4的dns服务器</p><h3 id="–dns-ipv6-addr"><a href="#–dns-ipv6-addr" class="headerlink" title="–dns-ipv6-addr"></a>–dns-ipv6-addr</h3><p>指定ipv6的dns服务器</p><h3 id="–dns-servers"><a href="#–dns-servers" class="headerlink" title="–dns-servers"></a>–dns-servers</h3><p>指定一个dns服务器</p><h3 id="e-–referer"><a href="#e-–referer" class="headerlink" title="-e&#x2F;–referer"></a>-e&#x2F;–referer</h3><p>当在浏览器中，从一个页面，点击另一个页面，会形成一个<code>Referer:</code>的头，它说明是从哪个网站进去的，例如：<br><code>curl --referer http://comes-from.example.com https://www.example.com/</code></p><h3 id="–etag-save-etagSavedFile"><a href="#–etag-save-etagSavedFile" class="headerlink" title="–etag-save [etagSavedFile]"></a>–etag-save [etagSavedFile]</h3><p>把该资源的Etag保存到某文件中</p><h3 id="–etag-compare-etagFile"><a href="#–etag-compare-etagFile" class="headerlink" title="–etag-compare [etagFile]"></a>–etag-compare [etagFile]</h3><p>与本地文件中保存Etag做对比，只下载更新的，可以与–etag-save连用，达到自动更新的目的<br><code>curl --etag-compare etag.txt --etag-save etag.txt https://example.com/file -o output</code></p><h3 id="f-–fail"><a href="#f-–fail" class="headerlink" title="-f&#x2F;–fail"></a>-f&#x2F;–fail</h3><p>一般http返回4xx码时，curl也会认为是成功的一次传输，如果启用该选项，如果是4xx，curl将以22退出</p><h3 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h3><p>http的方法将是POST</p><h3 id="–fail-early"><a href="#–fail-early" class="headerlink" title="–fail-early"></a>–fail-early</h3><h3 id="–fail-with-body"><a href="#–fail-with-body" class="headerlink" title="–fail-with-body"></a>–fail-with-body</h3><p>同–fail</p><h3 id="–ftp-method-multicwd-nocwd-singlecwd"><a href="#–ftp-method-multicwd-nocwd-singlecwd" class="headerlink" title="–ftp-method [multicwd&#x2F;nocwd&#x2F;singlecwd]"></a>–ftp-method [multicwd&#x2F;nocwd&#x2F;singlecwd]</h3><ul><li>multicwd(curl默认方法)：<code>curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CWD one &lt; 250 OK. Current directory is /one CWD two &lt; 250 OK. Current directory is /one/two CWD three &lt; 250 OK. Current directory is /one/two/three RETR file.txt<br></code></pre></td></tr></table></figure></li><li>nocwd(并不符合标准):<code>curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">RETR one/two/three/file.txt<br></code></pre></td></tr></table></figure></li><li>singlecwd(服务器不一定支持):<code>curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt</code><br>等价于<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CWD one/two/three &lt; 250 OK. Current directory is /one/two/three RETR file.txt<br></code></pre></td></tr></table></figure></li></ul><h3 id="–ftp-pasv"><a href="#–ftp-pasv" class="headerlink" title="–ftp-pasv"></a>–ftp-pasv</h3><p>curl默认就是ftp被动连接，这个选项是重新设置为被动连接</p><h3 id="–ftp-skip-pasv-ip"><a href="#–ftp-skip-pasv-ip" class="headerlink" title="–ftp-skip-pasv-ip"></a>–ftp-skip-pasv-ip</h3><p>有时服务器对于PASV被动建立连接命令会故意返回一个错的ip地址，此时该选项可以忽略该地址，使用控制连接的地址</p><h3 id="G-–get"><a href="#G-–get" class="headerlink" title="-G&#x2F;–get"></a>-G&#x2F;–get</h3><p>当指定-d等选项时，默认为post方法，此选项可以强制转成get，所有数据都追加在url末尾，以<code>?</code>分割</p><h3 id="h-–help"><a href="#h-–help" class="headerlink" title="-h&#x2F;–help"></a>-h&#x2F;–help</h3><h3 id="H-header-content"><a href="#H-header-content" class="headerlink" title="-H [header content]"></a>-H [header content]</h3><ul><li>自定义头部内容<br><code>curl -H &quot;Host: www.example.com&quot; http://localhost/</code></li><li>去除curl自动形成的头，只要不给值就行：<br><code>curl -H &quot;User-Agent:&quot; http://example.com/</code></li><li>去除所有头<br><code>curl -H &quot;Empty;&quot; http://example.com</code></li></ul><h3 id="–hsts-hstsFile"><a href="#–hsts-hstsFile" class="headerlink" title="–hsts [hstsFile]"></a>–hsts [hstsFile]</h3><p>HSTS是一个严格的传输安全协议，它保护https不被降级和中间cookie注入，整个过程中不能使用明文。该选项使curl读入某个server的HSTS缓存,然后自动更新，并且自动转换http为https:<br><code>curl --hsts hsts.txt https://example.com</code></p><h3 id="–http0-9"><a href="#–http0-9" class="headerlink" title="–http0.9"></a>–http0.9</h3><p>该版本非常不成熟，响应只有body，没有header,使用该选项是告诉curl接受该种响应</p><h3 id="–http1-0"><a href="#–http1-0" class="headerlink" title="–http1.0"></a>–http1.0</h3><p>尝试使用http1.0</p><h3 id="–http1-1"><a href="#–http1-1" class="headerlink" title="–http1.1"></a>–http1.1</h3><p>尝试使用http1.1</p><h3 id="–http2"><a href="#–http2" class="headerlink" title="–http2"></a>–http2</h3><p>尝试使用http2</p><h3 id="–http2-prior-knowledge"><a href="#–http2-prior-knowledge" class="headerlink" title="–http2-prior-knowledge"></a>–http2-prior-knowledge</h3><p>前提你确定已经知道服务器支持http2了，这个加快negotiate的速度</p><h3 id="–http3"><a href="#–http3" class="headerlink" title="–http3"></a>–http3</h3><p>尝试使用http3</p><h3 id="I"><a href="#I" class="headerlink" title="-I"></a>-I</h3><p>HTTP方法将是HEAD</p><h3 id="–ignore-content-length"><a href="#–ignore-content-length" class="headerlink" title="–ignore-content-length"></a>–ignore-content-length</h3><p>忽略头部的Content-Length信息（早期数据不可以超过2g,content-length可能是负的），直接接受数据</p><h3 id="–interface-ip-addr-or-some-interface"><a href="#–interface-ip-addr-or-some-interface" class="headerlink" title="–interface [ip addr or some interface]"></a>–interface [ip addr or some interface]</h3><p>指定哪个网络接口来传输流量，或者使用哪个原始ip地址（前提你有多个ip）这个不影响dns的接口，dns接口可用–dns-interface</p><h3 id="j-–junk-session-cookies"><a href="#j-–junk-session-cookies" class="headerlink" title="-j&#x2F;–junk-session-cookies"></a>-j&#x2F;–junk-session-cookies</h3><p>模拟浏览器重新打开，一个新的会话cookie<br><code>curl -j -b cookies.txt http://example.com/</code></p><h3 id="J-–remote-header-name"><a href="#J-–remote-header-name" class="headerlink" title="-J&#x2F;–remote-header-name"></a>-J&#x2F;–remote-header-name</h3><p>HTTP头可能提供<code>Content-Disposition:</code>,这其中包含了建议的文件名，这个选项使用该文件名作为输出，如果该内容存在，会覆盖-O选项。</p><ul><li>它只会保留文件名部分，忽略目录</li><li>CURL不会帮你解码，可能是个URL原码格式的文件名（浏览器会解码）</li></ul><h3 id="–json"><a href="#–json" class="headerlink" title="–json"></a>–json</h3><p>该选项是为了更好的post json格式的内容，等价于下面三个选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">--data [jsonformat]<br>--header <span class="hljs-string">&quot;Content-Type: application/json&quot;</span><br>--header <span class="hljs-string">&quot;Accept: application/json&quot;</span><br></code></pre></td></tr></table></figure><p>注意多次使用该选项时，curl只是简单的字符串拼接，并不会帮你合并，所以应该像下面这样使用：<br><code>curl --json @json.txt --json &quot;, &quot;end&quot;: &quot;true&quot;&#125;&#39; https://example.com/</code></p><h3 id="k-–insecure"><a href="#k-–insecure" class="headerlink" title="-k&#x2F;–insecure"></a>-k&#x2F;–insecure</h3><p>tls&#x2F;ssh协议中，curl会跳过检查known_hosts文件及本地安全证书，直接信任</p><h3 id="K-–config"><a href="#K-–config" class="headerlink" title="-K&#x2F;–config"></a>-K&#x2F;–config</h3><p><code>-K &lt;fileName&gt;</code><br>此选项是为了帮助过长的选项不好输在命令行中，fileName则可以保存这些选项</p><ul><li>一行一个选项，长选项可以省略<code>--</code></li><li>可以用<code>#</code>注释</li><li>选项和参数内容间可以用<code>=</code>或<code>:</code>使结构清晰</li><li>参数如果含空格，必须用双引号括起来,括号内只可以用下面这些转义字符<code>\\,\&quot;,\t,\n,\r,\v</code>,如果不用双引号,则遇到第一个空格就结束读取</li><li>文件内也可以指明url，必须如下格式<br><code>url = &quot;http://example.com&quot;</code></li></ul><h3 id="–keepalive-time-num"><a href="#–keepalive-time-num" class="headerlink" title="–keepalive-time [num]"></a>–keepalive-time [num]</h3><p>curl默认会保持无流量的tcp连接长达60s,这可以更改时间，单位为秒</p><h3 id="–key"><a href="#–key" class="headerlink" title="–key"></a>–key</h3><p>指定cert健，见–cert</p><h3 id="–key-type"><a href="#–key-type" class="headerlink" title="–key-type"></a>–key-type</h3><p>见–cert</p><h3 id="l-–list-only"><a href="#l-–list-only" class="headerlink" title="-l&#x2F;–list-only"></a>-l&#x2F;–list-only</h3><p>FTP协议中相当与使用NLST命令，可能不会list符号链接和目录</p><h3 id="L-–location"><a href="#L-–location" class="headerlink" title="-L&#x2F;–location"></a>-L&#x2F;–location</h3><p>如果返回重定向，则继续访问重定向的地址。默认最多50个。curl默认不会访问重定向的内容,</p><h3 id="–limit-rate"><a href="#–limit-rate" class="headerlink" title="–limit-rate "></a>–limit-rate <num></h3><p>参数是个数字，默认单位是byte，可以跟K&#x2F;M&#x2F;G，整个过程的平均速度将不超过这个值,也同样适用于上传速率</p><h3 id="–location-trusted"><a href="#–location-trusted" class="headerlink" title="–location-trusted"></a>–location-trusted</h3><p>永远信任重定向的任何主机，默认是不信任，因为，可能重定向不同主机</p><h3 id="–local-port-num-or-range"><a href="#–local-port-num-or-range" class="headerlink" title="–local-port [num or range]"></a>–local-port [num or range]</h3><p>通常不需要指定本地端口，但有时只有某些端口是开放的，指定curl的本地端口，可以指定一个范围，因为一个可能被占用了,最好不要指定1024以下的端口</p><h3 id="m-–max-time-num"><a href="#m-–max-time-num" class="headerlink" title="-m&#x2F;–max-time [num]"></a>-m&#x2F;–max-time [num]</h3><p>整个命令允许运行的最长时间，即使正在下载，也会立刻退出(退出码28)</p><h3 id="–mail-from"><a href="#–mail-from" class="headerlink" title="–mail-from"></a>–mail-from</h3><p>smtp中指定发件人</p><h3 id="–mail-rcpt"><a href="#–mail-rcpt" class="headerlink" title="–mail-rcpt"></a>–mail-rcpt</h3><p>smtp中指定收件人</p><h3 id="–manual"><a href="#–manual" class="headerlink" title="–manual"></a>–manual</h3><h3 id="–max-filesize-num"><a href="#–max-filesize-num" class="headerlink" title="–max-filesize [num]"></a>–max-filesize [num]</h3><p>单位是byte，如果curl在传输开始可以获得将要下载的内容大小，该选项才会起作用，如果超过该大小，curl将会自动放弃。</p><h3 id="–max-redirs-num"><a href="#–max-redirs-num" class="headerlink" title="–max-redirs [num]"></a>–max-redirs [num]</h3><p>指定最多重定向次数，默认50个</p><h3 id="n-–netrc"><a href="#n-–netrc" class="headerlink" title="-n&#x2F;–netrc"></a>-n&#x2F;–netrc</h3><p>读取<code>~/.netrc</code>配置文件，该文件存储用户名密码，例子如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#以下的值都不许有空格，且可以写在一行</span><br>machine example.com <span class="hljs-comment">#可以填default,此时不需要machine关键字</span><br>login nanbert<br>password xxx <br>macdef xxx <span class="hljs-comment">#该选项curl不支持，会忽略</span><br></code></pre></td></tr></table></figure><h3 id="–negotiate"><a href="#–negotiate" class="headerlink" title="–negotiate"></a>–negotiate</h3><p>negotiate的认证方式</p><h3 id="netrc-file-path"><a href="#netrc-file-path" class="headerlink" title="-netrc-file [path]"></a>-netrc-file [path]</h3><p>不读默认<code>~/.netrc</code>文件，而是具体某个文件</p><h3 id="–netrc-optional"><a href="#–netrc-optional" class="headerlink" title="–netrc-optional"></a>–netrc-optional</h3><p>这与<code>--netrc</code>区别在于，使得默认配置内容是可选的,不是强制的</p><h3 id="–next"><a href="#–next" class="headerlink" title="–next"></a>–next</h3><h3 id="–no-eprt"><a href="#–no-eprt" class="headerlink" title="–no-eprt"></a>–no-eprt</h3><p>ftp协议中禁止使用命令EPRT，该命令比PORT更新</p><h3 id="–no-epsv"><a href="#–no-epsv" class="headerlink" title="–no-epsv"></a>–no-epsv</h3><p>ftp协议中进制使用命令EPSV，该命令比PASV更新</p><h3 id="–no-keepalive"><a href="#–no-keepalive" class="headerlink" title="–no-keepalive"></a>–no-keepalive</h3><p>默认curl会保持tcp(无流量)连接60s,这个会关闭该功能</p><h3 id="–noproxy"><a href="#–noproxy" class="headerlink" title="–noproxy"></a>–noproxy</h3><p>不使用全局环境变量代理</p><h3 id="–no-verbose"><a href="#–no-verbose" class="headerlink" title="–no-verbose"></a>–no-verbose</h3><h3 id="–ntlm"><a href="#–ntlm" class="headerlink" title="–ntlm"></a>–ntlm</h3><p>ntlm的认证方式</p><h3 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h3><p>输出到某个文件，一个该选项对应一个url,想要指明多个，必须声明多个-o</p><h3 id="O-–remote-name"><a href="#O-–remote-name" class="headerlink" title="-O&#x2F;–remote-name"></a>-O&#x2F;–remote-name</h3><p>把结果输出到使用远程服务器的原始文件名,一个该选项对应一个url,想要指明多个，必须声明多个-O</p><h3 id="–path-as-is"><a href="#–path-as-is" class="headerlink" title="–path-as-is"></a>–path-as-is</h3><p>在url指定路径时，如果出现<code>/../</code>或<code>/./</code>,curl会替换它们，再发送给服务器，比如<code>/hello/sir/../</code>变成<code>/hello/</code>,<code>/hello/./sir</code>变成<code>/hello/sir/</code>,而该选项会保留<code>..</code>和<code>.</code></p><h3 id="P-–ftp-port-ip"><a href="#P-–ftp-port-ip" class="headerlink" title="-P&#x2F;–ftp-port [ip&#x2F;-]"></a>-P&#x2F;–ftp-port [ip&#x2F;-]</h3><p>这其实是使用命令PORT或EPRT，即服务器建立新连接到客户,但经常不指定一个确切的port,直接使用<code>-</code>,总是为，信息来时的地址，如下：<br><code>curl -P - ftp://example.com/foobar.txt</code></p><h3 id="–post301"><a href="#–post301" class="headerlink" title="–post301"></a>–post301</h3><p>返回301重定向时，保持初始的方法</p><h3 id="–post302"><a href="#–post302" class="headerlink" title="–post302"></a>–post302</h3><p>返回302重定向时，保持初始的方法</p><h3 id="–post303"><a href="#–post303" class="headerlink" title="–post303"></a>–post303</h3><p>返回303重定向时，保持初始的方法</p><h3 id="p-–proxytunnel"><a href="#p-–proxytunnel" class="headerlink" title="-p&#x2F;–proxytunnel"></a>-p&#x2F;–proxytunnel</h3><p>使用隧道对代理加密<br><code>curl -p -x http://proxy.example.com:80 ftp://ftp.example.com/file.txt</code></p><h3 id="–parallel-max"><a href="#–parallel-max" class="headerlink" title="–parallel-max"></a>–parallel-max</h3><h3 id="–pinnedpubkey-sha256-hashnum1-hashnum2"><a href="#–pinnedpubkey-sha256-hashnum1-hashnum2" class="headerlink" title="–pinnedpubkey [sha256&#x2F;&#x2F;hashnum1;hashnum2;..]"></a>–pinnedpubkey [sha256&#x2F;&#x2F;hashnum1;hashnum2;..]</h3><p>TLS协议中，Certifiate pinning中直接指定sha256值</p><h3 id="–proto-default"><a href="#–proto-default" class="headerlink" title="–proto-default"></a>–proto-default</h3><h3 id="–proxy1-0-ip-addr"><a href="#–proxy1-0-ip-addr" class="headerlink" title="–proxy1.0 [ip addr]"></a>–proxy1.0 [ip addr]</h3><p>指定代理，和<code>--x</code>一样，只是使用HTTP&#x2F;1.0</p><h3 id="–proxy-anyauth"><a href="#–proxy-anyauth" class="headerlink" title="–proxy-anyauth"></a>–proxy-anyauth</h3><p>任意一种代理用户名认证方式,根据代理服务器要求自动匹配或者不使用认证</p><h3 id="–proxy-digest"><a href="#–proxy-digest" class="headerlink" title="–proxy-digest"></a>–proxy-digest</h3><p>一种代理用户名认证方式</p><h3 id="–proxy-header"><a href="#–proxy-header" class="headerlink" title="–proxy-header"></a>–proxy-header</h3><p>该头只发送给代理，真正的远程服务器不会收到，这比–header更精细化<br><code>curl --proxy-header &quot;User-Agent: magic/3000&quot; -x proxy https://example.com/</code></p><h3 id="–proxy-negotiate"><a href="#–proxy-negotiate" class="headerlink" title="–proxy-negotiate"></a>–proxy-negotiate</h3><p>一种代理用户名认证方式</p><h3 id="–proxy-ntlm"><a href="#–proxy-ntlm" class="headerlink" title="–proxy-ntlm"></a>–proxy-ntlm</h3><p>一种代理用户名认证方式</p><h3 id="Q-–quote-ftp-cmd"><a href="#Q-–quote-ftp-cmd" class="headerlink" title="-Q&#x2F;–quote [ftp cmd]"></a>-Q&#x2F;–quote [ftp cmd]</h3><p>发送命令给ftp服务器</p><ul><li>在传输之前发送NOOP命令<code>curl -Q NOOP ftp://example.com/file</code></li><li>在传输之后发送NOOP命令<code>curl -Q -NOOP ftp://example.com/file</code></li><li>不知什么时候发<code>curl -Q +NOOP ftp://example.com/file</code><br>发送的命令发生错误时会导致curl退出，有时可以在命令前加<code>*</code>，忽略可能发送错误，如：<br><code>curl -Q &quot;-*DELE file&quot; ftp://example.com/moo</code></li></ul><h3 id="r-–range-num1-num2-num3-0-num3-…"><a href="#r-–range-num1-num2-num3-0-num3-…" class="headerlink" title="-r&#x2F;–range [num1-num2,num3-,0-num3,…]"></a>-r&#x2F;–range [num1-num2,num3-,0-num3,…]</h3><p>只下num1 byte offset至num2 byte offset的内容,服务器可以选择性的实现该功能，也就是说，即使你这么请求，服务器也可能返回全部内容</p><h3 id="–remote-name-all"><a href="#–remote-name-all" class="headerlink" title="–remote-name-all"></a>–remote-name-all</h3><p>所有结果均输出保存到服务器上的原始文件名</p><h3 id="–remote-time"><a href="#–remote-time" class="headerlink" title="–remote-time"></a>–remote-time</h3><p>使得下载到本地的文件的时间戳和远程服务器文件的时间戳一样，常和-z -o选项搭配<br><code>curl -z file.html -o file.html --remote-time https://example.com/file.html</code></p><h3 id="–resolve-host-name-port-ip-address"><a href="#–resolve-host-name-port-ip-address" class="headerlink" title="–resolve [host name:port:ip address]"></a>–resolve [host name:port:ip address]</h3><p>dns重定向，这会保存到curl的cache中<br><code>curl --resolve example.com:80:127.0.0.1 http://example.com/</code></p><h3 id="s-–silent"><a href="#s-–silent" class="headerlink" title="-s&#x2F;–silent"></a>-s&#x2F;–silent</h3><p>此选项关闭进度条，并不显示错误，但是-S&#x2F;–show-error不受此选项影响</p><h3 id="S-–show-error"><a href="#S-–show-error" class="headerlink" title="-S&#x2F;–show-error"></a>-S&#x2F;–show-error</h3><p>默认情况下curl会输出错误，该选项主要是抵消-s的作用</p><h3 id="–speed-time-num"><a href="#–speed-time-num" class="headerlink" title="–speed-time [num]"></a>–speed-time [num]</h3><p>经常和–speed-limit一起用,下面的意思是速度小于1000并且持续15s就退出<br><code>curl --speed-time 15 --speed-limit 1000 https://example.com/</code></p><h3 id="–speed-limit-num"><a href="#–speed-limit-num" class="headerlink" title="–speed-limit [num]"></a>–speed-limit [num]</h3><p>见–speed-time</p><h3 id="–ssl"><a href="#–ssl" class="headerlink" title="–ssl"></a>–ssl</h3><p>尝试ssl加密(FTP,IMAP,POP3,SMTP)</p><h3 id="–sslv2"><a href="#–sslv2" class="headerlink" title="–sslv2"></a>–sslv2</h3><p>使用SSL2版本</p><h3 id="–sslv3"><a href="#–sslv3" class="headerlink" title="–sslv3"></a>–sslv3</h3><p>使用SSL3版本</p><h3 id="–ssl-reqd"><a href="#–ssl-reqd" class="headerlink" title="–ssl-reqd"></a>–ssl-reqd</h3><p>强制ssl加密(FTP,IMAP,POP3,SMTP)</p><h3 id="–raw"><a href="#–raw" class="headerlink" title="–raw"></a>–raw</h3><p>禁用内容或传输编码的所有内部http解码，而是使用未经修改的原始数据,这经常用在curl为一个代理的情况</p><h3 id="–retry-num"><a href="#–retry-num" class="headerlink" title="–retry [num]"></a>–retry [num]</h3><p>curl会在发生transient error时，会重新尝试num次，默认失败一次就不会尝试，transient error包括以下：超时，FTP 4XX返回码，http5xx返回码</p><h3 id="–request-target"><a href="#–request-target" class="headerlink" title="–request-target"></a>–request-target</h3><p>获取的资源路径，这个一般直接写在url中，但这配合OPTIONS方法，有个特殊用法：<br><code>curl -X OPTIONS --request-target &quot;*&quot; http://example.com/</code><br>会形成下面的头：<br><code>OPTIONS * HTTP/1.1</code></p><h3 id="–retry-all-errors"><a href="#–retry-all-errors" class="headerlink" title="–retry-all-errors"></a>–retry-all-errors</h3><p>有时你确定一个服务器是好的，出现任何错误都想重试，该选项就可以帮你</p><h3 id="–retry-connrefused"><a href="#–retry-connrefused" class="headerlink" title="–retry-connrefused"></a>–retry-connrefused</h3><p>重试只会发生在transient error时，但拒绝访问不属于，有时你确认服务器只是重启或其他原因，该选项可以使得出现拒绝访问时，也可以重试。</p><h3 id="–retry-max-time-num"><a href="#–retry-max-time-num" class="headerlink" title="–retry-max-time [num]"></a>–retry-max-time [num]</h3><p>第一次重试之前,curl会等1s,然后第二次重试会等2s,如此指数增长下去，直到达到10min，该选项会指明等待时间不少于num秒，–max-time选项仍会起作用</p><h3 id="T"><a href="#T" class="headerlink" title="-T"></a>-T</h3><ul><li>HTTP PUT就是上传某个完整资源上传或替换远程的现有资源，很少被服务器启用</li><li>FTP或TFTP 上传文件，如下<br><code>curl -T uploadthis ftp://example.com/this/directory/</code><br><code>curl -T uploadthis ftp://example.com/this/directory/remotename</code></li><li>SMTP上传body内容，通常需要其他选项(有关header的选项)配合（–mail-from,等）<br><code>curl -T mail smtp://mail.example.com/ --mail-from user@example.com</code></li></ul><h3 id="t-–telnet-option-keyword-value"><a href="#t-–telnet-option-keyword-value" class="headerlink" title="-t&#x2F;–telnet-option [keyword&#x3D;value]"></a>-t&#x2F;–telnet-option [keyword&#x3D;value]</h3><p>telnet选项特有，传递以下三个参数：</p><ul><li>TTYPE&#x3D;[term]:设置终端类型</li><li>XDISPLOC&#x3D;[X display]:设置X展示位置</li><li>NEW_ENV&#x3D;[var,val]:设置环境变量值</li></ul><h3 id="–tftp-blksize-num"><a href="#–tftp-blksize-num" class="headerlink" title="–tftp-blksize [num]"></a>–tftp-blksize [num]</h3><p>tftp通信传输块默认大小为512,此选项可以修改，支持8-65464</p><h3 id="–tftp-no-options"><a href="#–tftp-no-options" class="headerlink" title="–tftp-no-options"></a>–tftp-no-options</h3><p>有些tftp服务器不接受任何选项，此时该选项可以应用</p><h3 id="–tlspassword-passwd"><a href="#–tlspassword-passwd" class="headerlink" title="–tlspassword [passwd]"></a>–tlspassword [passwd]</h3><p>TLS的特性，可以在命令行中直接使用用户名和密码<br><code>curl --tlsuser daniel --tlspassword secret https://example.com</code></p><h3 id="–tlsuser-name"><a href="#–tlsuser-name" class="headerlink" title="–tlsuser [name]"></a>–tlsuser [name]</h3><p>见–tlspassword</p><h3 id="–tlsv1-–tlsv1-0"><a href="#–tlsv1-–tlsv1-0" class="headerlink" title="–tlsv1&#x2F;–tlsv1.0"></a>–tlsv1&#x2F;–tlsv1.0</h3><p>使用TLS&gt;&#x3D;1.0的版本</p><h3 id="–tlsv1-1"><a href="#–tlsv1-1" class="headerlink" title="–tlsv1.1"></a>–tlsv1.1</h3><p>使用TLS&gt;&#x3D;1.0的版本</p><h3 id="–tlsv1-2"><a href="#–tlsv1-2" class="headerlink" title="–tlsv1.2"></a>–tlsv1.2</h3><p>使用TLS&gt;&#x3D;1.2的版本</p><h3 id="–tlsv1-3"><a href="#–tlsv1-3" class="headerlink" title="–tlsv1.3"></a>–tlsv1.3</h3><p>使用TLS&gt;&#x3D;1.3的版本,curl默认</p><h3 id="–tr-encoding"><a href="#–tr-encoding" class="headerlink" title="–tr-encoding"></a>–tr-encoding</h3><p>采用Transfer-Encoded压缩传输内容，curl会自动解压,不能和–compressed混用,且该选项不常用</p><h3 id="–trace-filename"><a href="#–trace-filename" class="headerlink" title="–trace [filename]"></a>–trace [filename]</h3><p>会跟踪每拍接受的内容，以16进制显示,每行开头的十六进制加冒号代表该内容的byte offset</p><h3 id="–trace-ascii-filename"><a href="#–trace-ascii-filename" class="headerlink" title="–trace-ascii [filename]"></a>–trace-ascii [filename]</h3><p>会跟踪每拍接受的内容，以ascii码可读形式显示</p><h3 id="–trace-time"><a href="#–trace-time" class="headerlink" title="–trace-time"></a>–trace-time</h3><p>化学选项：-v&#x2F;–verbose,–trace和–trace-ascii<br>这个选项会帮助化学选项所输出内容之前加高精度的时间。</p><h3 id="u-–user"><a href="#u-–user" class="headerlink" title="-u&#x2F;–user"></a>-u&#x2F;–user</h3><p>指定用户名和密码，冒号分隔<code>user:passwd</code>,这种明文，最好不用，协议层方面使用https和ftps等，如果非要使用明文,可以选择选项<code>--digest</code>,<code>--negotiate</code>,<code>--ntlm</code>,或者直接通过配置文件###1禁用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --digest --user daniel:secret http://example.com/<br>curl --negotiate --user daniel:secret http://example.com/<br>curl --ntlm --user daniel:secret http://example.com/<br></code></pre></td></tr></table></figure><h3 id="U-–proxy-user-user-passwd"><a href="#U-–proxy-user-user-passwd" class="headerlink" title="-U&#x2F;–proxy-user [user:passwd]"></a>-U&#x2F;–proxy-user [user:passwd]</h3><p>指定代理的用户名和密码<br><code>curl -U daniel:secr3t -x myproxy:80 http://example.com</code></p><h3 id="–upload-file"><a href="#–upload-file" class="headerlink" title="–upload-file"></a>–upload-file</h3><p>指定上传内容文件，用于smtp</p><h3 id="–use-ascii"><a href="#–use-ascii" class="headerlink" title="–use-ascii"></a>–use-ascii</h3><p>使用ascii传输，而不是二进制</p><h3 id="v-–verbose"><a href="#v-–verbose" class="headerlink" title="-v&#x2F;–verbose"></a>-v&#x2F;–verbose</h3><p>该选项会使curl显示更多的内容，具体格式如下：</p><ul><li><code>*</code>后面跟解释性内容</li><li><code>&gt;</code>后面跟客户端发送的头协议，（FTP,SMTP,POP3等没有头协议的，命令和返回当成头）</li><li><code>&lt;</code>后面跟从服务端接受的返回头协议<br>HTTP&#x2F;2和HTTP&#x2F;3协议头是压缩的，但在此选项下会展开和HTTP&#x2F;1.1一样的格式</li></ul><h3 id="V-–version"><a href="#V-–version" class="headerlink" title="-V&#x2F;–version"></a>-V&#x2F;–version</h3><p>会输出版本相关的信息，各行含义如下:<br>**第一行:**版本号+平台+第三方依赖信息<br>**第二行:**版本发布日期<br>**第三行:**支持的协议<br>**第四行:**支持的特性</p><h3 id="w-–write-out"><a href="#w-–write-out" class="headerlink" title="-w&#x2F;–write-out"></a>-w&#x2F;–write-out</h3><p>参数:<code>&lt;formatted string&gt;</code>或<code>@[filename或-]</code><br>该选项会在每个传输完毕后，在末尾加上formatted string或文件中的内容,%可以使用<code>\n,\r,\t</code>转义字符，特殊的变量跟在<code>%</code>后,<code>%%</code>输出真正的%<br>有以下formatted string:</p><table><thead><tr><th align="center">格式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>%&#123;content_type&#125;</code></td><td align="center">字面义，有的内容没有类型</td></tr><tr><td align="center"><code>%&#123;errormsg&#125;</code></td><td align="center">字面义，无错误为空</td></tr><tr><td align="center"><code>%&#123;exitcode&#125;</code></td><td align="center">传输的退出码，无错返回0</td></tr><tr><td align="center"><code>%&#123;filename_effective&#125;</code></td><td align="center">最终传输内容所保存的文件名，只当指定-o或–remote-name选项有意义</td></tr><tr><td align="center"><code>%&#123;ftp_entry_path&#125;</code></td><td align="center">登陆ftp的初始路径</td></tr><tr><td align="center"><code>%&#123;http_code&#125;</code></td><td align="center">也就是response_code</td></tr><tr><td align="center"><code>%&#123;http_connect&#125;</code></td><td align="center">待探索</td></tr><tr><td align="center"><code>%&#123;http_version&#125;</code></td><td align="center">字面义</td></tr><tr><td align="center"><code>%&#123;json&#125;</code></td><td align="center">所有write-out的变量生成json格式</td></tr><tr><td align="center"><code>%&#123;local_ip&#125;</code></td><td align="center">最近一次连接的ipv4或ipv6的本地地址</td></tr><tr><td align="center"><code>%&#123;local_port&#125;</code></td><td align="center">最近一次连接的本地端口</td></tr><tr><td align="center"><code>%&#123;method&#125;</code></td><td align="center">最近请求的方法</td></tr><tr><td align="center"><code>%&#123;num_connects&#125;</code></td><td align="center">最近传输的新连接数量</td></tr><tr><td align="center"><code>%&#123;num_headers&#125;</code></td><td align="center">上一次传输的反应头的数量</td></tr><tr><td align="center"><code>%&#123;num_redirects&#125;</code></td><td align="center">请求的重定向次数</td></tr><tr><td align="center"><code>%&#123;onerror&#125;</code></td><td align="center">如果传输发生错误，输出之后的string,内容，否则不输出</td></tr><tr><td align="center"><code>%&#123;proxy_ssl_verify_result&#125;</code></td><td align="center">与代理通信时请求的SSL对等证书验证的结果,0表示成功</td></tr><tr><td align="center"><code>%&#123;redirect_url&#125;</code></td><td align="center">当发出HTTP请求而没有-L重定向时，重定向会将您带到的实际URL</td></tr><tr><td align="center"><code>%&#123;remote_ip&#125;</code></td><td align="center">远程的ipv4或6地址</td></tr><tr><td align="center"><code>%&#123;remote_port&#125;</code></td><td align="center">远程的端口</td></tr><tr><td align="center"><code>%&#123;response_code&#125;</code></td><td align="center">字面义</td></tr><tr><td align="center"><code>%&#123;scheme&#125;</code></td><td align="center">url的scheme</td></tr><tr><td align="center"><code>%&#123;size_download&#125;</code></td><td align="center">字面义</td></tr><tr><td align="center"><code>%&#123;size_header&#125;</code></td><td align="center">头部的大小</td></tr><tr><td align="center"><code>%&#123;size_request&#125;</code></td><td align="center">请求的大小</td></tr><tr><td align="center"><code>%&#123;size_upload&#125;</code></td><td align="center">上传大小</td></tr><tr><td align="center"><code>%&#123;speed_download&#125;</code></td><td align="center">平均下载速度</td></tr><tr><td align="center"><code>%&#123;speed_upload&#125;</code></td><td align="center">平均上传速度</td></tr><tr><td align="center"><code>%&#123;ssl_verify_result&#125;</code></td><td align="center">请求SSL对等证书验证的结果，0表示成功</td></tr><tr><td align="center"><code>%&#123;stderr&#125;</code></td><td align="center">接下来的内容输出到标准错误</td></tr><tr><td align="center"><code>%&#123;stdout&#125;</code></td><td align="center">接下来的内容输出到标准输出</td></tr><tr><td align="center"><code>%&#123;time_appconnect&#125;</code></td><td align="center">从开始到完成SSL&#x2F;SSH&#x2F;etc到远程主机的连接&#x2F;握手花费的时间，单位秒</td></tr><tr><td align="center"><code>%&#123;time_connect&#125;</code></td><td align="center">从一开始直到TCP连接到远程主机（或代理）完成花费的时间，单位秒</td></tr><tr><td align="center"><code>%&#123;time_namelookup&#125;</code></td><td align="center">从一开始直到名字解析完成所花费的时间,单位秒</td></tr><tr><td align="center"><code>%&#123;time_pretransfer&#125;</code></td><td align="center">从一开始直到文件传输即将开始所花费的时间，单位秒</td></tr><tr><td align="center"><code>%&#123;time_redirect&#125;</code></td><td align="center">所有重定向步骤，包括名称查找，连接，预传输和最终事务开始之前的传输所花费的时间,单位秒</td></tr><tr><td align="center"><code>%&#123;time_starttransfer&#125;</code></td><td align="center">从一凯斯直到第一个字节即将被传输，这包括time_pretransfer和服务器计算结果所需的时间</td></tr><tr><td align="center"><code>%&#123;time_total&#125;</code></td><td align="center">完整操作持续的总时间，时间为秒，精度达到毫秒</td></tr><tr><td align="center"><code>%&#123;url&#125;</code></td><td align="center">命令行中指定url</td></tr><tr><td align="center"><code>%&#123;url_effective&#125;</code></td><td align="center">真实有效的url</td></tr><tr><td align="center"><code>%&#123;urlnum&#125;</code></td><td align="center">url的编号，从0开始计数</td></tr></tbody></table><h3 id="X-–request"><a href="#X-–request" class="headerlink" title="-X&#x2F;–request"></a>-X&#x2F;–request</h3><p>指定http的方法，一般curl会根据选项自动判断，无需特地指定该选项，错误的方法可能使得curl行为怪异</p><h3 id="x-–proxy-ip-addr"><a href="#x-–proxy-ip-addr" class="headerlink" title="-x&#x2F;–proxy [ip addr]"></a>-x&#x2F;–proxy [ip addr]</h3><ul><li>指定代理，默认scheme为http,默认端口为1080<br><code>curl -x 192.168.0.1:8080 http://example.com/</code></li><li>指定SOCKS协议代理，这可以直接使用各个版本，而不用-x，说明如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#SOCKS4版本</span><br>curl -x socks4://proxy.example.com http://www.example.com/<br>curl --socks4 proxy.example.com http://www.example.com/<br><span class="hljs-comment">#SOCKS4a版本</span><br>curl -x socks4a://proxy.example.com http://www.example.com/<br>curl --socks4a proxy.example.com http://www.example.com/<br><span class="hljs-comment">#SOCKS5版本</span><br>curl -x socks5://proxy.example.com http://www.example.com/<br>curl --socks5 proxy.example.com http://www.example.com/<br><span class="hljs-comment">#SOCKS5h版本</span><br>curl -x socks5h://proxy.example.com http://www.example.com/<br>curl --socks5-ostname proxy.example.com http://www.example.com/<br></code></pre></td></tr></table></figure></li></ul><h3 id="–xattr"><a href="#–xattr" class="headerlink" title="–xattr"></a>–xattr</h3><h3 id="Z-–parallel"><a href="#Z-–parallel" class="headerlink" title="-Z&#x2F;–parallel"></a>-Z&#x2F;–parallel</h3><h3 id="z-–time-cond-time-stamp-file"><a href="#z-–time-cond-time-stamp-file" class="headerlink" title="-z&#x2F;–time-cond [time stamp&#x2F;file]"></a>-z&#x2F;–time-cond [time stamp&#x2F;file]</h3><p>对下载的内容做时间限制(可早，可晚)，时间格式可以是常见的格式，或者指定比某个本地文件新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -z <span class="hljs-string">&quot;Jan 10, 2017&quot;</span> https://example.com/file -O<span class="hljs-comment">#只下载比该时间戳新的</span><br>curl --time-cond <span class="hljs-string">&quot;Sun, 12 Sep 2004 15:05:58 -0700&quot;</span> https://www.example.org/file.html<span class="hljs-comment">#只下载比该时间早的</span><br>curl -z file.html https://example.com/file.html -O<span class="hljs-comment">#比file.html新的</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="-:"></a>-:</h3><h3 id="–progress-bar"><a href="#–progress-bar" class="headerlink" title="-#&#x2F;–progress-bar"></a>-#&#x2F;–progress-bar</h3><p>当内容重定向时，进度条是默认打开的,该选项会展示一种简单的进度条，有时进度条无法估计时间</p><h3 id="作用"><a href="#作用" class="headerlink" title="@作用"></a>@作用</h3><p>传参数可以把参数放到文件里，如下:<br><code>curl -d @json http://example.com</code></p><h2 id="curl退出码"><a href="#curl退出码" class="headerlink" title="curl退出码"></a>curl退出码</h2><ul><li>1：不支持的协议</li><li>2：初始化失败，libcurl可能出了问题</li><li>3：url格式不对</li><li>4：某个请求需要某个特性或选项未能满足</li><li>5：无法解析代理</li><li>6：无法解析主机</li><li>7：无法连接主机。可能端口，主机名或防火墙的问题</li><li>8：未知的ftp服务返回。可能未支持，也可能未启用选项</li><li>9：ftp拒绝访问。没该文件或用户名或没权限</li><li>10：ftp接受失败。</li><li>11：ftp奇怪的PASS回复</li><li>12：在等待服务器连接的活动FTP会话期间，超过限期</li><li>13：FTP PASV命令未知的反应。通过–ftp-port选项可能解决该问题</li><li>14：未知FTP227格式。这肯定是个坏服务器，或者可以通过–ftp-port解决该问题</li><li>15：FTP无法获得主机</li><li>16：HTTP&#x2F;2 error</li><li>17：FTP无法设置binary传输。坏的服务器</li><li>18：只传输了部分文件</li><li>19：FTP无法获得下载该文件。RETR命令失败</li><li>20：（保留）</li><li>21：引用错误。IMAP、POP3、SMTP、FTP发送自定义命令时出错，建议查看报头</li><li>22：HTTP页面未抓取。对应400反应码以上的错误，出现该错误只能在-f选项启用的时候</li><li>23：写错误。写到本地时发生的错误</li><li>24：（保留）</li><li>25：上传失败。服务器空间已满或拒绝上传</li><li>26：读错误。从本地读取时发生错误</li><li>27：内存不够。系统分配给curl内存不足</li><li>28：操作超时。由各种选项设置的各种超时</li><li>29：（保留）</li><li>30：FTP PORT命令错误。PORT命令有点非主流，可以试试PASV</li><li>31：FTP无法使用REST。可以在没有范围或恢复的情况下重试</li><li>32：（保留）</li><li>33：HTTP范围错误</li><li>34：HTTP post错误,需要反馈BUG</li><li>35：TLS&#x2F;SSL连接错误</li><li>36：无法恢复下载。FILE,FTP,SFTP会发生此错误</li><li>37：无法读取该文件。FILE协议，可能不存在或没权限</li><li>38：绑定LDAP失败。可能用户密码错误</li><li>39：LDAP搜索失败。</li><li>40：（保留）</li><li>41：（保留）</li><li>42：回调错误。开发者编程的错误</li><li>43：错误函数参数。libcurl的调用问题</li><li>44：（保留）</li><li>45：网络接口错误</li><li>46：（保留）</li><li>47：太多重定向。默认最多50个，可以通过–max-redirs改变</li><li>48：libcurl未知选项。可能curl和libcurl版本不一</li><li>49：telnet错误的选项</li><li>50：（保留）</li><li>51：SSL&#x2F;TLS、SSH认证失败</li><li>52：服务器未返回任何内容。可能是服务器有意为之</li><li>53：未发现SSL引擎</li><li>54：无法设置SSL加密引擎为默认</li><li>55：无法发送网络数据。网络底层的错误，需要Wireshark等工具查看</li><li>56：无法接受网络数据。网络底层错误。</li><li>57：（保留）</li><li>58：本地认证有问题。</li><li>59：无法使用ssl密码。密码有格式标准</li><li>60：对等证书无法使用已知ca认证</li><li>61：无法识别传输编码</li><li>62：无效LDAP URL</li><li>63：超过最大文件大小限制</li><li>64：FTP SSL失败</li><li>65：发送之前帧失败</li><li>66：初始化SSL引擎失败</li><li>67：用户名密码CURL无法登陆</li><li>68：TFTP服务没有该文件</li><li>69：TFTP服务权限问题</li><li>70：TFTP服务没有空间</li><li>71：非法TFTP操作</li><li>72：未知TFTP传输id</li><li>73：TFTP文件已存在</li><li>74：TFTP没有该用户</li><li>75：字符转换失败</li><li>76：需要字符转换函数</li><li>77：读SSL CA认证时发生问题</li><li>78：URL中的资源不存在</li><li>79：在SSH会话中发生错误</li><li>80：关闭SSL连接失败</li><li>81：（保留）</li><li>82：无法下载CRL文件，错误格式</li><li>83：TLS认证检查失败</li><li>84：FTP PRET命令失败</li><li>85：RTSP:CSeq数字不匹配</li><li>86：RTSP:会话标识符不匹配</li><li>87：无法解析ftp文件列表</li><li>88：FTP 块回掉错误</li><li>89：没有可用的连接，会话将排队</li><li>90：SSL公钥不匹配固定公钥</li><li>91：无效SSL认证状态</li><li>92：HTTP&#x2F;2流错误</li><li>93：API回调错误</li><li>94：认证错误</li><li>95：HTTP&#x2F;3错误</li><li>96：QUIC连接错误</li></ul><h2 id="curl与浏览器的区别"><a href="#curl与浏览器的区别" class="headerlink" title="curl与浏览器的区别"></a>curl与浏览器的区别</h2><ul><li>浏览器会对接受的数据进行二次解码,更易懂些，curl就直接解码</li><li>有的服务器会根据不同客户端(甚至不同的浏览器)提供更适配的内容</li><li>你可以使用f12然后选中network,右键点击你想要的资源，选中<code>copy cURL</code>就可以复制相应的命令</li></ul><h2 id="POP3-curl读邮件使用的协议"><a href="#POP3-curl读邮件使用的协议" class="headerlink" title="POP3(curl读邮件使用的协议)"></a>POP3(curl读邮件使用的协议)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#To list message numbers and sizes:</span><br>curl pop3://mail.example.com/<br><span class="hljs-comment">#To download message 1:</span><br>curl pop3://mail.example.com/1<br><span class="hljs-comment">#To delete message 1:</span><br>curl --request DELE pop3://mail.example.com/1<br></code></pre></td></tr></table></figure><p><strong>TLS加密</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl pop3://mail.example.com/ --ssl-reqd<br>curl pop3s://mail.example.com/<br></code></pre></td></tr></table></figure><h2 id="IMAP-curl读邮件使用的协议，更常用现代"><a href="#IMAP-curl读邮件使用的协议，更常用现代" class="headerlink" title="IMAP(curl读邮件使用的协议，更常用现代)"></a>IMAP(curl读邮件使用的协议，更常用现代)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Get the mail using the UID 57 from mailbox &#x27;stuff&#x27;:</span><br>curl imap://server.example.com/stuff;UID=57<br><span class="hljs-comment">#get the mail with index 57 from the mailbox &#x27;fun&#x27;</span><br>curl imap://server.example.com/fun;MAILINDEX=57<br><span class="hljs-comment">#List the mails in the mailbox &#x27;boring&#x27;:</span><br>curl imap://server.example.com/boring<br><span class="hljs-comment">#List the mails in the mailbox &#x27;boring&#x27; and provide user and password:</span><br>curl imap://server.example.com/boring -u user:password<br></code></pre></td></tr></table></figure><p><strong>TLS加密</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ssl imap://mail.example.com/inbox<br>curl imaps://mail.example.com/inbox<br></code></pre></td></tr></table></figure><h2 id="SMTP-cURL写邮件使用的协议"><a href="#SMTP-cURL写邮件使用的协议" class="headerlink" title="SMTP(cURL写邮件使用的协议)"></a>SMTP(cURL写邮件使用的协议)</h2><p>必须指定收发邮箱，以及内容,默认端口587</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl smtp://mail.example.com --mail-from myself@example.com --mail-rcpt \<br>receiver@example.com --upload-file email.txt<br></code></pre></td></tr></table></figure><p>email.txt:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">From: John Smith &lt;john@example.com&gt;<br>To: Joe Smith &lt;smith@example.com&gt;<br>Subject: an example.com example email<br>Date: Mon, 7 Nov 2016 08:45:16<br><br>Dear Joe,<br>Welcome to this example email. What a lovely day.<br></code></pre></td></tr></table></figure><p>和POP3、IMAP一样，可以使用SSL&#x2F;TLS加密，schema改成smtps即可，或者使用–ssl或–ssl-reqd,此时默认端口为465</p><h2 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h2><p>订阅推送的协议，不太懂</p><h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2><p>小文件传输协议，使用的是UDP</p><ul><li>下载<code>curl -O tftp://localserver/file.boot</code></li><li>上传<code>curl -T file.boot tftp://localserver/</code></li></ul><h2 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h2><p>即时通信协议，默认端口23</p><h2 id="DICT"><a href="#DICT" class="headerlink" title="DICT"></a>DICT</h2><p>字典查询的协议<br>alias:</p><ul><li>m:match和find</li><li>d:define和lookup<br>例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl dict://dict.org/m:curl<br>curl dict://dict.org/d:heisenbug:jargon<br>curl dict://dict.org/d:daniel:gcide<br>curl dict://dict.org/find:curl<br></code></pre></td></tr></table></figure></li></ul><h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS&#x2F;SSL"></a>TLS&#x2F;SSL</h2><p>TLS是建立于TCP上一层的安全加密层，SSL是旧称(且所有ssl版本都在淘汰中)，两个是一个概念。<br>各个版本协议都有TLS版本：</p><ul><li>HTTP-HTTPS</li><li>LDAP-LDAPS</li><li>FTP-FTPS</li><li>POP3-POP3S</li><li>IMAP-IMAPS</li><li>SMTP-SMTPS<br>TLS属于third-party,你可以通过–version查看，如果你feature中有MultiSSL的特性，证明curl是支持多版本的，你可以通过<code>CURL_SSL_BACKEND</code>来设置使用那个版二</li></ul><h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h3><p>SSL2(1995)-&gt;SSL3-&gt;TLS1.0(1999)-&gt;TLS1.1(2006)-&gt;TLS1.2(2008)-&gt;TLS1.3(2018)</p><h3 id="CA的存储"><a href="#CA的存储" class="headerlink" title="CA的存储"></a>CA的存储</h3><p>一般都是内建的，但你也可以用–cacert指定路径（一定要是PEM格式），或者设置CURL-CA_BUNDLE环境变量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>zsh</title>
    <link href="/2022/02/03/zsh/"/>
    <url>/2022/02/03/zsh/</url>
    
    <content type="html"><![CDATA[<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>Zsh的变量除了哈希表以外，都直接赋值使用,包括整数(64位带符号)、浮点数(64位带符号)、字符串、数组、哈希表,<code>$+var</code>,判断变量是否定义,未定义返回0,否则为1</p><h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><ol><li>获取字符串长度<br><code>str=abcde echo $#str</code></li><li>字符串拼接<br><code>str2+=$str1;str3=$str1$str2</code><br><span id = "slice"></span></li><li>字符串切片<br>字符位置从1开始算,bash风格的则从0开始算<br><code>echo $str[2,4]</code></li><li>字符串截断<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">str=abcdeabcde<br><span class="hljs-comment">#删除左端匹配到的内容,最小匹配</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str#*b&#125;</span> <span class="hljs-comment">#输出cdeabcde</span><br><span class="hljs-comment">#删除右端匹配到的内容,最小匹配</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str%d*&#125;</span> <span class="hljs-comment">#输出abcdeabc</span><br><span class="hljs-comment">#删除左端匹配到的内容,最大匹配</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str##*b&#125;</span> <span class="hljs-comment">#输出cde</span><br><span class="hljs-comment">#删除右端匹配到的内容,最大匹配</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str%%d*&#125;</span> <span class="hljs-comment">#输出abc</span><br></code></pre></td></tr></table></figure><span id = "find"></span></li><li>字符串查找<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#从左往右找cd字符串,找不到返回数组大小+1</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span>[(i)<span class="hljs-built_in">cd</span>]<br><span class="hljs-comment">#从右往左找cd字符串,找不到返回0</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span>[(I)<span class="hljs-built_in">cd</span>]<br><span class="hljs-comment">#从第二个位置开始找</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str[(in:2:)cd]&#125;</span><br></code></pre></td></tr></table></figure></li><li>遍历字符<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i (&#123;1..<span class="hljs-variable">$#str</span>&#125;)&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span>[i]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>字符串替换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">str=abcabc<br><span class="hljs-comment">#只替换找到第一个</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str/bc/ef&#125;</span> <span class="hljs-comment">#aefabc</span><br><span class="hljs-comment">#只删除找到第一个</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str/bc&#125;</span> <span class="hljs-comment">#aabc</span><br><span class="hljs-comment">#上面两个的所有版本</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str//bc/ef&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str//bc&#125;</span><br><br>str=abcABCabcABCabc<br><br><span class="hljs-comment"># /# 只从字符串开头开始匹配，$&#123;str/#abc&#125; 也同理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str/#abc/123&#125;</span> <span class="hljs-comment">#123ABCabcABCabc</span><br><br><span class="hljs-comment"># /% 只从字符串结尾开始匹配，echo $&#123;str/%abc&#125; 也同理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str/%abc/123&#125;</span> <span class="hljs-comment">#abcABCabcABC123</span><br><br>str=abc<br><span class="hljs-comment"># 如果匹配到了则输出空字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str:#ab*&#125;</span><br><br><span class="hljs-comment"># 如果匹配不到，则输出原字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str:#ab&#125;</span><br><br><span class="hljs-comment">#按位置删除字符和替换字符,就是指定位置赋值</span><br>str[1]=<br>str[2,4]=<br>str[1]=k<br>str[2,4]=sjkg <span class="hljs-comment">#可以不一一对应</span><br></code></pre></td></tr></table></figure></li><li>字符串是否匹配<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#是否包含</span><br>[[ <span class="hljs-variable">$str1</span> == *<span class="hljs-variable">$str2</span>* ]] &amp;&amp; <span class="hljs-built_in">echo</span> good<br><span class="hljs-comment">#正则匹配</span><br>[[ <span class="hljs-variable">$str</span> =~ <span class="hljs-string">&#x27;c[0-9]&#x27;</span> ]]<br></code></pre></td></tr></table></figure></li><li>大小写转换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#转成大写</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(U)str&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str:u&#125;</span><br><span class="hljs-comment">#转成小写</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(L)str&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str:l&#125;</span><br><span class="hljs-comment">#首字母大写</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(C)str&#125;</span><br></code></pre></td></tr></table></figure></li><li>目录文件名截取<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">filepath=/a/b/c.x<br><span class="hljs-comment"># :h 是取目录名，即最后一个 / 之前的部分，如果没有 / 则为 .</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;filepath:h&#125;</span> <span class="hljs-comment">#/a/b</span><br><span class="hljs-comment"># :t 是取文件名，即最后一个 / 之后的部分，如果没有 / 则为字符串本身</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;filepath:t&#125;</span> <span class="hljs-comment">#c.x</span><br><span class="hljs-comment"># :e 是取文件扩展名，即文件名中最后一个点之后的部分，如果没有点则为空</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;filepath:e&#125;</span> <span class="hljs-comment">#x</span><br><span class="hljs-comment"># :r 是去掉末尾扩展名的路径</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;filepath:r&#125;</span> <span class="hljs-comment">#/a/b/c</span><br></code></pre></td></tr></table></figure></li><li>相对路径转绝对路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#功能相当于$(readlink -f $filepath)</span><br>filepath1=a.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;filepath1:A&#125;</span><br></code></pre></td></tr></table></figure></li><li>分割字符串<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用空格作为分隔符，多个空格也只算一个分隔符</span><br>str=<span class="hljs-string">&#x27;aa bb cc dd&#x27;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str[(w)2]&#125;</span><span class="hljs-comment">#bb</span><br><br><span class="hljs-comment"># 指定分隔符</span><br>str=<span class="hljs-string">&#x27;aa--bb--cc&#x27;</span><br><span class="hljs-comment"># 如果分隔符是 : 就用别的字符作为左右界，比如 ws.:.</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str[(ws:--:)3]&#125;</span><span class="hljs-comment">#cc</span><br></code></pre></td></tr></table></figure></li></ol><p><span id = "arrAndStr"></span></p><ul><li>转成数组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=()<span class="hljs-variable">$&#123;=str&#125;</span>)<span class="hljs-comment">#默认按空格分隔,可以设置IFS环境变量设置,也可以按以下方法</span><br>str=<span class="hljs-string">&quot;1:2::4&quot;</span><br><br><span class="hljs-comment">#可以是多个字符,如**s/::/**,以**::**为分隔,同时也可以写成**.::.**,不必一定</span><br><span class="hljs-comment">#使用**/**,可以用任意符号</span><br>str_array=(<span class="hljs-variable">$&#123;(s/:/)str&#125;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str_array</span> <span class="hljs-comment">#1 2 4 #忽略空字符串</span><br><span class="hljs-comment"># 保留其中的空字符串</span><br>str_array=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;(@s/:/)str&#125;</span>&quot;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str_array</span>[3]<span class="hljs-comment">#该值为空</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str_array</span>[4]<br>str+=(1234)<span class="hljs-comment">#字符串直接变成一个包含两个元素的数组</span><br></code></pre></td></tr></table></figure></li></ul><ol start="13"><li>读取文件内容到字符串<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 比用 str=$(cat filename) 性能好很多</span><br>str=$(&lt;filename)<br><br><span class="hljs-comment"># 比用 cat filename 性能好很多，引号不能省略</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(&lt;filename)</span>&quot;</span><br><br><span class="hljs-comment"># 遍历每行，引号不能省略</span><br><span class="hljs-keyword">for</span> i (<span class="hljs-variable">$&#123;(f)&quot;$(&lt;filename)&quot;&#125;</span>) &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br><span class="hljs-comment"># 小文件或者需要频繁调用时，尽量不要用 sed</span><br><span class="hljs-comment">#输出第2行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;&quot;$(&lt;test.txt)&quot;[(f)2]&#125;</span><br><span class="hljs-comment"># 输出包含 “ang” 的第一行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;&quot;$(&lt;test.txt)&quot;[(fr)*ang*]&#125;</span><br></code></pre></td></tr></table></figure></li><li>读取进程输出到字符串<br>就是把$(&lt;filename)换城$(cmd)</li></ol><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [some condition]&#123;<br>&#125; <span class="hljs-keyword">elif</span>&#123;<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="print和printf"><a href="#print和printf" class="headerlink" title="print和printf"></a>print和printf</h3><p>zsh支持print和printf,<code>print -</code>再按tab健就可以查看所有选项,<code>printf %</code>再按tab键就可以查看所有格式化的东西</p><p>print支持的选项</p><table><thead><tr><th align="center">选项</th><th align="center">功能</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">-C</td><td align="center">按列输出</td><td align="center">列数</td></tr><tr><td align="center">-D</td><td align="center">替换路径成带~的版本</td><td align="center">无</td></tr><tr><td align="center">-N</td><td align="center">使用\x00(null)作为字符串的间隔,默认是空格</td><td align="center">无</td></tr><tr><td align="center">-O</td><td align="center">降序排列</td><td align="center">无</td></tr><tr><td align="center">-P</td><td align="center">输出颜色和特殊样式</td><td align="center">无</td></tr><tr><td align="center">-R</td><td align="center">模拟echo命令</td><td align="center">无</td></tr><tr><td align="center">-S</td><td align="center">放命令放入了历史命令文件(要加引号)</td><td align="center">无</td></tr><tr><td align="center">-X</td><td align="center">替换所有tab为空格</td><td align="center">tab对应空格数</td></tr><tr><td align="center">-a</td><td align="center">和-c&#x2F;-C一起使用时,改为从左到右</td><td align="center">无</td></tr><tr><td align="center">-b</td><td align="center">识别出bindkey转义字符串</td><td align="center">无</td></tr><tr><td align="center">-c</td><td align="center">按列输出(自动决定列数)</td><td align="center">无</td></tr><tr><td align="center">-f</td><td align="center">同printf</td><td align="center">无</td></tr><tr><td align="center">-i</td><td align="center">和-o&#x2F;-O一起使用时,大小写不敏感排序</td><td align="center">无</td></tr><tr><td align="center">-l</td><td align="center">使用换行符作为字符串分隔符</td><td align="center">无</td></tr><tr><td align="center">-m</td><td align="center">只输出匹配的字符串</td><td align="center">匹配模式字符串</td></tr><tr><td align="center">-n</td><td align="center">不自动添加最后的换行符</td><td align="center">无</td></tr><tr><td align="center">-o</td><td align="center">升序排列</td><td align="center">无</td></tr><tr><td align="center">-r</td><td align="center">不处理转义字符</td><td align="center">无</td></tr><tr><td align="center">-s</td><td align="center">放命令放入历史命令文件(不要加引号)</td><td align="center">无</td></tr><tr><td align="center">-u</td><td align="center">指定fd输出</td><td align="center">fd号</td></tr><tr><td align="center">-v</td><td align="center">把内容保存到变量</td><td align="center">变量名</td></tr><tr><td align="center">-x</td><td align="center">替换行首的tab为空格</td><td align="center">tab对应空格数</td></tr><tr><td align="center">-z</td><td align="center">把内容放置到命令行编辑区</td><td align="center">无</td></tr></tbody></table><ul><li>颜色<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># %B 加粗 %b 取消加粗</span><br><span class="hljs-comment"># %F&#123;red&#125; 前景色 %f 取消前景色</span><br><span class="hljs-comment"># %K&#123;red&#125; 背景色 %k 取消背景色</span><br><span class="hljs-comment"># %U 下滑线 %u 取消下滑线</span><br><span class="hljs-comment"># %S 反色 %s 取消反色</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># black or 0  red     or 1</span><br><span class="hljs-comment"># green or 2  yellow  or 3</span><br><span class="hljs-comment"># blue  or 4  magenta or 5</span><br><span class="hljs-comment"># cyan  or 6  white   or 7</span><br><br><span class="hljs-comment"># 显示加粗的红色 abc</span><br><span class="hljs-built_in">print</span> -P <span class="hljs-string">&#x27;%B%F&#123;red&#125;abc&#x27;</span><br><br><span class="hljs-comment"># 没覆盖到的功能可以用原始的转义符号，可读性比较差</span><br><span class="hljs-comment"># 4[0-7] 背景色</span><br><span class="hljs-comment"># 3[0-7] 前景色</span><br><span class="hljs-comment"># 0m 正常 1m 加粗 2m 变灰 3m 斜体 4m 下滑钱 5m 闪烁 6m 快速闪烁 7m 反色</span><br><br><span class="hljs-comment"># 显示闪烁的红底绿字 abc</span><br>% <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;\033[41;32;5mabc\033[0m&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table><thead><tr><th align="center">通配符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">任意数量的字符</td></tr><tr><td align="center">?</td><td align="center">任意一个字符</td></tr><tr><td align="center">[abcd]</td><td align="center">abcd中的任意一个字符</td></tr><tr><td align="center">[^abcd]</td><td align="center">除abcd中的任意一个字符</td></tr><tr><td align="center">[a-c]</td><td align="center">a和c之间的一个字符</td></tr><tr><td align="center">[a-cB-Dxyz]</td><td align="center">a和c之间、B和D之间以及xyz中的一个字符</td></tr><tr><td align="center">&lt;1-100&gt;</td><td align="center">1和100之间的整数</td></tr><tr><td align="center">&lt;-50&gt;</td><td align="center">0和50之间的整数</td></tr><tr><td align="center">&lt;100-&gt;</td><td align="center">大于100的整数</td></tr><tr><td align="center">-</td><td align="center">任意正整数和0</td></tr><tr><td align="center">([a-c]|&lt;1-100&gt;)</td><td align="center">a和c之间的一个字符或者1和100之间的整数</td></tr></tbody></table><p><strong>加强版,要支持需要加上<code>setopt EXTENDED_GLOB</code></strong></p><table><thead><tr><th align="center">通配符</th><th align="center">含义</th><th align="center">匹配的样式</th></tr></thead><tbody><tr><td align="center">^abc</td><td align="center">除了 abc 外的任意字符串</td><td align="center">aaa</td></tr><tr><td align="center">abc^abc</td><td align="center">以 abc 开头，但后边不是 abc 的字符串</td><td align="center">abcabd</td></tr><tr><td align="center">a*c~abc</td><td align="center">符合 a*c 但不是 abc 的字符串</td><td align="center">adc</td></tr><tr><td align="center">a#</td><td align="center">任意数量（包括 0）个 a</td><td align="center">aaa</td></tr><tr><td align="center">b##</td><td align="center">一个或者多个b</td><td align="center">b</td></tr><tr><td align="center">(ab)##</td><td align="center">一个或者多个ab</td><td align="center">abab</td></tr><tr><td align="center">(#i)abc</td><td align="center">忽略大小写的abc</td><td align="center">AbC</td></tr><tr><td align="center">(#i)ab(#I)c</td><td align="center">忽略大小写的 ab 接着 c</td><td align="center">ABc</td></tr><tr><td align="center">(#l)aBc</td><td align="center">和 c 忽略大小写，但 B 必须大写 的 aBc</td><td align="center">aBC</td></tr><tr><td align="center">(#a1)abc</td><td align="center">最多错（多或缺也算）一个字符的 abc</td><td align="center">a2c 或 ab 或 abcd</td></tr></tbody></table><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><ol><li>数组定义<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(a <span class="hljs-string">&quot;bb cc&quot;</span> <span class="hljs-built_in">dd</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#打印所有元素在一行</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$array</span> <span class="hljs-comment">#每行输出一个元素</span><br></code></pre></td></tr></table></figure></li><li>元素读写<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span>[3]<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span>[-1]<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$#array</span> <span class="hljs-comment">#获取长度</span><br>array[3]=some<br>array[3]=() <span class="hljs-comment">#删除元素</span><br>array+=eeee <span class="hljs-comment">#添加元素</span><br><span class="hljs-built_in">unset</span> array <span class="hljs-comment">#删除整个数组</span><br></code></pre></td></tr></table></figure></li><li>数组拼接<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">array1+=(e f g)<br>array1+=(<span class="hljs-variable">$array2</span>) <span class="hljs-comment">#小括号必须加,不加的话,则array2视为一个字符串</span><br></code></pre></td></tr></table></figure></li><li><a href="#arrAndStr">字符串与数组</a></li><li>数组遍历<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">for</span> i (<span class="hljs-variable">$array1</span>)&#123;<br><span class="hljs-attribute">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br><span class="hljs-comment">#同时遍历两个数组</span><br>for i (<span class="hljs-variable">$array1</span> <span class="hljs-variable">$array2</span>)&#123;<br><span class="hljs-attribute">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><a href="#slice">切片访问</a></li><li><a href="#find">元素查找</a></li><li>元素排序<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(o)array&#125;</span> <span class="hljs-comment">#升序排列</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(O)array&#125;</span> <span class="hljs-comment">#降序排列</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(oi)array&#125;</span> <span class="hljs-comment">#大小写不敏感升序排列</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(on)array&#125;</span> <span class="hljs-comment">#按数字升序排列</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(Oa)array&#125;</span> <span class="hljs-comment">#反转数组元素</span><br></code></pre></td></tr></table></figure></li><li>去重<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(u)array&#125;</span><br></code></pre></td></tr></table></figure></li><li>构造连续字符或数值数组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(aa&#123;bb,cc,11&#125;) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#aabb aacc aa11</span><br>array=(aa&#123;1..3&#125;) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#aa1 aa2 aa3</span><br>array=(aa&#123;15..19..2&#125;) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#aa15 aa17 aa19</span><br>array=(aa&#123;19..15..2&#125;) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#aa19 aa17 aa15</span><br>array=(aa&#123;01..03&#125;) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#aa01 aa02 aa03</span><br>array=(aa&#123;a..c&#125;) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#aaa aab aac</span><br>array=(aa&#123;Y..c&#125;) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span> <span class="hljs-comment">#ASCII码顺序</span><br></code></pre></td></tr></table></figure></li><li>从文件构造数组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># f 的功能是将字符串以换行符分隔成数组</span><br><span class="hljs-comment"># 双引号不可省略，不然会变成一个字符串，引号也可以加在 $&#123; &#125; 上</span><br>array=(<span class="hljs-variable">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>)<br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$array</span><br><span class="hljs-comment">#a</span><br><span class="hljs-comment">#bb</span><br><span class="hljs-comment">#ccc</span><br><span class="hljs-comment">#dddd</span><br><span class="hljs-comment"># 不加引号的效果</span><br>array=(<span class="hljs-variable">$&#123;(f)$(&lt;test.txt)&#125;</span>)<br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$array</span><br><span class="hljs-comment">#a bb ccc dddd</span><br><br><span class="hljs-comment"># 从文件构造数组，并将每行按分隔符 : 分隔后输出所有列</span><br><span class="hljs-keyword">for</span> i (<span class="hljs-variable">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>) &#123;<br>    array=(<span class="hljs-variable">$&#123;(s.:.)i&#125;</span>)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$array</span>[1,-1]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>从文件列表构造数组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(/usr/bin/vim*)<br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$array</span><br><span class="hljs-comment">#/usr/bin/vim</span><br><span class="hljs-comment">#/usr/bin/vimdiff</span><br><span class="hljs-comment">#/usr/bin/vimtutor</span><br><br><span class="hljs-comment"># 要比 ls /usr/bin/[a-b]?? | wc -l 快很多</span><br>array=(/usr/bin/[a-b]??) &amp;&amp; <span class="hljs-built_in">print</span> <span class="hljs-variable">$#array</span><br></code></pre></td></tr></table></figure></li><li>数组交集差集<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 两个数组的交集，只输出两个数组都有的元素,如果有重复元素不会去重</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array1:*array2&#125;</span><br><span class="hljs-comment"># 两个数组的差集，只输出 array1 中有，而 array2 中没有的元素</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array1:|array2&#125;</span><br></code></pre></td></tr></table></figure></li><li>数组交叉合并<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从 array1 取一个，再从 array2 取一个，以此类推，一个数组取完了就结束</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array1:^array2&#125;</span><br><span class="hljs-comment"># 如果用 :^^，只有一个数组取完了的话，继续从头取，直到第二个数组也取完了</span><br>% <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array1:^^array2&#125;</span><br></code></pre></td></tr></table></figure></li><li>对数组中的字符串进行统一处理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># :t 是取字符串中的文件名，可以用在数组上，取所有元素的文件名</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$&#123;array:t&#125;</span><br><span class="hljs-comment"># :e 是取扩展名，如果没有没有扩展名，结果数组中不会添加空字符串</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$&#123;array:e&#125;</span><br><span class="hljs-comment"># 字符串替换等操作也可以对数组使用，替换所有字符串</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$&#123;array/a/j&#125;</span><br><span class="hljs-comment"># :# 是排除匹配到的元素，类似 grep -v</span><br><span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;array:#a*&#125;</span><br><span class="hljs-comment"># 前边加 (M)，是反转后边的效果，即只输出匹配到的元素，类似 grep</span><br><span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;(M)array:#a*&#125;</span><br><span class="hljs-comment"># 多个操作可以同时进行，(U) 是把字符串转成大写字母</span><br><span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;(UM)array:#a*&#125;</span><br><br><span class="hljs-comment"># 截断或对齐数组中的字符串</span><br>array=(abc bcde cdefg defghi)<br><br><span class="hljs-comment"># 只取每个字符串的最后两个字符</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(l:2:)array&#125;</span><br>bc de <span class="hljs-built_in">fg</span> hi<br><br><span class="hljs-comment"># 用空格补全字符串并且右对齐</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$&#123;(l:7:)array&#125;</span><br>    abc<br>   bcde<br>  cdefg<br> defghi<br><br><span class="hljs-comment"># 用指定字符补全</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$&#123;(l:7::0:)array&#125;</span><br>0000abc<br>000bcde<br>00cdefg<br>0defghi<br><br><span class="hljs-comment"># 用指定字符补全，第二个字符只用一次</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$&#123;(l:7::0::1:)array&#125;</span><br>0001abc<br>001bcde<br>01cdefg<br>1defghi<br><br><span class="hljs-comment"># 左对齐</span><br><span class="hljs-built_in">print</span> -l <span class="hljs-variable">$&#123;(r:7::0::1:)array&#125;</span><br>abc1000<br>bcde100<br>cdefg10<br>defghi1<br></code></pre></td></tr></table></figure></li></ol><h3 id="字典变量"><a href="#字典变量" class="headerlink" title="字典变量"></a>字典变量</h3><ol><li>定义<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">typeset</span> -A table<br><span class="hljs-comment"># 先声明,或者用 local，二者功能是一样的</span><br><span class="hljs-built_in">local</span> -A table<br><br><span class="hljs-comment"># 赋值的语法和数组一样，但顺序依次是键、值、键、值</span><br>table=(k1 v1 k2 v2)<br><span class="hljs-comment">#可以声明赋值一块,local -A table=(k1 v1 k2 v2)</span><br><br><span class="hljs-comment"># 直接用 echo 只能输出值</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$table</span> <span class="hljs-comment">#v1 v2</span><br><br><span class="hljs-comment"># 使用 (kv) 同时输出键和值，(kv) 会把键和值都放到同一个数组里</span><br>% <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(kv)table&#125;</span> <span class="hljs-comment">#k1 v1 k2 v2</span><br><br><span class="hljs-comment"># 哈希表的大小是键值对的数量</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$#table</span><br></code></pre></td></tr></table></figure></li><li>读写<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$table</span>[k2]<br>table[k2]=<span class="hljs-string">&quot;v2&quot;</span><br><span class="hljs-comment"># 删除元素的方法和数组不同，引号不能省略</span><br><span class="hljs-built_in">unset</span> <span class="hljs-string">&quot;table[k1]&quot;</span><br></code></pre></td></tr></table></figure></li><li>哈希表拼接<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 追加元素的方法和数组一样</span><br>table+=(k4 v4 k5 v5)<br><span class="hljs-comment"># 拼接哈希表，要展开成数组再追加</span><br>table1+=(<span class="hljs-variable">$&#123;(kv)table2&#125;</span>)<br></code></pre></td></tr></table></figure></li><li>哈希表遍历<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只遍历值</span><br><span class="hljs-keyword">for</span> i (<span class="hljs-variable">$table</span>) &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br><span class="hljs-comment"># 只遍历键</span><br><span class="hljs-keyword">for</span> i (<span class="hljs-variable">$&#123;(k)table&#125;</span>) &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br><span class="hljs-comment"># 同时遍历键和值</span><br><span class="hljs-keyword">for</span> k v (<span class="hljs-variable">$&#123;(kv)table&#125;</span>) &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$k</span> -&gt; <span class="hljs-variable">$v</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>键是否存在<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(($+table[k1]))<br></code></pre></td></tr></table></figure></li><li>元素排序<br>和数组类似,增加k、v两个选项<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只对值排序</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(o)table&#125;</span><br><br><span class="hljs-comment"># 只对键排序</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(ok)table&#125;</span><br><br><span class="hljs-comment"># 键值放在一起排序</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(okv)table&#125;</span><br></code></pre></td></tr></table></figure></li><li>从字符串、文件构造哈希表<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">str=<span class="hljs-string">&quot;k1 v1 k2 v2&quot;</span><br><span class="hljs-built_in">local</span> -A table=(<span class="hljs-variable">$&#123;=str&#125;</span>)<br><span class="hljs-comment">#从文件构造和数组类似</span><br></code></pre></td></tr></table></figure></li><li>对哈希表的每个元素统一处理<br>可参见数组,同时增加kv两个选项<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#值转成大写</span><br><span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;(U)table&#125;</span><br><span class="hljs-comment">#键转成大写</span><br><span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;(Uk)table&#125;</span><br><span class="hljs-comment">#键值转成大写</span><br><span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;(Ukv)table&#125;</span><br><span class="hljs-comment"># 排除匹配到的值</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;table:#v1&#125;</span><br><span class="hljs-comment"># 只输出匹配到的键</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(Mk)table:#k[1-2]&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>zsh通常不指定数值是整形还是浮点型,通常直接赋值，<strong>虽然默认为字符串</strong>,但作数值计算时自动判断,但可以如下指明类型,同时在双小括号里做c语言的任何符号计算,同时括号内变量可以不需要加$符号(貌似是zsh的一般特性,适用于许多其他场合)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">integer</span> i=123<br><span class="hljs-built_in">float</span> f=12.56<br><span class="hljs-comment">#(t)用于输出变量类型</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(t)i&#125;</span> <span class="hljs-comment">#integer</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(t)f&#125;</span> <span class="hljs-comment">#float</span><br><span class="hljs-comment"># 注意一旦指定了变量类型，类型就不会变了，除非再重新指定其他类型，或者用 unset 删除掉 </span><br><span class="hljs-comment"># 如果把浮点数赋值给整数变量，会取整</span><br>i=12.34<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> <span class="hljs-comment">#会输出12</span><br></code></pre></td></tr></table></figure><ul><li>数学函数<br>zsh&#x2F;mathfunc模块包含数学函数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">zmodload</span> -i zsh/mathfunc<br><span class="hljs-built_in">echo</span> $((sin(<span class="hljs-number">0</span>)+ceil(<span class="hljs-number">14.4</span>)))<br></code></pre></td></tr></table></figure><strong>函数列表</strong></li></ul><table><thead><tr><th align="center">函数名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">abs</td><td align="center">取绝对值</td></tr><tr><td align="center">ceil</td><td align="center">向上取整</td></tr><tr><td align="center">floor</td><td align="center">向下取整</td></tr><tr><td align="center">int</td><td align="center">截断取整</td></tr><tr><td align="center">float</td><td align="center">转换成浮点数</td></tr><tr><td align="center">sqrt</td><td align="center">开平方</td></tr><tr><td align="center">cbrt</td><td align="center">开立方</td></tr><tr><td align="center">log</td><td align="center">自然对数</td></tr><tr><td align="center">log10</td><td align="center">常用对数</td></tr><tr><td align="center">rand48</td><td align="center">随机数</td></tr></tbody></table><p>还有:acos、acosh、asin、asinh、atan、atanh、cos、cosh、erf、erfc、exp、 expm1、fabs、gamma、j0、j1、lgamma、log1p、logb、sin、sinh、tan、 tanh、y0、y1、ilogb、signgam、copysign、fmod、hypot、nextafter、jn、 yn、ldexp、scalb</p><h3 id="变量修饰语"><a href="#变量修饰语" class="headerlink" title="变量修饰语"></a>变量修饰语</h3><p><strong>一般两种格式:</strong></p><ul><li><code>$&#123;(x)var&#125;</code> var是变量名,x是一个或多个字母,</li><li><code>$&#123;var:x&#125;</code> var是变量名,x是一个或多个字母,或其他符号</li></ul><p><strong>注意:加了修饰语的变量依然是变量,可以当普通变量处理,可以嵌套使用,$符号后不可以有空格</strong></p><table><thead><tr><th align="center">修饰符</th><th align="center">举例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:-</td><td align="center"><code>echo $&#123;var:-abc&#125;</code></td><td align="center">如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc</td></tr><tr><td align="center">-</td><td align="center"><code>echo $&#123;var-abc&#125;</code></td><td align="center">如果变量有值,则输出原值,如果变量不存在,则输出abc</td></tr><tr><td align="center">:&#x3D;</td><td align="center"><code>echo $&#123;var:=abc&#125;</code></td><td align="center">如果变量有值,则输出原值,如果变量不存在、为空字符串、空数组等,则输出abc并且赋值给var</td></tr><tr><td align="center">::&#x3D;</td><td align="center"><code>echo $&#123;var::=123&#125;</code></td><td align="center">不管有没有值，村不存在，都输出123，并且重新赋值</td></tr><tr><td align="center">:?</td><td align="center"><code>echo $&#123;var:?error&#125;</code></td><td align="center">var没有值或不存在,则直接报错,否则输出原值</td></tr><tr><td align="center">:+</td><td align="center"><code>echo $&#123;var:+123&#125;</code></td><td align="center">如果var有值,则输出123,否则输出空</td></tr><tr><td align="center">(F)</td><td align="center"><code>echo $&#123;(F)array&#125;</code></td><td align="center">把数组中的元素以换行符拼接成字符串,不加任何修饰的话则是空格拼接</td></tr><tr><td align="center">(j&#x2F;x&#x2F;)</td><td align="center"><code>echo $&#123;(j/-=/)array&#125;</code></td><td align="center">把数组中的元素以-&#x3D;两个字符连接</td></tr><tr><td align="center">(s&#x2F;x&#x2F;)</td><td align="center"><code>echo $&#123;(s/==/)str&#125;</code></td><td align="center">把字符串中的字符以&#x3D;&#x3D;两个字符为分隔符分成数组</td></tr><tr><td align="center">(t)</td><td align="center"><code>echo $&#123;(t)var&#125;</code></td><td align="center">输出变量的类型:integer float scalar array association</td></tr><tr><td align="center"><code>(P)</code></td><td align="center"><code>var=abc abc=123 echo $&#123;(P)var&#125;</code></td><td align="center">多重替换,输出123</td></tr><tr><td align="center">[#n]</td><td align="center"><code>echo $(([#16] 255))</code></td><td align="center">以n进制显示十进制整数</td></tr><tr><td align="center">n#</td><td align="center"><code>echo $((16#ff))</code></td><td align="center">显示n进制整数为十进制</td></tr></tbody></table><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与bash基本一致,增加了<code>unfunction fun</code>删除某个函数的功能,还有就是规避了<code>$*</code>和<code>$@</code>的区别,zsh推荐只用<code>$*</code></p><h3 id="替代find和ls"><a href="#替代find和ls" class="headerlink" title="替代find和ls"></a>替代find和ls</h3><p>需要开启扩展通配符:setopt EXTENDED_GLOB<br><strong>通配符修饰语列表</strong></p><table><thead><tr><th align="center">名称</th><th align="center">含义</th><th align="center">使用样例或补充说明</th></tr></thead><tbody><tr><td align="center">&#x2F;</td><td align="center">目录</td><td align="center"></td></tr><tr><td align="center">F</td><td align="center">非空</td><td align="center">&#x2F;F(非空目录) &#x2F;^F(空目录)</td></tr><tr><td align="center">.</td><td align="center">普通文件</td><td align="center"></td></tr><tr><td align="center">@</td><td align="center">符号链接</td><td align="center"></td></tr><tr><td align="center">&#x3D;</td><td align="center">socket文件</td><td align="center"></td></tr><tr><td align="center">p</td><td align="center">FIFO 文件</td><td align="center"></td></tr><tr><td align="center">*</td><td align="center">可执行的普通文件</td><td align="center"></td></tr><tr><td align="center">%</td><td align="center">设备文件</td><td align="center"></td></tr><tr><td align="center">%b</td><td align="center">块设备文件</td><td align="center"></td></tr><tr><td align="center">%c</td><td align="center">字符设备文件</td><td align="center"></td></tr><tr><td align="center">r</td><td align="center">文件拥有着有读权限</td><td align="center"></td></tr><tr><td align="center">w</td><td align="center">文件拥有着有写权限</td><td align="center"></td></tr><tr><td align="center">x</td><td align="center">文件拥有着有执行权限</td><td align="center"></td></tr><tr><td align="center">A</td><td align="center">文件拥有组用户有读权限</td><td align="center"></td></tr><tr><td align="center">I</td><td align="center">文件拥有组用户有写权限</td><td align="center"></td></tr><tr><td align="center">E</td><td align="center">文件拥有组用户有执行权限</td><td align="center"></td></tr><tr><td align="center">R</td><td align="center">任何用户都有读权限</td><td align="center"></td></tr><tr><td align="center">W</td><td align="center">任何用户都有写权限</td><td align="center"></td></tr><tr><td align="center">X</td><td align="center">任何用户都有执行权限</td><td align="center"></td></tr><tr><td align="center">s</td><td align="center">设置了setuid的文件</td><td align="center"></td></tr><tr><td align="center">S</td><td align="center">设置了setgid的文件</td><td align="center"></td></tr><tr><td align="center">t</td><td align="center">设置了粘滞位（sticky bit）的文件</td><td align="center"></td></tr><tr><td align="center">f</td><td align="center">符合指定的权限</td><td align="center">f0644 f4755 f700</td></tr><tr><td align="center">e</td><td align="center"></td><td align="center">暂无</td></tr><tr><td align="center">+</td><td align="center">大于某个数</td><td align="center">通常跟数字,与其他配合使用</td></tr><tr><td align="center">d</td><td align="center">指定设备号</td><td align="center"></td></tr><tr><td align="center">l</td><td align="center">硬连接个数</td><td align="center">l-2（小于 2） l+3（大于 3）</td></tr><tr><td align="center">U</td><td align="center">当前用户拥有</td><td align="center"></td></tr><tr><td align="center">G</td><td align="center">当前用户所在组拥有</td><td align="center"></td></tr><tr><td align="center">u</td><td align="center">指定用户 id 拥有</td><td align="center">u1000</td></tr><tr><td align="center">g</td><td align="center">指定用户组 id 拥有</td><td align="center">g1000</td></tr><tr><td align="center">a</td><td align="center">指定文件的 atime</td><td align="center">访问时间,默认单位是天,可跟单位M(月)、w(周)、h(小时)、m(分钟)、s(秒)、+(指定时间之前)、-(指定时间之内)</td></tr><tr><td align="center">m</td><td align="center">指定文件的 mtime</td><td align="center">修改时间,可跟单位、+-,<code>print -l *(.mm+1)</code></td></tr><tr><td align="center">c</td><td align="center">指定文件的 ctime</td><td align="center">文件状态属性修改时间,可跟单位、+-,<code>print -l *(.cm+1)</code></td></tr><tr><td align="center">L</td><td align="center">指定文件大小</td><td align="center">默认单位是字节,单位有k、m和p(512字节的块),也可以大写,<code>print -l *(.Lm-1)</code></td></tr><tr><td align="center">^</td><td align="center">取反</td><td align="center">&#x2F;^F</td></tr><tr><td align="center">-</td><td align="center">小于某个数</td><td align="center">通常跟数字,与其他配合使用</td></tr><tr><td align="center">M</td><td align="center"></td><td align="center">暂无</td></tr><tr><td align="center">T</td><td align="center"></td><td align="center">暂无</td></tr><tr><td align="center">N</td><td align="center">如果没匹配到，返回空而不报错</td><td align="center"></td></tr><tr><td align="center">D</td><td align="center">包含隐藏文件（. 开头）</td><td align="center"></td></tr><tr><td align="center">n</td><td align="center">按数值大小排序</td><td align="center">下文有说明</td></tr><tr><td align="center">o</td><td align="center">递增排序</td><td align="center">下文有说明</td></tr><tr><td align="center">O</td><td align="center">递减排序</td><td align="center">下文有说明</td></tr><tr><td align="center">[n]</td><td align="center">只取第 n 个文件</td><td align="center">.[5]</td></tr><tr><td align="center">[n1,n2]</td><td align="center">取第 n1 到 n2 个文件</td><td align="center">&#x2F;[5,10]</td></tr><tr><td align="center">:X</td><td align="center"></td><td align="center">暂无</td></tr></tbody></table><ol><li>文件排序</li></ol><p>可供排序的因子:n(文件名),L(大小),I(硬连接数),a(atime),m(mtime),c(ctime),d(所在目录深度,从深到浅)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按文件名排序，同一目录下的文件和目录名会一起排，而不是先排目录再排文件</span><br><span class="hljs-comment">#**/*,指当前目录和子目录</span><br><span class="hljs-built_in">print</span> -l **/*(.on)<br>bb.txt<br>cc/aa.txt<br>cc/dd.txt<br>zz.txt<br><br><span class="hljs-comment"># 按文件的目录深度逆序排，d 是从深往浅排，O 是逆序</span><br><span class="hljs-built_in">print</span> -l **/*(.Od)<br>zz.txt<br>bb.txt<br>cc/dd.txt<br>cc/aa.txt<br><br><span class="hljs-comment"># 先按文件名排序，然后再按大小排序，这样大小相同的文件依然是按文件名排的</span><br><span class="hljs-built_in">print</span> -l **/*(.onoL)<br>bb.txt<br>cc/aa.txt<br>cc/dd.txt<br>cc.txt<br></code></pre></td></tr></table></figure><ol start="2"><li><p>组合使用</p><p> 类型和类型之间要用逗号个开,逗号前后内容互不干扰(取反^只影响到逗号之前的内容)</p><p> <code>print -l *(/m-2,.Lm-3oL,@D)</code></p></li><li><p>批量重命名zmv</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用前需要先加载进来</span><br><span class="hljs-built_in">autoload</span> -U zmv<br><br><span class="hljs-comment"># 将所有 txt 文件扩展名改成 conf</span><br><span class="hljs-comment"># 参数要用单引号扩起来，$1 代表第一个参数中括号中的内容</span><br> zmv <span class="hljs-string">&#x27;(*).txt&#x27;</span> <span class="hljs-string">&#x27;$1.conf&#x27;</span><br><br><span class="hljs-comment"># 如果加了 -W 参数，zmv 会自动识别文件名中需要保留的部分</span><br> zmv -W <span class="hljs-string">&#x27;*.txt&#x27;</span> <span class="hljs-string">&#x27;*.conf&#x27;</span><br><br><span class="hljs-comment"># 调整文件名各部分的前后顺序</span><br>zmv <span class="hljs-string">&#x27;(*).(*).txt&#x27;</span> <span class="hljs-string">&#x27;$2.$1.txt&#x27;</span><br><span class="hljs-comment"># 加 -n 预览而不实际运行</span><br>zmv -n <span class="hljs-string">&#x27;(*).(*).txt&#x27;</span> <span class="hljs-string">&#x27;$2.$1.txt&#x27;</span><br><span class="hljs-built_in">mv</span> -- a.b.txt b.a.txt<br><br><span class="hljs-comment"># 0 1 2 ... 前添加 0，以便和 10 11 12 ... 宽度一致</span><br>zmv <span class="hljs-string">&#x27;([0-9]).(*)&#x27;</span> <span class="hljs-string">&#x27;0$1.$2&#x27;</span><br><span class="hljs-comment"># 去掉开头的一个 0</span><br>zmv <span class="hljs-string">&#x27;(0)(*)&#x27;</span> <span class="hljs-string">&#x27;$2&#x27;</span><br><br><span class="hljs-comment"># 文件整理到目录</span><br>zmv <span class="hljs-string">&#x27;(*) - (*) - (*).txt&#x27;</span> <span class="hljs-string">&#x27;$1/$2 - $3.txt&#x27;</span><br><br><span class="hljs-comment"># 转换大小写</span><br>zmv <span class="hljs-string">&#x27;(*).txt&#x27;</span> <span class="hljs-string">&#x27;$&#123;(U)1&#125;.txt&#x27;</span><br>zmv <span class="hljs-string">&#x27;(*).txt&#x27;</span> <span class="hljs-string">&#x27;$&#123;(L)1&#125;.txt&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>不展开通配符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">calc</span></span>() &#123;<br>    <span class="hljs-built_in">zmodload</span> zsh/mathfunc<br>    <span class="hljs-built_in">echo</span> $(($*))<br>&#125;<br>calc 12+12<br>calc 12*12 <span class="hljs-comment">#会报错</span><br><span class="hljs-built_in">noglob</span> calc 12*12 <span class="hljs-comment">#可以</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="local和typeset"><a href="#local和typeset" class="headerlink" title="local和typeset"></a>local和typeset</h3><p>local和typeset基本一样(除了不能用-f和-g这两个选项)</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">-l</td><td align="center">强制字符串内容为小写</td><td align="center"><code>local -l str=abcABC</code></td></tr><tr><td align="center">-u</td><td align="center">强制字符串内容为大写</td><td align="center"><code>local -u str=abcABC</code></td></tr><tr><td align="center">-x</td><td align="center">设置为环境变量</td><td align="center"><code>export str=abc</code>等价于<code>local -x str=abc</code></td></tr><tr><td align="center">-r</td><td align="center">只读</td><td align="center"><code>local -r strl=abc</code>等价于<code>readonly str1=abc</code></td></tr><tr><td align="center">-U</td><td align="center">设置数组不包含重复元素</td><td align="center"><code>local -U array=(aa bb aa cc)</code></td></tr><tr><td align="center">-Z n</td><td align="center">设置整数位数</td><td align="center">不够用0不全,超过会被截断</td></tr><tr><td align="center">-i n</td><td align="center">设置整数为其他进制显示</td><td align="center">支持2-36</td></tr><tr><td align="center"><code>local &#123;i,j,k&#125;=123</code></td><td align="center">赋值多个变量为同一个值</td><td align="center"></td></tr><tr><td align="center">-T</td><td align="center">绑定字符串和数组</td><td align="center"><code>local -T DIR dir</code>,DIR为字符串,dir为数组,以冒号连接,主要用于path变量</td></tr><tr><td align="center">-p</td><td align="center">显示变量的定义方式</td><td align="center">显示脚本如何定义该变量的</td></tr></tbody></table><h3 id="双引号问题"><a href="#双引号问题" class="headerlink" title="双引号问题"></a>双引号问题</h3><p>zsh不需要像bash那样频繁加双引号来避免错误。<br>zsh需要加双引号的场景:</p><ol><li>像这样的包含字符或者特殊符号的字符串 <code>&quot;aa bb \t \n *&quot;</code> 出现在代码中时，两边要加双引号</li><li>在用<code>$()</code>调用命令时，如果希望结果按一个字符串处理，需要加上双引</li><li>如果想将数组当单个字符串处理，需要加双引号，<code>array=(a b); print -l &quot;$array&quot;</code></li><li>其他的原本不是单个字符串的东西，需要转成单个字符串的场景，要加双引号</li></ol><p>其余通常不加,其中典型场景:</p><ol><li>任何情况下，字符串变量的两边都不需要加双引号，无论里边的内容多么特殊，或者变量存不存在，都没有关系，如<code>$str</code></li><li>如果不转换类型（比如数组转成字符串），任何变量的两边都不需要加双引号</li><li><code>$1 $2 $*</code>这些参数（其实它们也都是单个字符串），都不需要加双引号，无论内容是什么，或者参数是否存在。</li></ol><h3 id="mapfile读写文件"><a href="#mapfile读写文件" class="headerlink" title="mapfile读写文件"></a>mapfile读写文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">zmodload</span> zsh/mapfile<br><br><span class="hljs-comment"># 这样就可以创建文件并写入内容，如果文件存在则会被覆盖</span><br><span class="hljs-built_in">mapfile</span>[test.txt]=<span class="hljs-string">&quot;ab cd&quot;</span><br><span class="hljs-built_in">cat</span> test.txt<br><span class="hljs-comment">#ab cd</span><br><br><span class="hljs-comment"># 判断文件是否存在</span><br>(($+mapfile[test.txt])) &amp;&amp; <span class="hljs-built_in">echo</span> good<br><span class="hljs-comment">#good</span><br><br><span class="hljs-comment"># 读取文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$mapfile</span>[test.txt]<br><span class="hljs-comment">#ab cd</span><br><br><span class="hljs-comment"># 删除文件</span><br><span class="hljs-built_in">unset</span> <span class="hljs-string">&quot;mapfile[test.txt]&quot;</span><br><br><span class="hljs-comment"># 遍历文件</span><br><span class="hljs-keyword">for</span> i (<span class="hljs-variable">$&#123;(k)mapfile&#125;</span>) &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br><span class="hljs-comment">#test1.txt</span><br><span class="hljs-comment">#test2.txt</span><br></code></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> [some condition]&#123;<br><span class="hljs-built_in">break</span>/continue<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">until [some condition]&#123;<br><span class="hljs-keyword">break</span>/<span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#样例</span><br><span class="hljs-keyword">for</span> i (aa bb cc)&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br>array=(aa bb cc)<br><span class="hljs-keyword">for</span> i (<span class="hljs-variable">$array</span>) &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br><span class="hljs-keyword">for</span> ((i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++))&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br><span class="hljs-keyword">for</span> i (&#123;1..10&#125;)&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">repeat</span> <span class="hljs-number">5</span>&#123;<br><span class="hljs-attribute">echo</span> good<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> <span class="hljs-variable">$i</span> &#123;<br>(a)<br><span class="hljs-built_in">echo</span> 1<br>;;<br><br>(b)<br><span class="hljs-built_in">echo</span> 2<br><span class="hljs-comment">#继续执行下一个匹配的语句(不再进行匹配)</span><br>;&amp;<br><br>(c)<br><span class="hljs-built_in">echo</span> 3<br><span class="hljs-comment">#继续向下匹配，看是否有满足条件的分支</span><br>;|<br><br>(c)<br><span class="hljs-built_in">echo</span> 33<br>;;<br><br>(*)<br><span class="hljs-built_in">echo</span> oher<br>;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户输入选择语句"><a href="#用户输入选择语句" class="headerlink" title="用户输入选择语句"></a>用户输入选择语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> i (aa bb cc)&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>&#125;<br></code></pre></td></tr></table></figure><p>必须加break,否则会一直让用户选择</p><h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>语句1<br>&#125; always&#123;<br>语句2<br>&#125;<br></code></pre></td></tr></table></figure><p>无论语句1是否出错,都执行语句2</p><h3 id="socket模块"><a href="#socket模块" class="headerlink" title="socket模块"></a>socket模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 监听连接端=======</span><br><span class="hljs-comment"># 首先要加载 socket 模块</span><br><span class="hljs-built_in">zmodload</span> zsh/net/socket<br><br><span class="hljs-built_in">zsocket</span> -l test.sock<br>listenfd=<span class="hljs-variable">$REPLY</span><br><span class="hljs-comment"># 此处阻塞等待连接</span><br><span class="hljs-built_in">zsocket</span> -a <span class="hljs-variable">$listenfd</span><br><span class="hljs-comment"># 连接建立完成</span><br>fd=<span class="hljs-variable">$REPLY</span><br><span class="hljs-comment"># 然后 $fd 就可读可写</span><br><span class="hljs-built_in">cat</span> &lt;&amp;<span class="hljs-variable">$fd</span><br><br><span class="hljs-comment"># 发起连接端==========</span><br><span class="hljs-built_in">zmodload</span> zsh/net/socket<br><span class="hljs-built_in">zsocket</span> test.sock<br>fd=<span class="hljs-variable">$REPLY</span><br><span class="hljs-built_in">echo</span> good &gt;&amp;<span class="hljs-variable">$fd</span><br><br><span class="hljs-comment"># 关闭监听端========</span><br><span class="hljs-built_in">exec</span> &#123;listenfd&#125;&gt;&amp;-<br><span class="hljs-built_in">exec</span> &#123;fd&#125;&gt;&amp;-<br><span class="hljs-built_in">rm</span> test.sock<br><br><span class="hljs-comment"># 关闭连接端======</span><br><span class="hljs-built_in">exec</span> &#123;fd&#125;&gt;&amp;-<br></code></pre></td></tr></table></figure><h3 id="TCP模块"><a href="#TCP模块" class="headerlink" title="TCP模块"></a>TCP模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 监听连接端=======</span><br><span class="hljs-comment"># 首先要加载 tcp 模块</span><br><span class="hljs-built_in">zmodload</span> zsh/net/tcp<br><br><span class="hljs-built_in">ztcp</span> -l 1234<br>listenfd=<span class="hljs-variable">$REPLY</span><br><span class="hljs-comment"># 此处阻塞等待连接</span><br><span class="hljs-built_in">ztcp</span> -a <span class="hljs-variable">$listenfd</span><br><span class="hljs-comment"># 连接建立完成</span><br>fd=<span class="hljs-variable">$REPLY</span><br><br><span class="hljs-comment"># 然后 $fd 就可读可写</span><br><span class="hljs-built_in">cat</span> &lt;&amp;<span class="hljs-variable">$fd</span><br><br><span class="hljs-comment"># 发起连接端===========</span><br><span class="hljs-comment"># 首先要加载 tcp 模块</span><br><span class="hljs-built_in">zmodload</span> zsh/net/tcp<br><br><span class="hljs-built_in">ztcp</span> 127.0.0.1 1234<br><span class="hljs-comment"># 连接建立完成</span><br>fd=<span class="hljs-variable">$REPLY</span><br><br><span class="hljs-comment"># 然后 $fd 就可读可写</span><br><span class="hljs-built_in">echo</span> good &gt;&amp;<span class="hljs-variable">$fd</span><br><br><span class="hljs-comment"># 关闭发起连接端===============</span><br><span class="hljs-comment"># fd 是之前存放 fd 号的变量</span><br>% <span class="hljs-built_in">ztcp</span> -c <span class="hljs-variable">$fd</span><br><br><span class="hljs-comment"># 关闭监听连接端=============</span><br>% <span class="hljs-built_in">ztcp</span> -c <span class="hljs-variable">$listenfd</span><br>% <span class="hljs-built_in">ztcp</span> -c <span class="hljs-variable">$fd</span><br></code></pre></td></tr></table></figure><p>接受端例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/zsh</span><br><br><span class="hljs-built_in">zmodload</span> zsh/net/tcp<br><br>(($+<span class="hljs-number">1</span>)) || &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$&#123;0:t&#125;</span> port&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>&#125;<br><br><span class="hljs-built_in">ztcp</span> -l <span class="hljs-variable">$1</span><br>listenfd=<span class="hljs-variable">$REPLY</span><br><br>[[ <span class="hljs-variable">$listenfd</span> == &lt;-&gt; ]] || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-built_in">ztcp</span> -a <span class="hljs-variable">$listenfd</span><br>    fd=<span class="hljs-variable">$REPLY</span><br>    [[ <span class="hljs-variable">$fd</span> == &lt;-&gt; ]] || <span class="hljs-built_in">continue</span><br><br>    <span class="hljs-built_in">cat</span> &lt;&amp;<span class="hljs-variable">$fd</span><br>    <span class="hljs-built_in">ztcp</span> -c <span class="hljs-variable">$fd</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发送端例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/zsh</span><br><br><span class="hljs-built_in">zmodload</span> zsh/net/tcp<br><br>((<span class="hljs-variable">$#</span> &gt;= <span class="hljs-number">2</span>)) || &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$&#123;0:t&#125;</span> [hostname] port message&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>&#125;<br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$1</span> == &lt;0-65535&gt; ]] &#123;<br>    <span class="hljs-built_in">ztcp</span> 127.0.0.1 <span class="hljs-variable">$1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">ztcp</span> <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">shift</span><br>&#125;<br><br>fd=<span class="hljs-variable">$REPLY</span><br>[[ <span class="hljs-string">&quot;<span class="hljs-variable">$fd</span>&quot;</span> == &lt;-&gt; ]] || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;*[2,-1]&#125;</span> &gt;&amp;<span class="hljs-variable">$fd</span><br><span class="hljs-built_in">ztcp</span> -c <span class="hljs-variable">$fd</span><br></code></pre></td></tr></table></figure><h3 id="日期模块-zmodload-zsh-datetime"><a href="#日期模块-zmodload-zsh-datetime" class="headerlink" title="日期模块:zmodload zsh&#x2F;datetime"></a>日期模块:zmodload zsh&#x2F;datetime</h3><table><thead><tr><th align="center">例子</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>echo $EPOCHSECONDS</code></td><td align="center">从光标1970年到现在的秒数,等价于<code>date +%s</code></td></tr><tr><td align="center"><code>echo $EPOCHREALTIME</code></td><td align="center">输出高精度当前时间戳</td></tr><tr><td align="center"><code>echo $epochtime</code></td><td align="center">输出当前时间戳的秒和纳秒</td></tr><tr><td align="center"><code>strftime &quot;%Y-%m-%d %H:%M:%S (%u)&quot; $EPOCHSECONDS</code></td><td align="center">按指定格式输出</td></tr><tr><td align="center"><code>strftime -s str &quot;%Y-%m-%d %H:%M:%S (%u)&quot; $EPOCHSECONDS</code></td><td align="center">存到变量str中</td></tr><tr><td align="center"><code>strftime -r &quot;%Y-%m-%d %H:%M:%S (%u)&quot; &quot;2017-09-01 10:10:58 (5)&quot;</code></td><td align="center">上述的反操作</td></tr></tbody></table><h3 id="gdbm模块–存在文件里的哈希表"><a href="#gdbm模块–存在文件里的哈希表" class="headerlink" title="gdbm模块–存在文件里的哈希表"></a>gdbm模块–存在文件里的哈希表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">% <span class="hljs-built_in">zmodload</span> zsh/db/gdbm<br><br><span class="hljs-comment"># 声明数据库文件对应的哈希表</span><br><span class="hljs-built_in">local</span> -A sampledb<br><span class="hljs-comment"># 创建数据库文件，文件名是 sample.gdbm，对应 sampledb 哈希表</span><br><span class="hljs-comment"># 如果该文件已经存在，则会继续使用该文件</span><br>ztie -d db/gdbm -f sample.gdbm sampledb<br><br><span class="hljs-comment"># 然后正常使用 sampledb 哈希表即可，数据会同步写入到数据库文件中</span><br>sampledb[k1]=v1<br>sampledb+=(k2 v2 k3 v3)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;(kv)sampledb&#125;</span><br><span class="hljs-comment">#k1 v1 k2 v2 k3 v3</span><br><br><span class="hljs-comment"># 获取数据库文件路径</span><br>% zgdbmpath sampledb<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$REPLY</span><br><span class="hljs-comment">#/home/goreliu/sample.gdbm</span><br><br><span class="hljs-comment"># 释放数据库文件</span><br>zuntie -u sampledb<br><br><br><span class="hljs-comment"># 也可以用只读的方式加载数据库文件</span><br>ztie -r -d db/gdbm -f sample.gdbm sampledb<br><span class="hljs-comment"># 但这样的话，需要用 zuntie -u 释放数据库文件</span><br>zuntie -u sampledb<br></code></pre></td></tr></table></figure><h3 id="sched–-计划调度命令"><a href="#sched–-计划调度命令" class="headerlink" title="sched–&gt;计划调度命令"></a>sched–&gt;计划调度命令</h3><p>zmodload zsh&#x2F;sched</p><ul><li><code>sched +5 ls</code>5秒后运行ls</li><li><code>sched</code>列出已有任务</li><li><code>sched -n</code>去除第n个待运行命令</li></ul><h3 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h3><p>可以用man zshmodules查看模块功能</p><ul><li>zsh&#x2F;system:底层文件读写</li><li>zsh&#x2F;pcre:正则表达式库</li><li>zsh&#x2F;stat:内部stat，取代stat</li><li>zsh&#x2F;zftp:内部ftp客户端</li><li>zsh&#x2F;zprof:性能追踪工具</li><li>zsh&#x2F;zpty:操作pty的命令</li><li>zsh&#x2F;zselect:select系统调用的封装</li></ul><h3 id="TRAPINT"><a href="#TRAPINT" class="headerlink" title="TRAPINT"></a>TRAPINT</h3><p>该函数名,捕获任意信号?有待研究,如下的代码竟然捕捉到SIGINT信号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/zsh</span><br><br><span class="hljs-comment"># SIGINT 是 2 信号，ctrl + c 会触发</span><br><span class="hljs-function"><span class="hljs-title">TRAPINT</span></span>() &#123;<br>    <span class="hljs-comment"># 处理一些退出前的善后工作</span><br>    <span class="hljs-built_in">sleep</span> 333<br>&#125;<br><br><span class="hljs-built_in">sleep</span> 1000<br></code></pre></td></tr></table></figure><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><ol><li>统一使用4个空格来缩进</li><li>非特殊场景,每行代码不超过100个字符</li><li>在前一行尾部加一个空格和 \ 折行，折行后缩进一层（4 个空格）。</li><li>如果缩进的是一个文本块，可以使用对齐缩进，也可以使用 4 个空格的固定缩进。</li><li>如果是在 aa &amp;&amp; bb || cc、[[ ]] 或者 (( )) 中折行，&amp;&amp; || 放在下一行的行首。</li><li>在缩进和对齐之外的场景，不允许出现逻辑上不必要的连续多个空格。</li><li><ul><li>&amp;&amp; | 等双元运算符左右要加一个空格。</li></ul></li><li>! ~等一元运算符和作用对象之间不加空格。</li><li>( ) 和 (( )) { } 内侧不加空格，[[ ]] 因为语法需要，内侧加一个空格。</li><li><code>;</code>之前不加空格，之后加一个空格。</li><li>定义函数时（以及在 (( )) 中调用函数时），函数名和 ( 之间不加空格。</li><li>if while 等关键字和后边的内容之间加一个空格</li><li>if<code>[[ ]] &#123;</code>等场景中，<code>&#123;</code>和前边的内容之间加一个空格。</li><li>变量和<code>[ ]</code>之间不加空格，用<code>[ ]</code>取数组或者哈希表值时，<code>[ ]</code>内侧不加空格。</li><li><code>&gt; &lt;</code>等重定向符号和文件或者文件描述符之间不加空格。</li><li>非特殊场景，不允许出现超过两个连续空行。</li><li>#!&#x2F;bin&#x2F;zsh 后加一个空行。</li><li>if while 等语句块之后加一个空行。</li><li>定义函数后加一个空行。</li><li>逻辑关系不强的两行（或者两块）代码之间，根据逻辑关系强弱（自行判断），加一个或两个空行。</li><li>在判断条件的场景，不使用<code>[ ]</code>，用<code>[[ ]]</code>代替。</li><li>在数值计算的场景，使用<code>$(( ))</code>而不是<code>$[ ]</code>。</li><li>使用数值时，两端不加引号。</li><li>用<code>$var</code>取变量值时，两边不加双引号，除非需要将非字符串变量转换成字符串。</li><li>在非必须场景，不需要加<code>$&#123;var&#125;</code>中的大括号。</li><li>变量使用前要明确指明是局部变量（用 local 定义）还是全局变量（用 typeset -g 定义）。</li><li>能用局部变量的地方全部使用局部变量（用 local 定义）。</li><li>变量名中的单词可以使用下划线分隔或者驼峰风格，在不影响可读性的情况也可以使用全小写字母，但在同一个文件中要一致。</li><li>字符串常量两端可以添加双引号或者单引号，但同一个文件中风格要一致。</li><li>可以使用 name() 或者 function name() 定义函数，但同一个文件中风格要一致。</li><li>非特殊场景，单个脚本文件不超过 1000 行。</li></ol><h3 id="bash和zsh的简明对比"><a href="#bash和zsh的简明对比" class="headerlink" title="bash和zsh的简明对比"></a>bash和zsh的简明对比</h3><table><thead><tr><th align="center">bash</th><th align="center">zsh</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>&quot;$var&quot;</code></td><td align="center"><code>$var</code></td><td align="center">避免变量中有空格导致异常</td></tr><tr><td align="center"><code>&quot;$@&quot;</code></td><td align="center"><code>$*</code></td><td align="center">避免变量中有空格导致异常</td></tr><tr><td align="center"><code>&quot;$&#123;array[@]&#125;&quot;</code></td><td align="center"><code>$array</code></td><td align="center">取数组所有元素，@ 可改成 *</td></tr><tr><td align="center">&#96;”$</td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件系统与存储</title>
    <link href="/2021/10/21/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8/"/>
    <url>/2021/10/21/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>原始磁盘-&gt;创建分区(划分磁盘)-&gt;在各个分区上创建文件系统-&gt;挂载文件系统</p><h3 id="创建分区-fdisk和cfdisk"><a href="#创建分区-fdisk和cfdisk" class="headerlink" title="创建分区-&gt;fdisk和cfdisk"></a>创建分区-&gt;fdisk和cfdisk</h3><p>cfdisk更加界面友好一点</p><ul><li>查看当前系统所有设备<code>fdisk -l</code></li><li>对某个设备进行分区<code>fdisk [设备名]</code>或<code>cfdisk [设备名]</code>,注意设备名后面不加数字,加数字的都是该设备上的某分区,如:<strong>&#x2F;dev&#x2F;sda是设备,&#x2F;dev&#x2F;sda1则是已分好的分区</strong>,(之后进入工具,有关知识待实践)</li></ul><h3 id="创建文件系统-mkfs"><a href="#创建文件系统-mkfs" class="headerlink" title="创建文件系统-&gt;mkfs.*"></a>创建文件系统-&gt;mkfs.*</h3><p>目前流行的系统有:ext4(mkfs.ext4),zfs(mkfs.zfs),btrfs(mkfs.btrfs)<br><code>mkfs.* [分区名]</code>分区名有数字,这会格式化分区后建文件系统</p><h3 id="挂载文件系统-mount"><a href="#挂载文件系统-mount" class="headerlink" title="挂载文件系统-&gt;mount"></a>挂载文件系统-&gt;mount</h3><p><code>mount -t [ext4、zfs、btrfs] [设备名] [目录]</code>把已经建好文件系统的分区挂载到指定目录</p><h3 id="文件系统的检查与修复-fsck"><a href="#文件系统的检查与修复-fsck" class="headerlink" title="文件系统的检查与修复-&gt;fsck"></a>文件系统的检查与修复-&gt;fsck</h3><p>fsck检查文件系统时,文件系统必须未挂载,fsck使用&#x2F;etc&#x2F;fstab文件自动检查文件系统类型,如果&#x2F;etc&#x2F;fstab里没有该文件系统分区的信息,需要加-t选项指明文件系统类型,如下:<br><code>fsck -t ext4 /dev/sdb1</code></p><h2 id="逻辑卷"><a href="#逻辑卷" class="headerlink" title="逻辑卷"></a>逻辑卷</h2><p>逻辑卷可以把不同物理设备上的分区,结合起来,动态增加文件系统大小:下面是类比<br>物理卷(实质上是各个原始分区)-&gt;卷组(多个物理卷)-&gt;逻辑卷(在卷组基础上加上逻辑关联,新成整体)。<br>物理设备-&gt;某个原始分区-&gt;文件系统。<br>Linux系统将一个逻辑卷视为一个物理分区,格式化一个文件系统后可以挂载</p><h3 id="pvcreate转化物理分区为物理卷"><a href="#pvcreate转化物理分区为物理卷" class="headerlink" title="pvcreate转化物理分区为物理卷"></a>pvcreate转化物理分区为物理卷</h3><p><code>sudo pvcreate /dev/sdb1</code>这实际只是标记该分区为一个物理卷<br><code>sudo pvdisplay /dev/sdb1</code>显示物理卷的详细信息</p><h3 id="vgcreate创建卷组"><a href="#vgcreate创建卷组" class="headerlink" title="vgcreate创建卷组"></a>vgcreate创建卷组</h3><p><code>sudo vgcreate Vol1 /dev/sdb1 /dev/sdx</code>将两个物理卷创建到一个卷组<br><code>sudo vgdisplay Vol1</code>查看卷组信息</p><h3 id="lvcreate创建逻辑卷"><a href="#lvcreate创建逻辑卷" class="headerlink" title="lvcreate创建逻辑卷"></a>lvcreate创建逻辑卷</h3><p><code>sudo lvcreate -l 100%FREE -n lvtest Vol1</code>在卷组上创建逻辑卷,-l制定多少可用的卷组空间,以百分比表示,-L选项以字节为单位,-n制定逻辑卷的名字,更多选项看man(有待研究)<br><code>sudo lvdisplay Vol1</code>查看逻辑卷</p><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p><code>sudo mkfs.ext4 /dev/Vol1/lvtest</code>创建文件系统<br><code>sudo mount /dev/Vol1/lvtest /mnt</code>挂载<br>注意:路径中同时指明了卷组名和逻辑卷名</p><h3 id="修改逻辑卷-待建"><a href="#修改逻辑卷-待建" class="headerlink" title="修改逻辑卷(待建)"></a>修改逻辑卷(待建)</h3><ul><li>vgchange 激活和禁用卷组</li><li>vgremove 删除卷组</li><li>vgextend 将物理卷加到卷组中</li><li>vgreduce 从卷组中删除物理卷</li><li>lvextend 增加逻辑卷的大小</li><li>lvreduce 减小逻辑卷的大小</li></ul><h2 id="一些tips"><a href="#一些tips" class="headerlink" title="一些tips"></a>一些tips</h2><h3 id="windows下U盘只读不可写问题"><a href="#windows下U盘只读不可写问题" class="headerlink" title="windows下U盘只读不可写问题"></a>windows下U盘只读不可写问题</h3><p>a.<code>df -h</code>查找挂载点<br>b.<code>sudo umount 位置</code>卸载U盘而不拔掉<br>c.<code>sudo dosfsck -v -a 文件系统分区(如:/dev/sdb1)</code>修复故障<br>d.<code>sudo mount 文件系统 挂载点</code>重新挂载</p><h3 id="自动挂载磁盘"><a href="#自动挂载磁盘" class="headerlink" title="自动挂载磁盘:"></a>自动挂载磁盘:</h3><p>　a.<code>fdisk -l</code>查看可挂载磁盘<br>　b.<code>df -h</code>查看已挂载的磁盘<br>　c.<code>blkid</code>获取目标磁盘的uuid和属性<br>　d.<code>vi /etc/fstab</code>添加开机mount,格式:UUID&#x3D;xx &#x2F;home&#x2F;nanbert&#x2F;disk ext4 defaults 1 1 </p><h3 id="从现有文件创建映像文件"><a href="#从现有文件创建映像文件" class="headerlink" title="从现有文件创建映像文件"></a>从现有文件创建映像文件</h3><p><code>genisoimage -o cd-rom.iso -R -J ~/cd-rom-files</code></p><h3 id="CD-ROM"><a href="#CD-ROM" class="headerlink" title="CD-ROM"></a>CD-ROM</h3><p>清除一张CD-ROM<br><code>wodim dev=/dev/cdrw blank=fast</code><br>写入一个映像文件进CD-ROM<br><code>wodim dev=/dev/cdrw image.iso</code></p><h3 id="挂载某个镜像"><a href="#挂载某个镜像" class="headerlink" title="挂载某个镜像"></a>挂载某个镜像</h3><p><code>sudo mount xx.iso -o loop /mnt</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件权限</title>
    <link href="/2021/10/20/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <url>/2021/10/20/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="&#x2F;etc&#x2F;passwd文件"></a>&#x2F;etc&#x2F;passwd文件</h3><p>&#x2F;etc&#x2F;passwd包含了一些与用户有关的信息 以’:’分割符依次为以下内容</p><ul><li>登陆用户名</li><li>用户账户的UID(数字形式)</li><li>用户账户的组ID(GID)(数字形式)</li><li>用户账户的文本描述(备注字段)</li><li>用户HOME目录位置</li><li>用户默认shell<br>root的UID为0,1000以下的UID为系统服务账户预留,普通用户为1000以后</li></ul><h3 id="etc-shadow文件"><a href="#etc-shadow文件" class="headerlink" title="&#x2F;etc&#x2F;shadow文件"></a>&#x2F;etc&#x2F;shadow文件</h3><p>&#x2F;etc&#x2F;shadow文件管理着各个用户的密码,** 最好不要擅自修改,可能会造成系统崩溃**,以冒号分隔符,有以下字段</p><ul><li>与&#x2F;etc&#x2F;passwd 文件中的登录名字段对应的登录名</li><li>加密后的密码</li><li>自上次修改密码后过去的天数（自 1970 年 1 月 1 日开始计算）</li><li>多少天后才能更改密码</li><li>多少天后必须更改密码</li><li>密码过期前提前多少天提醒用户更改密码</li><li>密码过期后多少天禁用用户账户</li><li>用户账户被禁用的日期（用自 1970 年 1 月 1 日到当天的天数表示）</li><li>预留字段给将来使用</li></ul><h3 id="useradd命令与useradd文件"><a href="#useradd命令与useradd文件" class="headerlink" title="useradd命令与useradd文件"></a>useradd命令与useradd文件</h3><p><code>useradd</code>命令使用系统的默认配置存在&#x2F;etc&#x2F;default&#x2F;useradd文件中,arch linux默认配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># useradd defaults file for ArchLinux</span><br><span class="hljs-comment"># original changes by TomK</span><br>GROUP=<span class="hljs-built_in">users</span><br>HOME=/home<br>INACTIVE=-1<br>EXPIRE=<br>SHELL=/bin/bash<br>SKEL=/etc/skel<br>CREATE_MAIL_SPOOL=no<br></code></pre></td></tr></table></figure><p>含义如下:</p><ul><li>新用户会被添加到 users 的公共组；</li><li>新用户的 HOME 目录将会位于&#x2F;home&#x2F;loginname；</li><li>新用户账户密码在过期后不会被禁用；</li><li>新用户账户未被设置过期日期；</li><li>新用户账户将 bash shell 作为默认 shell；</li><li>系统会将&#x2F;etc&#x2F;skel 目录下的内容复制到用户的 HOME 目录下；(一般用于一些bash或vim配置文件等)</li><li>系统不会为该用户账户在 mail 目录下创建一个用于接收邮件的文件。<br>最常用命令<br><code>sudo useradd -m test</code>创建新HOME目录名为test。</li></ul><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p><code>sudo userdel -r test</code>删除用户test，-r选项表明删除test用户的HOME目录及邮件目录</p><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>usermod命令很强大(基本可以替代接下来的修改命令)可以用来修改&#x2F;etc&#x2F;passwd中的大部分字段,常用选项如下:</p><ul><li>-c修改备注字段</li><li>-e修改过期日期</li><li>-g修改默认的登录组</li><li>-l修改用户账户的登录名</li><li>-L锁定账户,使用户无法登录</li><li>-p修改账户的密码</li><li>-U解除锁定,使用户能够登录</li><li><code>sudo usermod -G shared test</code>把test用户添加到组shared <span id = "usermod"></span></li></ul><h3 id="passwd和chpasswd"><a href="#passwd和chpasswd" class="headerlink" title="passwd和chpasswd"></a>passwd和chpasswd</h3><ul><li><code>sudo passwd test</code>修改test用户的密码,如果只用passwd只会改变当前用户的密码,-e选项能强制用户下次登录时修改密码。</li><li>chpasswd可以大量修改密码<code>sudo chpasswd &lt; users.txt</code>能从users.txt中自动读取登录名和密码对(由冒号分割)列表</li></ul><h3 id="chsh、chfn和chage"><a href="#chsh、chfn和chage" class="headerlink" title="chsh、chfn和chage"></a>chsh、chfn和chage</h3><ul><li><code>sudo chsh -s /bin/zsh test</code>快速修改默认的用户登录shell。必须全路径</li><li><code>sudo chfn test</code>为用户test添加备注字段,默认会用finger命令的输出作为备注字段,如果没装finger，会询问你。</li><li>chage命令用来帮助管理用户的有效期<ul><li>-d:设置上次修改密码到现在的天数</li><li>-E:设置密码过期的日期</li><li>-l:设置密码过期到锁定账户的天数</li><li>-m:设置修改密码之间最少要多少天</li><li>-W:设置密码过期前多久开始出现提醒信息<br>change命令的日期值可以用下面两种方式</li><li>YYYY-MM-DD</li><li>代表从1970年1月1日起到该日期的天数</li></ul></li></ul><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><h3 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="&#x2F;etc&#x2F;group文件"></a>&#x2F;etc&#x2F;group文件</h3><p>与&#x2F;etc&#x2F;passwd文件类似,以冒号分割符有以下四个字段:</p><ul><li>组名</li><li>组密码(用的不多,允许非成员通过它成为该组的成员)</li><li>GID</li><li>属于该组的用户列表(<strong>注意:文件中不一定列全了,一定要结合&#x2F;etc&#x2F;passwd来查看</strong>)</li></ul><h3 id="groupadd命令"><a href="#groupadd命令" class="headerlink" title="groupadd命令"></a>groupadd命令</h3><p><code>sudo groupad shared</code>创建新组,默认没有用户<br>见<a href="#usermod">usermod</a>那节,为组添加用户</p><h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><ul><li>-g:修改已有组GID<code>groupmod -g newGid groupName</code></li><li>-n:修改组名<code>groupmod -n newname oldname</code></li></ul><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p><code>umask</code>命令会输出4位数的掩码值,以<strong>0022</strong>为例(第一个0仅代表8进制的意思):</p><ul><li>二进制: 000 010 010</li><li>取消新文件和新目录的组w权限和其他用户w权限<br>对照表</li></ul><table><thead><tr><th align="center">Oct</th><th align="center">Bin</th><th align="center">File Mode</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">000</td><td align="center">—</td></tr><tr><td align="center">1</td><td align="center">001</td><td align="center">–x</td></tr><tr><td align="center">2</td><td align="center">010</td><td align="center">-w-</td></tr><tr><td align="center">3</td><td align="center">011</td><td align="center">-wx</td></tr><tr><td align="center">4</td><td align="center">100</td><td align="center">r–</td></tr><tr><td align="center">5</td><td align="center">101</td><td align="center">r-x</td></tr><tr><td align="center">6</td><td align="center">110</td><td align="center">rw-</td></tr><tr><td align="center">7</td><td align="center">111</td><td align="center">rwx</td></tr></tbody></table><p>问题是touch默认的权限是644(即rw-r–r–),怎么来的呢？首先文件有个全权限为666,目录的全权限为777,666把umask值的1位减去即是644</p><h2 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h2><p>文件除了权限外,还有属性设置,也很有用</p><ul><li>chattr:为文件添加或删除属性<code>sudo chattr +i testfile</code>,<code>sudo chattr -i testfile</code></li><li>lsattr:查看文件的属性<code>sudo lsattr testfile</code></li></ul><p>可通过<code>man chattr</code>来查看可以设置哪些属性,下表列出常用属性</p><table><thead><tr><th align="center">字母</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">文件不能被删除、改名、设置链接、也无法写入或新增数据</td></tr><tr><td align="center">a</td><td align="center">只能增加数据,而不能删除也不能修改数据</td></tr></tbody></table><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>chmod [ugoa][+&#x3D;-][rwxst] 文件名表<br>也可以用八进制数字设置:<code>chmod xxx file</code>,对应关系见上表</p><h3 id="三个特殊权限"><a href="#三个特殊权限" class="headerlink" title="三个特殊权限:"></a>三个特殊权限:</h3><ul><li>setuid(SUID)–仅作用于可执行文件,<code>chmod u+s program</code> 当应用到一个可执行文件(s标志会出现在拥有者的x权限上)，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。<br>b.setgid(SGID)–作用于可执行文件和目录(s标志会出现在组的x权限上) ,<code>chmod g+s dir</code> 把有效用户组 ID 从真正的用户组ID更改为文件所有者的组ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。<br>c.sticky位(SBIT)–仅作用于目录(t标志会出现在其他的x权限上)<code>chmod o+t dir</code>,如果一个目录设置了sticky位，那么它能阻止用户删除或重命名文件,除非用户是这个目录的所有者,或者是文件所有者,或是超级用户。这个经常用来控制访问共享目录,比方说&#x2F;tmp。<br>这3种权限也可以用另一套八进制来表示<code>chmod xxxx file</code>第一个数字是设置特殊权限的,这与umask的第一位<strong>含义不同</strong></li></ul><table><thead><tr><th align="center">Oct</th><th align="center">Bin</th><th align="center">File Mode</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">000</td><td align="center">所有特殊位为0</td></tr><tr><td align="center">1</td><td align="center">001</td><td align="center">sticky置位</td></tr><tr><td align="center">2</td><td align="center">010</td><td align="center">SGID置位</td></tr><tr><td align="center">3</td><td align="center">011</td><td align="center">SGID和sticky置位</td></tr><tr><td align="center">4</td><td align="center">100</td><td align="center">SUID置位</td></tr><tr><td align="center">5</td><td align="center">101</td><td align="center">SUID和sticky置位</td></tr><tr><td align="center">6</td><td align="center">110</td><td align="center">SUID和SGID置位</td></tr><tr><td align="center">7</td><td align="center">111</td><td align="center">所有位都置位</td></tr></tbody></table><h3 id="可执行权限上的’S-T’-还有X有待研究"><a href="#可执行权限上的’S-T’-还有X有待研究" class="headerlink" title="可执行权限上的’S&#x2F;T’(还有X有待研究)"></a>可执行权限上的’S&#x2F;T’(还有X有待研究)</h3><p>没有执行权限的 UID&#x2F;GID 和黏置位。小写的 s 与 t 都是取代 x 这个权限的，但是当下达 7666 权限时，也就是说,user,group 以及 others 都没有 x 这个可执行的标志时(因为是 666)，特殊权限位也不可能有权限执行，7666 的结果为-rwSrwSrwT。所以，这个 S, T 代表的就是“空的”执行权限，不具有执行权限。换个说法， SUID +s 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件拥有者都无法执行时，也就不存在权限给其他人使用了。</p><h2 id="chown和chgrp"><a href="#chown和chgrp" class="headerlink" title="chown和chgrp"></a>chown和chgrp</h2><p>这两个命令除了root外,只有修改用户处于原用户组和新用户组才能修改</p><ul><li><code>chown username.groupname filename</code>改变文件的用户和用户组,用户组名可选,当省略username,并在groupname前面加个<code>.</code>,则只改变用户组名,当省略groupname,在username后面加个<code>.</code>,则改变用户并把用户组改成与用户名同名的用户组<ul><li>-R:递归目录</li><li>-h:该文件的所有链接文件也被改变所属关系</li></ul></li><li><code>chgrp groupname filename</code>更改用户组</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell基本概念</title>
    <link href="/2021/10/15/shell%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/10/15/shell%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释: #</li><li>多行注释:  <code>:&lt;&lt;EOF ... EOF</code>或者 <code>:&lt;&lt;! ... !</code></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>创建普通变量: <strong>name&#x3D;”test”</strong> (&#x3D;两边不可有空格)</li><li>创建函数体中的局部变量: ** local name&#x3D;”test”**,函数体及整个脚本中的变量默认都是全局变量,函数体内外皆可访问和改变,函数体内的变量最好用这个加以限制,同时为了得到命令替换的返回码时最好分开写(否则只会捕获local的成功码)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> varname<br>varname=$(<span class="hljs-built_in">command</span>)<br>re=$?<br></code></pre></td></tr></table></figure></li><li>使用变量: <strong>echo $name 或者 echo $(name)</strong> 使用时要加$,重新赋值时不需要</li><li>只读变量: <strong>name&#x3D;”only_read” -&gt; readonly name</strong></li><li>删除变量: <strong>unset name</strong></li></ul><h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><p>字符串与变量展开有密切联系,可以参考那节</p><ol><li>单引号</li></ol><ul><li>单引号变量var&#x3D;’test’,只能原样输出,不能解释变量</li><li>单引号中不能出现一个单引号,转义也不行</li></ul><ol start="2"><li>双引号</li></ol><ul><li>双引号变量<code>var=&quot;my name is $&#123;name&#125;&quot;</code>,可以解释变量</li><li>可以出现转移字符</li></ul><ol start="3"><li>拼接字符串</li></ol><ul><li><code>name=&quot;this is&quot;&quot;my name&quot;;name=&quot;this is my name&quot;;name=&quot;this&quot;is&quot;my name&quot;</code>等效</li></ul><ol start="4"><li><p>获取字符串长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#str&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>提取子字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=<span class="hljs-string">&quot;this is my name&quot;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name:1:4&#125;</span> <span class="hljs-comment">#输出his</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name::4&#125;</span> <span class="hljs-comment">#输出this</span><br></code></pre></td></tr></table></figure></li><li><p>大小写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -u upper<br><span class="hljs-built_in">declare</span> -l lower<br><span class="hljs-comment">#upper将会强制转成SL</span><br>upper=<span class="hljs-string">&quot;sl&quot;</span><br><span class="hljs-comment">#lower将会强制转成sl</span><br>lower=<span class="hljs-string">&quot;SL&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>bash只支持以为数组,不支持多维数组</p><ul><li>定义数组: <strong>array_name&#x3D;(li wang xiang zhang)</strong> (小括号做边界、使用空格分离)或者<strong>declare -a array_name</strong></li><li>单独定义数组的元素: <strong>arraypara[0]&#x3D;”w”;arraypara[3]&#x3D;”s”</strong> (定义时下标可以不连续,同样可以用于赋值)</li><li>获取数组元素<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">array_name[0]=<span class="hljs-string">&quot;li&quot;</span><br>array_name[3]=<span class="hljs-string">&quot;zhang&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array_name[0]&#125;</span> <span class="hljs-comment">#输出&quot;li&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array_name[1]&#125;</span> <span class="hljs-comment">#输出空</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array_name[@]&#125;</span> <span class="hljs-comment">#输出&quot;li zhang&quot;输出数组所有元素,没有元素的下标省略</span><br><span class="hljs-comment">#等价于下面</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array_name[*]&#125;</span><br></code></pre></td></tr></table></figure></li><li>取得元素个数:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;#arrayname[@]&#125;</span><br><span class="hljs-comment">#或者</span><br><span class="hljs-variable">$&#123;#arrayname[\*]&#125;</span><br></code></pre></td></tr></table></figure></li><li>取得单个元素长度: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;#array_name[1]&#125;</span><br></code></pre></td></tr></table></figure></li><li><code>for i in &quot;$&#123;!foo[@]&#125;&quot;</code>取得每个非空元素的下标</li><li><code>foo+=(d e f)</code>添加3个元素</li><li>删除数组不能通过赋空值,只能通过unset,unset还能删除某个元素(这样后面元素往前补)</li><li>没有指明数组下标的访问或赋值皆指向第一个值</li><li>最新版本bash支持关联数组<code>declare -A colors;colors[&quot;red&quot;]=&quot;red&quot;</code></li><li><a href="#funAndArr">函数与数组</a></li><li>取切片<code>echo $&#123;array:0:3&#125;</code></li><li>遍历数组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#方法1</span><br><span class="hljs-keyword">for</span>(( i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable">$&#123;#array[@]&#125;</span>;i++)) <span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[i]&#125;</span>;<br><span class="hljs-keyword">done</span>;<br><span class="hljs-comment">#方法2</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;array[@]&#125;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$element</span><br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#方法3</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;!arr[@]&#125;</span>&quot;</span>;<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\t%s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;arr[$i]&#125;</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>添加数组元素<br><code>$arr+=(a b)</code></li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="FUNCNAME"><a href="#FUNCNAME" class="headerlink" title="FUNCNAME"></a>FUNCNAME</h4><p>该环境变量是个数组，存储当前位置函数调用的堆栈，当只有主程序时，个数为0,当存在调用函数时，第一个总是当前函数名，最后一个为main表示主程序</p><h4 id="BASH-SOURCE"><a href="#BASH-SOURCE" class="headerlink" title="BASH_SOURCE"></a>BASH_SOURCE</h4><p>是一个数组，不过它的第一个元素是当前脚本名称，然后是source它的脚本，依次类推，常用如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果脚本是被source的话</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$BASH_SOURCE</span>&quot;</span> -a <span class="hljs-string">&quot;<span class="hljs-variable">$BASH_SOURCE</span>&quot;</span> != <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    do_something<br><span class="hljs-keyword">else</span> <span class="hljs-comment"># Otherwise, run directly in the shell</span><br>    do_other<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="参数传递的相关特殊变量"><a href="#参数传递的相关特殊变量" class="headerlink" title="参数传递的相关特殊变量"></a>参数传递的相关特殊变量</h3><table><thead><tr><th align="center">变量</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>$0</code></td><td align="center">代表执行的文件名</td></tr><tr><td align="center"><code>$n</code></td><td align="center">代表传入的第n个参数</td></tr><tr><td align="center"><code>$#</code></td><td align="center">参数个数,不包括程序名本身</td></tr><tr><td align="center"><code>$</code></td><td align="center">以一个单字符串显示所有向脚本传递的参数。即为”$1 $2…$n”</td></tr><tr><td align="center"><code>$@</code></td><td align="center">展开成一个从 1 开始的位置参数列表。当它被用双引号引 起来的时候，展开成一个由双引号引起来的字符串，包含了 所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个 字符（默认为一个空格）分隔开。</td></tr><tr><td align="center"><code>$*</code></td><td align="center">把所有参数当成一个大字符串</td></tr><tr><td align="center"><code>$$</code></td><td align="center">该脚本进程ID</td></tr><tr><td align="center"><code>$!</code></td><td align="center">后台运行的最后一个进程ID</td></tr><tr><td align="center"><code>$?</code></td><td align="center">上个调用(最后命令)返回值,0表示没有错误</td></tr></tbody></table><p>有个<strong>shift</strong>命令可以方便处理命令行参数,每次执行该命令的时候,变量$2会移动到$1,变量$3会移动到变量$2,以此类推,$#值也会减1。例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">count=1<br><span class="hljs-keyword">while</span> [[ <span class="hljs-variable">$#</span> -gt 0 ]];<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Argument <span class="hljs-variable">$count</span> = <span class="hljs-variable">$1</span>&quot;</span><br>count=$((count + <span class="hljs-number">1</span>))<br><span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><a href="#jumpopt">getopt和getopts两个命令经常被用来处理传递的参数</a></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let使数字运算更方便:<code>let a++</code>,<code>let a+=2</code></p><h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><ul><li><code>+ - * /</code></li><li>加法运算<ul><li><code>bash val=$(expr 2 + 2)</code> 这么写乘号要加转义,空格也是必须</li><li><code>val=$[2+2]</code> (4个空格不是必要的,不同于条件判断)</li><li><code>val=$((2+2))</code>(4个空格不是必要的)</li></ul></li></ul><p>bash支持任意进制</p><table><thead><tr><th align="center">表示法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">默认10进制</td></tr><tr><td align="center">0number</td><td align="center">8进制</td></tr><tr><td align="center">0xnumber</td><td align="center">16进制</td></tr><tr><td align="center">base#number</td><td align="center">base进制</td></tr></tbody></table><p>在双括号中会被解释成数字,否则默认为字符串</p><h4 id="数字关系运算符"><a href="#数字关系运算符" class="headerlink" title="数字关系运算符"></a>数字关系运算符</h4><p>关系运算符只支持数字,不支持字符串,除非字符串是数字</p><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-eq</code></td><td align="center">相等返回true,<code>[$a -eq $b]</code></td></tr><tr><td align="center"><code>-ne</code></td><td align="center">不相等返回true,<code>[$a -ne $b]</code></td></tr><tr><td align="center"><code>-gt</code></td><td align="center">大于号</td></tr><tr><td align="center"><code>-lt</code></td><td align="center">小于号</td></tr><tr><td align="center"><code>-ge</code></td><td align="center">大于等于号</td></tr><tr><td align="center"><code>-le</code></td><td align="center">小于等于号</td></tr></tbody></table><h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><strong>&#x3D;</strong></td><td align="center">相等返回true,<code>[$a = $b]</code></td></tr><tr><td align="center"><strong>!&#x3D;</strong></td><td align="center">不相等返回true,<code>[$a != $b]</code></td></tr><tr><td align="center"><strong>-z</strong></td><td align="center">字符串长度为0返回true,<code>[-z $b]</code></td></tr><tr><td align="center"><strong>-n</strong></td><td align="center">字符串长度不为0返回true,<code>[-n $b]</code></td></tr><tr><td align="center"><strong>$</strong></td><td align="center">不为空返回true,<code>[$a]</code></td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><strong>!</strong></td><td align="center">非运算,<code>[! false]</code></td></tr><tr><td align="center"><strong>&amp;&amp;</strong></td><td align="center">与运算,<code>[[ $a -lt 20 ]] &amp;&amp; [[$b -gt 100 ]]</code></td></tr><tr><td align="center">**</td><td align="center"></td></tr></tbody></table><p>逻辑判断的括号<br>1.<code>[]</code>:中括号旁边和运算符两边必须添加空格(可以使用，等价于test命令,本文不讲test命令,不推荐)<br>2.<code>[[]]</code>:中括号旁边和运算符两边必须添加空格(字符串验证,文件名时，推荐)<br>3.<code>(())</code>:中括号旁边和运算符两边必须添加空格(数字验证时，推荐)<br>4.<code>[[]]和(())</code>分别是针对数学表达式和字符串表达式的加强版<br>5.<code>[]</code>基本舍弃的原因，它与**&amp;&amp;、||、&lt;和&gt;**不兼容,会报错,它只能用-ne等等这些,例如下面是等价的<br><code>if [[ $a != 1 &amp;&amp; $a !=2 ]]</code>,<code>if [ $a -ne 1 ] &amp;&amp; [ $a != 2 ]</code>,<code>if [ $a -ne 1 -a $a !=2 ]</code><br>6.双括号支持以下额外的符号(没列全,C语言能用的都能用,包括?:)</p><table><thead><tr><th align="center">符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">val++</td><td align="center">后增</td></tr><tr><td align="center">val–</td><td align="center">后减</td></tr><tr><td align="center">++val</td><td align="center">前增</td></tr><tr><td align="center">–val</td><td align="center">前减</td></tr><tr><td align="center">!</td><td align="center">逻辑求反</td></tr><tr><td align="center">~</td><td align="center">位求反</td></tr><tr><td align="center">**</td><td align="center">幂运算</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左位移</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右位移</td></tr><tr><td align="center">&amp;</td><td align="center">布尔和</td></tr><tr><td align="center">&#96;</td><td align="center">&#96;</td></tr><tr><td align="center">&#96;</td><td align="center"></td></tr><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td align="center">&#x3D;~</td><td align="center">用于字符串的模式匹配,右边加上引号会丧失正则的含义，变成普通字符串,避免反斜杠转移，可以赋值给一个变量</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">用于字符串的类型匹配(通配符等),例子<code>if [[ $FILE == foo.* ]]</code></td></tr><tr><td align="center">&#x3D;</td><td align="center">用于字符串是否相同，右边一定要引号括起来，否则是模式匹配，如<code>*</code>则会永远为true</td></tr></tbody></table><h4 id="文件运算符"><a href="#文件运算符" class="headerlink" title="文件运算符"></a>文件运算符</h4><p>file是代表文件名的字符串</p><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">$file1 -ef $file2</td><td align="center">拥有相同的索引号返回True(硬连接)</td></tr><tr><td align="center">$file1 -nt $file2</td><td align="center">file1新于file2返回true</td></tr><tr><td align="center">$file1 -ot $file2</td><td align="center">file1早于file2返回true</td></tr><tr><td align="center"><code>[-b $file]</code></td><td align="center">是块设备文件返回true</td></tr><tr><td align="center"><code>[-c $file]</code></td><td align="center">是字符备文件返回true</td></tr><tr><td align="center"><code>[-d $file]</code></td><td align="center">是目录返回true</td></tr><tr><td align="center"><code>[-f $file]</code></td><td align="center">是普通文件返回true</td></tr><tr><td align="center"><code>[-g $file]</code></td><td align="center">设置了SGID位文件返回true</td></tr><tr><td align="center"><code>[-h $file]</code></td><td align="center">是符号链接返回true</td></tr><tr><td align="center"><code>[-G $file]</code></td><td align="center">由有效组(即当前进程用户组)ID拥有返回true</td></tr><tr><td align="center"><code>[-L $file]</code></td><td align="center">是符号链接返回true</td></tr><tr><td align="center"><code>[-k $file]</code></td><td align="center">设置了stick位文件返回true</td></tr><tr><td align="center"><code>[-N $file]</code></td><td align="center">atime和mtime一样的文件</td></tr><tr><td align="center"><code>[-p $file]</code></td><td align="center">是有名管道文件返回true</td></tr><tr><td align="center"><code>[-u $file]</code></td><td align="center">设置了SUID位文件返回true</td></tr><tr><td align="center"><code>[-O $file]</code></td><td align="center">由有效用户(即当前进程用户)件D拥有返回true</td></tr><tr><td align="center"><code>[-r $file]</code></td><td align="center">是可读文件返回true</td></tr><tr><td align="center"><code>[-w $file]</code></td><td align="center">是可写文件返回true</td></tr><tr><td align="center"><code>[-x $file]</code></td><td align="center">是可执行文件返回true</td></tr><tr><td align="center"><code>[-s $file]</code></td><td align="center">非空文件返回true</td></tr><tr><td align="center"><code>[-S $file]</code></td><td align="center">是一个网络Socket返回true</td></tr><tr><td align="center"><code>[-e $file]</code></td><td align="center">文件存在返回true</td></tr><tr><td align="center"><code>[-t $fd]</code></td><td align="center">fd是一个定向到终端&#x2F;从终端定向的文件描述符。这可以被用来判断是否重定向了标准输入&#x2F;错误</td></tr></tbody></table><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><strong>echo</strong>只用于字符串,自动添加换行符号<code>echo nanbert male 66.1234</code><br><strong>printf</strong>不自动加换行符号,例:<code>printf &quot;%-10s %-8s %-4.2f\n&quot; nanbert male 66.1234</code></p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#then后必须有语句,空语句可以用:</span><br><span class="hljs-keyword">if</span> condition<br><span class="hljs-keyword">then</span> <br>command1<br>...<br><span class="hljs-keyword">elif</span> condition<br><span class="hljs-keyword">then</span><br>command2<br>...<br><span class="hljs-keyword">else</span><br>command3<br>...<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> item1 item2 ... itemN<br><span class="hljs-keyword">do</span> <br>command1<br>...<br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#等价于c语言</span><br><span class="hljs-keyword">for</span> (( expression1;expression2; expression3 ));<span class="hljs-keyword">do</span><br>commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>如果省略in，默认处理位置参数</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span> <br>command1<br>...<br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#无限循环</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">until</span> condition<br><span class="hljs-keyword">do</span> <br>command1<br>...<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>Shell case匹配一个值与一个模式,用两个分号表示break</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> value <span class="hljs-keyword">in</span><br>pattern1)<br>command1<br>...<br>commandN<br>;;<br>pattern2)<br>command1<br>...<br>commandN<br>;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><p>循环都支持<strong>continue</strong>和<strong>break</strong>,<code>break n</code>则可以指定跳出n层循环,n默认为1<br>,continue也支持数字。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ul><li>函数定义<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun</span></span>()&#123;<br>action;<br>[<span class="hljs-built_in">return</span> int;]<br>&#125;<br><span class="hljs-comment">#等价于下面</span><br><span class="hljs-function"><span class="hljs-title">fun1</span></span>()&#123;<br>action;<br>[<span class="hljs-built_in">return</span> int;]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>参数传递<br>函数中直接使用特殊变量来获取参数,可以加上{}<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">funWithParam</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数为 <span class="hljs-variable">$1</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数为 <span class="hljs-variable">$2</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十个参数为 <span class="hljs-variable">$10</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十个参数为 <span class="hljs-variable">$&#123;10&#125;</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十一个参数为 <span class="hljs-variable">$&#123;11&#125;</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数总数有 <span class="hljs-variable">$#</span> 个!&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;作为一个字符串输出所有参数 $* !&quot;</span>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br><span class="hljs-built_in">echo</span> $?  <span class="hljs-comment"># 判断执行是否成功</span><br></code></pre></td></tr></table></figure></li><li>函数返回值<ul><li>返回值是可选的</li><li>return只能为<strong>return [0-255]</strong>,可通过$?获取该值</li><li>如果不加return,则最后一条语句的执行状态为返回值,0为成功</li><li>如果用反引号执行函数,结果是函数内的所有输出而非返回值</li></ul></li><li><a href="#funAndArr">函数与数组</a></li></ul><ul><li>函数本质上是一组命令集合,不一定用大括号括起来,更多见shell例子</li><li>可以使用<code>declare -F | sed &#39;s/declare -f//&#39;</code>来查看当前脚本定义的函数</li></ul><h3 id="读取外部输入"><a href="#读取外部输入" class="headerlink" title="读取外部输入"></a>读取外部输入</h3><p><code>read arg</code>从键盘读取输入并赋值给arg</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-a array</td><td align="center">把输入赋值到数组array中</td></tr><tr><td align="center">-d delimiter</td><td align="center">用字符串delimiter中的第一个字符指示输入结束,而不是一个换行符</td></tr><tr><td align="center">-e</td><td align="center">使用readline来处理输入</td></tr><tr><td align="center">-n num</td><td align="center">读取num个输入字符,而不是整行</td></tr><tr><td align="center">-p prompt</td><td align="center">为输入显示提示信息,使用字符串prompt</td></tr><tr><td align="center">-r</td><td align="center">Raw mode,不把反斜杠解释为转义字符</td></tr><tr><td align="center">-s</td><td align="center">Silent mode,不会在屏幕上显示输入的字符。输入密码的时候很有用</td></tr><tr><td align="center">-t seconds</td><td align="center">超过时间，终止输入,read会非0状态退出</td></tr><tr><td align="center">-u fd</td><td align="center">使用文件描述符fd中的输入,而不是标准输入</td></tr><tr><td align="center">-k n</td><td align="center">只读n个字节</td></tr></tbody></table><p>IFS是字段分割符,默认为空格,tab,换行符。可以自行改变。如下:<br><code>IFS=:</code>改成冒号<br><code>IFS=$&#39;\n&#39;:;&quot;</code>改成换行符、冒号、分号和双引号<br>read不应该使用管道线来接受赋值，如下是错误的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file_info</span>&quot;</span> | IFS=<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-built_in">read</span> user pw uid gid name home shell<br></code></pre></td></tr></table></figure><p>而应该这么写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-built_in">read</span> user pw uid gid name home shell &lt;&lt;&lt; <span class="hljs-string">&quot;<span class="hljs-variable">$file_info</span>&quot;</span><br></code></pre></td></tr></table></figure><p>这是因为管道线会开个子进程,子进程变量的变化不会影响父进程,可以用<a href="#jump">进程替换</a>解决<br>如果输入的数多余接受的变量,则多出来的会保存在变量REPLY中</p><h3 id="包含其他shell文件"><a href="#包含其他shell文件" class="headerlink" title="包含其他shell文件"></a>包含其他shell文件</h3><ul><li><code>. filepath/filename</code></li><li><code>source filepath/filename</code></li></ul><h3 id="颜色标识"><a href="#颜色标识" class="headerlink" title="颜色标识"></a>颜色标识</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printf</span>  <span class="hljs-string">&quot;\033[32m SUCCESS: yay \033[0m\n&quot;</span>;<br><span class="hljs-built_in">printf</span>  <span class="hljs-string">&quot;\033[33m WARNING: hmm \033[0m\n&quot;</span>;<br><span class="hljs-built_in">printf</span>  <span class="hljs-string">&quot;\033[31m ERROR: fubar \033[0m\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>具体内容有待研究</p><h3 id="长句换行"><a href="#长句换行" class="headerlink" title="长句换行"></a>长句换行</h3><p>在shell中为避免一个语句过长,可以使用”&quot;进行换行,注意”&quot;前加一个空格,之后无空格直接换行。</p><h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p><code>exit [num]</code>num为0表示执行成功,可以不加num<br><code>set -e 或 set +e</code>set -e表示从当前位置开始,如果出现任何错误都将触发exit。相反,set +e表示不管出现任何错误继续执行脚本</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>-n表示检查有无语法错误,-x表示调试</p><h3 id="变量展开"><a href="#变量展开" class="headerlink" title="变量展开"></a>变量展开</h3><table><thead><tr><th align="center">操作符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>:$&#123;parameter:=word&#125;</code></td><td align="center">如果parameter没有设置或者为空,展开的结果是word的值,并且word的值会赋给parameter;否则展开为parameter的值</td></tr><tr><td align="center"><code>$&#123;parameter:-word&#125;</code></td><td align="center">如果parameter没有设置或者为空,展开的结果是word的值,否则是parameter的值</td></tr><tr><td align="center"><code>$&#123;parameter:?word&#125;</code></td><td align="center">如果parameter没有设置或者为空,会带有错误的推出,否则是parameter的值</td></tr><tr><td align="center"><code>$&#123;parameter:+word&#125;</code></td><td align="center">如果parameter没有设置或者为空,展开为空,否则是word的值;不管如何parameter值不会变</td></tr><tr><td align="center"><code>$&#123;parameter#pattern&#125;</code></td><td align="center">pattern是通配符模式,会从parameter开头开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td></tr><tr><td align="center"><code>$&#123;parameter##pattern&#125;</code></td><td align="center">pattern是通配符模式,会从parameter开头开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td></tr><tr><td align="center"><code>$&#123;parameter%pattern&#125;</code></td><td align="center">pattern是通配符模式,会从parameter结尾开始最短匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td></tr><tr><td align="center"><code>$&#123;parameter%%pattern&#125;</code></td><td align="center">pattern是通配符模式,会从parameter结尾开始最长匹配pattern,删除匹配中的部分,留下剩余部分,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td></tr><tr><td align="center"><code>$&#123;parameter/pattern/string&#125;</code></td><td align="center">在parameter中找到匹配通配符pattern的文本,用string替换,只替换第一次匹配到的</td></tr><tr><td align="center"><code>$&#123;parameter//pattern/string&#125;</code></td><td align="center">在parameter中找到匹配通配符pattern的文本,用string替换,替换所有匹配到的</td></tr><tr><td align="center"><code>$&#123;parameter/#pattern/string&#125;</code></td><td align="center">在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter开头开始匹配,注意是开头不是从左到右第一次的意思,即第一个字符一定要匹配上</td></tr><tr><td align="center"><code>$&#123;parameter/%pattern/string&#125;</code></td><td align="center">在parameter中找到匹配通配符pattern的文本,用string替换,只能从parameter结尾开始匹配,注意是结尾不是从右到左第一次的意思,即最后一个字符一定要匹配上</td></tr><tr><td align="center"><code>$&#123;parameter,,&#125;</code></td><td align="center">把parameter全部展开成小写字母</td></tr><tr><td align="center"><code>$&#123;parameter,&#125;</code></td><td align="center">把parameter首字母展开成小写字母</td></tr><tr><td align="center"><code>$&#123;parameter^^&#125;</code></td><td align="center">把parameter全部展开成大写字母</td></tr><tr><td align="center"><code>$&#123;parameter^&#125;</code></td><td align="center">把parameter首字母展开成大写字母</td></tr></tbody></table><p><code>$&#123;!prefix*&#125;</code>等价于<code>$&#123;!prefix@&#125;</code>这种展开会返回以prefix开头的已有变量名(而不是变量的值)<br>字符串的长度和切片其实也是一种展开</p><p><span id = "jump"></span></p><h3 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h3><p>进程替换可以用来解决子进程问题,它实质是把子进程的输出当作一个用于重定向的普通文件(文件描述符)。<br>标准输出<br><code>&lt;(cmd1;cmd2)</code><br>标准输入<br><code>&gt;(cmd1;cmd2)</code><br>由此可以解决read管道线的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> attr links owner group size <span class="hljs-built_in">date</span> time filename;<span class="hljs-keyword">do</span><br><span class="hljs-built_in">cat</span> &lt;&lt;- <span class="hljs-string">EOF</span><br><span class="hljs-string">Filename: $filename</span><br><span class="hljs-string">Size:     $size</span><br><span class="hljs-string">Owner:    $owner</span><br><span class="hljs-string">Group:    $group</span><br><span class="hljs-string">Modified: $date $time</span><br><span class="hljs-string">Links:    $links</span><br><span class="hljs-string">Attributes: $attr</span><br><span class="hljs-string">EOF</span><br><span class="hljs-keyword">done</span> &lt; &lt;(<span class="hljs-built_in">ls</span> -l | <span class="hljs-built_in">tail</span> -n +2)<br></code></pre></td></tr></table></figure><p><span id = "jumpopt"></span></p><h3 id="getopt和getopts"><a href="#getopt和getopts" class="headerlink" title="getopt和getopts"></a>getopt和getopts</h3><h4 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h4><p>格式:<code>getopt [options] optstring parameters</code>,例:<br><code>getopt ab:cd -a -b test1 -cd test2 test3</code>该命令会产生如下输出:<br><code>-a -b test1 -c -d -- test2 test3</code>,optstring定义了四个有效项字母:a、b、c和d。冒号(:)表示b选项需要个参数值,它会将-cd选项分成两个单独选项,插入’–’来分隔额外的参数,如果提供’-cde’由于e不在optstring中,会报错<strong>getopt: invalid option – e</strong>,但还会输出结果,可以加-q选项忽略报错结果。<br>在脚本中经常与set的’–’选项来使用,来把getopt的输出转成当前脚本的输入参数,示例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># Extract command line options &amp; values with getopt</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">set</span> -- $(getopt -q ab:<span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)<br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>    -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span> ;;<br>    -b) param=<span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option, with parameter value <span class="hljs-variable">$param</span>&quot;</span><br>        <span class="hljs-built_in">shift</span> ;;<br>    -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span> ;;<br>    --) <span class="hljs-built_in">shift</span><br>        <span class="hljs-built_in">break</span> ;;<br>    *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span>;;<br>    <span class="hljs-keyword">esac</span><br>    <span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#</span><br>count=1<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$param</span>&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h4 id="getopts"><a href="#getopts" class="headerlink" title="getopts"></a>getopts</h4><p>格式:<code>getopts optstring variable</code>,这里variable为命令行上检测到的第一个参数(getopts会去除’-‘,这点与getopt不同),处理完所有参数后,它会返回一个大于0的退出状态码。可以用”:optstring”格式来忽略未识别选项的错误信息。会用到两个环境变量,如果选项用到一个参数值,OPTARG会保存该值,OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。<br>getopts可以识别双引号内的带括号参数值,而getopt不可以。getopts将命令行上找到的所有未定义选项统一输成问号,getopt遇到未识别的非选项值时,会结束识别,即使后面有正确的选项。可以用以下脚本自行测试getopts的行为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> :ab:<span class="hljs-built_in">cd</span> opt<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$opt</span>&quot;</span> <span class="hljs-keyword">in</span><br>        a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span>  ;;<br>        b) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option, with value <span class="hljs-variable">$OPTARG</span>&quot;</span> ;;<br>        c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span>  ;;<br>        d) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -d option&quot;</span>  ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Unknown option: <span class="hljs-variable">$opt</span>&quot;</span> ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">shift</span> $[ <span class="hljs-variable">$OPTIND</span> - 1 ]<br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span><br>count=1<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter <span class="hljs-variable">$count</span>: <span class="hljs-variable">$param</span>&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h3><p>set 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。可以使用<code>echo $-</code>查看当前设置,默认是（himxBH）<br>参数说明：</p><p>|参数|说明|<br>|:-:||:-:|<br>|-a|标示已修改的变量，以供输出至环境变量|<br>|-b|使被中止的后台程序立刻回报执行状态|<br>|-B|启用大括号展开|<br>|-d|Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消|<br>|-e|若指令传回值不等于0，则立即退出shell|<br>|-f|取消使用通配符|<br>|-h|自动缓存命令的所在位置,如果在PATH指定路径内，更换命令的位置,缓存就不会同步，就会发生错误，不过谁会换命令的位置呢,可以使用which更新缓存|<br>|-i|设置当前选项为交互式|<br>|-k|指令所给的参数都会被视为此指令的环境变量|<br>|-l|记录for循环的变量名称|<br>|-m|使用监视模式,可以控制进程的停止、继续、后台前台等，默认打开|<br>|-n|测试模式，只读取指令，而不实际执行|<br>|-p|启动优先顺序模式|<br>|-P|启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接|<br>|-t|执行完随后的指令，即退出shell|<br>|-u|当执行时使用到未定义过的变量，则显示错误信息|<br>|-v|显示shell所读取的输入值|<br>|-H shell|可利用”!”加&lt;指令编号&gt;的方式来执行 history 中记录的指令,最好不用|<br>|-x|执行指令后，会先显示该指令及所下的参数|<br>|+&lt;参数&gt;|取消某个set曾启动的参数。与-&lt;参数&gt;相反|<br>|-o [option]|特殊属性有很多,见下面|</p><p><strong>option属性</strong></p><ul><li>pipefail:管道流水线中有一个失败，则返回失败值，从右往左数起(默认只返回最后一个命令的退出码)</li><li>noclobber:防止&gt;重定向操作符覆盖已有内容，你可以使用<code>command &gt;| file</code>强制覆盖</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>波浪号展开只能<strong>紧跟</strong>在<code>=</code>和<code>:</code>之后才能正确展开,引号中无法正确展开</li><li>**&lt;&lt;<strong>和</strong>&lt;&lt;-**的区别在于,&lt;&lt;-会忽略接下来输入的tab建,一般用于格式化脚本,便于读代码</li><li>组命令(在当前shell执行)–<code>&#123; command1;command2;command3  &#125;</code>,子shell–<code>(command1;command2;command3)</code>一般配合管道符</li><li>trap命令<br><code>trap &quot;命令&quot; &quot;信号&quot;</code>当脚本遇到信号前执行的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo I am ignoring you&quot;</span> SIGINT SIGTERM<br></code></pre></td></tr></table></figure>常见信号有:</li></ul><table><thead><tr><th align="center">编号</th><th align="center">英文名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIGHUP</td><td align="center">挂起进程</td></tr><tr><td align="center">2</td><td align="center">SIGINT</td><td align="center">终止进程</td></tr><tr><td align="center">3</td><td align="center">SIGQUIT</td><td align="center">停止进程</td></tr><tr><td align="center">9</td><td align="center">SIGKILL</td><td align="center">无条件终止进程</td></tr><tr><td align="center">15</td><td align="center">SIGTERM</td><td align="center">尽可能终止进程</td></tr><tr><td align="center">17</td><td align="center">SIGSTOP</td><td align="center">无条件停止进程,但不是终止进程</td></tr><tr><td align="center">18</td><td align="center">IGTSTP</td><td align="center">停止或暂停进程,但不终止进程</td></tr><tr><td align="center">19</td><td align="center">SIGCONT</td><td align="center">继续运行停止的进程</td></tr></tbody></table><pre><code class="hljs">* tap除了捕获信号外,还会捕获脚本退出:`trap &quot;echo Goodbye...&quot; EXIT`,不管正常还是非正常,都会打印Goodbye* `trap -- SIGINT`取消某个信号的设置* `trap -`恢复信号的默认行为</code></pre><ul><li>wait命令<br><code>wait $pid</code>等待子进程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#小火车子进程</span><br>sl &amp;<br>pid=$!<br><span class="hljs-comment">#父进程继续干事</span><br><span class="hljs-built_in">sleep</span> 2<br><span class="hljs-comment">#干完事等子进程</span><br><span class="hljs-built_in">wait</span> <span class="hljs-variable">$pid</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;子父进程都结束了&quot;</span><br></code></pre></td></tr></table></figure></li><li>命名管道<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个命名管道文件</span><br><span class="hljs-built_in">mkfifo</span> pipe1<br><span class="hljs-comment">#子进程写入(写入完会阻塞,等待另一端读,所以不要wait)</span><br><span class="hljs-built_in">ls</span> -l &gt; pipe1 &amp;<br><span class="hljs-comment">#父进程读</span><br><span class="hljs-built_in">sleep</span> 5<br><span class="hljs-built_in">cat</span>&lt;pipe1<br></code></pre></td></tr></table></figure></li></ul><ul><li>IFS默认是空白字符(回车，空格，制表符等)，位于字符串和结尾的空白字符都被删除，中间连续空格会被压缩成一个</li></ul><ul><li>子shell的全局环境变量改变并不会影响父shell,甚至用export也不行</li><li>命令替换<code>$(command)</code>,子shell<code>(command)</code>两个是不同概念,命令替换会开个子shell(貌似都会开子shell)</li><li>文件描述符与exec<ul><li>配合exec可以使标准输入输出永久重定向:<code>exec 2&gt;testerror</code>重定向标准错误至文件。</li><li>exec可以创建文件描述:<code>exec 3&gt;testxx;echo hello&gt;&amp;3</code>这可以用来恢复正常的输入输出,如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> 3&gt;&amp;1<br><span class="hljs-built_in">exec</span> 1&gt;test14out<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这会输入到test14out&quot;</span><br><span class="hljs-built_in">exec</span> 1&gt;&amp;3<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这会输入到屏幕&quot;</span><br></code></pre></td></tr></table></figure></li><li>exec创建读写描述符:<code>exec 3&lt;&gt;testfile</code>,这要特别小心,任何读或写都会从文件指针的上次位置开始</li><li>exec关闭文件描述符:<code>exec 3&gt;&amp;-</code></li><li>lsof命令可以查看已经打开的文件描述符,见Linux命令博客</li></ul></li></ul><p><span id = "funAndArr"></span></p><ul><li><p>函数与数组<br>将数组变量当作但个参数传递的话,它不会其作用,只会传递第一个值,可以借鉴以下例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># array variable to function test</span><br><span class="hljs-keyword">function</span> testit &#123;<br>    <span class="hljs-built_in">local</span> newarray<br>    newarray=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>`<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new array value is: <span class="hljs-variable">$&#123;newarray[*]&#125;</span>&quot;</span><br>&#125;<br>myarray=(1 2 3 4 5)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original array is <span class="hljs-variable">$&#123;myarray[*]&#125;</span>&quot;</span><br>testit <span class="hljs-variable">$&#123;myarray[*]&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>预处理替换优先级<br>a.shell替换:文件通配符<br>b.变量替换<br>c.命令替换,如下示例:  </p></li><li><p>shell元字符汇总</p></li></ul><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">空格、制表符</td><td align="center">命令行参数的分隔符</td></tr><tr><td align="center">回车</td><td align="center">执行键入的命令</td></tr><tr><td align="center">&lt; &gt; &brvbar;</td><td align="center">重定向与管道</td></tr><tr><td align="center">;</td><td align="center">多个命令分隔符</td></tr><tr><td align="center">&amp;</td><td align="center">后台运行</td></tr><tr><td align="center">$</td><td align="center">引用shell的变量</td></tr><tr><td align="center">`</td><td align="center">命令替换,<code>\\</code>代表反斜线自身,&#96;`&#96;代表反撇号自身</td></tr><tr><td align="center">* [] ?</td><td align="center">文件通配符,不匹配*和&#x2F;</td></tr><tr><td align="center">()</td><td align="center">用于定义shell函数或子shell中执行命令</td></tr><tr><td align="center">\</td><td align="center">转义字符取消元字符特殊含义，若不用于元字符跟不加一样</td></tr><tr><td align="center">“ “</td><td align="center">其中的内容除$和`外取消元字符的特殊含义</td></tr><tr><td align="center">‘ ‘</td><td align="center">取消所有元字符特殊含义</td></tr></tbody></table><ul><li>RANDOM是个内建的随机值</li><li><code>&lt;&lt;&lt;</code><br>here-string语法，允许直接传递字符串给标准输入</li><li>eval<br>eval 的功能是将字符串作为代码来执行。看上去好像很简单，但实际涉及很复杂的内容，主要是符号转义导致的语义问题。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">str1</span>=str2<br><span class="hljs-attribute">str2</span>=abc<br>eval echo \$<span class="hljs-variable">$str1</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2021/03/31/git/"/>
    <url>/2021/03/31/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git预设置-gitconfig"><a href="#git预设置-gitconfig" class="headerlink" title="git预设置(~&#x2F;.gitconfig)"></a>git预设置(~&#x2F;.gitconfig)</h1><ul><li><code>git config --global user.name &quot;xxx&quot;</code></li><li><code>git config --global user.email &quot;xx.com&quot;</code></li><li><code>git config --list</code>检查已有配置信息</li><li><code>git config --global core.editor vim</code>配置默认编辑器</li><li><code>git config --global alias.comi commit</code>命令的别名</li><li><code>git config --global credential.helper cache</code>设置无密码推送</li><li><code>git config --global alias.st &quot;status&quot;</code>设置status的别名为st</li><li><code>git config --global alias.st &quot;status&quot;</code>设置status的别名为st</li><li><code>git config --global --replace-all alias.lg  &quot;log --pretty=format:&#39;%C(auto) %h | %ai | %Cred %an %Cgreen %s&#39;&quot;</code>推荐设置log的别名</li></ul><h1 id="git-初始化"><a href="#git-初始化" class="headerlink" title="git 初始化"></a>git 初始化</h1><p><code>git init</code>初始化仓库，并建立.git子目录</p><h1 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h1><p><code>-s</code>:简单展现，A表示新添加到缓存区,左边M表示文件被修改并放入缓存区,右边M表示文件被修改并没有放入缓存区,??问号表示未被跟踪的文件</p><h1 id="git-add"><a href="#git-add" class="headerlink" title="git add &lt;files&gt;"></a><code>git add &lt;files&gt;</code></h1><p>跟踪文件并加入暂存区,可以通过<code>git ls-files --stage</code>来查看暂存区的文件</p><h1 id="git-diff显示更为详细的变化"><a href="#git-diff显示更为详细的变化" class="headerlink" title="git diff显示更为详细的变化"></a><code>git diff</code>显示更为详细的变化</h1><ul><li>默认比较工作目录与缓存区间的差异</li><li><code>--cached</code>比较缓存区与已提交的差异</li><li>HEAD查看所有改动</li><li>–stat:显示摘要</li></ul><h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h1><p>注释行里会有最后一次运行git status的输出</p><ul><li>-v:会将diff输出加入到注释行</li><li>-m:将提交信息与命令放在同一行</li><li>-a:可以将所有跟踪文件跳过add步骤直接commit</li><li>–amend:上次提交后发现忘了几个文件,可以add之后再加上此选项提交将会覆盖上次提交。</li></ul><h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm &lt;files&gt;"></a><code>git rm &lt;files&gt;</code></h1><ul><li>移除缓存区文件并且工作目录也一并移除</li><li>–cached:只删除缓存区,保留工作目录</li></ul><h1 id="git-mv移动文件"><a href="#git-mv移动文件" class="headerlink" title="git mv移动文件"></a><code>git mv</code>移动文件</h1><ul><li>等价于’mv file1 file2;git rm file1;git add README’</li></ul><h1 id="git-log显示提交记录-git-shortlog-显示简短的记录"><a href="#git-log显示提交记录-git-shortlog-显示简短的记录" class="headerlink" title="git log显示提交记录(git shortlog 显示简短的记录)"></a><code>git log</code>显示提交记录(git shortlog 显示简短的记录)</h1><ul><li><p>-p:显示每次提交的差异</p></li><li><p>-(n):显示最近n次提交</p></li><li><p>–since,–after:仅显示指定时间之后的提交</p></li><li><p>–until,–before:仅显示指定时间之前的提交</p></li><li><p>–author:仅显示指定作者相关的提交</p></li><li><p>–committer:仅显示指定提交者相关的提交</p></li><li><p>–grep:仅显示含指定关键字的提交</p></li><li><p>-S:仅显示添加或移除了某个关键字的提交</p></li><li><p>–stat:简略信息</p></li><li><p>–graph:显示ASCLL图形表示分支的合并历史</p></li><li><p>–relative-date:使用较短的相对时间显示</p></li><li><p>–abbrev-commit:仅显示SHA-1的前几个字符,而非所有的40个字符</p></li><li><p>–name-status:显示增删改的文件清单</p></li><li><p>–name-only:仅在提交信息后显示以修改的文件清单</p></li><li><p>–pretty&#x3D;format:”&lt;格式&gt;”:指定格式输出<br>&lt;格式&gt;有如下：</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%H</td><td align="center">提交对象(commit)的完整哈希字串</td></tr><tr><td align="center">%h</td><td align="center">提交对象的简短哈希字串</td></tr><tr><td align="center">%T</td><td align="center">树对象的完整哈希字串</td></tr><tr><td align="center">%t</td><td align="center">树对象的简短哈希字串</td></tr><tr><td align="center">%P</td><td align="center">父对象的完整哈希字串</td></tr><tr><td align="center">%p</td><td align="center">父对象的简短哈希字串</td></tr><tr><td align="center">%an</td><td align="center">作者的名字</td></tr><tr><td align="center">%ae</td><td align="center">作者的邮件</td></tr><tr><td align="center">%ad</td><td align="center">作者修订日期</td></tr><tr><td align="center">%ar</td><td align="center">作者修订日期,按多久以前的方式显示</td></tr><tr><td align="center">%cn</td><td align="center">提交者的名字</td></tr><tr><td align="center">%ce</td><td align="center">提交者的电子邮件</td></tr><tr><td align="center">%cd</td><td align="center">提交日期</td></tr><tr><td align="center">%cr</td><td align="center">提交日期,按多久以前的方式显示</td></tr><tr><td align="center">%s</td><td align="center">提交说明</td></tr></tbody></table></li></ul><h1 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h1><ul><li><code>git reset HEAD &lt;file&gt;</code>(适用已提交add):撤销某个暂存文件,即将add退回</li><li><code>git reset HEAD\~1</code>:回退到上一个版本</li><li><code>git reset --hard &lt;commit_id&gt;</code>注意此步骤会将commit_id后的commit删除,最好不用</li><li><code>git push origin HEAD --force</code>让服务器也回退到某版本(本地仓库已回退)</li><li><code>git revert HEAD</code>回退到HEAD上一个版本,但是树结构往下走，只不过与父节点相同</li><li><code>git checkout [file]</code>(未git add的情况下):撤销某个工作目录下文件的修改,恢复为版本库中一模一样的版本,危险的命令,你的修改将不会保存</li></ul><h1 id="git-remote远程仓库的使用"><a href="#git-remote远程仓库的使用" class="headerlink" title="git remote远程仓库的使用"></a><code>git remote</code>远程仓库的使用</h1><ul><li>-v:显示简写对应的url</li><li><code>show origin</code>:展示origin的具体信息</li><li><code>rename o1 o2</code>:重命名某个远程</li><li><code>rm xx</code>:移除某个远程</li><li><code>add xx</code>:增加某个远程</li><li><code>prune origin</code>:删除本地在远程服务器上不存在的分支</li></ul><h1 id="git-push"><a href="#git-push" class="headerlink" title="git push &lt;remote-name&gt; &lt;branch-name&gt;"></a><code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code></h1><ul><li><code>--tags</code>:推送所有标签</li><li>使用git push &lt;远程主机名(origin)&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</li><li><code>git push --set-upstream &lt;remote_name&gt; &lt;branch_name&gt;</code>将远程分支作为当前分支的上游分支,–unset-upstream,则是删除这种关联</li></ul><h1 id="远程拉取"><a href="#远程拉取" class="headerlink" title="远程拉取"></a>远程拉取</h1><ul><li>git fetch:会抓取数据到本地数据库，但不会自动合并并修改当前工作</li><li>git clone:会自动将其添加为远程仓库并默认以’origin’缩写,并自动跟踪远程master</li><li>git pull:主区数据并自动尝试合并到当前所在分支</li></ul><h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><ul><li>-a:增加个标签,可以在后面加个校验和,为指定的补打标签</li><li>-m:在命令行增加说明</li><li>-d:删除某个标签</li><li>-l:列举标签</li><li><tag_name> <commit_id>:为某个哈希打标签,必须显示地推送标签至远程库’git push origin v1.5’,当某个标签被删除或信息改变’git push origin  :refs&#x2F;tags&#x2F;<tag_name>‘</li><li><code>git branch &lt;new-branch-name&gt; &lt;tag-name&gt;</code>从指定的标签拉取一个分支出来</li><li><code>git show &lt;tag_name&gt;</code>查看tag信息</li></ul><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul><li><code>git clone -b &lt;分支名&gt; &lt;仓库地址&gt;</code>克隆指定分支</li><li><code>git fetch origin &lt;branch_name&gt;</code>抓取某个远程分支</li><li><code>git branch xxx</code>创建分支,不加任何xxx会显示所有分支</li><li><code>git log --oneline --decorate</code>查看各个分支当前所指对象</li><li><code>git checkout xxx</code>切换分支,切换分支会改变工作目录里的文件</li><li><code>git log --oneline --decorate --graph --all</code>查看分叉历史</li><li><code>git merge xxbranch</code>合并指定分支到当前分支,如果当前分支可以沿着一条线走下去则会有’fast-forward提示’</li><li><code>git merge --abort</code>取消当前合并,重建合并前状态</li><li><code>git merge --no-commit xxbranch</code>合并到本地文件,之后需要手动commit,xxbranch仍是新节点的父节点</li><li><code>git merge --squash xxbranch</code>生成本地diff,patch,手动提交后,与xxbranch不构成父子节点</li><li><code>git checkout -b serverfix origin/serverfix</code>跟踪远程库其他分支等价于<code>git checkout --track orighin/serverfix</code></li><li><code>git push origin --delete xxx</code> 删除远程分支</li></ul><h2 id="git-branch-选项"><a href="#git-branch-选项" class="headerlink" title="git branch 选项"></a>git branch 选项</h2><ul><li>-d xxx: 删除分支</li><li>-D xxx:强制删除某个未合并的分支</li><li>-v:显示每个分支最后的提交</li><li>–merged:查看所有已与当前分支合并的分支</li><li>–no-merged:查看所有未与当前分支合并的分支</li><li>-f some hash:强制some分支移动到某hash版本</li><li><code>-u origin:master</code>:设置当前分支跟踪远程分支</li><li><code>-r</code>:显示所有远程分支</li><li><code>-a</code>:显示所有本地和远程分支</li></ul><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a><code>git rebase</code></h2><ul><li><code>git rebase xxx</code>把当前分支衍合到xxx分支</li><li><code>git rebase --onto master server client</code>把server与client共同祖先之后的变化加到master中去</li><li><code>git rebase -i xx</code>以他为xx基础或其共同祖先节点进行交互界面的rebase</li></ul><h2 id="git-cherry-pick-a-b-c把a-b-c等应用到当前分支"><a href="#git-cherry-pick-a-b-c把a-b-c等应用到当前分支" class="headerlink" title="git cherry-pick a b c把a,b,c等应用到当前分支"></a><code>git cherry-pick a b c</code>把a,b,c等应用到当前分支</h2><h2 id="git-describe-会输出以下信息"><a href="#git-describe-会输出以下信息" class="headerlink" title="git describe &lt;branch&gt;会输出以下信息"></a><code>git describe &lt;branch&gt;</code>会输出以下信息</h2><p><code>&lt;最近的tag&gt;_&lt;tag距离分支几个节点&gt;_&lt;当前分支hash值&gt;</code></p><h2 id="第一个父提交-2第二个父提交-2爷爷提交"><a href="#第一个父提交-2第二个父提交-2爷爷提交" class="headerlink" title="^第一个父提交^2第二个父提交~2爷爷提交"></a><code>^</code>第一个父提交<code>^2</code>第二个父提交<code>~2</code>爷爷提交</h2><h2 id="格式-source-destination"><a href="#格式-source-destination" class="headerlink" title="格式:[source:destination]"></a>格式:<code>[source:destination]</code></h2><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><code>git stash</code></h2><p>备份当前的工作区内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到git栈中</p><ul><li><code>git stash list</code>显示所有栈内的备份</li><li><code>git stash apply &lt;stash_name&gt;</code>从栈中读取最新一次保存的内容，恢复工作区的相关内容</li><li><code>git stash pop</code>删除最新的暂存</li><li><code>git stash drop&lt;stash_name&gt;</code>删除指定暂存</li></ul><h1 id="建议规范"><a href="#建议规范" class="headerlink" title="建议规范"></a>建议规范</h1><h2 id="推荐的分支管理"><a href="#推荐的分支管理" class="headerlink" title="推荐的分支管理"></a>推荐的分支管理</h2><ul><li><code>master</code>:主分支,禁止直接在master上进行代码的提交和修改,此分支的代码可以随时被发布到线上</li><li><code>develop</code>:测试分支,所有开发完成需要提交测试的功能合并到该分支,该分支包含最新的更改</li><li><code>feature</code>:开发分支,大家根据不同需求创建独立的功能分支,开发后合并到develop分支</li><li><code>fix</code>:分支为bug修复分支,需要根据实际情况对已发布的版本进行漏洞修复</li></ul><h2 id="标签tag管理"><a href="#标签tag管理" class="headerlink" title="标签tag管理"></a>标签tag管理</h2><p>Tag采用三段式:v版本.里程碑.序号(v2.3.1)</p><ul><li>第一位:架构升级或架构重大调整</li><li>第二位:新功能上线或模块大的调整</li><li>第三位:bug修复</li></ul><h2 id="提交信息格式"><a href="#提交信息格式" class="headerlink" title="提交信息格式"></a>提交信息格式</h2><h3 id="中文"><a href="#中文" class="headerlink" title="中文:"></a>中文:</h3><ul><li>-&lt;新功能&gt;添加解析url功能</li><li>-&lt;修改&gt;修改某功能的某个实现为另一个实先</li><li>-&lt;Bug修复&gt;修复url的特殊情况下解析失败的问题</li><li>-&lt;重构&gt;重构获取数据的方法</li><li>-&lt;测试&gt;添加(修改、删除)获取数据的单元测试代码</li><li>-&lt;文档&gt;修改(添加、删除)文档</li></ul><h3 id="英文"><a href="#英文" class="headerlink" title="英文:"></a>英文:</h3><ul><li>-feat:新功能</li><li>-fix:修补bug</li><li>-refactor:重构</li><li>-test:测试相关</li><li>-docs:文档</li></ul><h1 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h1><p>该文件里的文件夹和文件(可以使用通配符<code>*</code>,<code>!</code>,<code>?</code>,<code>[a-zA-Z]</code>等，具体看)不被加入版本控制中，也就不会出现在git status中(文件.gitignore本身还是会untrack状态),git add的时候不会被加入，这里仅局限于untracked file，那些Staged file，不受.gitignore影响</p><ul><li>每一行定义一个或一组文件夹或文件，以<code>/</code>结尾的只匹配文件夹，否则，可以匹配文件或文件夹</li><li>以<code>!</code>开头的，如果有冲突，会把之前模式匹配的覆盖掉</li><li>如果一个文件夹已经被匹配，那么其子文件夹和文件就不受其他模式影响</li><li><code>**/foo</code>匹配任何位置的foo，类似的<code>a/**/b</code>匹配<code>a/x/b</code>,<code>a/b</code>等</li></ul><h1 id="常见问题技巧"><a href="#常见问题技巧" class="headerlink" title="常见问题技巧:"></a>常见问题技巧:</h1><ul><li>推送要密码,改成ssh认证,在.git&#x2F;config里修改remote地址,从仓库复制过去ssh地址,不用httpServer,因为它就是默认用密码登录,也可以从命令行修改</li><li>仓库中所有文件的sha1值在.git目录中的objects文件夹下，想要根据sha1值查看文件内容，可以用<code>git cat-file -p [sha1值]</code>注意，objects中只有两个数字的文件夹是该文件夹下所有文件内容的sha1值的前两位，所以要拼接一下，当然你如果用命令知道它的完整sha1值就不用拼接了</li><li><code>gitjk</code>有用的命令，可以查看如何撤销上个命令,可以从网上下载该工具，需要npm</li><li><code>git log --tags --simplify-by-decoration --pretty=&quot;format:%ci %d&quot;</code>通过log来看tag,并且加上了日期</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>输入输出流</title>
    <link href="/2021/03/11/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <url>/2021/03/11/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>1.操纵符</p><table><thead><tr><th align="center">操纵符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">boolalpha</td><td align="center">将true和false输出为字符串</td></tr><tr><td align="center">*noboolalpha</td><td align="center">将true和false输出为1,0</td></tr><tr><td align="center">showbase</td><td align="center">对整型值输出表示进制的前缀</td></tr><tr><td align="center">*noshowbase</td><td align="center">不生成表示进制的前缀</td></tr><tr><td align="center">showpoint</td><td align="center">对浮点值总是显示小数点</td></tr><tr><td align="center">*noshowpoint</td><td align="center">只有当浮点值包含小数部分时,显示小数点</td></tr><tr><td align="center">showpos</td><td align="center">对非负数显示+</td></tr><tr><td align="center">*noshowpos</td><td align="center">对非负数不显示+</td></tr><tr><td align="center">uppercase</td><td align="center">在十六进制中打印0X,在科学计数法中打印E</td></tr><tr><td align="center">*uppercase</td><td align="center">在十六进制中打印0x,在科学计数法中打印e</td></tr><tr><td align="center">*dec</td><td align="center">整型值显示为十进制</td></tr><tr><td align="center">hex</td><td align="center">整型值显示为十六进制</td></tr><tr><td align="center">oct</td><td align="center">整型值显示为十进制</td></tr><tr><td align="center">left</td><td align="center">左对齐,在值的右侧添加填充字符</td></tr><tr><td align="center">right</td><td align="center">右对齐,在值的左侧添加填充字符</td></tr><tr><td align="center">internal</td><td align="center">左对齐符号,右对齐值,在值和符号之间添加填充字符</td></tr><tr><td align="center">fixed</td><td align="center">浮点值显示为定点十进制</td></tr><tr><td align="center">scientific</td><td align="center">浮点值显示为科学计数法</td></tr><tr><td align="center">hexfloat</td><td align="center">浮点值显示为十六进制(c++11)</td></tr><tr><td align="center">defaultfloat</td><td align="center">重置浮点值显示为十进制(c++11)</td></tr><tr><td align="center">unitbuf</td><td align="center">每次输出操作后都刷新缓冲区</td></tr><tr><td align="center">*nounitbuf</td><td align="center">恢复正常的缓冲区刷新方式</td></tr><tr><td align="center">*skipws</td><td align="center">输入运算符跳过空白符</td></tr><tr><td align="center">noskipws</td><td align="center">输入运算符不跳过空白符</td></tr><tr><td align="center">flush</td><td align="center">刷新ostream缓冲区</td></tr><tr><td align="center">ends</td><td align="center">插入空字符,然后刷新ostream缓冲区</td></tr><tr><td align="center">endl</td><td align="center">插入换行符,然后刷新ostream缓冲区</td></tr><tr><td align="center">setprecision([int])</td><td align="center">在iomanip,接受一个int值,来设置精度,见详解</td></tr><tr><td align="center">setfill([char])</td><td align="center">在iomanip,用一个字符填充空白</td></tr><tr><td align="center">setw([int])</td><td align="center">在iomanip,指定值的最小宽度,注意它只影响接下来的那个值</td></tr><tr><td align="center">setbase([int])</td><td align="center">在iomanip,将整数输出为某进制</td></tr></tbody></table><p>2.流对象的成员函数</p><table><thead><tr><th align="center">成员函数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">precision()</td><td align="center">返回当前精度值</td></tr><tr><td align="center">precision(int)</td><td align="center">将精度设置为此值,返回旧精度</td></tr><tr><td align="center">is.get(ch)</td><td align="center">从istream is读取下一个字节存入字符ch。返回is</td></tr><tr><td align="center">os.put(ch)</td><td align="center">将字符ch输出到ostream os。返回os</td></tr><tr><td align="center">is.get()</td><td align="center">将is的下个字节作为int返回,不返回char的原因是可以多存个结尾符,与cstdio里的EOF做比较</td></tr><tr><td align="center">is.putback(ch)</td><td align="center">将字符ch放回is。返回is</td></tr><tr><td align="center">is.unget()</td><td align="center">将is向后移动一个字节。返回is</td></tr><tr><td align="center">is.peek()</td><td align="center">将下个字节作为int返回。但不从流中删除</td></tr><tr><td align="center">is.get(sink,size,delim)</td><td align="center">从is中读取最多size字节,并保存在字符数组中,字符数组的起始地址由sink给出。读取过程知道遇到字符delim或读取了size个字节或遇到文件尾。如果遇到delim，将其留在输入流中，不读取出来存入sink</td></tr><tr><td align="center">is.getline(sink,size,delim)</td><td align="center">与接受三个参数的类似，但会丢弃delim</td></tr><tr><td align="center">is.read(sink,size)</td><td align="center">读取最多size个字节，存入字符数组sink中，返回is</td></tr><tr><td align="center">is.gcount()</td><td align="center">返回上一个未格式化读取操作从is读取的字节数</td></tr><tr><td align="center">os.write(source,size)</td><td align="center">将字符数组source中的size个字节写入os，返回os</td></tr><tr><td align="center">is.ignore(size,delim)</td><td align="center">读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾</td></tr></tbody></table><p>3.流的随机访问(只支持fstream,sstream)</p><table><thead><tr><th align="center">函数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">tellg()</td><td align="center">返回输入流中标记的当前位置</td></tr><tr><td align="center">tellp()</td><td align="center">返回输出流中标记的当前位置</td></tr><tr><td align="center">seekg()</td><td align="center">在一个输入流中将标记重定位到给定的绝对地址。pos通常是tellg的返回值</td></tr><tr><td align="center">seekp()</td><td align="center">在一个输出流中将标记重定位到给定的绝对地址。pos通常是tellp的返回值</td></tr><tr><td align="center">seekg(off,from)</td><td align="center">在一个输入流中将标记定位到from之前(off为负的时候)或之后off个字符。from是下列的值:beg(流开始位置)，cur(当前位置)，end(结尾位置)</td></tr><tr><td align="center">seekp(off,from)</td><td align="center">(输出流同上)</td></tr></tbody></table><p>4.getline()函数<br>getlint([istream],[string])从输入流中读取一行，并舍弃换行符，赋值给string<br>5.流的状态位</p><table><thead><tr><th align="center">状态成员(类型为strm::iostate)</th><th align="center">成员函数</th><th align="center">函数意义</th></tr></thead><tbody><tr><td align="center">badbit</td><td align="center">s.bad()</td><td align="center">strm:badbit用来指出流已经奔溃。若流s的badbit置位，成员函数返回true，这个一般由系统造成，一般这个流就废了</td></tr><tr><td align="center">failbit</td><td align="center">s.fail()</td><td align="center">strm::failbit用来指出一个IO操作失败。若s的failbit置位，成员函数返回true,流还可以修正继续使用</td></tr><tr><td align="center">eofbit</td><td align="center">s.eof()</td><td align="center">strm::eofbit用来指出流到达结尾。若s的eofbit置位，成员函数返回true</td></tr><tr><td align="center">goodbit</td><td align="center">s.good()</td><td align="center">strm::goodbit用来指出流未处于错误状态。若上述三个被置位任何一个，成员函数返回true</td></tr><tr><td align="center"></td><td align="center">s.clear()</td><td align="center">所有条件状态复位，流状态设置为有效，返回void</td></tr><tr><td align="center"></td><td align="center">s.clear(flags)</td><td align="center">根据给定的flags标志位，进行条件置位，如：<code>cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit)</code>只对failbit和badbit复位，其余保持不变</td></tr><tr><td align="center"></td><td align="center">s.rdstate()</td><td align="center">返回流当前状态，类型为strm::iostate</td></tr></tbody></table><p>6.流之间的关联<br>一般情况下cin和cerr被关联到cout,所以cin操纵之后，都会刷新cout的缓冲区<br>cin.tie()会返回关联的输出流的指针<br>cin.tie([*os])关联流到该指针<br>每个流最多关联到一个输出流，但多个流可以同时关联到同一个输出流。<br>istream可以关联ostream的对象，ostream也可以关联到ostream的对象，也可以关联到一个空指针。<br>7.文件模式</p><p>|文件模式|含义|<br>|in|以读方式打开|<br>|out|以写方式打开|<br>|app|每次写操作前均定位到文件末尾|<br>|ate|打开文件后立刻定位到文件末尾|<br>|trunc|截断文件|<br>|binary|以二进制方式进行IO|</p><p>文件模式指定之间以‘|’分割，并有如下限制:<br>-只可以对ofstream或fstream对象设定out模式<br>-只可以对ifstream或fstream对象设定in模式<br>-只有当out模式设定时才可以设定trunc模式<br>-只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出模式打开<br>-默认情况下，即使我们没有指定trunc,out模式打开的文件也会被截断，或者同时指定app模式或者in模式<br>-ate和binary可以用于任何文件流对象，可以与其他模式任意组合<br>4.精度<br>默认情况下,精度会控制打印的数字的总数。打印时,<font color=#FF0000>浮点值按当前精度舍入而非截断</font>,在执行scientific,fixed或hexfloat后,精度值控制的是小数点后面的数字位数</p><p>1.scanf与printf<br>格式:<code>scanf(&quot;format_specifier&quot;,&amp;val)</code>与<code>printf(&quot;format_specifier&quot;,&amp;val)</code><br>例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> ch;<br><span class="hljs-type">double</span> d;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %lf&quot;</span>,&amp;ch,&amp;d);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %lf&quot;</span>,ch,d);<br></code></pre></td></tr></table></figure><p>|:-:|:-:|:-:|<br>|类型|格式|大小|<br>|int|%d|32bit|<br>|long|%ld|64bit|<br>|char|%c|16bit|<br>|float|%f|32bit|<br>|double|%lf|64bit|<br>2.float与double固定小数点后的位数输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">float</span> a=<span class="hljs-number">8.333291</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.03f&quot;</span>,a);<span class="hljs-comment">//小数点后面保留3位</span><br>cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">3</span>);<br>cout&lt;&lt;fixed&lt;&lt;endl;<span class="hljs-comment">//保留3位</span><br><br></code></pre></td></tr></table></figure><p>3.进制转换<br>十六进制 <code>cout&lt;&lt;hex;</code><br>十进制 <code>cout&lt;&lt;dec</code>;<br>八进制 <code>cout&lt;&lt;oct</code>;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AWK</title>
    <link href="/2021/01/24/AWK/"/>
    <url>/2021/01/24/AWK/</url>
    
    <content type="html"><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>awk [-v var=value] [-F re] [--] &#39;pattern n&#123;action&#125;&#39; var=value files</code><br><code>awk [-v var=value] [-F re] [--] -f scriptfile [file] var=value files</code><br><strong>注:</strong>-v指定的变量定义在BEGIN之前,BEGIN过程中不能访问有关文件或命令行的任何变量(除了环境变量)</p><h3 id="awk选项总结"><a href="#awk选项总结" class="headerlink" title="awk选项总结"></a>awk选项总结</h3><table><thead><tr><th align="center">options</th><th align="center">describe</th></tr></thead><tbody><tr><td align="center">-F</td><td align="center">改变字段分割符,默认为空格</td></tr><tr><td align="center">-f</td><td align="center">跟随脚本中的文件名</td></tr><tr><td align="center">-v</td><td align="center">跟随var&#x3D;value,作用域在BEGIN之前</td></tr><tr><td align="center">-mf [N]</td><td align="center">指定处理的数据文件中最大字段数</td></tr><tr><td align="center">-mr [N]</td><td align="center">指定处理的数据文件中最大行数</td></tr><tr><td align="center">-W keyword</td><td align="center">指定gawk的兼容模式或警告等级</td></tr></tbody></table><h3 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h3><table><thead><tr><th align="center">variable</th><th align="center">describe</th></tr></thead><tbody><tr><td align="center">ARGV</td><td align="center">命令行参数的数组,不包括脚本本身(-f选项也不包括),下标从0开始(一般为awk),一般大于0的下标都是输入的文件名,最后一个是ARGC-1</td></tr><tr><td align="center">ARGC</td><td align="center">ARGV数组个数</td></tr><tr><td align="center">ARGIND</td><td align="center">当前输入文件在ARGV的索引值</td></tr><tr><td align="center">CONVFMT</td><td align="center">用于数字的字符串转换格式(%.6g)</td></tr><tr><td align="center">ENVIRON</td><td align="center">环境变量数组,下标是环境变量名</td></tr><tr><td align="center">FILENAME</td><td align="center">当前输入文件名称</td></tr><tr><td align="center">FNR</td><td align="center">当前输入文件的记录(行)个数</td></tr><tr><td align="center">FS</td><td align="center">字段分隔符,最好在BEGIN的时候定义</td></tr><tr><td align="center">ERRNO</td><td align="center">当getline或close失败时的描述信息</td></tr><tr><td align="center">FIELDWIDTHS</td><td align="center">见该小结</td></tr><tr><td align="center">IGNORECASE</td><td align="center">如果不为0,模式匹配不区分大小写</td></tr><tr><td align="center">NF</td><td align="center">每段记录(即行)的字段数(即单词)</td></tr><tr><td align="center">NR</td><td align="center">行号</td></tr><tr><td align="center">OFMT</td><td align="center">数值的输出格式,默认为”%.6g”</td></tr><tr><td align="center">OFS</td><td align="center">输出字段分割符,默认为” “</td></tr><tr><td align="center">ORS</td><td align="center">输出的记录分割符,默认为”\n”</td></tr><tr><td align="center">RLENGTH</td><td align="center">被函数match匹配的字符串长度</td></tr><tr><td align="center">RS</td><td align="center">记录分隔符</td></tr><tr><td align="center">RT</td><td align="center">如果RS为正则表达式，RT则代表当前行所匹配的值</td></tr><tr><td align="center">RSTART</td><td align="center">被函数match匹配的字符串的开始</td></tr><tr><td align="center">SUBSEP</td><td align="center">下标分割符(\034)</td></tr><tr><td align="center">$0</td><td align="center">整行内容</td></tr></tbody></table><h3 id="awk内置函数"><a href="#awk内置函数" class="headerlink" title="awk内置函数"></a>awk内置函数</h3><table><thead><tr><th align="center">算术函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">cos(x)</td><td align="center">返回x的余弦</td></tr><tr><td align="center">exp(x)</td><td align="center">返回e的x次幂</td></tr><tr><td align="center">sin(x)</td><td align="center">返回x的正弦</td></tr><tr><td align="center">int(x)</td><td align="center">返回x的整数部分的值</td></tr><tr><td align="center">log(x)</td><td align="center">返回x的自然对数(以e为底)</td></tr><tr><td align="center">sqrt(x)</td><td align="center">返回x的平方根</td></tr><tr><td align="center">atan2(y,x)</td><td align="center">返回y&#x2F;x的反正切</td></tr><tr><td align="center">rand()</td><td align="center">返回0-1之间的随机数</td></tr><tr><td align="center">srand(x)</td><td align="center">建立rand()的新的种子数。如果没有指定种子数,就用当天的时间。返回旧的种子值</td></tr><tr><td align="center">字符串函数</td><td align="center">描述</td></tr><tr><td align="center">gsub(r,s,t)</td><td align="center">在字符串t中用字符串s替换和正则表达式r匹配的所有字符串。返回替换的个数。如果没有给出t,默认$0</td></tr><tr><td align="center">gensub(r,s,h,t)</td><td align="center">如果h以g或G开始的字符串，则对于在t中的r,用s进行全局替换。否则，h是一个数据：替换第h次出现的r.该函数返回新值，t本身不会改变，t默认为$0</td></tr><tr><td align="center">sprintf(fmt,expr-list)</td><td align="center">根据格式字符串fmt返回格式化后的expr-list,fmt格式见printf那里</td></tr><tr><td align="center">index(s,t)</td><td align="center">返回子串t在字符串s中的位置,如果没有指定s,则返回0</td></tr><tr><td align="center">length(s)</td><td align="center">返回字符串s的长度,当没有给出s时,返回$0的长度</td></tr><tr><td align="center">match(s,r)</td><td align="center">如果正则表达式r在s中出现,则返回出现的起始位置;如果没有,则返回0</td></tr><tr><td align="center">spllit(s,a,sep)</td><td align="center">使用字段分隔符sep将字符串s分解到数组a的元素中,返回元素个数。如果没有给出sep,则使用FS。数组分割和字段分隔采用相同的方式</td></tr><tr><td align="center">sub(r,s,t)</td><td align="center">在字符串t中用s替换正则表达式r的首次匹配。如果成功则返回1,否则返回0,,如果没有给出t,默认为$0</td></tr><tr><td align="center">substr(s,p,n)</td><td align="center">返回字符串s中从位置p开始最大长度为n的子串。如果没有给出n,返回从p开始剩余的字符串。</td></tr><tr><td align="center">systime()</td><td align="center">返回用秒表示的天的当前的时间,从UNIX元年开始算</td></tr><tr><td align="center">strftime(format,timestamp)</td><td align="center">依照format格式化timestamp。timestamp默认为当前</td></tr><tr><td align="center">tolower(s)</td><td align="center">将字符串s中的所有大写字符转换为小写,并返回新串</td></tr><tr><td align="center">toupper(s)</td><td align="center">将字符串s中的小写字符转换为大写,并返回新串</td></tr></tbody></table><h3 id="模式汇总"><a href="#模式汇总" class="headerlink" title="模式汇总"></a>模式汇总</h3><table><thead><tr><th align="center">格式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">BEGIN {statements}</td><td align="center">在输入被读取之前,statements执行一次,<strong>注意BEGIN里一些内建变量可能为空(如FILENAME)</strong></td></tr><tr><td align="center">END {statements}</td><td align="center">当所有输入被读取完毕之后,statements执行一次</td></tr><tr><td align="center">expression {statements}</td><td align="center">每碰到一个使expression为真的输入行,statements就执行.expression为真指的是其值非零或非空</td></tr><tr><td align="center">&#x2F;regular expression&#x2F; {statements}</td><td align="center">当输入行有一段字符串可以被正则表达式匹配,则执行statements</td></tr><tr><td align="center">compound pattern {statements}</td><td align="center">一个复合模式将表达式用&amp;&amp;,</td></tr><tr><td align="center">pattern1,pattern2 {statements}</td><td align="center">一个范围模式匹配多个输入行,这些输入行从匹配pattern1的开始,到匹配pattern2的行结束(包括这两行),对这其中的每一行执行statements</td></tr></tbody></table><h3 id="字符串匹配模式"><a href="#字符串匹配模式" class="headerlink" title="字符串匹配模式"></a>字符串匹配模式</h3><table><thead><tr><th align="center">格式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&#x2F;regexpr&#x2F;</td><td align="center">当当前输入行包含一段能够被regexexpr匹配的子字符串时,该模式匹配</td></tr><tr><td align="center">expression ~ &#x2F;regexpr&#x2F;</td><td align="center">如果expression的字符串值包含一段能够被regexpr匹配的子字符串时,该模式被匹配,返回该字符串,否则返回（待测试）</td></tr><tr><td align="center">expression !~ &#x2F;regexpr&#x2F;</td><td align="center">与上述相反</td></tr></tbody></table><h3 id="正则和字符串中的转移序列"><a href="#正则和字符串中的转移序列" class="headerlink" title="正则和字符串中的转移序列"></a>正则和字符串中的转移序列</h3><table><thead><tr><th align="center">序列</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>\a</code></td><td align="center">报警字符</td></tr><tr><td align="center"><code>\b</code></td><td align="center">退格</td></tr><tr><td align="center"><code>\f</code></td><td align="center">换页</td></tr><tr><td align="center"><code>\n</code></td><td align="center">换行</td></tr><tr><td align="center"><code>\r</code></td><td align="center">回车</td></tr><tr><td align="center"><code>\t</code></td><td align="center">制表符</td></tr><tr><td align="center"><code>\v</code></td><td align="center">垂直制表符</td></tr><tr><td align="center"><code>\ddd</code></td><td align="center">八进制数ddd, ddd含有1到3个数字,每个数字的值在0到7 之间</td></tr><tr><td align="center"><code>\xbex</code></td><td align="center">十六进制</td></tr></tbody></table><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>awk中的数组不需要声明定义,都是关联数组</p><ul><li>赋值一个数组<code>array[0]=1;array[1]=2</code></li><li>删除一个元素<code>delete array[subscript]</code></li><li>删除一个数组<code>delete array</code></li><li><code>i in a</code>如果a[i]存在,则表达式为1,否则为0</li><li>遍历数组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#var是arr的每个下标</span><br><span class="hljs-keyword">for</span> (var <span class="hljs-keyword">in</span> arr)<br>&#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>字符串的连接<code>&quot;pre&quot;str&quot;suf&quot;</code>不需要加号</li></ul><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>自定义函数的参数为值传递，不改变遍历本身，但是数组例外,函数体内出现的任何变量都是全局变量，想要使用局部变量，只能放在参数列表中（参数列表中没有实际参数对应的参数都将作为局部变量使用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> name(patameter-list)&#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="awk处理多行记录-主要改变分隔符"><a href="#awk处理多行记录-主要改变分隔符" class="headerlink" title="awk处理多行记录,主要改变分隔符"></a>awk处理多行记录,主要改变分隔符</h3><p><code>BEGIN &#123; FS=&quot;\n&quot;;RS=&quot;&quot;&#125;</code>,RS代表空行</p><h3 id="awk-script-x-1-test1-x-2-test2-awk可以这样传递变量"><a href="#awk-script-x-1-test1-x-2-test2-awk可以这样传递变量" class="headerlink" title="awk &#39;script&#39; x=1 test1 x=2 test2,awk可以这样传递变量"></a><code>awk &#39;script&#39; x=1 test1 x=2 test2</code>,awk可以这样传递变量</h3><h3 id="BEGIN与END"><a href="#BEGIN与END" class="headerlink" title="BEGIN与END"></a>BEGIN与END</h3><p>特殊的模式BEGIN在第一个输入文件的第一行之前被匹配,END在最后一个输入文件的最后一行被处理之后匹配。</p><h3 id="next与exit"><a href="#next与exit" class="headerlink" title="next与exit"></a>next与exit</h3><p>next使awk抓取下一行,并返回到脚本底部;exit会使awk执行END,如果已经在END,则结束程序</p><h3 id="nextfile"><a href="#nextfile" class="headerlink" title="nextfile"></a>nextfile</h3><p>nextfile语句和next类似，但它是更高层次上的操作。当执行nextfile时，当前的数据文件将被放弃，操作从脚本顶端开始，并使用下一个文件的第一个记录。</p><h3 id="输入分隔符"><a href="#输入分隔符" class="headerlink" title="输入分隔符"></a>输入分隔符</h3><p>内建变量 FS 的默认值是 “ “, 也就是一个空格符. 当 FS 具有这个特定值时, 输入字段按照 空格和 (或) 制表符分割, 前导的空格与制表符会被丢弃, 所以下面三行数据中, 其每一行的第 1 个字段都相同:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"> field1<br> field1<br>field1 field2<br></code></pre></td></tr></table></figure><p>然而, 当 FS 是其他值时, 前导的空格与制表符不会被丢弃.  把一个字符串赋值给内建变量 FS 就可以改变字段分隔符. 如果字符串的长度多于一个字 符, 那么它会被当成一个正则表达式. 当前输入行中, 与该正则表达式匹配的最左, 最长, 非空且<br>不重叠的子字符串变成字段分隔符, 举例来说,<br><code>BEGIN &#123; FS = &quot;,[ \t]*|[ \t]+&quot; &#125;</code><br>如果某个子串由一个后面跟着空格或制表符的逗号组成, 或者没有逗号, 只有空格与制表符, 那 么这个子串就是字段分隔符.  如果 FS 被设置成单个字符 (除了空格符), 那么这个字符就变成字段分隔符. 这个约定使得<br>把正则表达式元字符当作字段分隔符来用, 变得很容易:<br>FS &#x3D; “|”<br>把 | 变成字段分隔符<br><font color=#FF0000>不管FS的值是什么,换行符总是多行记录的字段分隔符之一 </font>,如果RS被设置成””(即空行为记录分割符),则默认的字段分隔符就是空格,制表及换行;如果FS是\n,则换行符既是唯一分隔符</p><h4 id="FIELDWIDTHS"><a href="#FIELDWIDTHS" class="headerlink" title="FIELDWIDTHS"></a>FIELDWIDTHS</h4><p>该变量可以用来分隔出现在固定宽度列中的数据。这些数据可能或不可能由空白字符来风格字段的值<br><code>FIELDWIDTHS= &quot;5 6 8 3&quot;</code><br>这里的记录有4个字段：$1有5个字符宽度，$2有6个字符的宽度等等。为FS指定一个值将恢复常规机制。通常使用FS&#x3D;FS恢复，无需保存到额外变量中。</p><h3 id="print与printf"><a href="#print与printf" class="headerlink" title="print与printf"></a>print与printf</h3><table><thead><tr><th align="center">格式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">print</td><td align="center">将$0打印到标准输出</td></tr><tr><td align="center">print expression,expression,…</td><td align="center">打印各个expression,expression之间由OFS分开,由ORS终止</td></tr><tr><td align="center">print expression,expression,…&gt;filename</td><td align="center">输出至filename</td></tr><tr><td align="center">print expression,expression,…&gt;filename</td><td align="center">追加到filename,不覆盖之前内容</td></tr><tr><td align="center">print expression,expression,…</td><td align="center">command</td></tr><tr><td align="center">close(filename),close(command)</td><td align="center">断开print与filename(或command)之间的连接,同一命令想要两次之间毫无关联,必须先close</td></tr><tr><td align="center">fflush(filename&#x2F;cmd)</td><td align="center">刷新缓存</td></tr><tr><td align="center">system(command)</td><td align="center">执行command;函数的返回值是command的退出状态</td></tr></tbody></table><p>printf主要可以指定格式,以上都能用printf替换,如:<code>printf(format,expression,expression,...) &gt; filename</code>末尾不会自动添加换行符<br>printf格式控制符(每一个格式说明符都以%开始,以转换字符结束)</p><p>|字符|表达式将被打印成|<br>|C|ASCII 字符|<br>|d|十进制整数|<br>|e|[-]d.dddddde[+-]dd|<br>|E|[-]d.ddddddE[+-]dd|<br>|f|[-]ddd.dddddd|<br>|g|照e或f进行转换, 选择较短的那个, 无意义的零会被抑制|<br>|G|照E或f进行转换, 选择较短的那个, 无意义的零会被抑制|<br>|i|十进制|<br>|O|无符号八进制数|<br>|s|字符串|<br>|x|无符号十六进制数|<br>|X|无符号十六进制数,字母大写|<br>|%|打印一个百分号 %, 不会有参数被吸收|</p><table><thead><tr><th align="center">修饰符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">表达式在它的域内左对齐</td></tr><tr><td align="center">width</td><td align="center">为了达到规定的宽度,必要时填充空格，前导0表示用0填充</td></tr><tr><td align="center">.prec</td><td align="center">字符串最大宽度, 或十进制数的小数部分的位数</td></tr></tbody></table><table><thead><tr><th align="center">fmt</th><th align="center">$1</th><th align="center">printf(fmt,$1)</th></tr></thead><tbody><tr><td align="center">%c</td><td align="center">97</td><td align="center">a</td></tr><tr><td align="center">%d</td><td align="center">97.5</td><td align="center">97</td></tr><tr><td align="center">%5d</td><td align="center">97.5</td><td align="center">97</td></tr><tr><td align="center">%e</td><td align="center">97.5</td><td align="center">9.750000e+01</td></tr><tr><td align="center">%f</td><td align="center">97.5</td><td align="center">97.500000</td></tr><tr><td align="center">%7.2f</td><td align="center">97.5</td><td align="center">97.50</td></tr><tr><td align="center">%g</td><td align="center">97.5</td><td align="center">97.5</td></tr><tr><td align="center">%.6g</td><td align="center">97.5</td><td align="center">97.5</td></tr><tr><td align="center">%o</td><td align="center">97</td><td align="center">141</td></tr><tr><td align="center">%06o</td><td align="center">97</td><td align="center">000141</td></tr><tr><td align="center">%x</td><td align="center">97</td><td align="center">61</td></tr><tr><td align="center">%s</td><td align="center">January</td><td align="center">&#96;</td></tr><tr><td align="center">%10s</td><td align="center">January</td><td align="center">&#96;</td></tr><tr><td align="center">%-10s</td><td align="center">January</td><td align="center">&#96;</td></tr><tr><td align="center">%.3s</td><td align="center">January</td><td align="center"><code>Jan</code></td></tr><tr><td align="center">%10.3s</td><td align="center">January</td><td align="center">&#96;</td></tr><tr><td align="center">%-10.3s</td><td align="center">January</td><td align="center">&#96;</td></tr><tr><td align="center">%%</td><td align="center">January</td><td align="center">%</td></tr></tbody></table><h3 id="管道的奇怪用法-好好理解到底啥是管道"><a href="#管道的奇怪用法-好好理解到底啥是管道" class="headerlink" title="管道的奇怪用法(好好理解到底啥是管道)"></a>管道的奇怪用法(好好理解到底啥是管道)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br><span class="hljs-comment">#注意sort命令用引号括起来,当成字符串</span><br><span class="hljs-built_in">print</span> xx | <span class="hljs-string">&quot;sort -t&#x27;\t&#x27; +1rn&quot;</span><br><span class="hljs-comment">#上面的管道名就是&quot;sort -t&#x27;\t&#x27; +1rn&quot;</span><br>close(<span class="hljs-string">&quot;sort -t&#x27;\t&#x27; +1rn&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>假设有以下文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">France</span><span class="hljs-number">211</span><span class="hljs-number">55</span>Europe<br><span class="hljs-attribute">Japan</span><span class="hljs-number">144</span><span class="hljs-number">120</span>Asia<br><span class="hljs-attribute">Germany</span><span class="hljs-number">96</span><span class="hljs-number">61</span>Europe<br><span class="hljs-attribute">England</span><span class="hljs-number">94</span><span class="hljs-number">56</span>Europe<br><span class="hljs-attribute">USSR</span><span class="hljs-number">8649</span><span class="hljs-number">275</span>Asia<br><span class="hljs-attribute">Canada</span><span class="hljs-number">3852</span><span class="hljs-number">25</span>North America<br><span class="hljs-attribute">China</span><span class="hljs-number">3705</span><span class="hljs-number">1032</span>Asia<br><span class="hljs-attribute">USA</span><span class="hljs-number">3615</span><span class="hljs-number">237</span>North America<br><span class="hljs-attribute">Brazil</span><span class="hljs-number">3286</span><span class="hljs-number">134</span>South America<br><span class="hljs-attribute">India</span><span class="hljs-number">1267</span><span class="hljs-number">746</span>Asia<br><span class="hljs-attribute">Mexico</span><span class="hljs-number">762</span><span class="hljs-number">78</span>North America<br></code></pre></td></tr></table></figure><p>以下程序会简单排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># prep1 - prepare countries by continent and pop. den.</span><br>BEGIN &#123; FS = <span class="hljs-string">&quot;\t&quot;</span> &#125;<br>&#123; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:%s:%d:%d:%.1f\n&quot;</span>,<br><span class="hljs-variable">$4</span>, <span class="hljs-variable">$1</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$2</span>, 1000*<span class="hljs-variable">$3</span>/<span class="hljs-variable">$2</span>) | <span class="hljs-string">&quot;sort -t: -k 1,1 -k 5rn&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getline函数"><a href="#getline函数" class="headerlink" title="getline函数"></a>getline函数</h3><ul><li>描述:函数getline可以从当前输入行,或文件,或管道,读取输入.getline抓取下一个记录,按照通常的方式把记录分割成一个个的字段.它会设置NF,NR,和FNR;如果存在一个记录,返回1,若遇到文件末尾,返回0,发生错误时返回-1(例如打开文件失败).</li><li><code>getline x</code>读取下一条记录到变量x中，并递增NR与FNR,不会对记录进行分隔，不会设置NF</li><li><code>getline &lt;&quot;file&quot;</code>从文件file读取输入.它不会对NR与FNR产生影响, 但是会执行字段分割,并且设置NF.</li><li><code>getline x &lt;&quot;file&quot;</code>从file读取下一条记录,存到变量x中.记录不会被分割成字段,变量NF,NR,与FNR都不会被修改.</li></ul><table><thead><tr><th align="center">表达式</th><th align="center">被设置的变量</th></tr></thead><tbody><tr><td align="center">getline</td><td align="center">$0,NF,NR,FNR</td></tr><tr><td align="center">getline var</td><td align="center">var,NR,FNR</td></tr><tr><td align="center">getline &lt;file</td><td align="center">$0,NF</td></tr><tr><td align="center">getline var&lt;file</td><td align="center">var</td></tr><tr><td align="center">&#96;cmd</td><td align="center">getline&#96;</td></tr><tr><td align="center">&#96;cmd</td><td align="center">getline var&#96;</td></tr></tbody></table><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#必须判断大于0,否则文件不存在则就是死循环</span><br><span class="hljs-keyword">while</span> (getline x&lt;file &gt;0)<br><span class="hljs-built_in">print</span> x<br>next<br><span class="hljs-keyword">while</span> (<span class="hljs-string">&quot;who&quot;</span>|getline)<br>n++<br></code></pre></td></tr></table></figure><p>13.例子<br>a.将每一行的字段逆序打印</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br><span class="hljs-keyword">for</span> (i=NF;i&gt;0;i=i-1) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,<span class="hljs-variable">$i</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="awk的正则表达式"><a href="#awk的正则表达式" class="headerlink" title="awk的正则表达式"></a>awk的正则表达式</h3><ul><li>awk的圆括号用法有点异样:<code>(r1)(r2)</code>若匹配xy,其中x匹配r1,y匹配r2。<br>举例:<code>(Asian|European|North American) (male|female) (black|blue)bird</code>12种组合</li></ul><h3 id="shell中包含awk"><a href="#shell中包含awk" class="headerlink" title="shell中包含awk"></a>shell中包含awk</h3><ul><li>见例子1</li></ul><h3 id="awk程序搜索路径"><a href="#awk程序搜索路径" class="headerlink" title="awk程序搜索路径"></a>awk程序搜索路径</h3><p> awk允许你指定一个名为AWKPATH的环境变量，它定义了awk程序的文件搜索路径，默认路径为:&#x2F;usr&#x2F;local&#x2F;share&#x2F;awk。当前路径永远最优先,如果文件名包含<code>/</code>将不执行查找</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># field -打印每个文件的指定字段顺序</span><br><span class="hljs-comment"># usage: field n n n ... file file file ...</span><br>awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">#开始时,寻找数字,并使之清空,这样他们就不会被当成文件名</span><br><span class="hljs-string">BEGIN &#123;</span><br><span class="hljs-string">for (i = 1; ARGV[i] ~ /^[0-9]+$/; i++) &#123; # collect numbers</span><br><span class="hljs-string">fld[++nf] = ARGV[i]</span><br><span class="hljs-string">ARGV[i] = &quot;&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">if (i &gt;= ARGC)</span><br><span class="hljs-string"># no file names so force stdin</span><br><span class="hljs-string">ARGV[ARGC++] = &quot;-&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">for (i = 1; i &lt;= nf; i++)</span><br><span class="hljs-string">printf(&quot;%s%s&quot;, $fld[i], i &lt; nf ? &quot; &quot; : &quot;\n&quot;)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;</span> $*<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#交互式awk脚本</span><br>BEGIN &#123;<br>maxnum = ARGC &gt; 1 ? ARGV[1] : 10<br><span class="hljs-comment"># default size is 10</span><br>ARGV[1] = <span class="hljs-string">&quot;-&quot;</span><span class="hljs-comment"># read standard input subsequently</span><br>srand()<span class="hljs-comment"># reset rand from time of day</span><br><span class="hljs-keyword">do</span> &#123;<br>n1 = randint(maxnum)<br>n2 = randint(maxnum)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%g + %g = ? &quot;</span>, n1, n2)<br><span class="hljs-keyword">while</span> ((input = getline) &gt; <span class="hljs-number">0</span>)<br>if (<span class="hljs-variable">$0</span> == n1 + n2) &#123;<br>print &quot;Right!&quot;<br>break<br>&#125; else if (<span class="hljs-variable">$0</span> == &quot;&quot;) &#123;<br>print n1 + n2<br>break<br>&#125; else<br>printf(&quot;wrong, try again: &quot;)<br>&#125; while (input &gt; <span class="hljs-number">0</span>)<br>&#125;<br>function randint(n) &#123; return int(rand()*n)+<span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure><ul><li>去除字符串<code>gsub(/&quot;([^&quot;]|\\&quot;)*&quot;/, &quot;&quot;, line)</code></li><li>去除正则表达式<code>gsub(/\/([^\/]|\\\/)+\//, &quot;&quot;, line)</code></li><li>去除注释<code>sub(/#.*/, &quot;&quot;, line)</code></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux问题解决</title>
    <link href="/2020/12/31/Arch_Linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%BB%8F%E9%AA%8C/"/>
    <url>/2020/12/31/Arch_Linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>1.广通无线网卡问题<br><code>lspci</code>查看那个shit一样的网卡名字”BCM43142”<br><code>sudo pacman -S linux-headers</code>装这个东西<br><code>sudo pacman -S broadcom-wl-dkms</code>安装这个屎样的驱动<br>你可能会说,没网下个屁啊<br>打开archwiki的package页面搜索包,点想要的包,在右边有个小字download from mirrors,点他下载离线包,sudo pacman -U 那个包<br>最新包可能出现问题,降级的时候要连linux那个包一块降级,linux和linux-headers版本号要对应上,<br>2.降级问题<br>最新包可能出现问题,先在&#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F;那个目录下找缓存的文件<br>找不到再从网上找。<br>也可以用downgrade工具,没用过就不说它了<br>3.背光灯问题<br>&#x2F;etc&#x2F;modprobe.d&#x2F;sony-laptop.conf 索尼背光灯设置文件<br>4.制作启动盘<br>直接用如下命令制作,deepin官网的也不行<br><code>df</code>查看启动U盘的设备号<br><code>sudo dd bs=4M if=deepin-desktop-community-1010-amd64.iso of=/dev/sdb status=progress &amp;&amp; sync</code><br>注意:如果u盘表现异常,一插有两个部分(一个部分只有几百兆),制作不会成功.也无法直接格式化,此时可以借助deepin官网启动盘制作,先格式化,再按上述操作<br>5.pacman更新过程中崩溃,断电<br>a.先制作启动盘(按上述方法)<br>b.assistant键进入,选择U盘启动(bios里外部设备启动要打开)<br>c.<code>iwctl</code>进入无线网配置<br>(1)查看无线设备<br><code>device list</code><br>(2)扫描无线网<br><code>station wlan0 scan</code><br>(3)列出网络名<br><code>station wlan0 get-networks</code><br>(4)根据设备(wlan0)连接wifi名称<br><code>station wlan0 connect CMCC-A9wF</code>并输入密码(75ij3tw7)<br>(5)<br>exit退出<br>d.挂载根文件系统,proc,sys和dev<br><code>mount /dev/sda[x] /mnt;mount -t proc proc /mnt/proc;mount --rbind /sys /mnt/sys;mount --rbind /dev /mnt/dev</code><br>e.有锁的话,删除锁<br><code>rm /mnt/var/lib/pacman/db.lck</code>要加&#x2F;mnt绝对路径<br>f.查找损坏包<br><code>pacman --sysroot /mnt -S $(pacman --sysroot /mnt -Qnq)</code><br>损坏包会有<code>vim: /usr/xxx/xxx exists in filesystem</code>,这里vim就是损坏包<br>注意如果没有损坏包,就不要执行上述命令,因为他是重装所有包,这里只是检查以下<br>g.把上述命令重定向到一个文件,用vim修改成每一行如<code>rm -f /mnt/usr/xxx/xxx</code><br>列模式修改(选中按c即可)’:’前面的所有字符为<code>rm -f /mnt</code>(要加&#x2F;mnt,绝对路径),全局替换掉所有’exists in filesystem’为空<br>h.<code>chmod +x</code>赋予那个重定向文件执行权限,<code>./(那个文件)</code><br>i.更新或安装损坏包,<br><code>pacman --sysroot /mnt -S (package)</code><br>j.如果找不到镜像,重装下列包<br><code>pacman --sysroot /mnt -S mkinitcpio systemd linux</code><br>6.无线问题<br><code>如果无线标志都没出来</code>网卡重装,回到本博客开头的第一个问题<br><code>如果标志出来,收不到任何无线网</code>重装<code>wpa_supplicant</code><br>7.wps界面不显示中文<br>卸载,用yay重装wps-office-cn版本,提示你可选依赖，装上所有可选依赖<br>8.<br>gdm进不去,重装gtk,gdm,gnome,xorg,gnome相关的全部删除<br>9.yay包降级<br>在wiki上找到那个包,在右边点击View Changes,选择想要的版本,点击下载,然后进入下载的解压缩文件,输入命令makepkg,sudo pacman -U xx.tar*<br>10.自动挂载手机<br>安装<code>gvfs-mtp</code>和<code>gvfs-gphoto2</code><br>11.gnome的压缩软件-&gt;file-roller<br>12.lantern缺少的依赖-&gt;’libappindicator-gtk2&#x2F;3’<br>13.ubuntu虚拟机安装增强功能需要<code>build-essential gcc make perl linux-image-xx-generic</code></p><ul><li>声音要先放网易云才能有,且要一直放的trouble,装<code>pipewire pipewire-pulse pipewire-alsa pipewire-jack pipewire-media-session</code><br>14.鼠标大小<br>dconf write &#x2F;org&#x2F;gnome&#x2F;desktop&#x2F;interface&#x2F;cursor-size 42</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>openSSH</title>
    <link href="/2020/12/21/openSSH/"/>
    <url>/2020/12/21/openSSH/</url>
    
    <content type="html"><![CDATA[<p>1.登录服务器<br><code>ssh &lt;user&gt;@&lt;hostname&gt;</code>hostname是主机名,可以是域名,也可能是IP地址,不指定<user>@时,默认为客户端的当前用户名<br><code>ssh -p 8821 foo.com</code>默认端口为21,可以用-p选项指定服务器的端口<br>2.文件信息<br>服务器公钥的指纹既是SSH服务器公钥的哈希值,每台SSH服务器都有唯一一对密钥<br><code>ssh-keygen -l -f [*.pub]</code>查看某个公钥的指纹<br>ssh会将本机链接过的所有服务器公钥的指纹存储在”~&#x2F;.ssh&#x2F;known_hosts”文件中。每次链接服务器都会通过该文件判断是否为陌生服务器,如果是陌生的则会产生警告,如果输入yes忽略警告,将会自动添加该服务器的公钥指纹到该文件<br><code>ssh-keygen -R &lt;hostname&gt;</code>用于删除某服务器的公钥(用于失效的情况),也可以手动删除known_hosts文件中的相关内容<br>3.执行远程命令<br>一般在登陆后,输入命令,<br>也可以一步到位<code>ssh [username@hostname] &lt;command&gt;</code>登陆成功后立即执行命令,如果命令是交互式的,则需要加上-t选项,如:<code>ssh -t foo.com vi foo.txt</code><br>4.命令行配置项</p><table><thead><tr><th align="center">参数</th><th align="center">意义</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">指定加密算法</td><td align="center"><code>ssh -c blowfish,3des server.example.com</code>,<code>ssh -c blowfish -c 3des server.example.com</code></td></tr><tr><td align="center">-C</td><td align="center">压缩数据传输</td><td align="center"><code>ssh -C server.example.com</code></td></tr><tr><td align="center">-d</td><td align="center">设置打印的debug信息级别,数值越高越详细</td><td align="center"><code>ssh -d 1 foo.com</code></td></tr><tr><td align="center">-D</td><td align="center">指定本机的Socks监听端口,该端口收到的请求,都将转发到远程SSH主机,又称动态端口转发</td><td align="center"><code>ssh -D 1080 server</code></td></tr><tr><td align="center">-f</td><td align="center">表示SSH链接在后台运行</td><td align="center"></td></tr><tr><td align="center">-F</td><td align="center">指定配置文件</td><td align="center"><code>ssh -F /usr/local/ssh/other_config</code></td></tr><tr><td align="center">-i</td><td align="center">用于指定私钥,默认值是~&#x2F;.ssh&#x2F;id_dsa</td><td align="center"><code>ssh -i my-key server.example.com</code></td></tr><tr><td align="center">-l</td><td align="center">参数指定远程登录的账户名</td><td align="center"><code>ssh -l nanbert server.example.com</code></td></tr><tr><td align="center">-L</td><td align="center">设置本地端口转发</td><td align="center"><code>ssh -L 9999:targetServer:80 user@remoteServer</code>所有发向本地9999端口的请求,都会经过remoteServer发往targetServer的80端口,相当于直接连上了80的端口</td></tr><tr><td align="center">-m</td><td align="center">指定校验数据完整性的算法(MAC)</td><td align="center"><code>ssh -m hmac-sha1,hmac-md5 server.example.com</code></td></tr><tr><td align="center">-o</td><td align="center">参数用来指定一个配置命令,来覆盖配置文件设置</td><td align="center"><code>ssh -o &quot;User sally&quot; server.example.com</code></td></tr><tr><td align="center">-p</td><td align="center">指定链接的服务器的端口</td><td align="center"><code>ssh -p 2305 server.example.com</code></td></tr><tr><td align="center">-q</td><td align="center">安静模式,不输出任何警告</td><td align="center"><code>ssh -q foo.com</code></td></tr><tr><td align="center">-R</td><td align="center">指定远程端口转发</td><td align="center"><code>ssh -R 9999:targetServer:902 local</code>该命令需要在跳板服务器执行,指定本机计算机local监听自己的9999端口,所有发向这个端口的请求,都会转向targetServer的902端口</td></tr><tr><td align="center">-t</td><td align="center">在ssh直接运行远端命令时,提供一个交互shell</td><td align="center"><code>ssh -t server.example.com emacs</code></td></tr><tr><td align="center">-v</td><td align="center">显示详细信息,可重复多次,表示详细程度</td><td align="center"><code>ssh -vvv server.example.com</code></td></tr><tr><td align="center">-V</td><td align="center">显示客户端版本信息</td><td align="center"></td></tr><tr><td align="center">-X</td><td align="center">表示打开X窗口转发</td><td align="center"><code>ssh -X server.example.com</code></td></tr><tr><td align="center">-1,-2,-4,-6</td><td align="center">1表示SSH1协议,2表示SSH2协议,4表示IPv4协议(默认值),6表示Ipv6协议</td><td align="center"></td></tr></tbody></table><p>5.配置文件</p><table><thead><tr><th align="center">路径</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">&#x2F;etc&#x2F;ssh&#x2F;ssh_config</td><td align="center">全局配置文件</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;config</td><td align="center">用户个人的配置文件</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;id_ecdsa</td><td align="center">用户的ECDSA私钥</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;id_ecdsa.pub</td><td align="center">用户的ECDSA公钥</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;rsa</td><td align="center">用于SSH2的rsa私钥</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;rsa.pub</td><td align="center">用于SSH2的rsa公钥</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;identity</td><td align="center">用于SSH1的rsa私钥</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;identity.pub</td><td align="center">用于SSH1的rsa公钥</td></tr><tr><td align="center">~&#x2F;.ssh&#x2F;known_hosts</td><td align="center">包含SSH服务器的公钥指纹</td></tr></tbody></table><p>配置文件示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host *<br>Port 2222<br>Host remoteserver<br>HostName remote.example.com<br>User nanbert<br>Port 2112<br></code></pre></td></tr></table></figure><p>常见配置命令:<br><code>AddressFamily &lt;option&gt;</code>option可以是inet,表示IPV4协议,也可以是inet6,表示IPV6协议<br><code>BindAddress 192.168.10.235</code>指定本机的IP地址(如果本机有多个Ip地址)<br><code>CheckHostIP &lt;yesOrNo&gt;</code>是否检查SSH的服务器IP地址是否跟公钥数据库吻合<br><code>Ciphers &lt;option&gt;</code>:指定加密算法<br><code>Compression &lt;yesOrNo&gt;</code>是否压缩传输信号<br><code>ConnectionAttempts &lt;num&gt;</code>客户端进行连接时,最大尝试次数<br><code>ConnectTimeout &lt;num&gt;</code>客户端进行连接时,服务器在指定秒数内没有回复,则中断连接尝试<br><code>DynamicForward &lt;portNum&gt;</code>指定动态转发端口<br><code>GlobalKnownHostsFile &lt;filePath&gt;</code>指定全局的公钥数据库文件的位置<br><code>Host &lt;serverName&gt;</code>指定连接的域名或IP地址,也可以是别名,支持通配符,后面所有配置都是针对该主机,直到遇到下一个Host<br><code>HostKeyAlgorithm &lt;options&gt;</code>指定密钥算法,优先级从高到低排列,以逗号分隔<br><code>HostName &lt;serverAddress&gt;</code>在Host命令使用别名的情况下用<br><code>IdentityFile &lt;fileName&gt;</code>指定私钥文件<br><code>LocalForward 2001 localhost:143</code>指定本地端口转发<br><code>LogLevel &lt;options&gt;</code>指定日志详细程度。如果设为<code>QUIET</code>,将不输出大部分的警告和提示<br><code>MACs &lt;options&gt;</code>指定数据校验算法,以逗号分隔<br><code>NumberOfPasswordPrompts &lt;num&gt;</code>输错密码最大尝试数<br><code>PasswordAuthentication &lt;yesOrNo&gt;</code>是否支持密码登录,这里只是客户端,需要服务器也有相同的设置<br><code>Port &lt;portNum&gt;</code>指定客户端链接的SSH服务器端口<br><code>PreferredAutentications publickey,hostbased,password</code>指定各种登录方法优先级<br><code>Protocol &lt;1,2&gt;</code>支持的SSH协议版本,可以用逗号分隔同时支持两个版本<br><code>PubKeyAuthentication &lt;yesOrNo&gt;</code>是否支持密钥登录,这里只是客户端设置,需要服务器相同的设置<br><code>RemoteForward 2001 server:143</code>指定远程端口转发<br><code>SendEnv &lt;variable&gt;</code>客户端向服务器发送环境变量名,多个环境变量之间用空格分隔,变量的值从当前环境拷贝<br><code>ServerAliveCountMax &lt;num&gt;</code>如果没有收到服务器的回应,客户端发送多少次keepalive信号,才断开连接,默认为3<br><code>ServerAliveInterval &lt;num&gt;</code>客户端建立连接后,如果在给定的数秒内,没有收到服务器发来的消息,客户端向服务器发送keepalive消息,如果不希望客户端发送,这一项设为0<br><code>StrictHostKeyChecking &lt;yesOrNo&gt;</code>yes表示严格检查,服务器公钥为未知或发生变化,则拒绝连接。no表示如果服务器公钥未知,则加入客户端公钥数据库,如果公钥发生变化,不改变客户端公钥数据库,输出一条警告,依然允许连接继续进行。ask(默认值)表示向用户询问是否继续<br><code>TCPKeepAlive &lt;yesOrNo&gt;</code>客户端是否定期向服务器发送keepalive信息<br><code>User &lt;userName&gt;</code>指定登录账户名<br><code>UserKnownHostsFile &lt;filePath&gt;</code>指定当前用户的服务器公钥指纹列表(known_hosts)的文件位置<br><code>VerifyHostKeyDNS &lt;yesOrNo&gt;</code>是否检查SSH服务器的DNS记录,确认公钥指纹是否与known_hosts文件保持一致<br>6.密钥<br><em>概念</em>:<br>密钥是一个非常大的数字,通过加密算法得到。对称加密只需要一个密钥,非对称加密需要成对使用,分为公钥和私钥。<br>SSH密钥登录采用非对称加密,每个永不通过自己的密钥登录。其中,私钥必须私密保存,不能泄露;公钥则公开,对外发送。它们的关系是,公钥和私钥是一一对应<br><em>过程</em>:<br>预备步骤,客户端通过<code>ssh-keygen</code>生产自己的公钥和私钥<br>第一步,手动将客户端的公钥放入远程服务器的指定位置<br>第二步,客户端向服务器发起SSH登录请求<br>第三步,服务器收到用户SSH登录的请求,发送一些随机数据给用户,要求用户证明自己的身份<br>第四步,客户端收到服务器发来的数据,私用私钥对数据进行签名,然后再发给服务器<br>第五步,服务器收到客户端发来的加密签名后,使用对应的公钥解密,然后跟原始数据比较。如果一致,就允许用户登录<br><em>ssh-key–生成密钥</em><br>该命令会生成一对密钥,私钥默认存在<del>&#x2F;.ssh&#x2F;id_rsa,公钥默认存在</del>&#x2F;.ssh&#x2F;id_rsa.pub</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-b [num]</td><td align="center">指定密钥的二进制位数。这个参数越大,密钥越不容易破解,但是加密解密的开销也会越大,一般至少应该是1024</td></tr><tr><td align="center">-C “[string]”</td><td align="center">可以为密钥文件指定新的注释,格式一般为<code>username@host</code></td></tr><tr><td align="center">-f [filename]</td><td align="center">参数指定生成的私钥文件。不指定的话,会在~&#x2F;.ssh文件夹下生成一对密钥</td></tr><tr><td align="center">-F [hostname]</td><td align="center">检查某个主机名是否在known_hosts文件里面</td></tr><tr><td align="center">-N [secretword]</td><td align="center">指定私钥的密码</td></tr><tr><td align="center">-p[secretword]</td><td align="center">重新指定私钥的密码</td></tr><tr><td align="center">-R [hostname]</td><td align="center">将指定的主机公钥移除出known_hosts文件</td></tr><tr><td align="center">-t [algorithm]</td><td align="center">指定加密算法,一般为dsa或rsa</td></tr></tbody></table><p><em>手动上传公钥</em><br>把客户端生成的公钥复制粘贴到文件~&#x2F;.ssh&#x2F;authorized_keys中去,一个公钥占据一行<br><em>ssh-copy-id–自动上传公钥</em><br><code>ssh-copy-id -i key_file user@host</code> 自动上传公钥到服务器<br>公钥文件可以不指定路劲和.pub后缀,会自动在~&#x2F;.ssh目录下寻找<br>确保authorized_keys文件末尾为换行符,否则两个公钥连在一起,两个都会失效</p><p><em>ssh-agent命令</em><br>私钥设置了密码后,每次使用都必须输入密码,连续使用scp命令时,这就很麻烦,ssh-agent命令就是为了解决这个问题而设计的,它让用户在整个bash对话中,只在第一次使用SSH命令是输入密码,然后将私钥保存在内存中<br>第一步,新建一次命令对话<br><code>ssh-agent bash(zhs、fish)</code><br>第二步,添加私钥<br><code>ssh-add [filename]</code>可以不指定私钥名称,使用默认文件~&#x2F;.ssh&#x2F;id_rsa<br>第三步登录远程服务器<br><code>ssh remoteHost</code><br>最后,如果要退出ssh-agent,可以按Ctrl+d,也可以用如下命令<br><code>ssh-agent -k</code><br><em>ssh-add命令</em><br>ssh-add命令用来将私钥加入ssh-agent</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-d</td><td align="center">从内存中删除指定的私钥</td></tr><tr><td align="center">-D</td><td align="center">从内存中删除所有已经添加的私钥</td></tr><tr><td align="center">-l</td><td align="center">列出所有已经添加的私钥</td></tr></tbody></table><p><font size=6><strong>服务器端sshd</strong></font><br><strong>1.sshd配置文件</strong><br><code>/etc/ssh/sshd_config</code>配置文件<br><code>/etc/ssh/ssh_host_ecdsa_key</code>ECDSA私钥<br><code>/etc/ssh/ssh_host_ecdsa_key.pub</code>ECDSA公钥<br><code>/etc/ssh/ssh_host_key</code>用于SSH1协议版本的RSA私钥<br><code>/etc/ssh/ssh_host_key.pub</code>用于SSH1协议版本的RSA公钥<br><code>/etc/ssh/ssh_host_rsa_key</code>用于SSH2协议版本的RSA私钥<br><code>/etc/ssh/ssh_host_rsa_key.pub</code>用于SSH2协议版本的RSA公钥<br><code>/etc/pam.d/sshd</code>PAM配置文件<br><font color=#FF0000>重装会使这些文件失效,可以先备份</font><br><strong>sshd配置项</strong></p><table><thead><tr><th align="center">配置项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">AcceptEnv [variables…]</td><td align="center">允许接受客户端通过SendEnv命令发来的哪些环境变量,变量名用空格分隔</td></tr><tr><td align="center">AllowGroups [groupNames…]</td><td align="center">指定允许登录的用户组,多个组之间用空格隔开,若不用该项,则所有组都可以用</td></tr><tr><td align="center">AllowUsers [userNames…]</td><td align="center">指定允许登录的用户,用户名之间用空格隔开,支持通配符</td></tr><tr><td align="center">AllowTcpForwarding [options]</td><td align="center">默认值为yes,允许端口转发,local只允许本地端口转发,remote表示只允许远程端口转发</td></tr><tr><td align="center">AuthorizedKeysFile [directory]</td><td align="center">指定存储用户公钥的目录,默认是<code>~/.ssh/authorized_keys</code></td></tr><tr><td align="center">Banner [file]</td><td align="center">指定用户登录后,sshd向其展示的信息文件,默认不展示任何内容</td></tr><tr><td align="center">ChallengeResponseAuthentication [yesOrNo]</td><td align="center">指定是否用”键盘交互”身份验证方案,默认值为yes,如果完全禁用基于密码的验证,PasswordAuthentication也设为no</td></tr><tr><td align="center">Ciphers [algorithms]</td><td align="center">指定sshd可以接受的加密算法,多个算法之间使用逗号分割</td></tr><tr><td align="center">ClientAliveCountMax [num]</td><td align="center">指定建立连接后,客户端失去响应时,服务器尝试连接的次数</td></tr><tr><td align="center">ClientAliveInterval [num]</td><td align="center">允许客户端发呆的时间,单位为秒,如果超过这时间,连接将会关闭</td></tr><tr><td align="center">Compression [yesOrNo]</td><td align="center">Compression指定客户端与服务器之间的数据传输是否为压缩,默认为yes</td></tr><tr><td align="center">DenyGroups [groupNames…]</td><td align="center">指定不允许登录的用户组,组间空格分开</td></tr><tr><td align="center">DenyUsers [userNames…]</td><td align="center">指定不允许登录的用户,空格分开不同用户</td></tr><tr><td align="center">FascistLogging [yesOrNo]</td><td align="center">SSH1版本专用,指定日志是否输出全部Debug信息</td></tr><tr><td align="center">HostKey [filePath]</td><td align="center">指定服务器密钥的文件路径</td></tr><tr><td align="center">KeyRegenerationInterval [num]</td><td align="center">指定SSH1版本的密钥重新生成的时间间隔,单位为秒,默认为3600</td></tr><tr><td align="center">ListenAddress [ipAddress]</td><td align="center">指定sshd监听本机的IP地址,即sshd启用的IP地址,默认是0.0.0.0,表示在本机所有网络接口启用。可以改成只在某个网络接口启用,可以多次使用该配置项,来监听多个ip地址</td></tr><tr><td align="center">LoginGraceTime [num]</td><td align="center">指定允许客户端登录时发呆的最长时间,超过该时间就断开,0表示没有限制</td></tr><tr><td align="center">LogLevel [options]</td><td align="center">指定日志的详细程度,可能的值有:QUIET,FATAL,ERROR,INFO,VERNBOSE,DEBUG,DEBUG1,DEBUG2,DEBUG3,默认为INFO</td></tr><tr><td align="center">MACs [algorithms]</td><td align="center">指定sshd可以接受的数据校验算法(MACs hmac-sha1),多个算法之间使用逗号分隔</td></tr><tr><td align="center">MaxAuthTries [num]</td><td align="center">指定SSH登录允许的最大密码尝试数</td></tr><tr><td align="center">MaxStartups [num]</td><td align="center">指定允许同时并发的SSH链接数量,0表示没有限制,也可以是A:B:C形式,如10:50:20,表示如果达到10个并发链接,后面的连接有50%的概率被拒绝,如果达到20个并发连接,则后面的100%拒绝</td></tr><tr><td align="center">PasswordAuthentication [yesOrNo]</td><td align="center">是否允许密码登录,默认值为yes</td></tr><tr><td align="center">PermitEmptyPasswords [yesOrNo]</td><td align="center">指定是否允许空密码登录,默认为yes</td></tr><tr><td align="center">PermitRootLogin [yesOrNo]</td><td align="center">是否允许根用户登录,默认为yes,也可以设为prohibit-password,表示允许密钥登录root,但禁止密码登录</td></tr><tr><td align="center">PermitUserEnvironment [yesOrNo]</td><td align="center">是否允许sshd加载客户端的<del>&#x2F;.ssh&#x2F;environment文件和</del>&#x2F;.ssh&#x2F;authorized_keys文件里面的environment&#x3D;options 环境变量设置.默认值为no</td></tr><tr><td align="center">Port [num]</td><td align="center">指定sshd监听的端口,默认22,可以多次设置,监听多个端口</td></tr><tr><td align="center">PrintMoth [yesOrNo]</td><td align="center">指定用户登录后,是否向其展示系统的motd的信息文件&#x2F;etc&#x2F;motd,默认为yes</td></tr><tr><td align="center">Protocol [options]</td><td align="center">1表示使用SSH1协议,’1,2’表示支持两个版本的协议</td></tr><tr><td align="center">PubKeyAuthentication [yesOrNo]</td><td align="center">指定是否允许公钥登录,默认为yes</td></tr><tr><td align="center">QuietMode [yesOrNo]</td><td align="center">SSH1专用,yes表示日志只输出致命的错误信息</td></tr><tr><td align="center">RSAAuthentication [yesOrNo]</td><td align="center"></td></tr><tr><td align="center">ServerKeyBits [num]</td><td align="center">指定SSH1版本的密钥重新生成时的位数,默认为767</td></tr><tr><td align="center">StrictModes [yesOrNo]</td><td align="center">指定sshd是否检查用户的一些重要文件和目录权限,即对于用户的SSH配置文件,密钥文件和所在目录,SSH要求拥有者必须是根用户或用户本人,其他人的写权限必须关闭</td></tr><tr><td align="center">SyslogFacility [options]</td><td align="center">指定Syslog如何处理sshd日志,默认是AUTH</td></tr><tr><td align="center">TCPKeepAlive [unknown]</td><td align="center">指定打开sshd跟客户端tcp链接的keepalive参数</td></tr><tr><td align="center">UseDNS [yesOrNo]</td><td align="center">指定用户SSH登录一个域名时,服务器是否使用DNS,确认该域名对应的IP地址包含本机,建议关闭</td></tr><tr><td align="center">UserLogin [yesOrNo]</td><td align="center">指定用户认证内部是否使用&#x2F;user&#x2F;bin&#x2F;login代替SSH工具,默认为no</td></tr><tr><td align="center">UserPrivilegeSeparation</td><td align="center">指定用户认证通过后,使用另一个子线程处理用户权限相关的操作,这样利于提高安全性</td></tr><tr><td align="center">VerboseMode</td><td align="center">SSH2版本专用,指定日志输出详细的Debug信息</td></tr><tr><td align="center">X11Forwarding</td><td align="center">指定是否打开X window的转发,默认值为no</td></tr><tr><td align="center"><strong>sshd命令行配置项</strong></td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-d</td><td align="center">用于显示debug信息</td></tr><tr><td align="center">-D</td><td align="center">指定sshd不作为后台守护进程运行</td></tr><tr><td align="center">-e</td><td align="center">将sshd写入系统日志syslog的内容导向标准错误</td></tr><tr><td align="center">-f [filePath]</td><td align="center">指定配置文件位置</td></tr><tr><td align="center">-h [filePath]</td><td align="center">指定密钥</td></tr><tr><td align="center">-o [Key Value]</td><td align="center">指定配置文件的一个配置项和对应的值,如:sshd -o “Port 2034”</td></tr><tr><td align="center">-p [num]</td><td align="center">指定sshd的服务端口</td></tr><tr><td align="center">-t</td><td align="center">检查配置文件语法是否正确</td></tr></tbody></table><p><font size=6><strong>scp命令</strong></font><br><strong>简介</strong><br>它的底层是SSH协议,默认端口22,相当于先用ssh命令登陆远程主机,然后在执行拷贝,可以用于两个远程系统之间的复制</p><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">指定传输的加密算法,如blowfish</td></tr><tr><td align="center">-C</td><td align="center">传输时压缩文件</td></tr><tr><td align="center">-F</td><td align="center">用来指定ssh_config文件,供ssh链接使用</td></tr><tr><td align="center">-i</td><td align="center">用来指定密钥的文件</td></tr><tr><td align="center">-l</td><td align="center">用来限制传输数据的带宽速率,单位是kb&#x2F;s</td></tr><tr><td align="center">-p</td><td align="center">用来保留修改时间,访问时间,文件状态等原始文件的信息</td></tr><tr><td align="center">-P</td><td align="center">用来指定远程主机的SSH端口,默认用22</td></tr><tr><td align="center">-q</td><td align="center">用来关闭显示拷贝的进度条</td></tr><tr><td align="center">-r</td><td align="center">递归复制</td></tr><tr><td align="center">-v</td><td align="center">显示详细的输出</td></tr></tbody></table><p><font size=6><strong>sftp命令</strong></font><br><strong>简介</strong><br>sftp是ssh提供的一个客户端应用程序,主要用来安全地访问FTP。因为FTP是不加密协议,很不安全,sftp相当于将FTP放入SSH:<br><code>sftp username@hostname</code><br>进入sftp后,使用那些命令,如get获取远程文件,put上传文件等<br><font size=6><strong>端口转发</strong></font><br>(待建)可见<a href="https://wangdoc.com/ssh/port-forwarding.html">https://wangdoc.com/ssh/port-forwarding.html</a><br><font size=6><strong>证书登录</strong></font><br>(待建)可见<a href="https://wangdoc.com/ssh/ca.html">https://wangdoc.com/ssh/ca.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>gcc编译器及编译原理</title>
    <link href="/2020/12/19/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%8A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2020/12/19/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%8A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>1.基本概念</strong><br><strong>预处理:</strong><code>g++ -E main.cpp -o main.ii</code>,-E表示只进行预处理。预处理主要是处理各种宏的展开;添加行号和文件标识符,为编译器产生调试信息提供便利;删除注释;保留编译器用到的编译器指令等<br><strong>编译:</strong><code>g++ -S main.ii -o main.s</code>,-S表示只编译。编译是在预处理的基础上经过一系列词法分析、语法分析及优化后生成汇编代码。<br><strong>汇编:</strong><code>g++ -c main.s -o main.o</code>,汇编将汇编代码转换为机器可执行的指令<br><strong>链接:</strong><code>g++ main.o</code>,链接生成可执行程序,之所以需要链接是因为我们的代码不可能像main.cpp这么简单,现代软件动则成百上千万行,如果写在一个main.cpp既不利于分工合作,也无法维护,因此通常是由一堆cpp文件组成,编译器分别编译每个cpp,这些cpp里会引用别的模块中的函数或全局变量,在编译单个cpp的时候是没法知道它们的准确地址,因此在编译结束后,需要连接器将各种还没有准确地址的符号(函数、变量等)设置为正确的值,这样组装在一起就可以形成一个完整的可执行程序<br><strong>2.选项</strong><br><code>-l&lt;library&gt;</code> 链接动态库<br><code>-L&lt;dir&gt;</code> 动态库搜索目录<br><code>-D&lt;expression&gt;</code> 宏定义命令中定义<br><code>-l &lt;dir&gt;</code>头文件搜索目录<br><strong>3.静态库编译和使用</strong><br><code>gcc -c increase.c -o increase.o</code>把.c编译成.o<br><code>ar -r libincrease.a increase.o</code>归档成静态库.a<br><code>gcc main.c -L -static -o main</code>链接成可执行文件<br><strong>4.动态库编译和使用</strong><br><code>gcc -shared -fPIC -o libinc.so increase.c</code>-fPIC生成位置独立的代码,此类代码可以在不同进程间共享<br><code>gcc -lincrease -o main main.c</code>链接动态库<br>有错误</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文本处理瑞士军刀--小而强悍</title>
    <link href="/2020/11/21/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-%E5%B0%8F%E8%80%8C%E5%BC%BA%E6%82%8D/"/>
    <url>/2020/11/21/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-%E5%B0%8F%E8%80%8C%E5%BC%BA%E6%82%8D/</url>
    
    <content type="html"><![CDATA[<p><font size=4><strong>1.cat命令</strong></font></p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-A</td><td align="center">用$表示每行的结尾,^I表示tab空格字符(是个判别空格和tab的方法)</td></tr><tr><td align="center">-n</td><td align="center">显示行号</td></tr><tr><td align="center">-s</td><td align="center">对于连续空行,只保留一行</td></tr></tbody></table><p><strong>cat用例</strong><br><code>cat &lt;&lt; END</code>接下来直到END之间的内容<br><code>cat &gt; foo.txt</code>快捷新建foo.txt并输入内容,以ctrl-D结束<br><code>cat &lt;&lt;&lt; filename</code>打印filename这个单词<br><font size=4><strong>2.sort命令</strong></font></p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-b</td><td align="center">忽略开头的空白字符,从第一个非空白字符进行排序</td></tr><tr><td align="center">-f</td><td align="center">让排序忽略大小写</td></tr><tr><td align="center">-n</td><td align="center">基于字符串的数值来排序,而不是字母值</td></tr><tr><td align="center">-r</td><td align="center">降序排序</td></tr><tr><td align="center">-k [field1],[field2]</td><td align="center">举例<code>-k 4,5</code>,根据[4,5]间的字符段对行进行排序,如果没有5,则只是根据第四个字符段进行行排序,字符段的分隔符默认为空,可以由-t来指定</td></tr><tr><td align="center">-t [char]</td><td align="center">定义域分割字符,默认为空格或制表</td></tr><tr><td align="center">-u</td><td align="center">去除比较相等的行,即便行内容不相等,如果比较结果相等(如只从第二个字符比较)改行也会被去除,</td></tr></tbody></table><p><strong>-key选项的魅力</strong><br><code>sort -k 1,1 -k 2n foo.txt</code>先按第一个字段按字符串排序,如果第一字段相等,再2n表示第二个字段用数值排序,n和sort选项一样表示数值排序,同样还可以指定b(忽略开头的空格),r(逆向排序)<br>考虑系列文本字段,如何以日期的格式降序排序呢</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2008</span><br><span class="hljs-attribute">11</span>/<span class="hljs-number">25</span>/<span class="hljs-number">2008</span><br><span class="hljs-attribute">06</span>/<span class="hljs-number">19</span>/<span class="hljs-number">2008</span><br></code></pre></td></tr></table></figure><p>简单用如下命令:<br><code>sort -k 1.7nbr -k 1.1nbr -k 1.4nbr xx.txt</code>表示先从第一个字段第7个字符开始进行排序,如果相等,再比较第一个字符开始的第一个字段开始排序,再者第四个字符开始排序<br><strong>sort用例</strong><br><code>sort &gt; foo.txt</code>同cat一样只不过对你输入的内容进行排序,也是ctrl-d结束<br><code>sort file1.txt file2.txt file3.txt &gt; final_sorted.txt</code>对多个文件进行排序<br><font size=4><strong>3.unique命令</strong></font><br>unique命令只能删除排好序的行,即是它只判断连续相等的行</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">输出所有重复行,并且每行开头显示重复次数</td></tr><tr><td align="center">-d</td><td align="center">只输所有出重复行</td></tr><tr><td align="center">-f [n]</td><td align="center">忽略每行开头的n个字段,字段之间由空格分割(不支持自定义)</td></tr><tr><td align="center">-i</td><td align="center">忽略大小写</td></tr><tr><td align="center">-s [n]</td><td align="center">跳过每行开头的n个字符</td></tr><tr><td align="center">-u</td><td align="center">只输出独有的文本,默认选项</td></tr></tbody></table><p><font size=4><strong>4.cut命令</strong></font><br>cut 程序被用来从文本行 抽取文本，并把其输出到标准输出。能够接受多个文件参数或标准输入</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-b [num_list]</td><td align="center">从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分隔开的数值区间组成</td></tr><tr><td align="center">-c [num_list]</td><td align="center">从文本行中抽取由num_list定义的文本,这个列表可能有一个或多个逗号分割开的数值区间组成</td></tr><tr><td align="center">-f [num_list]</td><td align="center">从文本行中抽取一个或多个由num_list定义的字段。这个列表可能包括一个或多个字段,或由逗号分割开的字段区间</td></tr><tr><td align="center">-d [delim_char]</td><td align="center">指定字段分隔符,默认情况下,由单个tab字符分隔开</td></tr><tr><td align="center">–complement</td><td align="center">抽取整个文本行，除了那些由-c或-f选项指定的文本</td></tr></tbody></table><p>选项中各个list列表格式如下:<br>N     从第1个开始数的第N个字节、字符或域<br>N-    从第N个开始到所在行结束的所有字符、字节或域<br>N-M   从第N个开始到第M个之间(包括第M个)的所有字符、字节或域<br>-M    从第1个开始到第M个之间(包括第M个)的所有字符、字节或域<br><font size=4><strong>4.paste命令</strong></font><br>格式:<code>paste [file1] [file2]</code>,在file1每行后添加file2中对应行内容,默认使用制表符分割两个文件的内容,可以用-d选项指定分割符<br><font size=4><strong>5.join命令</strong></font><br>与paste类似,但是它对文件有一个要求,每个文件对应行,都有相同的字段(默认为空白分割符),效果如下图:</p><p>|A文本|B文本|结果|<br>|John 20|John man|John 20 man|<br>|May 15|May woman|May 15 woman|<br>|Mike 33|Mike man|Mike 33 man|</p><p>各种设置有待研究<br><font size=4><strong>6.comm命令</strong></font><br>comm比较两个文本文件,会产生三列输出,第一列包含第一个文件独有的文本行,第二列包含第二个文本行独有的,第三列,两个文本共有的,-n选项会隐藏第n列的内容,n只有三个数字选择1,2,3<br><font size=4><strong>7.diff命令</strong></font><br>格式:<code>diff &lt;options&gt; [old file] [new file]</code><br>diff默认输出如何使第一个文件变成第二个文件<br>常用选项-c,-u选项<br><font size=4><strong>8.patch命令</strong></font><br>patch程序被用来把更改应用到文本文件中。它接受从diff程序的输出,并且通常被用来把较老的文件转变为较新的文件,注意不一定要指定文件名,因为diff信息中已经有了文件信息<br><font size=4><strong>9.tr命令</strong></font><br>选项:<code>tr [选项] [set1] [set2]</code><br>tr用来更改字符(只能从标准输出中接受数据),把一个字母换成另一个字母<br>set1,set2是下列选项之一:<br>1.一个枚举列表,例如:ABSCKAL<br>2.一个字符域:A-Z,a-z<br>3.POSIX字符类:[:upper:]<br><font color=#FF0000>注意:</font>set1和set2字符集长度相同,一对一,但是,也有多对一,把所有符合字符换成同一个字符<br><strong>tr例子</strong><br>1.<code>tr -d &#39;\r&#39; dos_file &gt; unix_file</code>把dos_file的换行符删除<br>2.<code>echo &quot;aabbbbccc&quot; | tr -s ab</code>挤压重复字符,这个结果为”abccc”<br>但如果是<code>echo &quot;abcabcabc&quot; | tr -s ab</code>结果不变<br>3.<code>seq 1 2 9 | paste -sd,</code>paste的神奇用法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>grep与正则表达式</title>
    <link href="/2020/11/20/grep%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/11/20/grep%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>格式:<code>grep [options] [regex] [file...]</code></p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">忽略大小写</td></tr><tr><td align="center">-v</td><td align="center">打印不匹配的文本行</td></tr><tr><td align="center">-c</td><td align="center">只打印匹配或不匹配(-v选项)的行数</td></tr><tr><td align="center">-l</td><td align="center">打印包含匹配项的文件名,而不是文本行本身</td></tr><tr><td align="center">-L</td><td align="center">相似于-l项,但是只是打印不包含匹配项的文件名</td></tr><tr><td align="center">-n</td><td align="center">在每个匹配行之前打印出相应的行号</td></tr><tr><td align="center">-w</td><td align="center">只识别整个单词(即模式前后有空格)</td></tr><tr><td align="center">-E</td><td align="center">识别扩展正则表达式</td></tr><tr><td align="center">-r</td><td align="center">递归对某个目录的所有文件</td></tr><tr><td align="center">-I</td><td align="center">等价于-binary-files&#x3D;without-match,不匹配二进制</td></tr><tr><td align="center">-exclude-dir&#x3D;[目录路径]</td><td align="center">跳过某个目录</td></tr><tr><td align="center">–binary-files&#x3D;without-match</td><td align="center">二进制文件不匹配</td></tr></tbody></table><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式的元字"><a href="#正则表达式的元字" class="headerlink" title="正则表达式的元字"></a>正则表达式的元字</h2><table><thead><tr><th align="center">特殊字符</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><code>.</code></td><td align="center">匹配除换行符外的任一单字符。在awk中,句点也能匹配换行符</td></tr><tr><td align="center"><code>*</code></td><td align="center">匹配任一个(包括零个)在它面前的字符(包括由正则表达式指定的字符)</td></tr><tr><td align="center"><code>[...]</code></td><td align="center">匹配方括号中的字符类中的任意一个。如果方括号中第一个字符为脱字符号(^),则表示否定匹配,即匹配除了换行符和类中列出的那些字符以外的所有字符。在awk中,也匹配换行符。连字符(-)用于表示字符的范围(可以连续用如[A-Za-z0-9])。如果类中的第一个字符为右方括号(])则表示它是类的成员＝所有其他的元字符在被指定为类中的成员时都会失去它们原来的含义</td></tr><tr><td align="center"><code>^</code></td><td align="center">如果作为正则表达式的第一个字符,则表示匹配行的开始。在awk中匹配字符串的开始,即使字符串包含嵌入的换行符</td></tr><tr><td align="center"><code>$</code></td><td align="center">如果作为正则表达式的最后一个字符,则表示匹配行的结尾。在awk中匹配字符串的结尾,即使字符串包含嵌入的换行符。</td></tr><tr><td align="center"><code>\&#123;n,m\&#125;</code></td><td align="center">匹配它前面某个范围内单个字符出现的次数(包括由正则表达式指定的字符)。<code>\&#123;n\&#125;</code>将匹配n次出现,<code>\&#123;n,\&#125;</code>至少匹配n次出现,而且<code>\&#123;n,m\&#125;</code>匹配n和m之间任意次的出现</td></tr><tr><td align="center"><code>\</code></td><td align="center">转义随后的特殊字符</td></tr></tbody></table><h2 id="POSIX字符类"><a href="#POSIX字符类" class="headerlink" title="POSIX字符类"></a>POSIX字符类</h2><p>POSIX是标准,通用于其它shell命令,不仅仅是正则,并且只能出现在中括号中,就是说应该这么写<code>[[:alnum:]]</code></p><table><thead><tr><th align="center">类</th><th align="center">打印字符</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">字母数字字符,等价于[A-Za-z0-9]</td></tr><tr><td align="center">[:word:]</td><td align="center">与[:alnum:]相同,但增加了下划线字符</td></tr><tr><td align="center">[:alpha:]</td><td align="center">字母字符</td></tr><tr><td align="center">[:blank:]</td><td align="center">空格和制表符</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">控制字符,0~31和127的ASCII字符</td></tr><tr><td align="center">[:digit:]</td><td align="center">数字字符0~9</td></tr><tr><td align="center">[:graph:]</td><td align="center">可打印和可见的(非空格)字符,33-126的ASCII</td></tr><tr><td align="center">[:lower:]</td><td align="center">小写字符</td></tr><tr><td align="center">[:upper:]</td><td align="center">大写字符</td></tr><tr><td align="center">[:print:]</td><td align="center">可打印的字符(包括空白字符)</td></tr><tr><td align="center">[:punct:]</td><td align="center">标点符号字符,在 ASCII 中, 等 价 于:&#96;-!”#$%&amp;’()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[\]_‘</td></tr><tr><td align="center">[:space:]</td><td align="center">空白字符,包括空格,tab,回车,换行,vertical tab和form feed,在ASCII中,等价于:[\t\r\n\v\f]</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">十六进制数字</td></tr></tbody></table><h2 id="扩展的元字符"><a href="#扩展的元字符" class="headerlink" title="扩展的元字符"></a>扩展的元字符</h2><table><thead><tr><th align="center">特殊字符</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">匹配前面的正则表达式的一次或多次出现</td></tr><tr><td align="center"><code>?</code></td><td align="center">匹配前面的正则表达式的零次或一次出现</td></tr><tr><td align="center"><code>|</code></td><td align="center">逻辑表达或,指定可以匹配前面的或后面的正则表达式</td></tr><tr><td align="center"><code>()</code></td><td align="center">对正则表达式分组,如&#96;^(bz</td></tr><tr><td align="center"><code>&#123;n,m&#125;</code></td><td align="center">匹配它前面某个范围内单个字符出现的次数,与基本元字符的一样</td></tr><tr><td align="center"><code>\w</code></td><td align="center">和任何可以做单词组成成分的字符匹配(字母下划线数字)</td></tr><tr><td align="center"><code>\W</code></td><td align="center">和任何不能做单词组成成分的字符匹配</td></tr><tr><td align="center"><code>\&lt;</code></td><td align="center">和一个单词开头的空字符串匹配</td></tr><tr><td align="center"><code>\&gt;</code></td><td align="center">和一个单词末尾的空字符串匹配</td></tr><tr><td align="center"><code>\y</code></td><td align="center">和一个单词开头的空字符串或末尾的空字符串匹配（单词边界）,这适用于awk</td></tr><tr><td align="center"><code>\b</code></td><td align="center">同上，除了awk的其他软件</td></tr><tr><td align="center"><code>\B</code></td><td align="center">匹配非单词边界。er\B 能匹配 verb 中的 er，但不能匹配 never 中的 er。</td></tr><tr><td align="center"><code>\d</code></td><td align="center">匹配数字：[0-9]</td></tr><tr><td align="center"><code>\D</code></td><td align="center">匹配非数字</td></tr><tr><td align="center"><code>\s</code></td><td align="center">匹配所有空格字符，等价于<code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td align="center"><code>\S</code></td><td align="center">匹配所有非空格字符</td></tr><tr><td align="center"><code>p</code></td><td align="center">匹配 CR&#x2F;LF（等同于 \r\n），用来匹配DOS行终止符</td></tr><tr><td align="center"><code>\&#39;</code></td><td align="center">和在缓冲区开始处的空字符串匹配</td></tr></tbody></table><h2 id="零宽度断言"><a href="#零宽度断言" class="headerlink" title="零宽度断言"></a>零宽度断言</h2><p>|符号|描述|</p><p>|:-:|:-:|<br>|?&#x3D;|正先行断言-存在|<br>|?!|负先行断言-排除|<br>|?&lt;&#x3D;|正后发断言-存在|<br>|<code>?&lt;!</code>|负后发断言-排除|</p><h2 id="模式修正符"><a href="#模式修正符" class="headerlink" title="模式修正符"></a>模式修正符</h2><table><thead><tr><th align="center">标志</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">忽略大小写。</td></tr><tr><td align="center">g</td><td align="center">全局搜索。</td></tr><tr><td align="center">m</td><td align="center">多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</td></tr></tbody></table><h2 id="grep应用举例"><a href="#grep应用举例" class="headerlink" title="grep应用举例"></a>grep应用举例</h2><ul><li>打印匹配前后5行:<code>grep -5 &#39;pattern&#39; inputfile</code> </li><li>打印匹配后5行:<code>grep -A 5 &#39;pattern&#39; inputfile</code></li><li>打印匹配前5行:<code>grep -B 5 &#39;pattern&#39; inputfile</code></li><li>打印匹配前5行:<code>grep -i &#39;pattern&#39; inputfile</code></li></ul><h2 id="正则表达式举例"><a href="#正则表达式举例" class="headerlink" title="正则表达式举例"></a>正则表达式举例</h2><ul><li>引号中的任意字符串: <code>&quot;.*&quot;</code></li><li>邮箱：<code>^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</code></li><li>中国大陆手机号：<code>^1[3-9][[:digit:]]\&#123;9\&#125;$</code></li><li>匹配任意域名：<code>^((http:\/\/)|(https:\/\/))?([a-zA-Z0-9]([a-zA-Z0-9\-]&#123;0,61&#125;[a-zA-Z0-9])?\.)+[a-zA-Z]&#123;2,6&#125;(\/)</code></li><li>匹配IP地址：<code>((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</code></li><li>汉字：<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li><li>整数：<code>^-?[1-9]\d*$</code></li><li>浮点数：<code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li><li>身份证号：<code>^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$</code></li><li>军官证：<code>^[\u4E00-\u9FA5](字第)([0-9a-zA-Z]&#123;4,8&#125;)(号?)$</code></li><li>护照：<code>^([a-zA-z]|[0-9])&#123;5,17&#125;$</code></li><li>港澳通行证：<code>^([A-Z]\d&#123;6,10&#125;(\(\w&#123;1&#125;\))?)$</code></li><li>台湾通行证：<code>^\d&#123;8&#125;|^[a-zA-Z0-9]&#123;10&#125;|^\d&#123;18&#125;$</code></li><li>强密码：<code>^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$</code></li><li>火车车次：<code>^[GCDZTSPKXLY1-9]\d&#123;1,4&#125;$</code></li><li>url：<code>^[a-zA-Z]+:\/\/</code></li><li>Mac地址：<code>^([0-9a-fA-F][0-9a-fA-F]:)&#123;5&#125;([0-9a-fA-F][0-9a-fA-F])$</code></li><li>传真号码：<code>^(([0\+]\d&#123;2,3&#125;-)?(0\d&#123;2,3&#125;)-)(\d&#123;7,8&#125;)(-(\d&#123;3,&#125;))?$</code></li><li>手机号码：<code>^1[34578]\d&#123;9&#125;$</code></li><li>md5格式32位：<code>^[a-f0-9]&#123;32&#125;$</code></li><li>ipv4：<code>(\b25[0-5]|\b2[0-4][0-9]|\b[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))&#123;3&#125;</code></li><li>ipv6：<code>(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</code></li><li>email：<code>^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$</code></li><li>十六进制颜色：<code>^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$</code></li><li>版本号：<code>^\d+(?:\.\d+)&#123;2&#125;$</code></li><li>车牌号：<code>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z](?:((\d&#123;5&#125;[A-HJK])|([A-HJK][A-HJ-NP-Z0-9][0-9]&#123;4&#125;))|[A-HJ-NP-Z0-9]&#123;4&#125;[A-HJ-NP-Z0-9挂学警港澳])$</code></li><li>中国邮政编码：<code>[1-9]\d&#123;5&#125;(?!\d)</code></li><li>迅雷连接：<code>^thunderx?:\/\/[a-zA-Z\d]+=$</code></li><li>ed2k连接：<code>^ed2k:\/\/\|file\|.+\|\/$</code></li><li>磁力连接：<code>^magnet:\?xt=urn:btih:[0-9a-fA-F]&#123;40,&#125;.*$</code></li><li>html标记：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*?/&gt;</code></li><li>html注释：<code>&lt;!--(.*?)--&gt;</code></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>归档和备份命令</title>
    <link href="/2020/11/19/%E5%BD%92%E6%A1%A3%E5%92%8C%E5%A4%87%E4%BB%BD%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/11/19/%E5%BD%92%E6%A1%A3%E5%92%8C%E5%A4%87%E4%BB%BD%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>格式:<code>gzip [选项] [file]</code>,注意这不会保留原文件,默认输出为原文件加’.gz’后,同样解压缩也不会保留原压缩文件,注意只能对文件而不能对文件夹压缩,要走出这个误区</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">把输出写入到标注输出,并保留原始文件,注意要生成压缩文件,必须重定向到一个文件,这个选项就是这么令人费解</td></tr><tr><td align="center">-d</td><td align="center">解压缩,等价于gunzip</td></tr><tr><td align="center">-f</td><td align="center">强制压缩,即使原始文件已经被压缩</td></tr><tr><td align="center">-h</td><td align="center">显示用法信息</td></tr><tr><td align="center">-k</td><td align="center">保留原文件</td></tr><tr><td align="center">-l</td><td align="center">列出每个被压缩文件的压缩数据</td></tr><tr><td align="center">-r</td><td align="center">若命令的一个或多个参数是目录,则递归地压缩目录中的文件</td></tr><tr><td align="center">-t</td><td align="center">测试压缩文件的完整性</td></tr><tr><td align="center">-v</td><td align="center">显示压缩过程的信息</td></tr><tr><td align="center">-[number]</td><td align="center">设置压缩指数,[number]为1(最快,最小压缩)到9(最慢,最大压缩),默认为6</td></tr></tbody></table><p><strong>例子:</strong><br><code>gunzip -c foo.txt.gz | less</code>这可以不解压直接查看内容</p><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>bzip2程序程序和gzip一样,但是不支持<code>-r</code>递归选项,同时它压缩率更大,速度更慢</p><h2 id="归档tar"><a href="#归档tar" class="headerlink" title="归档tar"></a>归档tar</h2><p>.tar为普通的tar包,.tgz为压缩过的tar包<br>格式:<code>tar [options] [destination] [target]</code></p><table><thead><tr><th align="center">options</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">c</td><td align="center">Create创建新归档文件,存在则覆盖</td></tr><tr><td align="center">t</td><td align="center">Table列表,磁带文件名列表</td></tr><tr><td align="center">d</td><td align="center">磁带与文件系统的不同</td></tr><tr><td align="center">r</td><td align="center">添加文件至磁带末尾</td></tr><tr><td align="center">u</td><td align="center">只添加更新的文件</td></tr><tr><td align="center">x</td><td align="center">extract抽取,抽取文件</td></tr><tr><td align="center">v</td><td align="center">verbose冗长</td></tr><tr><td align="center">f</td><td align="center">必须指定归档文件名,必须包含该选项</td></tr><tr><td align="center">z</td><td align="center">gzip算法压缩</td></tr><tr><td align="center">j</td><td align="center">bzip2算法压缩</td></tr></tbody></table><p><code>--wildcards</code><br>提取某个文件而不是全部(见例子)时一般不支持文件通配符,可通过–wildcards来支持,如:<br><code>tar xf xx.tar --wildcards &#39;home/me/dir-\*/file&#39;</code><br><code>--file-from(-T)</code><br>这个选项导致tar命令从一个文件而不是命令行来读入它的路径名列表,可以是标准输入,例如:<br><code>find ~ -name &#39;file-A&#39;| tar cf - --files-from= -| gzip &gt;playground.tgz</code><br>注意上面这个例子中第一个’-‘表示标准输出,第二个则是标准输入(广泛用于其他程序),上面可以不用第二个管道,直接加个z选项即可,如下:<br><code>find playground -name &#39;file-A&#39; | tar czf playground.tgz -T -</code></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例:"></a>举例:</h4><p><code>tar cvf my.tar *.[ch] makefile</code>不压缩创建<br><code>tar xvf tar_file -C destination_direectory</code>提取文件至指定文件夹<br><code>tar xf my.tar home/file</code>只提取归档文件某一文件(前提归档文件里必须有)</p><h2 id="归档和压缩二合一"><a href="#归档和压缩二合一" class="headerlink" title="归档和压缩二合一"></a>归档和压缩二合一</h2><ul><li>格式:<code>zip [options] [destination] [origin]</code></li><li>对于目录必须加-r选项,否则只是空目录,它最优化决定是否压缩文件</li><li>对于中文字符无法显示：<code>unzip -O GB18030 XXX.zip</code></li></ul><h3 id="选项"><a href="#选项" class="headerlink" title="-@选项"></a>-@选项</h3><p>用来接受从标准输入的列表,例:<br><code>find playground -name &quot;fileA&quot; | zip -@ file-A.zip</code></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><p><code>unzip -l playground.zip playground/fileA</code>列出指定一个文件夹<br><code>unzip playground.zip playground/fileA</code>提取指定一个文件夹</p><h2 id="同步rsync"><a href="#同步rsync" class="headerlink" title="同步rsync"></a>同步rsync</h2><p>格式:<code>rsync [options] [source] [destination]</code><br>rsync会比较两者差异,最小化的复制修改以同步<br>这里source和destination是下列选项之一:<br>·一个本地文件或目录<br>·一个远端文件或目录,以[user@]host:path的形式存在<br>·一个远端rsync服务器,由rsync:&#x2F;&#x2F;[user@]host[:port]&#x2F;path指定<br>source和destination至少有一个本地文件,不支持远端到远端</p><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><h4 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h4><p>rsync默认使用ssh协议,如果想传递ssh命令的附加参数,必须使用-e选项,如:<br><code>rsync -av -e &#39;ssh -p 2234&#39; source/ user@remote_host:/destination</code></p><h4 id="rsync协议"><a href="#rsync协议" class="headerlink" title="rsync协议"></a>rsync协议</h4><p>如果另一台服务器安装并运行了rsync守护程序,则可以用该协议(默认端口873),具体写法是服务器与目标目录间使用冒号分割:<br><code>rsync -av source/ 192.168.122.32::module/destination</code><br>上面地址中的module并不是实际路径名,而是rsync守护程序指定的一个资源名,由管理员分配。<br>如果想知道rsync守护程序分配的所有module列表,可以执行下面命令:<br><code>rsync rsync://192.168.122.32</code><br>除了双冒号,也可以直接使用rsync:&#x2F;&#x2F;协议指定地址:<br><code>rsync -av source/ rsync://192.168.122.32/module/destination</code></p><h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><p>除了源目录与目标目录直接比较,rsync还支持使用基准目录,即将源目录与基准目录之间变动的部分,同步到目标目录。<br>具体做法,第一次同步是全量备份,所有文件在基准目录里同步一份。以后每一次同步都是增量备份,只同步源目录与基准目录之间有变动的部分,将这部分保存在一个新的目标目录。这个新的目标目录之中,也是包含所有文件,但实际上,只有那些变动过的文件是存在于该目录,其他没有变动的文件都是指向基准目录文件的硬链接。<br>–link-dest参数用来指定同步时的基准目录:<br><code>rsync -a --delete --link-dest /compare/path source/path /target/path</code><br>下面是个备份用户的主目录脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -o errexit<br><span class="hljs-built_in">set</span> -o nounset<br><span class="hljs-built_in">set</span> -o pipefail<br><br><span class="hljs-built_in">readonly</span> SOURCE_DIR=<span class="hljs-string">&quot;<span class="hljs-subst">$(HOME)</span>&quot;</span><br><span class="hljs-built_in">readonly</span> BACKUP_DIR=<span class="hljs-string">&quot;/mnt/data/backups&quot;</span><br><span class="hljs-built_in">readonly</span> DATETIME=<span class="hljs-string">&quot;<span class="hljs-subst">$(date &#x27;+%Y-%m-%d_%H:%M:%S&#x27;)</span>&quot;</span><br><span class="hljs-built_in">readonly</span> BACKUP_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span><br><span class="hljs-built_in">readonly</span> LATEST_LINK=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>/latest&quot;</span><br><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>&quot;</span><br><br>rsync -av --delete \<br><span class="hljs-string">&quot;<span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>/&quot;</span> \<br>--link-dest <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span> \<br>--exclude=<span class="hljs-string">&quot;.cache&quot;</span> \<br><span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_PATH&#125;</span>&quot;</span><br><br><span class="hljs-comment">#注意删除硬链接,只有最后为1时,才真正删除,因为i真正备份里有个指向链接,所以不会删除真正的文件</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span><br><span class="hljs-comment">#注意下面是软连接,也就是说基准文件为最新的备份文件</span><br><span class="hljs-comment">#我的疑惑,为啥非要用中间目录,直接比较不行吗?不是脱裤放屁吗?</span><br><span class="hljs-built_in">ln</span> -s <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_PATH&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">不仅递归同步,还可以同步元信息(比如修改时间、权限等),软连接也会同步过去</td></tr><tr><td align="center">–append</td><td align="center">参数指定文件接着上次中断的地方,继续传输</td></tr><tr><td align="center">–append-verify</td><td align="center">与–append参数类似,但会对传输完成后的文件进行一次校验,如果校验失败,将重新发送整个文件</td></tr><tr><td align="center">-b</td><td align="center">指定在删除或更新目标目录已经存在的文件时,将该文件更名后进行备份,默认行为是删除。更名规则是由–suffix参数指定的文件后缀名,默认是’~‘</td></tr><tr><td align="center">–backup-dir</td><td align="center">参数指定文件备份时存放的目录,比如<code>--backup-dir=/path/to/backups</code></td></tr><tr><td align="center">–bwlimit</td><td align="center">参数指定带宽限制,默认是kb&#x2F;s,比如<code>--bwlimit=100</code></td></tr><tr><td align="center">-c</td><td align="center">默认情况下,rsync只检查文件的大小和最后修改日期是否发生变化,如果发生变化,就重新传输,使用这个参数以后,则通过判断文件内容的校验和,决定是否重新传输</td></tr><tr><td align="center">-delete</td><td align="center">参数删除只存在与目标目录,不存在于源目标文件,即保证目标目录是源目标的镜像</td></tr><tr><td align="center">-e</td><td align="center">参数指定使用SSH协议传输数据</td></tr><tr><td align="center">–exclude</td><td align="center">指定排除不进行同步的文件,详细用法见下</td></tr><tr><td align="center">–exclude-from</td><td align="center">参数指定一个本地文件,里面是需要排除的文件模式,每个模式一行</td></tr><tr><td align="center">–existing、–ignore-non-existing</td><td align="center">参数表示不同步目标目录中不存在的文件和目录</td></tr><tr><td align="center">-h</td><td align="center">略</td></tr><tr><td align="center">-i</td><td align="center">参数表示输出源目录与目标目录之间文件差异详细情况</td></tr><tr><td align="center">–ignore-existing</td><td align="center">参数表示只要该文件在目标目录中已经存在,就跳过去,不再同步这些文件</td></tr><tr><td align="center">–include</td><td align="center">一般与–exclude结合使用,同步时要包括的文件</td></tr><tr><td align="center">–link-dest</td><td align="center">参数指定增量备份的基准目录</td></tr><tr><td align="center">-m</td><td align="center">指定不同步空目录</td></tr><tr><td align="center">–max-size</td><td align="center">参数设置传输的最大文件的大小限制,比如不超过200kb<code>--max-size=&#39;200k&#39;</code></td></tr><tr><td align="center">–min-size</td><td align="center">参数设置传输的最大文件的大小限制,比如不小于200kb<code>--min-size=&#39;200k&#39;</code></td></tr><tr><td align="center">-n</td><td align="center">模拟将要执行的操作,而不真的执行,配合-v参数使用看哪些内容同步过去</td></tr><tr><td align="center">-P</td><td align="center">–progress和–partial这两个参数的结合</td></tr><tr><td align="center">–partial</td><td align="center">允许恢复中断中断的传输。不使用该参数时,rsync会删除传输到一般被打断的文件,使用该参数后,传输到一般的文件也会同步到目标目录,下次同步时再恢复中断的传输,一般要与–append或–append-verify配合使用</td></tr><tr><td align="center">–partial-dir</td><td align="center">参数指定将传输到一半的文件保存到一个临时目录,比如<code>--partial-dir=rsync-partial</code>,一般要与–append或–append-verify配合使用</td></tr><tr><td align="center">–progress</td><td align="center">表示显示进度</td></tr><tr><td align="center">-r</td><td align="center">表示递归</td></tr><tr><td align="center">–remove-source-files</td><td align="center">表示传输成功后,删除源文件</td></tr><tr><td align="center">–size-only</td><td align="center">表示只同步大小有变化的文件,不考虑文件修改时间的的差异</td></tr><tr><td align="center">–suffix</td><td align="center">参数指定文件名备份时,对文件名添加的后缀,默认是~</td></tr><tr><td align="center">-u</td><td align="center">表示同步时跳过目标目录中修改时间更新的文件,即不同步这些有更新的时间戳文件</td></tr><tr><td align="center">-v,-vv,-vvv</td><td align="center">表示输出细节,v越多越详细</td></tr><tr><td align="center">–version</td><td align="center">略</td></tr><tr><td align="center">-z</td><td align="center">指定同步时压缩数据</td></tr></tbody></table><h4 id="–exclude和–include参数示范"><a href="#–exclude和–include参数示范" class="headerlink" title="–exclude和–include参数示范"></a>–exclude和–include参数示范</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av --exclude=<span class="hljs-string">&#x27;*.txt&#x27;</span> <span class="hljs-built_in">source</span>/ destination<br>rsync -av --exclude <span class="hljs-string">&#x27;*.txt&#x27;</span> <span class="hljs-built_in">source</span>/ destination<br>rsync -av --exclude <span class="hljs-string">&#x27;file.txt&#x27;</span> --exclude <span class="hljs-string">&#x27;dir1/*&#x27;</span> <span class="hljs-built_in">source</span>/ destination<br>rsync -av --exclude=&#123;<span class="hljs-string">&#x27;file1.txt&#x27;</span>,<span class="hljs-string">&#x27;dir1/*&#x27;</span>&#125; <span class="hljs-built_in">source</span>/ destination<br>rsync -av --exclude-from=<span class="hljs-string">&#x27;exclude-file.txt&#x27;</span> <span class="hljs-built_in">source</span>/ destination<br>rsync -av --include=<span class="hljs-string">&quot;*.txt&quot;</span> --exclude=<span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">source</span>/ destination<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Find命令</title>
    <link href="/2020/11/18/Find%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/11/18/Find%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>1.<strong>格式</strong><br>find &lt;范围&gt; &lt;条件&gt; &lt;动作&gt;<br>2.<strong>查询表</strong></p><table><thead><tr><th align="center">测试条件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-cmin [num]</td><td align="center">匹配文件的最后修改时间正好在[num]分钟之前</td></tr><tr><td align="center">-cnewer [fileName]</td><td align="center">匹配文件的最后修改时间晚于file的文件或目录</td></tr><tr><td align="center">-ctime [num]</td><td align="center">匹配文件的最后修改时间在num*24小时之前</td></tr><tr><td align="center">-empty</td><td align="center">匹配空文件和目录</td></tr><tr><td align="center">-group [groupName]</td><td align="center">匹配属于一个组的文件</td></tr><tr><td align="center">-iname [pattern]</td><td align="center">与-name一样，但是不区分大小写</td></tr><tr><td align="center">-inum [nodeId]</td><td align="center">匹配inode号是[nodeId]的文件,可用来查找硬链接</td></tr><tr><td align="center">-mmin [num]</td><td align="center">匹配内容修改于[num]分钟之前</td></tr><tr><td align="center">-mtime [num]</td><td align="center">匹配内容修改于[num*24]小时之前</td></tr><tr><td align="center">-name [pattern]</td><td align="center">用指定的通配符模式匹配文件名</td></tr><tr><td align="center">-newer [file]</td><td align="center">匹配晚于[file]的文件</td></tr><tr><td align="center">-newerct [yyyy-mm-dd HH:mm:ss]</td><td align="center">创建晚于某个时间,详见man</td></tr><tr><td align="center">-nouser</td><td align="center">匹配不属于一个有效用户的文件</td></tr><tr><td align="center">-nogroup</td><td align="center">匹配不属于一个有效组的文件</td></tr><tr><td align="center">-perm [mode]</td><td align="center">匹配权限设置为[mode]的文件,mode可用八进制或符号</td></tr><tr><td align="center">-samefile [filename]</td><td align="center">类似于-inum测试条件,匹配和文件[fileName]享有同样inode号的文件</td></tr><tr><td align="center">-size [num]</td><td align="center">匹配大小为[num]的文件,数字后加单位,详情见其他表</td></tr><tr><td align="center">-type [fileType]</td><td align="center">匹配文件类型是[fileType]的文件</td></tr><tr><td align="center">-user name</td><td align="center">匹配属于某个用户文件</td></tr></tbody></table><p>(注:一般[num]都可以在前面加±号,表示大于或少于,如+5M表示(5M,+∞),-5M表示(0,4M],5M则表示(4M,5M]))</p><table><thead><tr><th align="center">字符</th><th align="center">单位</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">512个字节快,为默认值</td></tr><tr><td align="center">c</td><td align="center">字节</td></tr><tr><td align="center">w</td><td align="center">两个字节的字</td></tr><tr><td align="center">k</td><td align="center">千字节(1024个字节单位)</td></tr><tr><td align="center">M</td><td align="center">兆字节(1048576个字节单位)</td></tr><tr><td align="center">G</td><td align="center">千兆字节(1073741824个字节单位)</td></tr></tbody></table><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-and(-a)</td><td align="center">如果操作符两边的测试条件都是真,则匹配,默认使用</td></tr><tr><td align="center">-or(-o)</td><td align="center">如果操作符两边的测试条件,任一是真,则匹配</td></tr><tr><td align="center">-not(!)</td><td align="center">如果操作符后面的条件为假,则匹配</td></tr><tr><td align="center">()</td><td align="center">用来改变优先级,注意一般shell对其有特殊解释,所以用引号或反斜杠加来转义</td></tr></tbody></table><table><thead><tr><th align="center">操作</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-delete</td><td align="center">删除当前匹配的文件</td></tr><tr><td align="center">-print</td><td align="center">默认操作，打印</td></tr><tr><td align="center">-ls</td><td align="center">对匹配文件执行等同ls -dils命令</td></tr><tr><td align="center">-quit</td><td align="center">匹配到第一个即立刻退出</td></tr><tr><td align="center"><code>-exec [command] &#39;&#123;&#125;&#39; &#39;;&#39;</code></td><td align="center">“{}”代表匹配到的文件(为决定路径),因为是shell特殊符号所以要用单引号,结尾必须用”;”,同样是特殊符号,要用单引号</td></tr><tr><td align="center"><code>-ok [command] &#39;&#123;&#125;&#39; &#39;;&#39;</code></td><td align="center">与-exec相似，只不过执行前会进行确认</td></tr><tr><td align="center">-regex</td><td align="center">文件路径的正则匹配</td></tr></tbody></table><table><thead><tr><th align="center">文件类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">块特殊设备文件</td></tr><tr><td align="center">c</td><td align="center">字符特殊设备文件</td></tr><tr><td align="center">d</td><td align="center">目录</td></tr><tr><td align="center">f</td><td align="center">普通文件</td></tr><tr><td align="center">l</td><td align="center">符号链接</td></tr></tbody></table><p>控制find命令的搜索范围</p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-depth</td><td align="center">指定find程序先处理目录中的文件,再处理目录自身(深度优先搜索?)。当指定-delete行为时,会自动用这个选项</td></tr><tr><td align="center">-maxdepth [num]</td><td align="center">设置陷入目录树的最大级别数</td></tr><tr><td align="center">-mindepth [num]</td><td align="center">设置陷入目录树的最小级别数</td></tr><tr><td align="center">-mount</td><td align="center">不搜索挂载到其他系统下的目录</td></tr><tr><td align="center">-noleaf</td><td align="center">在搜索DOS&#x2F;Win文件系统或CD&#x2F;ROMS时的时候优化选项</td></tr></tbody></table><p>3.<strong>-exec与”+”</strong><br><code>find -type f -name &#39;foo*&#39; -exec ls -l &#39;&#123;&#125;&#39; &#39;;&#39;</code><br><code>find -type f -name &#39;foo*&#39; -exec ls -l &#39;&#123;&#125;&#39; +</code><br>上述两个命令的区别在于,假设匹配到fooA与fooB两个文件,第一个相当于执行两次ls命令,相当于<code>ls -l fooA</code>和<code>ls -l fooB</code>而第二个只执行一次<code>ls -l fooA fooB</code></p><p>4.<strong>xargs</strong><br><code>find ~ -type f -name &#39;foo*&#39; -print | xargs ls -l</code>与上述带有”+”的-exec选项效果一样,注意xargs有最大参数个数限制,可以通过<code>xargs -show-limits</code>来查看最大值<br>5.<strong>文件名存在空格的问题</strong><br>类 Unix 的系统允许在文件名中嵌入空格(甚至换行符)。这就给一些程序,如<br>为其它程序构建参数列表的 xargs 程序,造成了问题。一个嵌入的空格会被看作是<br>一个分隔符,生成的命令会把每个空格分离的单词解释为单独的参数。为了解决这<br>个问题,find 命令和 xarg 程序允许使用一个可选的 null 字符作为参数分隔符。一<br>个 null 字符被定义在 ASCII 码中,由数字零来表示(相反的,例如,空格字符在<br>ASCII 码中由数字 32 表示)。find 命令提供的 -print0 行为,则会产生由 null 字符<br>分离的输出,并且 xargs 命令有一个 –null 选项,这个选项会接受由 null 字符分离<br>的输入。这里有一个例子<br><code>find ~ -iname &#39;*.jpg&#39; -print0 | xargs -null ls -l</code><br>6.<strong>例子</strong><br><code>sudo find /tmp -type d -empty</code><br><code>find ~ -perm /a=x</code>查找所有可执行文件<br><code>find . -regex &#39;.*[^-\_./0-9a-zA-Z].*&#39;</code>查找不符合规范字符的路径名(中文咋办?)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机原理</title>
    <link href="/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    <url>/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>1.位运算相关</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">a&amp;(b|c)=(a&amp;b)|(a&amp;c)<br>a|(b&amp;c)=(a|b)&amp;(a|c)<br>a^a=<span class="hljs-number">0</span> a^(a+<span class="hljs-number">1</span>)=<span class="hljs-number">1</span>(a为偶数)<br>a=<span class="hljs-built_in">n</span>&amp;(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)(移除<span class="hljs-built_in">n</span>最后一个<span class="hljs-number">1</span>)<br>diff=(<span class="hljs-built_in">n</span>&amp;(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>))^<span class="hljs-built_in">n</span>=<span class="hljs-built_in">n</span>&amp;(-<span class="hljs-built_in">n</span>) (获取最后一个<span class="hljs-number">1</span>)<br>(<span class="hljs-built_in">n</span>^(-<span class="hljs-number">1</span>))+<span class="hljs-number">1</span>=-<span class="hljs-built_in">n</span>(<span class="hljs-comment">有符号数取反加一为其相反数</span>)<br>(<span class="hljs-built_in">var</span>^(<span class="hljs-built_in">var</span>&gt;&gt;<span class="hljs-number">31</span>))-(<span class="hljs-built_in">var</span>&gt;&gt;<span class="hljs-number">31</span>) (<span class="hljs-number">32</span>位取绝对值)<br></code></pre></td></tr></table></figure><p>2.位移运算<br>左移:&lt;&lt;,丢弃高位,低位补0<br>逻辑右移:&gt;&gt;,左端补0(c语言,对于无符号数,为逻辑右移)<br>算术右移:&gt;&gt;,左端补最高有效位的值(c语言,对于有符号数,为算术右移)<br>3.无符号与有符号的转换<br>a.C语言两者之间的转换，保持位模式不变,只是改变解码规则,最高位的解释由负到正,除了最高位的解释变化，其余位不变，设那些的权重和为k。<br>所以有符号补码的解释为-2^(w-1)+k,而无符号解释为2^(w-1)+k,w表示位数,所以两者相差2^w, 对于位模式(只考虑负数,即超过有符号表示范围的正数)相同的有以下结论:<br>无符号数&#x3D;有符号负数+2^w<br>有符号负数&#x3D;无符号数-2^w<br>有符号负数的绝对值+无符号数&#x3D;2^w<br>b.无符号与有符号比较,c语言会都转换无符号<br>4.数字位的扩展<br>a.低位无符号向高位转换时,只要简单把多出来的位置为0<br>b.低位有符号向高位有符号扩展时,为保持表示的数值不变,多出的位与原来符号位保持一致,很好想,0好说,多出来的位为0即保持数不变,1的话即是负数，多出的位都置为1,记住2^w-2^(w-1)&#x3D;2^(w-1),这样多出来的权重和就是没多出位之前最高的负权重(用脑子一想就知道了)<br>c.低位有符号向高位无符号扩展时,C语言是这样处理,先进行低位有符号到高位有符号扩展,即b,在进行有符号到无符号的同位转换,即3中的方法<br>5.截断位<br>截断都是直接去除多出的位,C中不支持这种转换,但这就是溢出的本质<br>a.截断后表示无符号,低位表示的数&#x3D;高位数mod2^(低位数),很好想,去除的位数权重和肯定是2^(低位数)的倍数,低位表示的数肯定小于2^(低位数)(因为,低位表示的数最大值为2^(低位数)-1)<br>b.截断后表示有符号,比较弱智的想法是,先转无符号,在此基础上进行无符号到有符号的转换.<br>6.无符号相加溢出<br>若0&lt;&#x3D;x,y&lt;2^w,则x+y在[0,2^(w+1)-2]之间,x+y若大于等于2^w,则会被截断,表现为x+y-2^w。很容易想不做说明,同时也很容易得出,如果判断是否溢出,当且仅当得数小于其中任意一个加数。(因为溢出的话,x+y-2^w-x&#x3D;y-2^w,肯定小于0)<br>7.有符号相加<br>向上溢出和6相同,向下溢出,则表现为x+y+2^w。书上的太难啃,我是这么想的,接它一位,并且表示没借之前的最小负数,应该是最高前两位为1,其余为0,而没借之前无法表示多出来的值为(-x-y-2^(w-1)),再以无符号来看,所以借出来之后,表示溢出的应有负数对应的无符号值为2^w+2^(w-1)-(-x-y-2^(w-1)),该数补码值即是表示不出来的负数,该高位无符号值化简为x+y+2^(w+1),由于x+y处于[-2^w,-2^w-1)之间,所以x+y+2^(w+1)的最小值为2^w,所以补出来的那一位始终为1,所以截断时要减去个2^w,最终结果就是x+y+2^(w+1)-2^(w)&#x3D;x+y+2^(w)这个值,我知道我第二次看可能看不懂,以此纪念我思考的过程,和拙劣的表达<br>补码检测上溢出:x,y都大于0,但它们的和小于等于0即发生溢出<br>补码检测下溢出:x,y都小于0,但他们的和大于等于0即发生溢出<br><font color=#FF0000>其实本质上，溢出后表示的值,就是,借给它一个高位后,正确表达时,再按5的方法截断的值</font><br>8.整数相乘<br>若补码整数x0,y0,与它们位模式相同的无符号整数为x1,y1,(x0*y0)与(x1*y1)的结果，无论有没有被截断，它们的位模式是相同的(还要缕一缕)<br>9.乘以2的幂<br>x*2^k,就等价于x&lt;&lt;k,对于不是2的幂的也可以转换如:x*14&#x3D;x*(2^3+2^2+2)&#x3D;(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)<br>10.除以2的幂<br>无符号除以就是向右逻辑移位(与乘法相反嘛,聪明的你肯定想到了),而补码除以就是向右算术移位,同时当结果为负数,要保证舍入到0(简单来说就是无论正负,都去掉小数点,因为直接移位,会使结果原离远点),还需要做点修正,x&#x2F;2^k&#x3D;(x+(1&lt;&lt;k)-1)&gt;&gt;k(本质上,利用了如下的属性x&#x2F;y)<br>C中补码的除法会进行如下:<br><code>(x&lt;0 ? x+(1&lt;&lt;k)-1 :x)&gt;&gt;k</code>来计算x&#x2F;2^k<br>3.trick<br>a.-1用补码表示为全1位<br>b.0用补码表示为全0位<br>c.非负数x,-x的w位补码表示就是2^w-x,而反码则是[111…1]-x,（这两个表达式都当成无符号来进行位表示。反码也可以这么理解2^w-1-x）<br>d.一个位模式的补码,就是两者相加刚好溢出的那个码值,无符号数x(假设为w位),它的补码可以通过计算2^w-x(不包括0)得出,而有符号数x的补码即是它的相反数(不包括所能表示的最小值),其实从位角度来看对每一位取反加1(本质上就是这么算的),也可以这么看,以最右边的位为1的为界,它左边的(不包括它本身)都取反</p><p>2.取模的算式</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">(<span class="hljs-keyword">a</span>+b) <span class="hljs-keyword">mod</span> P = [(<span class="hljs-keyword">a</span> <span class="hljs-keyword">mod</span> P)+(b <span class="hljs-keyword">mod</span> P)]<span class="hljs-keyword">mod</span> P<br>(<span class="hljs-keyword">a</span>*b) <span class="hljs-keyword">mod</span> P = [(<span class="hljs-keyword">a</span> <span class="hljs-keyword">mod</span> P)*(b <span class="hljs-keyword">mod</span> P)]<span class="hljs-keyword">mod</span> P<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go基础</title>
    <link href="/2020/06/21/go%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/21/go%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>1.变量的声明与定义<br><code>var 变量名字 类型 = 表达式</code><br><code>var 变量列表 = 表达式列表</code><br><code>名字 := 表达式</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git及github</title>
    <link href="/2020/06/09/git%E5%8F%8Agithub/"/>
    <url>/2020/06/09/git%E5%8F%8Agithub/</url>
    
    <content type="html"><![CDATA[<p>1.git预设置<br>　<code>git config --global user.name &quot;xxx&quot;</code><br>　<code>git config --global user.email &quot;xx.com&quot;</code><br>　<code>git config --list</code>检查已有配置信息<br>　<code>git config --global core.editor vim</code>配置默认编辑器<br>　<code>git config --global alias.comi commit</code>命令别名<br>　<code>git config --global credential.helper cache</code>设置无密码推送<br>2.git 初始化<br>　<code>git init</code>初始化仓库，并建立.git子目录<br>3.<code>git status</code><br>　-s:简单展现，A表示新添加到缓存区,左边M表示文件被修改并放入缓存区,右边M表示文件被修改并没有放入缓存区,??问号表示未被跟踪的文件<br>4.<code>git add &lt;files&gt;</code><br>　跟踪文件并加入暂存区,可以通过<code>git ls-files --stage</code>来查看暂存区的文件<br>5.<code>git diff</code>显示更为详细的变化<br>　默认比较工作目录与缓存区间的差异<br>　<code>--cached</code>比较缓存区与已提交的差异<br>　HEAD查看所有改动<br>　–stat:显示摘要<br>6.<code>git commit</code><br>　注释行里会有最后一次运行git status的输出<br>　-v:会将diff输出加入到注释行<br>　-m:将提交信息与命令放在同一行<br>  -a:可以将所有跟踪文件跳过add步骤直接commit<br>  –amend:上次提交后发现忘了几个文件,可以add之后再加上此选项提交将会覆盖上次提交。<br>7.<code>git rm &lt;files&gt;</code><br>　移除缓存区文件并且工作目录也一并移除<br>　–cached:只删除缓存区,保留工作目录<br>8.<code>git mv</code>移动文件<br>　等价于’mv file1 file2;git rm file1;git add README’<br>9.<code>git log</code>显示提交记录<br>　-p:显示每次提交的差异<br>  -(n):显示最近n次提交<br>  –since,–after:仅显示指定时间之后的提交<br>  –until,–before:仅显示指定时间之前的提交<br>  –author:仅显示指定作者相关的提交<br>  –committer:仅显示指定提交者相关的提交<br>  –grep:仅显示含指定关键字的提交<br>  -S:仅显示添加或移除了某个关键字的提交<br>  –stat:简略信息<br>  –graph:显示ASCLL图形表示分支的合并历史<br>  –relative-date:使用较短的相对时间显示<br>  –abbrev-commit:仅显示SHA-1的前几个字符,而非所有的40个字符<br>  –name-status:显示增删改的文件清单<br>  –name-only:仅在提交信息后显示以修改的文件清单<br>  –pretty&#x3D;format:”&lt;格式&gt;”:指定格式输出</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%H</td><td align="center">提交对象(commit)的完整哈希字串</td></tr><tr><td align="center">%h</td><td align="center">提交对象的简短哈希字串</td></tr><tr><td align="center">%T</td><td align="center">树对象的完整哈希字串</td></tr><tr><td align="center">%t</td><td align="center">树对象的简短哈希字串</td></tr><tr><td align="center">%P</td><td align="center">父对象的完整哈希字串</td></tr><tr><td align="center">%p</td><td align="center">父对象的简短哈希字串</td></tr><tr><td align="center">%an</td><td align="center">作者的名字</td></tr><tr><td align="center">%ae</td><td align="center">作者的邮件</td></tr><tr><td align="center">%ad</td><td align="center">作者修订日期</td></tr><tr><td align="center">%ar</td><td align="center">作者修订日期,按多久以前的方式显示</td></tr><tr><td align="center">%cn</td><td align="center">提交者的名字</td></tr><tr><td align="center">%ce</td><td align="center">提交者的电子邮件</td></tr><tr><td align="center">%cd</td><td align="center">提交日期</td></tr><tr><td align="center">%cr</td><td align="center">提交日期,按多久以前的方式显示</td></tr><tr><td align="center">%s</td><td align="center">提交说明</td></tr></tbody></table><p>10.<code>git reset HEAD &lt;file&gt;</code>(适用已提交add):撤销某个暂存文件,即将add退回<br>　 <code>git reset HEAD\~1</code>:回退到上一个版本<br>   <code>git reset --hard &lt;commit_id&gt;</code>注意此步骤会将commit_id后的commit删除,最好不用<br>　　<code>git push origin HEAD --force</code>让服务器也回退到某版本(本地仓库已回退)<br>11.git revert HEAD:回退到HEAD上一个版本,但是树结构往下走，只不过与父节点相同<br>11.<code>git checkout -- [file]</code>(未git add的情况下):撤销某个工作目录下文件的修改,恢复为版本库中一模一样的版本,危险的命令,你的修改将不会保存<br>12.<code>git remote</code>远程仓库的使用<br>　-v:显示简写对应的url<br>　<code>show origin</code>:展示origin的具体信息<br>　<code>rename o1 o2</code>:重命名某个远程<br>　<code>rm xx</code>:移除某个远程<br>13.<code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code><br>　<code>--tags</code>:推送所有标签<br>　使用git push &lt;远程主机名(origin)&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>　<code>git push --set-upstream &lt;remote_name&gt; &lt;branch_name&gt;</code>将远程分支作为当前分支的上游分支<br>14.<br>　git fetch:会抓取数据到本地数据库，但不会自动合并并修改当前工作<br>  git clone:会自动将其添加为远程仓库并默认以’origin’缩写,并自动跟踪远程master<br>  git pull:主区数据并自动尝试合并到当前所在分支<br>15.git tag<br>　-a:增加个标签,可以在后面加个校验和,为指定的补打标签<br>　-m:在命令行增加说明<br>　-d:删除某个标签<br>　-l:列举标签<br>　<tag_name> <commit_id>:为某个哈希打标签<br>　必须显示地推送标签至远程库’git push origin v1.5’,当某个标签被删除或信息改变’git push origin  :refs&#x2F;tags&#x2F;<tag_name>‘<br><code>git branch &lt;new-branch-name&gt; &lt;tag-name&gt;</code>从指定的标签拉取一个分支出来<br>　<code>git show &lt;tag_name&gt;</code>查看tag信息<br>&#x2F;<em><strong>分支管理</strong></em>&#x2F;<br><code>git clone -b &lt;分支名&gt; &lt;仓库地址&gt;</code>克隆指定分支<br><code>git fetch origin &lt;branch_name&gt;</code>抓取某个远程分支<br>1.<code>git branch xxx</code>创建分支,不加任何xxx会显示所有分支<br>2.<code>git log --oneline --decorate</code>查看各个分支当前所指对象<br>3.<code>git checkout xxx</code>切换分支,切换分支会改变工作目录里的文件<br>4.<code>git log --oneline --decorate --graph --all</code>查看分叉历史<br>5.<code>git merge xxbranch</code>合并指定分支到当前分支,如果当前分支可以沿着一条线走下去则会有’fast-forward提示’<br>　<code>git merge --abort</code>取消当前合并,重建合并前状态<br>6.<code>git checkout -b serverfix origin/serverfix</code>跟踪远程库其他分支等价于<code>git checkout --track orighin/serverfix</code><br>7.<code>git push origin --delete xxx</code> 删除远程分支<br>8.git branch 选项<br> -d xxx: 删除分支<br> -D xxx:强制删除某个未合并的分支<br> -v:显示每个分支最后的提交<br> –merged:查看所有已与当前分支合并的分支<br> –no-merged:查看所有未与当前分支合并的分支<br> -f some hash:强制some分支移动到某hash版本<br> <code>-u origin:master</code>:设置当前分支跟踪远程分支<br>　<code>-r</code>:显示所有远程分支<br>　<code>-a</code>:显示所有本地和远程分支<br>9.<code>git rebase</code><br>　<code>git rebase xxx</code>把当前分支衍合到xxx分支<br>　<code>git rebase --onto master server client</code>把server与client共同祖先之后的变化加到master中去<br>　<code>git rebase -i xx</code>以他为xx基础或其共同祖先节点进行交互界面的rebase<br>10.<code>git cherry-pick a b c</code>把a,b,c等应用到当前分支<br>11.<code>git describe &lt;branch&gt;</code>会输出以下信息<br><code>&lt;最近的tag&gt;_&lt;tag距离分支几个节点&gt;_&lt;当前分支hash值&gt;</code><br>12.<code>^</code>第一个父提交<code>^2</code>第二个父提交<code>~2</code>爷爷提交<br>13.格式:<code>[source:destination]</code><br>###############################高级#####<br>1.<code>git stash</code><br>　备份当前的工作区内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到git栈中<br><code>git stash list</code>显示所有栈内的备份<br><code>git stash apply &lt;stash_name&gt;</code>从栈中读取最新一次保存的内容，恢复工作区的相关内容<br><code>git stash pop</code>删除最新的暂存<br><code>git stash drop&lt;stash_name&gt;</code>删除指定暂存<br>#################建议规范########<br>1.推荐的分支管理<br><code>master</code>:主分支,禁止直接在master上进行代码的提交和修改,此分支的代码可以随时被发布到线上<br><code>develop</code>:测试分支,所有开发完成需要提交测试的功能合并到该分支,该分支包含最新的更改<br><code>feature</code>:开发分支,大家根据不同需求创建独立的功能分支,开发后合并到develop分支<br><code>fix</code>:分支为bug修复分支,需要根据实际情况对已发布的版本进行漏洞修复<br>2.标签tag管理<br>Tag采用三段式:v版本.里程碑.序号(v2.3.1)<br>第一位:架构升级或架构重大调整<br>第二位:新功能上线或模块大的调整<br>第三位:bug修复<br>3.提交信息格式<br>中文:<br>-&lt;新功能&gt;添加解析url功能<br>-&lt;修改&gt;修改某功能的某个实现为另一个实先<br>-&lt;Bug修复&gt;修复url的特殊情况下解析失败的问题<br>-&lt;重构&gt;重构获取数据的方法<br>-&lt;测试&gt;添加(修改、删除)获取数据的单元测试代码<br>-&lt;文档&gt;修改(添加、删除)文档<br>英文:<br>-feat:新功能<br>-fix:修补bug<br>-refactor:重构<br>-test:测试相关<br>-docs:文档</p><p>常见问题技巧:<br>1.推送要密码,改成ssh认证,在.git&#x2F;config里修改remote地址,从仓库复制过去ssh地址,不用httpServer,因为它就是默认用密码登录,也可以从命令行修改<br>2.仓库中所有文件的sha1值在.git目录中的objects文件夹下，想要根据sha1值查看文件内容，可以用<code>git cat-file -p [sha1值]</code>注意，objects中只有两个数字的文件夹是该文件夹下所有文件内容的sha1值的前两位，所以要拼接一下，当然你如果用命令知道它的完整sha1值就不用拼接了<br>3.<code>gitjk</code>有用的命令，可以查看如何撤销上个命令,可以从网上下载该工具，需要npm</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XML</title>
    <link href="/2020/05/19/XML/"/>
    <url>/2020/05/19/XML/</url>
    
    <content type="html"><![CDATA[<p>1.XML拓展的语言<br>　-XHTML:最新的HTML版本<br>　-WSDL: 用于描述可用的ｗｅb service<br>　-WAP、WML:用于手持设备的标记语言<br>　-RSS:用于RSS feed的语言<br>　-RDF和OWL:用于描述资源和本体<br>　-SMIL:用于描述针对web的多媒体<br>2.tip<br>　a.属性值加引号<br>3.5个预定义实体引用(必须有分号)<br>|:-:|:-:|<br>|’&lt;’|’&lt;’|<br>|’&gt;’|’&gt;’|<br>|’&amp;’|’&amp;’|<br>|’&apos;’|’’’|<br>|’&quot;’|’”‘|<br>|’&#x000A;’|换行|</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>输入与输出</title>
    <link href="/2020/04/29/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <url>/2020/04/29/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>1.操纵符</p><table><thead><tr><th align="center">操纵符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">boolalpha</td><td align="center">将true和false输出为字符串</td></tr><tr><td align="center">*noboolalpha</td><td align="center">将true和false输出为1,0</td></tr><tr><td align="center">showbase</td><td align="center">对整型值输出表示进制的前缀</td></tr><tr><td align="center">*noshowbase</td><td align="center">不生成表示进制的前缀</td></tr><tr><td align="center">showpoint</td><td align="center">对浮点值总是显示小数点</td></tr><tr><td align="center">*noshowpoint</td><td align="center">只有当浮点值包含小数部分时,显示小数点</td></tr><tr><td align="center">showpos</td><td align="center">对非负数显示+</td></tr><tr><td align="center">*noshowpos</td><td align="center">对非负数不显示+</td></tr><tr><td align="center">uppercase</td><td align="center">在十六进制中打印0X,在科学计数法中打印E</td></tr><tr><td align="center">*uppercase</td><td align="center">在十六进制中打印0x,在科学计数法中打印e</td></tr><tr><td align="center">*dec</td><td align="center">整型值显示为十进制</td></tr><tr><td align="center">hex</td><td align="center">整型值显示为十六进制</td></tr><tr><td align="center">oct</td><td align="center">整型值显示为十进制</td></tr><tr><td align="center">left</td><td align="center">左对齐,在值的右侧添加填充字符</td></tr><tr><td align="center">right</td><td align="center">右对齐,在值的左侧添加填充字符</td></tr><tr><td align="center">internal</td><td align="center">左对齐符号,右对齐值,在值和符号之间添加填充字符</td></tr><tr><td align="center">fixed</td><td align="center">浮点值显示为定点十进制</td></tr><tr><td align="center">scientific</td><td align="center">浮点值显示为科学计数法</td></tr><tr><td align="center">hexfloat</td><td align="center">浮点值显示为十六进制(c++11)</td></tr><tr><td align="center">defaultfloat</td><td align="center">重置浮点值显示为十进制(c++11)</td></tr><tr><td align="center">unitbuf</td><td align="center">每次输出操作后都刷新缓冲区</td></tr><tr><td align="center">*nounitbuf</td><td align="center">恢复正常的缓冲区刷新方式</td></tr><tr><td align="center">*skipws</td><td align="center">输入运算符跳过空白符</td></tr><tr><td align="center">noskipws</td><td align="center">输入运算符不跳过空白符</td></tr><tr><td align="center">flush</td><td align="center">刷新ostream缓冲区</td></tr><tr><td align="center">ends</td><td align="center">插入空字符,然后刷新ostream缓冲区</td></tr><tr><td align="center">endl</td><td align="center">插入换行符,然后刷新ostream缓冲区</td></tr><tr><td align="center">setprecision([int])</td><td align="center">在iomanip,接受一个int值,来设置精度,见详解</td></tr><tr><td align="center">setfill([char])</td><td align="center">在iomanip,用一个字符填充空白</td></tr><tr><td align="center">setw([int])</td><td align="center">在iomanip,指定值的最小宽度,注意它只影响接下来的那个值</td></tr><tr><td align="center">setbase([int])</td><td align="center">在iomanip,将整数输出为某进制</td></tr></tbody></table><p>2.流对象的成员函数</p><table><thead><tr><th align="center">成员函数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">precision()</td><td align="center">返回当前精度值</td></tr><tr><td align="center">precision(int)</td><td align="center">将精度设置为此值,返回旧精度</td></tr></tbody></table><p>2.精度<br>默认情况下,精度会控制打印的数字的总数。打印时,<font color=#FF0000>浮点值按当前精度舍入而非截断</font>,在执行scientific,fixed或hexfloat后,精度值控制的是小数点后面的数字位数</p><p>1.scanf与printf<br>格式:<code>scanf(&quot;format_specifier&quot;,&amp;val)</code>与<code>printf(&quot;format_specifier&quot;,&amp;val)</code><br>例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> ch;<br><span class="hljs-type">double</span> d;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %lf&quot;</span>,&amp;ch,&amp;d);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %lf&quot;</span>,ch,d);<br></code></pre></td></tr></table></figure><p>|:-:|:-:|:-:|<br>|类型|格式|大小|<br>|int|%d|32bit|<br>|long|%ld|64bit|<br>|char|%c|16bit|<br>|float|%f|32bit|<br>|double|%lf|64bit|<br>2.float与double固定小数点后的位数输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">float</span> a=<span class="hljs-number">8.333291</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.03f&quot;</span>,a);<span class="hljs-comment">//小数点后面保留3位</span><br>cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">3</span>);<br>cout&lt;&lt;fixed&lt;&lt;endl;<span class="hljs-comment">//保留3位</span><br><br></code></pre></td></tr></table></figure><p>3.进制转换<br>十六进制 <code>cout&lt;&lt;hex;</code><br>十进制 <code>cout&lt;&lt;dec</code>;<br>八进制 <code>cout&lt;&lt;oct</code>;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Make</title>
    <link href="/2020/01/17/Make/"/>
    <url>/2020/01/17/Make/</url>
    
    <content type="html"><![CDATA[<h3 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h3><p><code>include &lt;filename&gt;</code><br>make会在当前目录寻找,接着在以下目录下找:</p><ul><li>如果make执行时，有 -I 或 –include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。</li><li>如果目录 <prefix>&#x2F;include （一般是： &#x2F;usr&#x2F;local&#x2F;bin 或 &#x2F;usr&#x2F;include ）存在的话，make也会去找。</li></ul><h3 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h3><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上<code>$</code>符号，但最好用小括号<code>()</code>或是大括号<code>&#123;&#125;</code>把变量给包括起来。如果你要使用真实的<code>$</code>字符，那么你需要用<code>$$</code>来表示</p><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><ul><li><code>:=</code>操作符,操作符右边只能出现已定义的变量,如果是未定义的变量,则会自动忽略,用来避免递归展开 </li><li><code>=</code>操作符右边可以出现未定义的变量</li><li><code>?=</code>如果变量没有定义过,则使用后面的值</li><li><code>+=</code>追加变量值</li></ul><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><table><thead><tr><th align="center">变量类型</th><th align="center">特殊变量</th><th align="center">含义</th><th align="center">用例或说明</th></tr></thead><tbody><tr><td align="center">特殊变量</td><td align="center"><code>VPATH</code></td><td align="center">寻找依赖或目标的路径,以冒号为分隔符,当前目录永远最优先</td><td align="center"><code>VPATH = src:../headers</code></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>SUFFIXE</code></td><td align="center">定义默认的后缀列表,最好不要直接改变，通过<code>.SUFFIXE</code></td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.MAKEDIR</td><td align="center">调用make的绝对路径名</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.NULL</td><td align="center">空字符串</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.OS</td><td align="center">正在运行的操作系统名称</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.PWD</td><td align="center">运行时活动工作目录的绝对路径名</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.SHELL</td><td align="center">启动的shell类型</td><td align="center"></td></tr><tr><td align="center">命令变量</td><td align="center"><code>AR</code></td><td align="center">函数库打包程序,默认命令是ar</td><td align="center"></td></tr><tr><td align="center">命令变量</td><td align="center"><code>AS</code></td><td align="center">汇编语言编译程序,默认命令是as</td><td align="center"></td></tr><tr><td align="center">命令变量</td><td align="center"><code>CC</code></td><td align="center">C语言编译程序,默认命令是cc</td><td align="center"></td></tr><tr><td align="center">命令变量</td><td align="center"><code>CXX</code></td><td align="center">C++语言编译程序,默认命令是g++</td><td align="center"></td></tr><tr><td align="center">命令变量</td><td align="center"><code>CPP</code></td><td align="center">C程序的预处理器,默认命令是$(CC) -E</td><td align="center"></td></tr><tr><td align="center">命令变量</td><td align="center"><code>RM</code></td><td align="center">删除文件命令,默认命令是rm -f</td><td align="center"></td></tr><tr><td align="center">参数变量</td><td align="center"><code>ARFLAGS</code></td><td align="center">函数库打包程序AR命令参数,默认值是rv</td><td align="center"></td></tr><tr><td align="center">参数变量</td><td align="center"><code>ASFLAGS</code></td><td align="center">汇编语言编译器参数,默认值是空</td><td align="center"></td></tr><tr><td align="center">参数变量</td><td align="center"><code>CFLAGS</code></td><td align="center">C语言编译器参数,默认为空</td><td align="center"></td></tr><tr><td align="center">参数变量</td><td align="center"><code>CPPFLAGS</code></td><td align="center">C预处理器参数,默认为空</td><td align="center"></td></tr><tr><td align="center">参数变量</td><td align="center"><code>CXXFLAGS</code></td><td align="center">C++语言编译器参数,默认为空</td><td align="center"></td></tr><tr><td align="center">参数变量</td><td align="center"><code>LDFLAGS</code></td><td align="center">ld链接器参数,默认为空</td><td align="center"></td></tr><tr><td align="center">系统变量</td><td align="center"><code>MAKELEVEL</code></td><td align="center">当前Makefile的调用层数,从0开始</td><td align="center"></td></tr><tr><td align="center">系统变量</td><td align="center"><code>MAKECMDGOALS</code></td><td align="center">存放那个你命令行中所指定的终极目标的列表,没有指定则为空</td><td align="center"></td></tr><tr><td align="center">自动变量</td><td align="center"><code>$@</code></td><td align="center">目标集</td><td align="center">它代表一个量,遍历目标集,一般与依赖集相匹配</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$%</code></td><td align="center">目标集</td><td align="center">仅当目标是函数库文件时,表示规则中的目标成员名,foo.a(bar.o),$%就是bar.o,$@就是foo.a</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$&lt;</code></td><td align="center">依赖集</td><td align="center">它代表一个量,遍历目标集,一般用于目标集相匹配</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$?</code></td><td align="center">依赖集</td><td align="center">所有比目标新的依赖目标的集合,以空格分隔</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$^</code></td><td align="center">依赖集</td><td align="center">所有依赖目标的集合,去掉重复以空格分隔</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$+</code></td><td align="center">依赖集</td><td align="center">所有依赖目标的集合,不去掉重复以空格分隔</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$*</code></td><td align="center"></td><td align="center">对应模式的’%’及之前的部分,包括路径</td></tr></tbody></table><p><strong>所有自动变量都可以与<code>D</code>,<code>F</code>搭配使用,表示匹配的目录部分和文件部分,如<code>$(@D)</code></strong></p><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><ul><li>替换<code>.o</code>到<code>.c</code><br><strong>方法一:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo:=a.o b.o c.o<br>bar:=$(foo:.o=.c)<br></code></pre></td></tr></table></figure><strong>方法二:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#静态模式</span><br>foo:=a.o b.o c.o<br>bar:=$(foo:%.o=%.c)<br></code></pre></td></tr></table></figure></li><li>强制覆盖</li></ul><p><code>override &lt;variable&gt;=&lt;value&gt;</code>make命令行参数可以用这个强制覆盖,否则覆盖不了</p><ul><li>替换变量中字符串<br><code>变量名: s/原字符串/新字符串</code></li><li>加前后缀<br><code>变量:^ &quot;前缀&quot;</code><br><code>变量:+ &quot;后缀&quot;</code></li><li>取部分<br><code>$(VARIABLE:&lt;option&gt;)</code>,option有3个选项d(仅取路径)、b(文件名,不包括扩展)、f(文件名,包括扩展)</li></ul><h3 id="关键字vpath"><a href="#关键字vpath" class="headerlink" title="关键字vpath"></a>关键字vpath</h3><ul><li>用法一:<code>vpath &lt;pattern&gt; &lt;directories&gt;</code>符合模式的在指定文件夹搜索</li><li>用法二:<code>vpath &lt;pattern&gt;</code>清除对应模式搜索目录</li><li>用法三:<code>vpath</code>清除所有搜索目录<br><em><strong>注意:<pattern>都必须包含%,意思是包含一个以上的匹配字符</strong></em></li></ul><h3 id="局部作用的变量"><a href="#局部作用的变量" class="headerlink" title="局部作用的变量"></a>局部作用的变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">prog: CFLAGS = -g<br>prog: prog.o foo.o bar.o<br>$(gcc) $(CFLAGS) prog.o foo.o bar.o<br>prog.o: prog.c<br>$(gcc) $(CFLAGS) prog.c<br>foo.o: foo.c<br>$(gcc) $(CFLAGS) bar.c<br></code></pre></td></tr></table></figure><p>不管全局的<code>$(CFLAGS)</code>的值是什么,prog目标及其所引发的所有规则中(prog.o foo.o bar.o),$(CFLAGS)的值都是-gl</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>用<code>.PHONY</code>指明伪目标</p><ul><li>伪目标并不是文件，只是个标签,最终不产生文件</li><li>只有显式地指名才能使其生效</li><li>最终目标可以是伪目标,一个用法如下,使一个make文件生成多个目标:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">all: prog1 prog2 prog3<br>.PHONY: all<br>prog1: prog1.o utils.o<br>gcc -o prog1 prog1.o utils.o<br>prog2: prog2.o<br>gcc -o prog2 prog2.o<br>prog3: prog3.o sort.o utils.o<br>gcc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure></li></ul><h3 id="静态模式-更方便定义多目标"><a href="#静态模式-更方便定义多目标" class="headerlink" title="静态模式:更方便定义多目标"></a>静态模式:更方便定义多目标</h3><p><code>&lt;targets&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns&gt;</code><br>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">objects = foo.o bar.o<br>all: $(objects)<br>$(objects): %.o: %.c<br>$(gcc) -c $(CFLAGS) $&lt; -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo.o: foo.c<br>$(gcc) -c $(CFLAGS) foo.c -o foo.o<br>bar.o: bar.c<br>$(gcc) -c $(CFLAGS) bar.c -o bar.o<br></code></pre></td></tr></table></figure><h3 id="gcc-MM选项"><a href="#gcc-MM选项" class="headerlink" title="gcc -MM选项"></a>gcc -MM选项</h3><p>该选项可以为.c源文件自动生成依赖的非标准库的头文件,按习惯称为.d文件<br>可以用以下模式规则来产生.d文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">%.d: %.c<br>    @<span class="hljs-built_in">set</span> -e; <span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$@</span>; \<br>    $(CC) -M $(CPPFLAGS) $&lt; &gt; <span class="hljs-variable">$@</span>.$$$$; \<br>    sed <span class="hljs-string">&#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27;</span> &lt; <span class="hljs-variable">$@</span>.$$$$ &gt; <span class="hljs-variable">$@</span>; \<br>    <span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$@</span>.$$$$<br></code></pre></td></tr></table></figure><p>然后用include</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sources = foo.c bar.c<br>include $(sources:.c=.d)<br></code></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="@关键字"></a><code>@</code>关键字</h3><p>make默认会显示命令,在命令前加@可以阻止输出,例如<br><code>@echo 正在编译XXX模块</code></p><h3 id="关键字-1"><a href="#关键字-1" class="headerlink" title="-关键字"></a><code>-</code>关键字</h3><p>在命令前加<code>-</code>会忽略该命令产生的错误</p><h3 id="嵌套make"><a href="#嵌套make" class="headerlink" title="嵌套make"></a>嵌套make</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">subsystem:<br><span class="hljs-built_in">cd</span> subdir &amp;&amp; $(MAKE) <span class="hljs-comment">#也可以这么写$(MAKE) -C subdir</span><br></code></pre></td></tr></table></figure><p>　要想传递变量给嵌套的make,使用export,不想传递使用unexport<br>　其中<code>SHELL</code>和<code>MAKEFLAGS</code>总会影响下层make,但-C、-f、-h、-o、-W几个参数并不往下传递</p><h3 id="定义命令包-即命令集"><a href="#定义命令包-即命令集" class="headerlink" title="定义命令包(即命令集)"></a>定义命令包(即命令集)</h3><p>其实这是多行变量<br>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">define run-yacc<br><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dir</span><br><span class="hljs-built_in">mv</span> <span class="hljs-built_in">dir</span> newdir<br>endef<br>crap: <br>$(run-yacc)<br></code></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>make是在读取Makefile时就计算条件表达式的值,而不是运行,所以不要用自动变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">xx: xc<br>&lt;conditional-directive&gt; <span class="hljs-comment">#可以是ifeq(arg1,arg2)、ifneq、ifdef &lt;variable-name&gt;(不加美元符号)、ifndef</span><br>&lt;text-if-true&gt;<br><span class="hljs-keyword">else</span><br>&lt;text-if-false&gt;<br>endif<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="调用语法"><a href="#调用语法" class="headerlink" title="调用语法"></a>调用语法</h4><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code>,参数间用’,’分隔</p><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><table><thead><tr><th align="center">函数</th><th align="center">功能</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center"><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></td><td align="center">把字符串<text>中的<from>换成<to></td><td align="center"><code>被替换过的字符串</code></td></tr><tr><td align="center"><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></td><td align="center">查找<text>中的单词(以空格、Tab、回车、换行)符合<pattern>,替换<replacement></td><td align="center">被替换后的字符串</td></tr><tr><td align="center"><code>$(strip &lt;string&gt;)</code></td><td align="center">去掉<string>中开头和结尾的空字符</td><td align="center">去掉空字符的字符串</td></tr><tr><td align="center"><code>$(findstring &lt;find&gt;,&lt;in&gt;)</code></td><td align="center">在字符串<in>中查找<find></td><td align="center">如果找到,返回<find>,否则返回空字符串</td></tr><tr><td align="center"><code>$(filter &lt;pattern...&gt;,&lt;text&gt;)</code></td><td align="center">以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割</td><td align="center">返回符合<pattern>的字符串</td></tr><tr><td align="center"><code>$(filter-out &lt;pattern...&gt;,&lt;text&gt;)</code></td><td align="center">以<pattern>模式过滤<text>字符串中的单词(以空格等作为分隔符),可以有多个模式,模式间以空格分割</td><td align="center">返回不符合<pattern>的字符串</td></tr><tr><td align="center"><code>$(sort &lt;list&gt;)</code></td><td align="center">给字符串<list>中的单词升序</td><td align="center">返回排序后的字符串(会去掉相同的单词)</td></tr><tr><td align="center"><code>$(word &lt;n&gt;,&lt;text&gt;)</code></td><td align="center">取字符串<text>中的第<n>个单词</td><td align="center">返回该单词,如果n过大,则返回空字符串</td></tr><tr><td align="center"><code>$(wordlist &lt;n&gt;,&lt;m&gt;,&lt;text&gt;)</code></td><td align="center">取第<n>-第<m>个单词</td><td align="center">返回那些单词</td></tr><tr><td align="center"><code>$(words &lt;text&gt;)</code></td><td align="center">统计<text>中的单词数</td><td align="center">返回个数</td></tr><tr><td align="center"><code>$(firstword &lt;text&gt;)</code></td><td align="center">返回字符串<text>中第一个单词</td><td align="center">返回第一个单词</td></tr></tbody></table><h4 id="文件名函数"><a href="#文件名函数" class="headerlink" title="文件名函数"></a>文件名函数</h4><table><thead><tr><th align="center">格式</th><th align="center">例子</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center"><code>$(dir &lt;names...&gt;)</code></td><td align="center"><code>$(dir src/foo.c hacks)</code></td><td align="center"><code>src/ ./</code></td></tr><tr><td align="center"><code>$(notdir &lt;names...&gt;)</code></td><td align="center"><code>$(notdir src/foo.c hacks)</code></td><td align="center"><code>foo.c hacks</code></td></tr><tr><td align="center"><code>$(suffix &lt;names...&gt;)</code></td><td align="center"><code>$(suffix src/foo.c src-1.0/bar.c hacks)</code></td><td align="center"><code>.c .c</code></td></tr><tr><td align="center"><code>$(basename &lt;names...&gt;)</code></td><td align="center"><code>$(basename src/foo.c src-1.0/bar.c hacks)</code></td><td align="center"><code>src/foo src-1.0/bar hacks</code></td></tr><tr><td align="center"><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</code></td><td align="center"><code>$(addsuffix .c,foo bar)</code></td><td align="center"><code>foo.c bar.c</code></td></tr><tr><td align="center"><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</code></td><td align="center"><code>$(addprefix src/,foo bar)</code></td><td align="center"><code>src/foo src/bar</code></td></tr><tr><td align="center"><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code></td><td align="center"><code>$(join aaa bbb,111 222 333)</code></td><td align="center"><code>aaa111 bbb222</code></td></tr></tbody></table><h4 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h4><p>格式:<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">names:= a b c d<br>files:= $(foreach n,$(names),$(n).o)<br><span class="hljs-comment">#$(files)的值是‘a.o b.o c.o d.o’</span><br></code></pre></td></tr></table></figure><h4 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h4><p><code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code>,<condition>若返回为非空,则执行<then-part>,其是整个函数的返回值</p><h4 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h4><p><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code>;<expression>中<code>$(1)</code>,<code>$(2)</code>等,会被参数<code>&lt;parm1&gt;</code>、<code>&lt;parm2&gt;</code>等代替</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">reverse=$(2) $(1)<br>foo=$(call reverse,a,b)<br></code></pre></td></tr></table></figure><p>此时foo的值就是’b a’</p><h4 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h4><p><code>files:=$(shell echo *.c)</code></p><h4 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h4><p><code>$(origin &lt;variable&gt;)</code>:告知变量来源情况</p><table><thead><tr><th align="center">返回值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">未定义</td></tr><tr><td align="center">default</td><td align="center">默认定义</td></tr><tr><td align="center">environment</td><td align="center">环境变量</td></tr><tr><td align="center">file</td><td align="center">定义在make文件中</td></tr><tr><td align="center">override</td><td align="center">被override重新定义</td></tr><tr><td align="center">automatic</td><td align="center">命令运行中的自动化变量</td></tr><tr><td align="center">command line</td><td align="center">命令行定义</td></tr></tbody></table><h4 id="error函数和warning函数"><a href="#error函数和warning函数" class="headerlink" title="error函数和warning函数"></a>error函数和warning函数</h4><p><code>$(error &lt;text ...&gt;)</code><br><code>$(warning &lt;text ...&gt;)</code><br>error函数产生一个致命的错误,&lt;text …&gt;是错误信息<br>warning函数只是输出警告信息,make会继续执行</p><p>例1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifdef ERROR_001<br><span class="hljs-comment">#运行到下面的会出错跳出脚本</span><br>    $(error error is $(ERROR_001))<br>endif<br></code></pre></td></tr></table></figure><p>例2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#这里并不会出错跳出脚本</span><br>ERR = $(error found an error!)<br><br>.PHONY: err<br><span class="hljs-comment">#这里才会跳出</span><br>err: $(ERR)<br></code></pre></td></tr></table></figure><h3 id="make的退出码"><a href="#make的退出码" class="headerlink" title="make的退出码"></a>make的退出码</h3><ul><li>0:表示成功执行</li><li>1:表示出错</li><li>2:如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li></ul><h3 id="一些常用伪目标命名"><a href="#一些常用伪目标命名" class="headerlink" title="一些常用伪目标命名"></a>一些常用伪目标命名</h3><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">all</td><td align="center">这个伪目标一般是所有目标的目标,一般为编译所有的目标</td></tr><tr><td align="center">clean</td><td align="center">这个伪目标的功能一般是删除所有make创建的文件</td></tr><tr><td align="center">install</td><td align="center">安装已编译好的程序,其实是把目标执行文件复制到指定文件夹</td></tr><tr><td align="center">print</td><td align="center">这个伪目标的功能是列出改变过的源文件</td></tr><tr><td align="center">tar</td><td align="center">这个伪目标的功能是打包备份源程序</td></tr><tr><td align="center">dist</td><td align="center">一般是把打包文件进行压缩</td></tr><tr><td align="center">tags</td><td align="center">这个伪目标的功能用于更新所有的目标,以备完整地重新编译</td></tr><tr><td align="center">check、test</td><td align="center">一般用来测试makefile文件流程</td></tr></tbody></table><h3 id="make选项参数"><a href="#make选项参数" class="headerlink" title="make选项参数"></a>make选项参数</h3><table><thead><tr><th align="center">短选项</th><th align="center">长选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-b,-m</td><td align="center"></td><td align="center">忽略其他版本make兼容性</td></tr><tr><td align="center">-B</td><td align="center">–always-make</td><td align="center">认为所有目标都更新(重编译)</td></tr><tr><td align="center">-C <dir></td><td align="center">–directory&#x3D;<dir></td><td align="center">指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen&#x2F;test -C prog”等价于“make -C ~hchen&#x2F;test&#x2F;prog”</td></tr><tr><td align="center">-d</td><td align="center"></td><td align="center">相当于<code>-debug=a</code></td></tr><tr><td align="center">-e</td><td align="center">–environment-overrides</td><td align="center">指定环境变量值,覆盖makefile文件中定义的变量值</td></tr><tr><td align="center">-f</td><td align="center">–file、–makefile</td><td align="center">指定某个makefile文件</td></tr><tr><td align="center">-i</td><td align="center">–ignore-errors</td><td align="center">在执行时忽略所有的错误</td></tr><tr><td align="center">-I <dir></td><td align="center">–include-dir&#x3D;<dir></td><td align="center">指定一个包含makefile文件的搜索目标</td></tr><tr><td align="center">-j <jobsnum></td><td align="center">–jobs&#x3D;<jobsnum></td><td align="center">指同时运行的命令数,如果没有这个参数,能运行多少就多少,只有最后一个-j选项有效</td></tr><tr><td align="center">-k</td><td align="center">–keep-going</td><td align="center">出错也不停止,执行其它目标,失败的目标,依赖于其上的就不会执行</td></tr><tr><td align="center">-l <load></td><td align="center">–load-average [&#x3D;<load>];–max-load[&#x3D;<load>]</td><td align="center">指定make运行命令的负载</td></tr><tr><td align="center">-n</td><td align="center">–just-print、–dry-run、–recon</td><td align="center">不管目标更不更新,只打印命令,不执行</td></tr><tr><td align="center">-o <file></td><td align="center">–old-file&#x3D;<file>;–assume-old&#x3D;<file></td><td align="center">不生成指定的<file>,即使这个目标的依赖文件比他新</td></tr><tr><td align="center">-p</td><td align="center">–print-database</td><td align="center">输出makefile文件中所有数据,包括所有的规则和变量</td></tr><tr><td align="center">-q</td><td align="center">–question</td><td align="center">寻找目标,如果目标存在,什么也不输出,也不执行编译,返回0.如果目标不存在,打印一条出错信息,返回2</td></tr><tr><td align="center">-r</td><td align="center">–no-builtin-rules</td><td align="center">禁止使用任何隐式规则，会使得SUFFIXE变量为空</td></tr><tr><td align="center">-R</td><td align="center">–no-builtin-variables</td><td align="center">禁止使用任作用于变量上的何隐式规则</td></tr><tr><td align="center">-s</td><td align="center">–silent;–quiet</td><td align="center">命令运行时不显示命令的输出</td></tr><tr><td align="center">-S</td><td align="center">–no-keep-going;–stop</td><td align="center">取消-k选项的作用</td></tr><tr><td align="center">-t</td><td align="center">–touch</td><td align="center">把目标文件时间更新,但不更改目标文件,假装编译文件</td></tr><tr><td align="center">-w</td><td align="center">–print-directory</td><td align="center">输出运行makefile文件之前之后的信息,跟踪嵌套make时很有用</td></tr><tr><td align="center">-W <file></td><td align="center">–what-if&#x3D;<file>;–assume-new&#x3D;<file>;–new-file&#x3D;<file></td><td align="center">假定目标<file>;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>;的修改时间为当前时间。</td></tr><tr><td align="center"></td><td align="center">–no-print-directory</td><td align="center">禁止-w选项</td></tr><tr><td align="center"></td><td align="center">–warn-undefined-variables</td><td align="center">警告未定义的变量</td></tr></tbody></table><h4 id="–debug"><a href="#–debug" class="headerlink" title="–debug &lt;options&gt;"></a>–debug &lt;options&gt;</h4><p>options可以是以下:</p><ul><li>也就是all,输出所有的调试信息</li><li>也就是basic,只输出简单的调试信息,即输出不需要重新编译的目标</li><li>也就是verbose,输出的信息包括哪一个makefile文件被解析,不需要重新编译的依赖文件(或是依赖目标)</li><li>也就是implicit,输出所有的隐含规则</li><li>也就是jobs,输出执行规则中命令的详细信息,如PID、返回码等</li><li>也就是makefile文件,输出make,读取makefile,更新makefile文件,并执行makefile文件的信息</li></ul><h4 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h4><ul><li><code>make -qp</code>只输出信息而不执行</li><li><code>make -p -f /dev/null</code>查看makefile前的预设变量和规则</li></ul><h3 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h3><p>一般来说，一个目标的模式有一个有前缀或是后缀的%，或是没有前后缀，直接就是一个%。因为%代表一个或多个字符，所以在定义好了的模式中，我们把%所匹配的内容叫做“茎”，例如%.c所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有%时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p><p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式e%t，文件src&#x2F;eat匹配于该模式，于是src&#x2F;a就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式c%r，那么，目标就是src&#x2F;car。（“茎”被传递）</p><h3 id="一些”老东西”–后缀规则"><a href="#一些”老东西”–后缀规则" class="headerlink" title="一些”老东西”–后缀规则"></a>一些”老东西”–后缀规则</h3><ul><li><code>.c.o:</code>等价于<code>%.o : %.c</code></li><li><code>.c:</code>等价于<code>% : %.c</code><br>以上称为后缀规则，要想这么用，必须为默认后缀，你可以用以下来添加默认后缀<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">.SUFFIXES:              <span class="hljs-comment"># 删除默认的后缀</span><br>.SUFFIXES: .a .b .c c <span class="hljs-comment"># 定义自己的后缀</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h3><h4 id="各个规则"><a href="#各个规则" class="headerlink" title="各个规则"></a>各个规则</h4><ul><li>C程序隐含规则:<n>.o的目标的依赖目标会是:<n>.c,命令是<code>$(CC) -c $(CPPFLAGS)$(CFLAGS)</code></li><li>C++程序隐含规则:<n>.o的目标的依赖目标是:<n>.cc或<n>.C,命令是<code>$(CXX) -c  $(CPPFLAGS)$(CXXFLAGS)</code></li><li>汇编和预处理隐含规则:<n>.o的目标的依赖目标会自动推导为<n>.s，默认使用编译器as，并且其生成命令是：<code>$ (AS) $(ASFLAGS)</code>。<n>.s的目标的依赖目标会自动推导为<n>.S，默认使用C预编译器cpp，并且其生成命令是：<code>$(AS) $(ASFLAGS)</code>。</li><li>链接Object文件的隐含规则:<n>目标依赖于<n>.o，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是：<code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code>。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">x : y.o z.o<br></code></pre></td></tr></table></figure>隐含规则执行如下(x.c、y.c、z.c都存在):<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">cc -c x.c -o x.o<br>cc -c y.c -o y.o<br>cc -c z.c -o z.o<br>cc x.o y.o z.o -o x<br><span class="hljs-built_in">rm</span> -f x.o<br><span class="hljs-built_in">rm</span> -f y.o<br><span class="hljs-built_in">rm</span> -f z.o<br></code></pre></td></tr></table></figure></li></ul><h4 id="一些tip"><a href="#一些tip" class="headerlink" title="一些tip"></a>一些tip</h4><ul><li>隐式规则产生的中间目标，最终会被自动删除，被makefile指定成的目标或依赖目标不能被当作中介，但是可以通过<code>.INTERMEDIATE</code>来强制声明为中间目标。如<code>.intermediate: mid</code></li><li>也可以阻止自动删除中间目标，通过<code>.SECONDARY</code>来强制声明。如<code>.SECONDARY</code>。或以模式的方式指定(如：%.o)成为伪目标<code>.PRECIOUS</code>的依赖目标。</li><li>Make会优化一些特殊的隐含规则，而不生成中间文件。从文件.c直接生成执行文件，不产生目标文件</li></ul><h4 id="模式规则来定义一个隐含规则"><a href="#模式规则来定义一个隐含规则" class="headerlink" title="模式规则来定义一个隐含规则"></a>模式规则来定义一个隐含规则</h4><p>模式规则，目标的定义需要有<code>%</code>字符。依赖目标随便，与变量不同的是，模式规则的展开发生在运行期间。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">%.o: %.c<br> $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><h4 id="隐含规则搜索算法"><a href="#隐含规则搜索算法" class="headerlink" title="隐含规则搜索算法"></a>隐含规则搜索算法</h4><p>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是archive(member)的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把member当作T来搜索。</p><ol><li>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是src&#x2F;foo.o，那么，D就是src&#x2F;，N就是foo.o）</li><li>创建所有匹配于T或是N的模式规则列表。</li><li>如果在模式规则列表中有匹配所有文件的模式，如%，那么从列表中移除其它的模式。</li><li>移除列表中没有命令的规则。</li><li>对于第一个在列表中的模式规则：</li></ol><ul><li>推导其“茎”S，S应该是T或是N匹配于模式中%非空的部分。</li><li>计算依赖文件。把依赖文件中的%都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li><li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）</li><li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li></ul><ol start="6"><li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：</li></ol><ul><li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li><li>计算依赖文件。（同第5步）</li><li>测试所有的依赖文件是否存在或是理当存在。</li><li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li><li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li><li>如果没有隐含规则可以使用，查看.DEFAULT规则，如果有，采用，把.DEFAULT的命令给T使用。</li></ul><h3 id="函数库打包"><a href="#函数库打包" class="headerlink" title="函数库打包"></a>函数库打包</h3><p>函数库文件也就是对.o文件的打包文件<br>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">foolib(hack.o xx.o): hack.o xx.o<br>ar cr foolib hack.o xx.o <span class="hljs-comment">#foolib是库名,hack.o是包含文件</span><br></code></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>make中遇到的第一条规则是最终目标  </li><li>和bash一样用空格和”&quot;进行换行</li><li>命令总是以tab键开头,其余不是命令</li><li><code>MAKEFILES</code>最好不用该环境变量,该变量类似于include动作,但其中文件中的目标不会起作用,最好置为空,以免引入未考虑到的东西,莫名奇妙出现问题时,可以查看该变量</li><li>要想前面命令作用于后面命令,需要写在同一行上,用分号分隔,如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span>:<br><span class="hljs-built_in">cd</span> /home/nanbert;<span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure></li><li>可以在命令前加<code>-</code>,来忽略该命令可能执行失败,这也可用于include</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Make及gcc</title>
    <link href="/2020/01/17/Make%E5%8F%8Agcc/"/>
    <url>/2020/01/17/Make%E5%8F%8Agcc/</url>
    
    <content type="html"><![CDATA[<p>1.make中遇到的第一条规则是最终目标<br>2.变量相关<br>　a.内置变量</p><table><thead><tr><th align="center">变量类型</th><th align="center">特殊变量</th><th align="center">含义</th><th align="center">用例或说明</th></tr></thead><tbody><tr><td align="center">特殊变量</td><td align="center"><code>VPATH</code></td><td align="center">寻找依赖的路径</td><td align="center"><code>VPATH = src:../headers</code></td></tr><tr><td align="center">特殊变量</td><td align="center">.DIRSEPSTR</td><td align="center">路径分隔符一般是斜杠</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.MAKEDIR</td><td align="center">调用make的绝对路径名</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.NULL</td><td align="center">空字符串</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.OS</td><td align="center">正在运行的操作系统名称</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.PWD</td><td align="center">运行时活动工作目录的绝对路径名</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center">.SHELL</td><td align="center">启动的shell类型</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>AR</code></td><td align="center">函数库打包程序,默认命令是ar</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>CC</code></td><td align="center">C语言编译程序,默认命令是cc</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>RM</code></td><td align="center">删除文件命令,默认命令是rm -f</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>ARFLAGS</code></td><td align="center">函数库打包程序AR命令参数,默认值是rv</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>CFLAGS</code></td><td align="center">C语言编译器参数,默认为空</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>CXXLAGS</code></td><td align="center">C++语言编译器参数,默认为空</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>CPPLAGS</code></td><td align="center">C预处理器参数,默认为空</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>CXX</code></td><td align="center">C++语言编译程序,默认命令是g++</td><td align="center"></td></tr><tr><td align="center">特殊变量</td><td align="center"><code>CPP</code></td><td align="center">C程序的预处理器,默认命令是$(CC) -E</td><td align="center"></td></tr><tr><td align="center">自动变量</td><td align="center"><code>$@</code></td><td align="center">目标集</td><td align="center">它代表一个量,遍历目标集,一般与依赖集相匹配</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$%</code></td><td align="center">目标集</td><td align="center">仅当目标是函数库文件时,表示规则中的目标成员名,foo.a(bar.o),$%就是bar.o,$@就是foo.a</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$&lt;</code></td><td align="center">依赖集</td><td align="center">它代表一个量,遍历目标集,一般用于目标集相匹配</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$?</code></td><td align="center">依赖集</td><td align="center">所有比目标新的依赖目标的集合,以空格分隔</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$^</code></td><td align="center">依赖集</td><td align="center">所有依赖目标的集合,去掉重复以空格分隔</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$+</code></td><td align="center">依赖集</td><td align="center">所有依赖目标的集合,不去掉重复以空格分隔</td></tr><tr><td align="center">自动变量</td><td align="center"><code>$*</code></td><td align="center"></td><td align="center">对应模式的’%’及之前的部分,包括路径</td></tr></tbody></table><p>所有自动变量都可以与<code>D</code>,<code>F</code>搭配使用,表示匹配的目录部分和文件部分,如<code>$(@D)</code><br>　b.<code>:=</code>操作符,操作符右边只能出现已定义的变量,如果是未定义的变量,则会自动忽略<br>　<code>=</code>操作符右边可以出现未定义的变量<br>　<code>?=</code>如果变量没有定义过,则使用后面的值<br>　<code>+=</code>追加变量值<br>　c.变量定义要注意空格<br>　d.替换<code>.o</code>到<code>.c</code><br>　　方法一:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo:=a.o b.o c.o<br>bar:=$(foo:.o=.c)<br></code></pre></td></tr></table></figure><p>　　方法二:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo:=a.o b.o c.o<br>bar:=$(foo:%.o=%.c)<br></code></pre></td></tr></table></figure><p>　e.<code>override &lt;variable&gt;=&lt;value&gt;</code>:强制覆盖,make命令行参数可以用这个强制覆盖,否则覆盖不了<br>　f.替换变量中字符串<br>　<code>变量名: s/原字符串/新字符串</code><br>　g.加前后缀<br>　<code>变量:^ &quot;前缀&quot;</code><br>　<code>变量:+ &quot;后缀&quot;</code><br>　h.取部分<br>　<code>$(VARIABLE:&lt;option&gt;)</code>,option有3个选项d(仅取路径)、b(文件名,不包括扩展)、f(文件名,包括扩展)<br>3.关键字vpath<br>　用法一: vpath <pattern> <directories>;符合模式的在指定文件夹搜索<br>　用法二: vpath <pattern>;清除对应模式搜索目录<br>　用法三: vpath;清除所有搜索目录<br><em><strong>注意:都必须包含%,意思是包含一个以上的匹配字符</strong></em><br>　f.局部作用的变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">prog: CFLAGS = -g<br>prog: prog.o foo.o bar.o<br>$(gcc) $(CFLAGS) prog.o foo.o bar.o<br>prog.o: prog.c<br>$(gcc) $(CFLAGS) prog.c<br>foo.o: foo.c<br>$(gcc) $(CFLAGS) bar.c<br></code></pre></td></tr></table></figure><p>不管全局的$(CFLAGS)的值是什么,prog目标及其所引发的所有规则中(prog.o foo.o bar.o),$(CFLAGS)的值都是-gl<br>4.伪目标:<code>.PHONY</code><br>　-伪目标并不是文件，只是个标签<br>　-只有显式地指名才能使其生效<br>　-最终目标可以是伪目标,一个用法如下,使一个make文件生成多个目标:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">all: prog1 prog2 prog3<br>.PHONY: all<br>prog1: prog1.o utils.o<br>gcc -o prog1 prog1.o utils.o<br>prog2: prog2.o<br>gcc -o prog2 prog2.o<br>prog3: prog3.o sort.o utils.o<br>gcc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure><p>5.静态模式:更方便定义多目标<code>&lt;targets&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns&gt;</code><br>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">objects = foo.o bar.o<br>all: $(objects)<br>$(objects): %.o: %.c<br>$(gcc) -c $(CFLAGS) $&lt; -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo.o: foo.c<br>$(gcc) -c $(CFLAGS) foo.c -o foo.o<br>bar.o: bar.c<br>$(gcc) -c $(CFLAGS) bar.c -o bar.o<br></code></pre></td></tr></table></figure><p>6.gcc -MM选项可以为.c源文件自动生成依赖<br>7.make默认会显示命令,在命令前加@可以阻止输出<br>8.要想前一个命令影响后一个命令要以‘;’分隔,不能分行写,<br>9.在命令前加上”-“,则命令都会被认为成功执行,如<code>-mkdir dir</code>,这样可以避免目录已存在的错误而终止规则<br>10.嵌套make  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">subsystem:<br><span class="hljs-built_in">cd</span> subdir &amp;&amp; $(MAKE) <span class="hljs-comment">#也可以这么写$(MAKE) -C subdir</span><br></code></pre></td></tr></table></figure><p>　要想传递变量给嵌套的make,使用export,不想传递使用unexport<br>　其中<code>SHELL</code>和<code>MAKEFLAGS</code>总会影响下层make,但-C、-f、-h、-o、-W几个参数并不往下传递<br>11.定义命令包(即命令集)<br>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">define run-yacc<br><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dir</span><br><span class="hljs-built_in">mv</span> <span class="hljs-built_in">dir</span> newdir<br>endef<br>crap: <br>$(run-yacc)<br></code></pre></td></tr></table></figure><p>12.条件判断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;conditional-directive&gt; <span class="hljs-comment">#可以是ifeq(arg1,arg2)、ifneq、ifdef &lt;variable-name&gt;、ifndef</span><br>&lt;text-if-true&gt;<br><span class="hljs-keyword">else</span><br>&lt;text-if-false&gt;<br>endif<br></code></pre></td></tr></table></figure><p>13.函数<br>　a.调用语法:<code>$(&lt;function&gt; &lt;arguments&gt;)</code>,参数间用’,’分隔<br>　b.字符串函数</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center"><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></td><td align="center">把字符串<text>中的<from>换成<to></td><td align="center"><code>被替换过的字符串</code></td></tr><tr><td align="center"><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></td><td align="center">查找<text>中的单词符合<pattern>,替换<replacement></td><td align="center">被替换后的字符串</td></tr><tr><td align="center"><code>$(strip &lt;string&gt;)</code></td><td align="center">去掉<string>中开头和结尾的空字符</td><td align="center">去掉空字符的字符串</td></tr><tr><td align="center"><code>$(findstring &lt;find&gt;,&lt;in&gt;)</code></td><td align="center">在字符串<in>中查找<find></td><td align="center">如果找到,返回<find>,否则返回空字符串</td></tr><tr><td align="center"><code>$(filter &lt;pattern...&gt;,&lt;text&gt;)</code></td><td align="center">以<pattern>模式过滤<text>字符串中的字符串,可以有多个模式,以空格分割</td><td align="center">返回符合<pattern>的字符串</td></tr><tr><td align="center"><code>$(filter-out &lt;pattern...&gt;,&lt;text&gt;)</code></td><td align="center">以<pattern>模式过滤<text>字符串中的字符串,可以有多个模式,以空格分割</td><td align="center">返回不符合<pattern>的字符串</td></tr><tr><td align="center"><code>$(sort &lt;list&gt;)</code></td><td align="center">给字符串<list>中的单词升序</td><td align="center">返回排序后的字符串(会去掉相同的单词)</td></tr><tr><td align="center"><code>$(word &lt;n&gt;,&lt;text&gt;)</code></td><td align="center">取字符串<text>中的第<n>个单词</td><td align="center">返回该单词,如果n过大,则返回空字符串</td></tr><tr><td align="center"><code>$(wordlist &lt;n&gt;,&lt;m&gt;,&lt;text&gt;)</code></td><td align="center">取第<n>-第<m>个单词</td><td align="center">返回那些单词</td></tr><tr><td align="center"><code>$(words &lt;text&gt;)</code></td><td align="center">统计<text>中的单词数</td><td align="center">返回个数</td></tr></tbody></table><p>　c.文件名函数</p><table><thead><tr><th align="center">格式</th><th align="center">例子</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center"><code>$(dir &lt;names...&gt;)</code></td><td align="center"><code>$(dir src/foo.c hacks)</code></td><td align="center"><code>src/ ./</code></td></tr><tr><td align="center"><code>$(notdir &lt;names...&gt;)</code></td><td align="center"><code>$(notdir src/foo.c hacks)</code></td><td align="center"><code>foo.c hacks</code></td></tr><tr><td align="center"><code>$(suffix &lt;names...&gt;)</code></td><td align="center"><code>$(suffix src/foo.c src-1.0/bar.c hacks)</code></td><td align="center"><code>.c .c</code></td></tr><tr><td align="center"><code>$(basename &lt;names...&gt;)</code></td><td align="center"><code>$(basename src/foo.c src-1.0/bar.c hacks)</code></td><td align="center"><code>src/foo src-1.0/bar hacks</code></td></tr><tr><td align="center"><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</code></td><td align="center"><code>$(addsuffix .c,foo bar)</code></td><td align="center"><code>foo.c bar.c</code></td></tr><tr><td align="center"><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</code></td><td align="center"><code>$(addprefix src/,foo bar)</code></td><td align="center"><code>src/foo src/bar</code></td></tr><tr><td align="center"><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code></td><td align="center"><code>$(join aaa bbb,111 222 333)</code></td><td align="center"><code>aaa111 bbb222</code></td></tr></tbody></table><p>　d.foreach函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">names:= a b c d<br>files:= $(foreach n,$(names),$(n).o)<br></code></pre></td></tr></table></figure><p>　$(files)的值是‘a.o b.o c.o d.o’<br>　e.if函数<br>　<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code>,<condition>若返回为非空,则执行<then-part>,其是整个函数的返回值<br>　f.call函数<br><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code>;<expression>中$(1),$(2)等,会被参数<parm1>、<parm2>等代替</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">reverse=$(2) $(1)<br>foo=$(call reverse,a,b)<br></code></pre></td></tr></table></figure><p>此时foo的值就是’b a’<br>  g.shell函数<br>  <code>files:=$(shell echo *.c)</code><br>  h.origin函数<br>  <code>$(origin &lt;variable&gt;)</code>:告知变量来源情况</p><table><thead><tr><th align="center">返回值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">未定义</td></tr><tr><td align="center">default</td><td align="center">默认定义</td></tr><tr><td align="center">environment</td><td align="center">环境变量</td></tr><tr><td align="center">file</td><td align="center">定义在make文件中</td></tr><tr><td align="center">override</td><td align="center">被override重新定义</td></tr><tr><td align="center">automatic</td><td align="center">命令运行中的自动化变量</td></tr><tr><td align="center">command line</td><td align="center">命令行定义</td></tr></tbody></table><p> 14.一些常用伪目标命名</p><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">all</td><td align="center">这个伪目标一般是所有目标的目标,一般为编译所有的目标</td></tr><tr><td align="center">clean</td><td align="center">这个伪目标的功能一般是删除所有make创建的文件</td></tr><tr><td align="center">install</td><td align="center">安装已编译好的程序,其实是把目标执行文件复制到指定文件夹</td></tr><tr><td align="center">print</td><td align="center">这个伪目标的功能是列出改变过的源文件</td></tr><tr><td align="center">tar</td><td align="center">这个伪目标的功能是打包备份源程序</td></tr><tr><td align="center">dist</td><td align="center">一般是把打包文件进行压缩</td></tr><tr><td align="center">tags</td><td align="center">这个伪目标的功能用于更新所有的目标,以备完整地重新编译</td></tr><tr><td align="center">check、test</td><td align="center">一般用来测试makefile文件流程</td></tr></tbody></table><p>15.make选项参数</p><table><thead><tr><th align="center">短选项</th><th align="center">长选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">–just-print、–dry-run、–recon</td><td align="center">不管目标更不更新,只打印命令,不执行</td></tr><tr><td align="center">-t</td><td align="center">–touch</td><td align="center">把目标文件时间更新,但不更改目标文件,假装编译文件</td></tr><tr><td align="center">-q</td><td align="center">–question</td><td align="center">寻找目标,如果目标存在,什么也不输出,也不执行编译.如果目标不存在,打印一条出错信息</td></tr><tr><td align="center">-B</td><td align="center">–always-make</td><td align="center">认为所有目标都需要更新(重编译)</td></tr><tr><td align="center">-W <file></td><td align="center">–what-if&#x3D;<file>;–assume-new&#x3D;<file>;–new-file&#x3D;<file></td><td align="center">make会根据规则推导来运行依赖于这个文件的命令</td></tr><tr><td align="center">-C</td><td align="center"></td><td align="center">指定makefile文件目录</td></tr><tr><td align="center">-e</td><td align="center">–environment-overrides</td><td align="center">指定环境变量值,覆盖makefile文件中定义的变量值</td></tr><tr><td align="center">-i</td><td align="center">–ignore-errors</td><td align="center">在执行时忽略所有的错误</td></tr><tr><td align="center">-I <dir></td><td align="center">–include-dir&#x3D;<dir></td><td align="center">指定一个包含makefile文件的搜索目标</td></tr><tr><td align="center">-k</td><td align="center">–keep-going</td><td align="center">出错也不停止,目标失败,依赖于其上的就不会执行</td></tr><tr><td align="center">-o <file></td><td align="center">–old-file&#x3D;<file>;–assume-old&#x3D;<file></td><td align="center">不生成指定的<file>,即使这个目标的依赖文件比他新</td></tr><tr><td align="center">-l <load></td><td align="center">–load-average [&#x3D;<load>];–max-load[&#x3D;<load>]</td><td align="center">指定make运行命令的负载</td></tr><tr><td align="center">-p</td><td align="center">–print-database</td><td align="center">输出makefile文件中所有数据,包括所有的规则和变量</td></tr><tr><td align="center">-r</td><td align="center">–no-builtin-rules</td><td align="center">禁止使用任何隐式规则</td></tr><tr><td align="center">-R</td><td align="center">–no-builtin-variables</td><td align="center">禁止使用任作用于变量上的何隐式规则</td></tr><tr><td align="center">-s</td><td align="center">–silent;–quiet</td><td align="center">命令运行时不显示命令的输出</td></tr><tr><td align="center">-S</td><td align="center">–no-keep-going;–stop</td><td align="center">取消-k选项的作用</td></tr><tr><td align="center">-w</td><td align="center">–print-directory</td><td align="center">输出运行makefile文件之前之后的信息,跟踪嵌套make时很有用</td></tr><tr><td align="center">长</td><td align="center">–no-print-directory</td><td align="center">禁止-w选项</td></tr><tr><td align="center">长</td><td align="center">–warn-undefined-variables</td><td align="center">警告未定义的变量</td></tr></tbody></table><p>–debug <options>,options可以是以下:<br>a:也就是all,输出所有的调试信息<br>b:也就是basic,只输出简单的调试信息,即输出不需要重新编译的目标<br>v:也就是verbose,输出的信息包括哪一个makefile文件被解析,不需要重新编译的依赖文件(或是依赖目标)<br>i:也就是implicit,输出所有的隐含规则<br>j:也就是jobs,输出执行规则中命令的详细信息,如PID、返回码等<br>m:也就是makefile文件,输出make,读取makefile,更新makefile文件,并执行makefile文件的信息<br>16.隐含规则<br>　a.C程序隐含规则:<n>.o的目标的依赖目标会是:<n>.c,命令是<code>$(CC) -c $(CPPFLAGS)$(CFLAGS)</code><br>　b.C++程序隐含规则:<n>.o的目标的依赖目标是:<n>.cc或<n>.C,命令是<code>$(CXX) -c  $(CPPFLAGS)$(CXXFLAGS)</code><br>　c.模式规则示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">%.o: %.c<br> $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>17.函数库打包<br>函数库文件也就是对.o文件的打包文件<br>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">foolib(hack.o): hack.o<br>ar cr foolib hack.o  <span class="hljs-comment">#foolib是库名,hack.o是包含文件</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;gcc&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>18.选项<br>-l<library> 链接动态库<br>-L<dir> 动态库搜索目录<br>-D<expression> 宏定义命令中定义<br>-l <dir>头文件搜索目录<br>18.静态库编译和使用<br><code>gcc -c increase.c -o increase.o</code>把.c编译成.o<br><code>ar -r libincrease.a increase.o</code>归档成静态库.a<br><code>gcc main.c -L -static -o main</code>链接成可执行文件<br>19.动态库编译和使用<br><code>gcc -shared -fPIC -o libinc.so increase.c</code>-fPIC生成位置独立的代码,此类代码可以在不同进程间共享<br><code>gcc -lincrease -o main main.c</code>链接动态库</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GDB</title>
    <link href="/2020/01/16/GDB/"/>
    <url>/2020/01/16/GDB/</url>
    
    <content type="html"><![CDATA[<ul><li>编译文件时要加上-g选项<br>　几种启动gdb方式:<br>　<code>gdb &lt;program&gt;</code>,<code>gdb &lt;program&gt; core</code>(core是程序非法执行后core dump后产生的文件),<code>gdb &lt;program&gt; &lt;PID&gt;</code>(可以指定这个服务程序运行时的进程ID)</li><li><code>break</code><br>　a.加函数名,则会在函数内第一个非简单赋值语句处<br>　b.加行号,则会在该行号处停止</li><li><code>step(s)</code>:进入函数</li><li><code>next</code>:不进入函数</li><li><code>print /&lt;f&gt; &lt;expr&gt;</code>:<f>为格式<br>　a.加表达式:其中$1、$2、….表示第几个print的表达式的值,$$n则表示倒数n+1的命令<br>　b.变量&#x3D;表达式:赋值<br>　c.静态数组直接加数组名,动态数组格式为<code>*array@len</code>,@左边是array数组的首地址,右边则是数组的长度<br>　d.格式表</li></ul><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">x(a)</td><td align="center">十六进制格式</td></tr><tr><td align="center">d</td><td align="center">十进制格式</td></tr><tr><td align="center">u</td><td align="center">十进制无符号整型</td></tr><tr><td align="center">o</td><td align="center">八进制格式</td></tr><tr><td align="center">t</td><td align="center">二进制格式</td></tr><tr><td align="center">c</td><td align="center">字符格式</td></tr><tr><td align="center">f</td><td align="center">浮点数格式</td></tr><tr><td align="center">s</td><td align="center">字符串格式</td></tr><tr><td align="center">i</td><td align="center">指令格式</td></tr></tbody></table><ul><li><code>display /&lt;fmt&gt; &lt;expr&gt;</code>:在使用display命令时,每次中断,挂起都会显示表达式的值,<fmt>指定格式可选有s和i<br>a.<code>info display</code>:查看display设置的自动显示信息<br>b.<code>enable/disable display &lt;dnums&gt;</code>:失效或恢复某个自动显示<br>c.<code>undisplay &lt;dnums&gt; or delete display &lt;dnums&gt;</code>:删除某个自动显示,支持1-5这样的范围表示或者以空格分割不同号码</li><li><code>run</code></li><li><code>finish</code>:结束执行当前函数,显示其返回值</li><li><code>set</code>:设置变量新值</li><li><code>continue(cont)</code>:后面可以加数字,表示忽略几个断点</li><li><code>condition &lt;断点号&gt;　&lt;条件表达式&gt;</code>:条件为真时,执行断点</li><li><code>tbreak</code>:临时断点等价于<code>break xx;enable delete &lt;断点号&gt;</code></li><li><code>enable &lt;断点编号&gt;</code>:恢复暂时失效的断点</li><li><code>disable &lt;断点编号&gt;</code>:使断点失效</li><li><code>delete &lt;断点的编号或表达式&gt;</code>:清除断点或者表达式</li><li><code>clear &lt;要清除的断点所在的行号&gt;</code>:与delete不同的是给出行号,并且gdb会给出提示,delete则不会</li><li><code>watch &lt;条件表达式&gt;</code>:在表达式为真时中断程序的运行</li><li><code>info line &lt;行号&gt;or&lt;函数名&gt;or&lt;文件名:行号&gt;or&lt;文件名:函数名&gt;</code>:显示所指定源代码运行时的内存地址</li><li><code>disassemble &lt;函数名&gt;</code>:该函数的机器指令(汇编码)</li><li>查看栈信息<br>　a.<code>bt &lt;n&gt;或&lt;-n&gt;</code>:打印栈顶n层或栈底n层信息,不加n则表示打印当前所有函数栈的信息<br>　b.<code>frame(f) &lt;n&gt;</code>:frame 0表示栈顶,依次类推,不加n则表示输出当前层<br>　c.<code>up &lt;n&gt;或down &lt;n&gt;</code>:向栈底移动n层或向栈顶移动一层,栈底处于高地址区域,栈顶处于低地址区域<br>　d.<code>info frame(f)</code>:显示当前层更为详细的信息<br>　e.<code>info args</code>:显示当前函数的参数名及值<br>　f.<code>info locals</code>:显示当前函数所有局部变量及值<br>　g.<code>info catch</code>:显示当前函数中的异常处理信息</li><li>显示源代码–list<br>　a.<code>list &lt;linenum&gt;</code>:显示第linenum行的周围的源程序<br>　b.<code>list &lt;function&gt;</code>:显示function函数的源程序<br>　c.<code>list</code>:显示当前行后面的源程序<br>　d.<code>list -</code>:显示当前行前面的源程序<br>　e.<code>list &lt;first&gt;,&lt;last&gt;</code>:first行到last行之间的源程序<br>　f.<code>list ,&lt;last&gt;</code>:当前行到last行之间的源程序</li><li>搜索源代码<br>　a.<code>search &lt;regexp&gt;</code>:正向搜索<br>　b.<code>reverse-search &lt;regexp&gt;</code>:反向搜索</li><li>指定源文件路径–directory<br>　a.<code>directory(dir) &lt;dirname1:dirname2&gt;</code>:添加路径到当前路径下<br>　b.<code>direcory</code>:清除所有自定义源文件搜索路径<br>　c.<code>show directories</code>:显示已定义的搜索路径</li><li><code>examine(x)/&lt;n/f/u&gt; &lt;addr&gt;</code>　<br>　n、f、u是可选参数<br>　n:是一个正整数,表示一个显示内存的长度,也就是说从当前地址向后显示几个地址的内容<br>　f:表示显示的格式<br>　u:表示往后请求的字节数,默认是4bytes,b表示单字节,h表示双字节,w表示4字节,g表示8字节<br>　<code>x/3uh 0x54320</code>表示从内存地址0x54320读取内容,h表示以双字节为一个单位,3表示3个单位,u表示以十进制无符号整型显示</li><li>设置显示选项:<code>show\set &lt;某个选项&gt; (状态)</code><br>　a.<code>set print address &lt;on/off&gt;</code>:系统默认打开,显示函数参数地址<br>　b.<code>set print array &lt;on/off&gt;</code>:系统默认关闭,显示数组元素是否占一行<br>　c.<code>set print elements &lt;number of elements&gt;</code>:显示数组最大显示长度,默认为0表示不做限制<br>　d.<code>set print null-stop &lt;on/off&gt;</code>:默认为off,表示字符串时，遇到结束符是否停止显示<br>　e.<code>set print pretty &lt;on/off&gt;</code>:为on时,结构体每个元素占一行<br>　f.<code>set print sevenbit-strings &lt;on/off&gt;</code>:为on时,字符显示ascll码<br>　g.<code>set print union &lt;on/off&gt;</code>:为on时,显示结构体中联合体数据<br>　h.<code>set print statci-members &lt;on/off&gt;</code>:是否显示c++对象中静态数据成员<br>　i.<code>set print object &lt;on/off&gt;</code>:是否按虚方法显示c++中的对象<br>　j.<code>set print vtbl &lt;on/off&gt;</code>:按规整的格式显示虚函数表<br>　k.<code>info frame</code>:查看当前函数语言<br>　l.<code>info source</code>:查看当前文件语言<br>　m.<code>show language</code>:查看当前语言环境<br>　n.<code>set language &lt;language&gt;</code>:设置语言环境</li><li><code>set</code>:可以用set设置gdb的环境变量,如:<code>set $i = 0</code>,为了不与环境变量冲突,设置程序中的值时最好用<code>set var xx=xx</code></li><li>寄存器情况<br>　a.<code>info registers</code>:查看除浮点寄存器外的所有寄存器<br>　b.<code>info all-registers</code>:查看所有寄存器<br>　c.<code>info registers &lt;regname&gt;</code>:查看指定寄存器</li><li>跳转<br>　a.<code>jump &lt;linespec or address&gt;</code>:可以是文件的行号、也可以是file:line、也可以是＋num偏移量、也可以是内存地址</li><li>产生信号量<br>　<code>signal &lt;1-15&gt;</code>:在断点处设置1-15的任意信号</li><li>强制函数返回<br>　<code>return (&lt;expression&gt;)</code>:忽略当前函数未执行语句,直接返回表达式的值</li><li>强制调用函数<br>　<code>cal &lt;expr&gt;</code>:调用某函数</li><li><code>ptype</code>:显示某个量的类型</li><li><code>until</code>:执行某个循环体直到结束</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MariaDB</title>
    <link href="/2019/11/18/MariaDB/"/>
    <url>/2019/11/18/MariaDB/</url>
    
    <content type="html"><![CDATA[<ol><li>启动关闭用’systemctl’命令</li><li><code>mysql</code>命令行工具:<br>“-h、–help”后接服务器地址,若是本地127.0.0.1,可以省略<br>“-p、–port”后接端口,默认是3306<br>“-u、–user”连接MariaDB服务器时用的用户名<br>“-p、–password”连接MariaDB服务器的密码<br>“-D、–database”连接MariaDB服务器时要使用的数据库<br>“–auto-rehash”在mysql客户端程序内输入表或列名时，使用TAB键可以自动补全<br>“–batch”以批处理模式(非交互模式)运行mysql客户端程序<br>“–execute、-e”mysql客户端程序在连接MariaDB服务器的同时执行参数给出的语句<br>“–skip-column-names、-N”在mysql客户端中不显示查询结果中的列名<br>“–safe-updates、-U”以安全模式运行mysql客户端，安全模式下防止误操作</li><li>默认数据库文件存放位置为:&#x2F;var&#x2F;lib&#x2F;mysql<br>读取配置文件顺序:&#x2F;etc&#x2F;my.cnf、&#x2F;etc&#x2F;mysql&#x2F;my.cnf、~&#x2F;.my.cnf</li><li>创建、删除数据库<br>CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET utf8mb4(指定字符集及排序方式)<br>DROP DATABASE 数据库名称</li><li>创建数据表<br>　<code>USE test</code>进入指定的数据库test<br>　<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] tab_test (<br>tid <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>tname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>tmemo <span class="hljs-type">TEXT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY KEY</span> (tid),<br><span class="hljs-keyword">INDEX</span> ix_tname_tid (tname,tid)<br>) ENGINE=InnoDB;<br></code></pre></td></tr></table></figure><br>约束分为表约束和列约束，上述NOT NULL为列约束跟在每个列定义后面,而PRIMARY KEY为表约束可以指定多个列。<br>完整性约束的基本语法格式：<br>[CONSTRAINT&lt;约束名&gt;]&lt;约束类型&gt;,中括号中内容可以省略,约束类型有:NULL&#x2F;NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK。 其中外键约束格式为:FOREIGN KEY REFERENCES &lt;主表名&gt;(&lt;列名&gt;),CHECK:CHECK(&lt;约束条件&gt;),约束条件举例:CHECK (Score&gt;&#x3D;0 AND Score&lt;&#x3D;100)<br>查看数据表<br><code>SHOW CREATE TABLE test</code><br>修改数据表格式<br>(待建设,各种情形不同处理,有点复杂)<br>删除数据表<br><code>DROP TABLE &lt;表名&gt;</code></li><li>a.插入元组数据<br><code>INSERT INTO test (fd1,fd2) VALUES (1,&#39;Matt&#39;) ON DUPLICATE KEY UPDATE fd2=&#39;Matt&#39;;</code>ON DUPLICATE KEY UPDATE选项可以确保若记录已存在则执行UPDATE,否则执行INSERT;<br>b.检索元祖数据<br><code>SELECT * FROM tab_test;</code><br><code>SELECT * FROM tab_test WHERE fd1=1;</code>条件查询可以有NOT、AND、OR(优先级从高到低);BETWEEN…AND…;IN(&lt;值1&gt;、&lt;值2&gt;);LIKE&lt;字符串常量&gt;(‘张％’代表姓张的人,’_力%’代表第二个字是力,%匹配0或多个字符);<br>统计汇总查询常用函数:<br>　AVG 按列计算平均值<br>　SUM 按列计算值的总和<br>　MAX 求一列中的最大值<br>　MIN 求一列中的最小值<br>　COUNT 按列值计算个数<br>例子:&#96;&#96;&#96;<br>SELECT MAX(Score) AS MaxScore,<br>   MIN(Score) AS MinScore,<br>   MAX(Score)-MIN(Score) AS Diff<br>   FROM SC<br>   WHERE(CNo&#x3D;’C1’)<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">`<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> Dept) <span class="hljs-keyword">AS</span> DeptNum <span class="hljs-keyword">FROM</span> S<span class="hljs-symbol">`DISTINCT关键字消除重复</span><br><span class="hljs-symbol">`</span><span class="hljs-keyword">SELECT</span> fd2 <span class="hljs-keyword">FROM</span> tab_test;`<br></code></pre></td></tr></table></figure>SELECT SNo,COUNT(<em>) AS SC_Num<br>FROM SC<br>GROUP BY SNo<br>HAVING(COUNT(</em>)&gt;&#x3D;2)<br>这GROUP BY后面的属性表示若其相同，将在同一行呈现(相当于DISTINCT),但count将计算当前组的个数，而HAVING则是对GROUP BY进一步筛选,不能用where。<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">```<br><span class="hljs-keyword">SELECT</span> SNo,CNo,Score<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> CNo <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;C2&#x27;</span>,<span class="hljs-string">&#x27;C3&#x27;</span>,<span class="hljs-string">&#x27;C4&#x27;</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SNo,Score <span class="hljs-keyword">DESC</span><br>学号升序，分数降序排列<br></code></pre></td></tr></table></figure><code>SELECT * FROM tab_test\G</code>注意这没有分号,按列输出记录<br>多表内连接查询<br>方法一:<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> T.TNo,TN,CNo<br><span class="hljs-keyword">FROM</span> T,TC<br><span class="hljs-keyword">WHERE</span> (T.TNo=TC.TNo) <span class="hljs-keyword">AND</span>(TN=<span class="hljs-string">&#x27;刘伟&#x27;</span>)<br><span class="hljs-comment">//这里TN=‘刘伟为查询条件’T.TNo=TC.TNo为连接条件，TNo为连接字段</span><br></code></pre></td></tr></table></figure>方法二:<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> T.TNo,TN,CNo <br><span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> TC<br><span class="hljs-keyword">ON</span> T.TNo=TC.TNo <span class="hljs-keyword">WHERE</span>(TN=<span class="hljs-string">&#x27;刘伟&#x27;</span>)<br></code></pre></td></tr></table></figure>多表外连接查询<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> S.SNo,SN,CN,Score<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC<br><span class="hljs-keyword">ON</span> S.SNo=SC.SNo<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> C<br><span class="hljs-keyword">ON</span> C.CNo=SC.CNo<br>//外链接不符合条件的将置为<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure>多表交叉查询<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> S CROSS <span class="hljs-keyword">JOIN</span> C<br><span class="hljs-comment">//行数两个表行的乘积，列数为两个表的列数和</span><br></code></pre></td></tr></table></figure>自连接查询(例子为查询所有比”刘伟”工资高的教师姓名、工资和刘伟的工资)<br>方法一:<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">X</span>.TN,<span class="hljs-keyword">X</span>.Sal AS Sal_a,<span class="hljs-keyword">Y</span>.Sal AS Sal_b<br>FROM T AS <span class="hljs-keyword">X</span>,T AS <span class="hljs-keyword">Y</span><br>WHERE <span class="hljs-keyword">X</span>.Sal&gt;<span class="hljs-keyword">Y</span>.Sal <span class="hljs-keyword">AND</span> <span class="hljs-keyword">Y</span>.TN=<span class="hljs-string">&#x27;刘伟&#x27;</span><br></code></pre></td></tr></table></figure>方法二:<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">X</span>.TN,<span class="hljs-keyword">X</span>.Sal,<span class="hljs-keyword">Y</span>.Sal<br>FROM T AS <span class="hljs-keyword">X</span> INNER JOIN T AS <span class="hljs-keyword">Y</span><br><span class="hljs-literal">ON</span> <span class="hljs-keyword">X</span>.Sal&gt;<span class="hljs-keyword">Y</span>.Sal<br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">Y</span>.TN=<span class="hljs-string">&#x27;刘伟&#x27;</span><br></code></pre></td></tr></table></figure>普通子查询<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> TNo,TN<br><span class="hljs-keyword">FROM</span> T<br><span class="hljs-keyword">WHERE</span> Prof= (<span class="hljs-keyword">SELECT</span> Prof <br><span class="hljs-keyword">FROM</span> T<br><span class="hljs-keyword">WHERE</span> TN=<span class="hljs-string">&#x27;刘伟&#x27;</span>)<br><span class="hljs-comment">//查询与刘伟老师相同职称的老师姓名与工号</span><br><span class="hljs-keyword">SELECT</span> TN<br><span class="hljs-keyword">FROM</span> T<br><span class="hljs-keyword">WHERE</span> (TNo = ANY (<span class="hljs-keyword">SELECT</span> TNo<br><span class="hljs-keyword">FROM</span> TC<br><span class="hljs-keyword">WHERE</span> CNo = <span class="hljs-string">&#x27;C5&#x27;</span>))<br><span class="hljs-comment">//查询讲授课程号为C5的教师姓名</span><br></code></pre></td></tr></table></figure>相关子查询(它先对外查询中每一条记录进行比对，这与普通子查询不同，普通子查询先执行子查询)<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> TN<br><span class="hljs-keyword">FROM</span> T<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> TC<br><span class="hljs-keyword">WHERE</span> TNo=T.TNo <span class="hljs-keyword">AND</span> CNo=<span class="hljs-string">&#x27;C5&#x27;</span>)<br>//查询讲授课程为C5的教师姓名<br></code></pre></td></tr></table></figure>合并查询(就是把结果合并到一起)<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SNo <span class="hljs-keyword">AS</span> 学号,<span class="hljs-built_in">SUM</span>(Score) <span class="hljs-keyword">AS</span> 总分<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> (SNo = <span class="hljs-string">&#x27;S1&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SNo<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> SNo <span class="hljs-keyword">AS</span> 学号,<span class="hljs-built_in">SUM</span>(Score) <span class="hljs-keyword">AS</span> 总分<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> (SNo = <span class="hljs-string">&#x27;S5&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SNo<br></code></pre></td></tr></table></figure>存储查询<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SNo <span class="hljs-keyword">AS</span> 学号,<span class="hljs-built_in">SUM</span>(Score) <span class="hljs-keyword">AS</span> 总分<br><span class="hljs-keyword">INTO</span> Cal_Table<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SNo<br>//如果在新表名前面加个#则是临时表，关闭则消失<br></code></pre></td></tr></table></figure>c.修改元祖数据<br><code>UPDATE tab_test SET fd2=&#39;Brandon&#39; WHERE fd1=1</code>如果没有WHERE则所有元祖的fd2都将改变，请一定小心<br><code>REPLACE tab_test SET fd1=1,fd2=&#39;Matt&#39;;</code>若记录存在执行UPDATE,否则执行INSERT,最好用INSERT加ON DUPLICATE KEY UPDATE命令,资源消耗更小。<br>d.删除元祖数据<br><code>DELETE FROM tab_test WHERE fd1=1;</code>同理没有WHERE将会删除所有元组<br>e.视图(是一个虚表,基于基本表，对其修改会影响基本表，但本身不占内存)<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> Sub_T<br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> TNo,TN,Prof<br><span class="hljs-keyword">FROM</span> T<br><span class="hljs-keyword">WHERE</span> Dept = <span class="hljs-string">&#x27;计算机&#x27;</span><br>//创建一个计算机系老师情况的视图Sub_T<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> S_SC_C(SN,CN,Score)<br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> SN,CN,Score<br> <span class="hljs-keyword">FROM</span> S,C,SC<br> <span class="hljs-keyword">WHERE</span> S.SNo=SC.SNo <span class="hljs-keyword">AND</span> SC.CNo=C.CNo<br>//修改,就是查询内容的覆盖<br></code></pre></td></tr></table></figure></li></ol><p>###对表的操作适用于视图，可以通过视图简化操作<br>6.索引(待建)<br>7.规则约束<br>　a.创建规则<br><code>CREATE RULE age_rule AS@age &gt;=18and @age &lt;= 50</code><br>b.将规则绑定到数据库的对象上，或者将规则从数据库的对象上松绑<br>用sp_bindrule绑定规则<br><code>EXEC sp_bindrule &#39;age_rule&#39;,&#39;S.Age&#39;</code>对已输入的数据不起作用<br><code>EXEC sp_unbindrule &#39;S.Age&#39;</code>解绑<br>c.删除规则<br><code>DROP RULE age_rule</code>删除前必须先解绑<br>8.默认<br>　a.创建默认<br><code>CREATE DEFAULT birthday_defa AS &#39;1978-1-1&#39;</code><br>　b.查看默认<br><code>EXEC sp_helptext birthday_defa</code><br>　c.默认的绑定与解绑<br><code>EXEC sp_bindefault &#39;birthday_defa&#39; &#39;S.[Birthday]&#39;</code><br><code>EXEC sp_unbinefault &#39;S.[Birthday]&#39;</code><br>　d.删除默认<br><code>DROP DEFAULT birthday_defa</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++标准库</title>
    <link href="/2019/08/10/C-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/2019/08/10/C-%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>1.顺序容器</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">c.resize(n)</td><td align="center">调整c的大小为n个元素。要么多出的元素被丢弃,要么新添加默认值的元素</td></tr><tr><td align="center">c.resize(n,t)</td><td align="center">调整c的大小为n个元素。任何新添加的元素初始为t</td></tr><tr><td align="center">c.shrink_to_fit()</td><td align="center">只适用于vector,string和deque。将capacity()减少与size()相同大小</td></tr><tr><td align="center">c.capacity()</td><td align="center">只适用于vector和string,返回c可以保存多少元素</td></tr><tr><td align="center">c.reserve(n)</td><td align="center">只适用于vector和string,分配至少容纳n个元素的内存空间</td></tr><tr><td align="center">c.assign(i1)</td><td align="center">将c中的元素全部替换为i1元素,i1可以和c类型不同,但元素必须相同,甚至可以是map与set类型</td></tr><tr><td align="center">c.assign(n,t)</td><td align="center">将c中的元素全部换为n个t</td></tr><tr><td align="center">2.lambda</td><td align="center"></td></tr><tr><td align="center">格式:<code>[capture list] (parameter list) -&gt; return type &#123;function body&#125;</code>,capture list可以为空，里面一般是包含此lambda的函数的(非static)局部变量,该函数外的变量可以在函数体内直接用,return type可以省略。</td><td align="center"></td></tr><tr><td align="center">3.优先队列</td><td align="center"></td></tr><tr><td align="center">格式:<code>priority_queue&lt;Type,Container,Functional&gt;</code></td><td align="center"></td></tr><tr><td align="center">例子:<code>priority_queue&lt;int,vector&lt;int&gt;,myCompare&gt;</code>,myCompare可以替换为less<int>降序,greater<int>升序</td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构笔记1</title>
    <link href="/2019/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B01/"/>
    <url>/2019/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p>1.<strong>顺序存储结构</strong>:<br>　a.所有元素占用一整块内存空间<br>　b.逻辑上相邻的元素，物理上也相邻<br>　<strong>链式存储结构</strong>:<br>　a.一个逻辑元素用一个节点存储，每个节点单独分配，所有节点的地址不一定连续<br>　b.用指针来表示逻辑关系<br>2.<strong>排序算法的对比</strong>:<br><img src="/images/sort_algori.png"><br>3.<strong>二叉树相关定理</strong><br>  a.非空满二叉树的叶节点数等于其分支节点数加１<br>  b.一棵非空二叉树空子树的数目等于节点数加１</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;fucking algorithm&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>动态规划中四键键盘第一种思路递归<br>dp按正序看，N每次减小一，就是一个重新状态,即每次进入一个递归，就相当于消耗一次操作(正向的操作)。记住递归函数整体是返回当前可以存在N步，已有a_num,以及存储器的状态可以得到最大的a。对它有个整体把握。<br>而第二种思路是迭代,第一种看半天就是把它以迭代思想来看的，蠢死了</p><p>KMP字符串匹配<br>pattern的辅助数组即是对应的下标的子串的前缀与后缀交集的最长串的长度,详情见知乎，不过不要偏移，以免看不懂，对于下标为0的数组值就是0，不用-1，不偏移。记住数组的含义，遇到0，if判断以下,特殊处理，你曾经自己写出来了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell例子</title>
    <link href="/2019/07/20/shell%E4%BE%8B%E5%AD%90/"/>
    <url>/2019/07/20/shell%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<ul><li>追加信息于文件<br><code>cat - &gt;&gt; filename</code></li><li>赋值日期命令<br><code>eval $(date &#39;+weekday=&quot;%a&quot; month=&quot;%b&quot; day=&quot;%e&quot; year=&quot;%G&quot;&#39;)</code></li><li>判断是否符合正则表达式<br><code>expr string : pattern</code></li></ul><ul><li>追加内容到文件<br>echo的-n选项不会在添加内容前加换行符</li><li>读取文件首行赋给变量<br><code>read -r line &lt; file</code>,-r选项保证读入的内容是原始内容，反斜杠不会发生转义，read命令会删除开头和结尾的<code>IFS</code>中的所有字符，如果想保留，把<code>IFS</code>置为空:<code>IFS= read -r line &lt; file</code></li><li>依次读入文件每一行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> IFS= <span class="hljs-built_in">read</span> -r line; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># do something with $line</span><br><span class="hljs-keyword">done</span> &lt; file<br></code></pre></td></tr></table></figure></li><li>随机读取一行内容<br><code>read -r random_line &lt; &lt;(shuf file)</code></li><li>读取文件首行前三个字段<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> -r field1 field2 field3 _; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># do something with $field1, $field2, and $field3</span><br><span class="hljs-keyword">done</span> &lt; file<br></code></pre></td></tr></table></figure><code>_</code>用来接受三个字段后的所有内容，如果没有他，field3会接受所有</li><li>从文件路径中获取文件名<br><code>filename=$&#123;path##*/&#125;</code>,这其实就是参数展开</li><li>从文件路径中获取目录名<br><code>dirname=$&#123;path%/*&#125;</code></li><li>相同路径下的快速拷贝&#x2F;移动写法<br><code>cp /path/to/file&#123;,_copy&#125;</code></li><li>生成a到z字母表<ul><li><code>echo &#123;a..z&#125;</code></li><li><code>printf &quot;%c&quot; &#123;a..z&#125;</code>,字母间不含空格</li><li><code>printf &quot;%c&quot; &#123;a..z&#125; $&#39;\n&#39;</code>结尾加空行</li><li><code>printf &quot;%c\n&quot; &#123;a..z&#125;</code>每个字符后加个空行</li></ul></li><li>生成00-09数字<ul><li><code>printf &quot;%02d&quot; &#123;0..9&#125;</code></li><li><code>echo &#123;00..09&#125;</code>bash4以上支持</li></ul></li><li>生成若干单词<br><code>echo &#123;w,t,&#125;h&#123;e&#123;n&#123;,ce&#123;,forth&#125;&#125;,re&#123;,in,fore,with&#123;,al&#125;&#125;&#125;,ither,at&#125;</code></li><li>重复输出10次字符串<br><code>echo foo&#123;,,,,,,,,,&#125;</code></li><li>分割字符串<ul><li><code>IFS=- read -r x y z &lt;&lt;&lt; &quot;$str&quot;</code></li><li><code>IFS=- read -ra parts &lt;&lt;&lt; &quot;foo-bar-baz&quot;</code>保存到数组</li></ul></li><li>逐个字符处理字符串<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> IFS= <span class="hljs-built_in">read</span> -rn1 c; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># do something with $c</span><br><span class="hljs-keyword">done</span> &lt;&lt;&lt; <span class="hljs-string">&quot;<span class="hljs-variable">$str</span>&quot;</span><br></code></pre></td></tr></table></figure>-n1表示一次读一个字符</li><li>获取一个字符的ascll<br><code>printf &#39;%02x&#39; &quot;+&quot;</code></li><li>获取最后一个参数<br><code>echo $&#123;@: -1&#125;</code>或<code>echo $&#123;!#&#125;</code></li><li>遍历参数<br><code>for arg in &quot;$@&quot;</code>等价于<code>for arg</code></li><li>路径中含空格：<ul><li>非递归：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> *.mp3;<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li>递归：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">OLDIFS=<span class="hljs-string">&quot;<span class="hljs-variable">$IFS</span>&quot;</span><br>filelist=$(find -name <span class="hljs-string">&#x27;*.mp3&#x27;</span> -print0|xargs --null <span class="hljs-built_in">ls</span>)&amp;&amp;IFS=$<span class="hljs-string">&#x27;\n&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$filelist</span>;<br><span class="hljs-keyword">do</span><br>IFS=<span class="hljs-string">&quot;<span class="hljs-variable">$OLDIFS</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><strong>注意，IFS必须单引号，filelist的变量是必须的,不能写在for后面,要即时还原IFS</strong></li></ul></li></ul><h2 id="函数特殊用法"><a href="#函数特殊用法" class="headerlink" title="函数特殊用法"></a>函数特殊用法</h2><ul><li>测试文件是否存在函数<br><code>function fileExists() [[ -f $1 ]]</code></li><li>测试是否及偶数<br><code>function isEven() (( $1 % 2 == 0 ))</code></li><li>使用小括号<br>会fork个子进程，对环境的修改不会印象外面，不需要恢复现场<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> name() ( <br>... <br>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="文件描述符与重定向"><a href="#文件描述符与重定向" class="headerlink" title="文件描述符与重定向"></a>文件描述符与重定向</h2><p>bash启动时，文件描述符表如下所示：<br><img src="/images/file_descriptor.png"><br>当bash执行命令时，他会fork一个子进程，它会继承父进程的描述符表</p><h3 id="重定向命令到stdout"><a href="#重定向命令到stdout" class="headerlink" title="重定向命令到stdout"></a>重定向命令到stdout</h3><ul><li><code>command &gt;file</code>到底发生了啥？<br><code>&gt;</code>是输出重定向操作符，bash首先打开文件准备写入，如果文件打开成功，command的stdout指向打开的文件，如果失败，不执行命令，其实等价于<code>command 1 &gt;file</code></li></ul><h3 id="重定向命令到stderr"><a href="#重定向命令到stderr" class="headerlink" title="重定向命令到stderr"></a>重定向命令到stderr</h3><p><code>command 2&gt;file</code></p><h3 id="重定向命令stdout和stderr到同一个文件"><a href="#重定向命令stdout和stderr到同一个文件" class="headerlink" title="重定向命令stdout和stderr到同一个文件"></a>重定向命令stdout和stderr到同一个文件</h3><p><code>command &amp;&gt;file</code>等价于<code>command &gt;file 2&gt;&amp;1</code><br>当只有一个重定向时，重定向位置可以任意放，甚至可以在命令的前面，但注意遇到多个重定向操作时,顺序很重要，会从左到右依次处理:<br>首先<code>&gt;file</code>会发生如下：<br><img src="/images/file_descriptor1.png"><br>然后<code>2&gt;&amp;1</code>会发生如下：<br><img src="/images/file_descriptor2.png"><br>如果顺序错了，为节省流量,你自己想会发生啥吧</p><h3 id="重定向stdin"><a href="#重定向stdin" class="headerlink" title="重定向stdin"></a>重定向stdin</h3><p><code>command &lt;file</code>Bash 在执行命令之前，打开文件file准备读入。如果打开文件出错，Bash 会直接返错，不会继续执行命令。相反如果打开成功，Bash 会使用打开的文件的文件描述符作为命令的标准输入</p><h3 id="重定向一堆字符到stdin"><a href="#重定向一堆字符到stdin" class="headerlink" title="重定向一堆字符到stdin"></a>重定向一堆字符到stdin</h3><p>这是最常见的here document语法<code>&lt;&lt;MARKER</code>,当bash遇到该操作符时，会从标输入读取每一行，直到遇到<code>MARKER</code>,例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed <span class="hljs-string">&#x27;s|http://||&#x27;</span> &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">http://url1.com</span><br><span class="hljs-string">http://url2.com</span><br><span class="hljs-string">http://url3.com</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line2; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">let</span> b++<br>    <span class="hljs-built_in">echo</span> ??<span class="hljs-variable">$line2</span>??<br><span class="hljs-keyword">done</span> &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">`grep -v 1 /tmp/test.txt`</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>如果MARKER用引号括起来，那么变量是不会展开的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>&lt;&lt;<span class="hljs-string">&quot;EOF&quot;</span><br>hello, <span class="hljs-variable">$USER</span> <span class="hljs-comment">#USER不会展开</span><br>EOF<br></code></pre></td></tr></table></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>见另一篇</p><h3 id="通过bash访问web站点"><a href="#通过bash访问web站点" class="headerlink" title="通过bash访问web站点"></a>通过bash访问web站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> 3&lt;&gt;/dev/tcp/www.google.com/80<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;GET / HTTP/1.1\n\n&quot;</span> &gt;&amp;3<br><span class="hljs-built_in">cat</span> &lt;&amp;3<br></code></pre></td></tr></table></figure><p>Bash 将&#x2F;dev&#x2F;tcp&#x2F;host&#x2F;port当作一种特殊的文件(套接字文件？)，它并不需要实际存在于系统中，这种类型的特殊文件是给 Bash 建立 tcp 连接用的。</p><h3 id="重定向进程的stdout和stderr到另外一个进程的输入"><a href="#重定向进程的stdout和stderr到另外一个进程的输入" class="headerlink" title="重定向进程的stdout和stderr到另外一个进程的输入"></a>重定向进程的stdout和stderr到另外一个进程的输入</h3><p><code>command1 |&amp; command2</code>等价于<code>command1 2&gt;&amp;1|command2</code></p><h3 id="交换标准输出与标准错误"><a href="#交换标准输出与标准错误" class="headerlink" title="交换标准输出与标准错误"></a>交换标准输出与标准错误</h3><p><code>command 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3</code></p><h3 id="重定向标准输出与错误给不同进程"><a href="#重定向标准输出与错误给不同进程" class="headerlink" title="重定向标准输出与错误给不同进程"></a>重定向标准输出与错误给不同进程</h3><p>主要就是使用进程替换<br><code>command &gt; &gt;(stdout_cmd) 2&gt; &gt;(stderr_cmd)</code></p><h3 id="获取管道流中的所有命令执行退出码"><a href="#获取管道流中的所有命令执行退出码" class="headerlink" title="获取管道流中的所有命令执行退出码"></a>获取管道流中的所有命令执行退出码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;pants are cool&#x27;</span> | grep <span class="hljs-string">&#x27;moo&#x27;</span> | sed <span class="hljs-string">&#x27;s/o/x/&#x27;</span> | awk <span class="hljs-string">&#x27;&#123; print $1 &#125;&#x27;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PIPESTATUS[@]&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shell相关</title>
    <link href="/2019/07/20/shell%E7%9B%B8%E5%85%B3/"/>
    <url>/2019/07/20/shell%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<ol><li>shell在处理命令前先预处理完成一些替换，其优先级较高:<br>a.shell替换:文件通配符<br>b.变量替换<br>c.命令替换,如下示例:<br><code>now=`date`</code><br>以命令date的标准输出为值,也可以采用如下表示:<br><code>now=$(date)</code></li><li>shell元字符汇总</li></ol><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">空格、制表符</td><td align="center">命令行参数的分隔符</td></tr><tr><td align="center">回车</td><td align="center">执行键入的命令</td></tr><tr><td align="center">&lt; &gt; &brvbar;</td><td align="center">重定向与管道</td></tr><tr><td align="center">;</td><td align="center">多个命令分隔符</td></tr><tr><td align="center">&amp;</td><td align="center">后台运行</td></tr><tr><td align="center">$</td><td align="center">引用shell的变量</td></tr><tr><td align="center">`</td><td align="center">命令替换,<code>\\</code>代表反斜线自身,&#96;`&#96;代表反撇号自身</td></tr><tr><td align="center">* [] ?</td><td align="center">文件通配符,不匹配*和&#x2F;</td></tr><tr><td align="center">()</td><td align="center">用于定义shell函数或子shell中执行命令</td></tr><tr><td align="center">\</td><td align="center">转义字符取消元字符特殊含义，若不用于元字符跟不加一样</td></tr><tr><td align="center">“ “</td><td align="center">其中的内容除$和`外取消元字符的特殊含义</td></tr><tr><td align="center">‘ ‘</td><td align="center">取消所有元字符特殊含义</td></tr></tbody></table><ol start="3"><li><code>bash -x script.sh</code>调试脚本</li><li><code>-x</code> 可执行返回真<br><code>-f</code> 文件存在返回真<br><code>-z</code> 变量为空返回真<br><code>-w</code> 测试文件可否写<br><code>-r</code> 测试文件可否读<br><code>-d</code> 目录文件是否为真<br><code>-s</code> 文件大小是否大于0<br><code>$(#var)</code>变量字符数<br><code>$((数字表达式))</code>必须双括号<br>5.特殊变量<table><thead><tr><th align="center">变量</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>RANDOM</code></td><td align="center">随机值</td></tr><tr><td align="center"><code>IFS</code></td><td align="center">分隔符默认为空格</td></tr><tr><td align="center"><code>OPTARG</code></td><td align="center">当前参数后面跟的字符窜</td></tr><tr><td align="center"><code>OPTIND</code></td><td align="center">参数个数</td></tr><tr><td align="center"><code>$$</code></td><td align="center">该脚本进程ID</td></tr><tr><td align="center"><code>$?</code></td><td align="center">上个调用返回值</td></tr><tr><td align="center"><code>$@</code></td><td align="center">除$0的所有参数列表</td></tr><tr><td align="center"><code>$*</code></td><td align="center">除$0的所有参数列表</td></tr><tr><td align="center"><code>$#</code></td><td align="center">参数个数</td></tr><tr><td align="center">6.追加信息于文件</td><td align="center"></td></tr><tr><td align="center"><code>cat - &gt;&gt; filename</code></td><td align="center"></td></tr><tr><td align="center">7.操作符</td><td align="center"></td></tr><tr><td align="center">8.读文件</td><td align="center"></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span><br><span class="hljs-keyword">done</span> &lt; filename<br></code></pre></td></tr></table></figure>9.eval命令<br><code>eval $(date &#39;+weekday=&quot;%a&quot; month=&quot;%b&quot; day=&quot;%e&quot; year=&quot;%G&quot;&#39;)</code>分别赋予几个变量值<br>10.trap命令<br><code>trap &quot;命令&quot; &quot;信号&quot;</code>当脚本遇到信号前执行的命令,信号有:SIGEXIT、SIGQUIT(CTRL-C)<br>11.<code>&#123;&#125;</code>花括号中的命令在当前shell执行命令<br>12.<code>expr string : pattern</code>判断是否符合正则表达式</li><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> &lt;name&gt; <span class="hljs-keyword">in</span> &lt;list&gt;<br><span class="hljs-keyword">do</span> <br>...<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>如果省略list,则list为命令行参数<br>还有一种<code>for i in $(seq start step end)</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类相关知识</title>
    <link href="/2019/07/20/%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2019/07/20/%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ol><li>成员默认为private</li><li>函数重载或默认函数，只能在内部定义</li><li>类不可以定义自身类数据成员，但可以定义自身类指针或应用</li><li>构造初始化列表只在构造函数的定义中而不是函数原型声明中<br>类中的类成员必须提供初始化列表，否则调用默认构造函数</li><li>友元函数在类内先声明，类外定义(不加friend标识)</li><li>友元函数可以是另一个类的成员函数</li><li>友元类中所有成员函数都是该类的友元函数</li><li>友元关系不能继承</li><li>派生类无法继承析构函数和构造函数，</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符相关</title>
    <link href="/2019/07/19/%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%85%B3/"/>
    <url>/2019/07/19/%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<ol><li>cctype中的函数<br>isalnum() 参数为字母或数字,返回true<br>isalpha() 参数字母为字母,返回true<br>iscntrl() 参数为控制字符,返回true<br>isdigit() 参数为数字(0～9),返回true<br>isgraph() 参数为除空格外的打印字符,返回true<br>islower() 参数为小写字母,返回true<br>isprint() 参数为打印字符(包括空格),返回true<br>ispunct() 参数为标点符号,返回true<br>isspace() 参数为标准空白字符,如空格,进纸,换行符,回车,制表符,返回true<br>isupper() 参数为大写字母,返回true<br>isxdigit() 参数为十六进制数字,即0～9,a～f或A～F,返回true<br>tolower() 若是大写,返回其小写,否则返回该参数<br>toupper() 若是小写,返回其大写,否则返回该参数</li><li>C字符串的函数(cstring)<br>strcpy(str1,str2)  复制str2到str1<br>strncpy(str1,str2,n) 把str2的前n字符拷贝到str1<br>strcat(str1,str2)  str2连接到str1后面<br>strncat(str1,str2,n) 把str2的前n字符连接到str1<br>strcmp(str1,str2) 比较两个字符串<br>strlen(str) 计算长度不包括结束标识符</li><li>C字符类型与其他类型的转换<br>atof(str) 将字符串转换为float类型<br>atoi(str) 将字符串转换为int类型<br>itoa(num,str,10) 将int类型转换为字符串,10代表十进制<br>ltoa(num,str,10) 将long类型转换为字符串,10代表十进制<br>ultoa(num,str,10) 将unsigned long类型转换为字符串,10代表十进制<br>sprintf() 函数比上述三个更灵活,具体百度<br>以下三个都是浮点型转换为字符串<br>fcvt()<br>ecvt()<br>gcvt()<br>cppstr.c_str() string类型转换为C类型<br>C字符串可以直接赋值给string类型</li><li>string类型的操作(详见C++Primer P323)<br>str1.substr(pos,n) 返回一个string,包含s中从pos开始的n个字符的拷贝.pos的默认值为0,n的默认值为str1.size()-pos,即所有字符<br>str1.insert(pos,args) 在pos之前插入args指定的字符,若pos不是下标而是迭代器,则返回指向第一个插入字符的迭代器<br>str1.erase(pos,len) 删除从pos开始的len个字符.len默认至末尾<br>str1.assign(args) 将str1字符替换为指定的args的字符<br>str1.append(args) 将args追加到str1,<br>str1.replace(range,args) 删除s中范围range内的字符,替换为args指定的字符.range或者是个下标和长度,或一堆迭代器<br>注:<br>以上args可以是下面格式:<br>a.str2  字符串str2<br>b.str2,pos,len 字符串str2中从pos开始的len个字<br>c.cp cp指向的以空字符结尾的字符数组<br>d.cp,len 从cp指向的字符数组的前len个字符<br>e.n,c n个字符c<br>f.b,e 迭代器的范围,不能是本身<br>g.初始化列表 花括号包围的,以逗号分隔的字符列表<br>而replace和insert的args形式取决于range和pos,以标号代替args.</li></ol><table><thead><tr><th align="center">args</th><th align="center">replace(pos,len,args)</th><th align="center">replace(b,e,args)</th><th align="center">insert(pos,args)</th><th align="center">insert(iter,args)</th></tr></thead><tbody><tr><td align="center">a.</td><td align="center">y</td><td align="center">y</td><td align="center">y</td><td align="center">n</td></tr><tr><td align="center">b.</td><td align="center">y</td><td align="center">n</td><td align="center">y</td><td align="center">n</td></tr><tr><td align="center">c.</td><td align="center">y</td><td align="center">y</td><td align="center">y</td><td align="center">n</td></tr><tr><td align="center">d.</td><td align="center">y</td><td align="center">y</td><td align="center">n</td><td align="center">n</td></tr><tr><td align="center">e.</td><td align="center">y</td><td align="center">y</td><td align="center">y</td><td align="center">y</td></tr><tr><td align="center">f.</td><td align="center">n</td><td align="center">y</td><td align="center">n</td><td align="center">y</td></tr><tr><td align="center">g.</td><td align="center">n</td><td align="center">y</td><td align="center">n</td><td align="center">y</td></tr></tbody></table><p>　　str1.find(args) 查找str1中args第一次出现的位置<br>　　str1.rfind(args) 查找str1中args最后一次出现的位置<br>　　str1.find_first_of(args) 在str1查找args中任意字符第一次出现的位置<br>　　str1.find_last_of(args) 在str1查找args中任意字符最后一次出现的位置<br>　　str1.find_first_not_of(args) 在str1查找第一个不在args中的字符<br>　　str1.find_last_not_of(args) 在str1查找最后一个不在args中的字符<br>　　注:<br>　　args可以是以下的格式:<br>　　c,pos  从str1中位置pos开始查找字符c.pos默认为0<br>　　str2,pos 从str1中位置pos开始查找字符串str2,pos默认为0<br>　　cp,pos 从str1中位置pos开始查找指针cp指向的C字符串.pos默认为0<br>　　cp,pos,n 从str1中查找指针cp指向的前n个字符.无默认值<br>　　str1.compare(args)<br>　　注:<br>　　args可以是以下格式:<br>　　str2 比较str1和str2<br>　　pos1,n1,str2 将str1中从pos1开始的n1个字符与str2字符进行比较<br>　　pos1,n1,str2,pos2,n2 将str1中从pos1开始的n1个字符与str2中从pos2开始的n2个字符串进行比较<br>　　cp 与C字符串比较<br>　　pos1,n1,cp ….<br>　　pos1,n1,cp,n2 ………………….C字符串cp指针指向的位置后的n2个字符串进行比较<br>5.<br>string类型与数字的转换<br>to_string(num) 数字转换成string<br>stoi(s,p,b)<br>stol(s,p,b)<br>stoul(s,p,b)<br>stoll(s,p,b)<br>stoull(s,p,b)<br>注:返回类型为int,long,unsigned long,long long,unsigned long long,<br>   b一般表示十进制<br>   p为size_t指针,用来保存s字符中第一个非数值字符的下标,默认为0,即不保存下标<br>stof(s,p)<br>stod(s,p)<br>stold(s,p)<br>注:返回类型为float,double,long double</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sed</title>
    <link href="/2019/07/18/sed/"/>
    <url>/2019/07/18/sed/</url>
    
    <content type="html"><![CDATA[<h3 id="sed作用原理"><a href="#sed作用原理" class="headerlink" title="sed作用原理"></a>sed作用原理</h3><p>sed首先将整个编辑脚本应用于第一个输入行(存在模式空间)，然后再读取第二个输入行。sed总是处理原始行的最新形式，所以生成的任何编辑动作都会作用于后续命令。</p><h3 id="sed选项总结"><a href="#sed选项总结" class="headerlink" title="sed选项总结"></a>sed选项总结</h3><table><thead><tr><th align="center">options</th><th align="center">describe</th><th align="center">example</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">编辑随后的指令</td><td align="center"><code>sed -e &#39;s/brown/green/;s/dog/cat/&#39; data.txt</code></td></tr><tr><td align="center">-f</td><td align="center">跟随脚本中的文件名</td><td align="center"></td></tr><tr><td align="center">-n</td><td align="center">阻止输入行的自动输出</td><td align="center"></td></tr><tr><td align="center">-r</td><td align="center">支持扩展的正则表达式</td><td align="center"></td></tr><tr><td align="center">-i</td><td align="center">直接修改读取的文件内容,而不是由屏幕输出</td><td align="center"></td></tr></tbody></table><h3 id="在命令行上指定多重命令"><a href="#在命令行上指定多重命令" class="headerlink" title="在命令行上指定多重命令"></a>在命令行上指定多重命令</h3><ul><li><code>sed &#39;s/MA/ma/; s/FA/fa/&#39; file</code></li><li><code>sed -e &#39;/MA/ma/&#39; -e &#39;s/FA/fa/&#39; file</code></li><li>bash等通用,输入单引号后回车,会出现<code>&gt;</code>多行输入提示符<br>sed为流编辑器,一次读取一行内容,并执行相应的命令,格式如下:<br><code>sed [options] &#39;[command]&#39; (file)</code></li></ul><h3 id="sed地址表示方法"><a href="#sed地址表示方法" class="headerlink" title="sed地址表示方法"></a>sed地址表示方法</h3><table><thead><tr><th align="center">地址</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">行号,n是一个正整数</td></tr><tr><td align="center">$</td><td align="center">最后一行</td></tr><tr><td align="center">&#x2F;regexp&#x2F;</td><td align="center">正则表达式匹配行</td></tr><tr><td align="center">addr1,addr2</td><td align="center">从addr1到addr2范围内的文本行,包含地址addr2在内,地址是上述任意的地址形式</td></tr><tr><td align="center">first~step</td><td align="center">匹配由数字first代表的文本行,然后随后的每个在step间隔处的文本行。例如1~2代表奇数行</td></tr><tr><td align="center">addr1,+n</td><td align="center">匹配地址addr1和随后的n个文本行</td></tr><tr><td align="center">addr!</td><td align="center">匹配所有文本行,除了addr之外,addr是上述任意的地址形式</td></tr></tbody></table><h3 id="分组命令"><a href="#分组命令" class="headerlink" title="分组命令"></a>分组命令</h3><p>sed使用大括号<code>&#123;&#125;</code>将一个地址嵌套在另一个地址上，或在相同的地址上应用多个命令，左大括号必须在行末，右大括号独占一行，之后必须没空格<br><strong>例1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1,5&#123;<br>/^$/d<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例2：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1,5&#123;<br>/^$/d<br>s/a/b/<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="替换s"><a href="#替换s" class="headerlink" title="替换s"></a>替换s</h3><p><code>[address]s/pattern/replacement/flags</code></p><h4 id="替换的标志位"><a href="#替换的标志位" class="headerlink" title="替换的标志位"></a>替换的标志位</h4><table><thead><tr><th align="center">flag</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">1到512之间的一个数字,表示对文本模式中指定模式第n次出现的情况进行替换</td></tr><tr><td align="center">g</td><td align="center">对模式空间的所有出现的情况进行全局更改</td></tr><tr><td align="center">p</td><td align="center">打印模式空间的内容,可以加感叹号，表示不打印</td></tr><tr><td align="center">W <file></td><td align="center">将模式空间的内容写到文件file中</td></tr></tbody></table><h4 id="替换部分的元字符"><a href="#替换部分的元字符" class="headerlink" title="替换部分的元字符"></a>替换部分的元字符</h4><ul><li><code>&amp;</code>:表示命中的正则表达式</li><li><code>\</code>:后面可接回车,其他元字符转义</li><li><code>\&lt;n&gt;</code>:表示匹配的部分,在pattern中用<code>\(</code>和<code>\)</code>括起来</li></ul><h4 id="界定符"><a href="#界定符" class="headerlink" title="界定符"></a>界定符</h4><ul><li>如果模式中含有’&#x2F;‘可以用感叹号作定界符,如<code>s!/usr/mail!/usr2/mail!</code></li><li>注意地址的界定符不能这么玩</li></ul><h3 id="删除d"><a href="#删除d" class="headerlink" title="删除d"></a>删除d</h3><p>匹配到这个地址就删除模式空间内容,并且会导致不再执行接下来的脚本，读取新的行。</p><h3 id="a、i、c"><a href="#a、i、c" class="headerlink" title="a、i、c"></a>a、i、c</h3><ul><li>追加<code>[line-address(单行)]a\   \&lt;text\&gt;</code><br>加入模式空间内容之后</li><li>插入<code>[line-address(单行)]i\   \&lt;text\&gt;</code><br>插入模式空间内容之前</li><li>更改<code>[address(可以是范围)]c\   \&lt;text\&gt;</code><br>替换模式空间(范围的话,替换范围内的内容)的内容</li></ul><h4 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h4><ul><li>每一个都要求后面跟一个反斜杠转义第一个行尾,text必须从下一行开始</li><li>text内容如果是多行,则行末要加反斜线,最后一行不需要</li><li>如果更改存在于组命令中,且是个范围，则会存在每一行都替换,而不是范围替换一次</li><li>插入与追加的文本内容不受命令影响,也不影响行计数器</li><li>更改命令则与删除命令类似,接下来的脚本不会作用，会立刻读入新行</li></ul><h3 id="读和写命令"><a href="#读和写命令" class="headerlink" title="读和写命令"></a>读和写命令</h3><ul><li><code>[line-address]r file</code>读入某个文件的内容,追加到模式空间后</li><li><code>[address]w file</code>把模式空间内容写到某个文件</li></ul><h4 id="注意项-1"><a href="#注意项-1" class="headerlink" title="注意项"></a>注意项</h4><ul><li>文件不存在不会报错</li><li>如果一个脚本中有多个指令写到同一个文件,那么每个写命令都将追加到这个文件</li><li>读的内容不受之后命令影响</li><li>sed最多打开10个文件</li></ul><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li>列表<code>[addess]l</code>:不仅显示内容,非打印字符显示为两个数字的ASCLL代码</li><li><code>[line-address]=</code>:不打印内容,但打印行号</li><li><code>[address]n</code>:输出模式空间内容(没抑制输出的话),读取输入的下一行,并且后续命令用于新行,之前的命令不会用于新行</li><li><code>[line-address]q</code>:停止读入新行，退出脚本,经常用来打印前几行</li><li>转换<code>[address]y/abc/xyz/</code>(类似于tr),有用的例子转换大小写y&#x2F;abcdefghijklmnopqrstuvwxyz&#x2F;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x2F;</li></ul><h3 id="反斜线圆括号用法"><a href="#反斜线圆括号用法" class="headerlink" title="反斜线圆括号用法"></a>反斜线圆括号用法</h3><p><code>s/\([0-9]\)-\([0-9]\)/\2-\1/g</code>指交换斜杠前后的两个数字</p><h3 id="多行模式N"><a href="#多行模式N" class="headerlink" title="多行模式N"></a>多行模式N</h3><p>多行模式空间:多行Next(N)命令通过读取新的输入行,并将它添加到模式空间的现有内容来创建多行模式空间。模式空间最初的内容和新的输入行之间用换行符分隔。在模式空间中嵌入的换行符可以用转义序列”\n”来匹配。在多行模式空间中,元字符”^”匹配空间中的第一个字条,而不匹配换行符后面的字符。同样,”$”只匹配模式空间中最后的换行符,而不匹配任何嵌入的换行符。在执行Next命令之后,控制将被传递给脚本中的后续命令。<br>这与next不同，next不创建多行模式，它输出内容，然后，读取新的行。<br>举例:例如要将”Owner and Operator Guide”换成”Installation Guide”,对于处于不同行的情况可以这样做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Operator$/&#123;<br>N<br>s/Owner and Operator\nGuide/Installation Guide/<br>&#125;<br></code></pre></td></tr></table></figure><p>上面比较不普遍,更普遍做法是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">s/Owner and Operator Guide/Installtion Guide/<br>/Owner/&#123;<br>N<br>s/ *\n/ /<br>s/Owner and Operator Guide */Installation Guide\<br>/<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多行模式D"><a href="#多行模式D" class="headerlink" title="多行模式D"></a>多行模式D</h3><p>删除命令(d)删除模式空间的内容并导致读入新的输入行,从而在脚本的顶端重新使用编辑方法。删除命令(D)稍微有些不同:它删除模式空间中直到第一个嵌入的换行符的这部分内容。他不会导致读入新的输入行,相反,<strong>它返回到脚本的顶端</strong>,将这些指令应用于模式空间的剩余内容。<br>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/^ $/&#123;<br>N<br>/^ \n$/D<br>&#125;<br></code></pre></td></tr></table></figure><p>以上可以删除连续多个空行,只保留一个空行</p><h3 id="多行模式P"><a href="#多行模式P" class="headerlink" title="多行模式P"></a>多行模式P</h3><p>该命令输出多行模式空间的第一部分，直到第一个嵌入的换行符为止。<br>P命令经常出现在Next命令之后和Delete命令之前，建立一个输入&#x2F;输出循环，用来维护两行的模式空间，这样就能之输出第一行，然后返回到脚本的顶端，用于第二行。</p><h3 id="保持空间"><a href="#保持空间" class="headerlink" title="保持空间"></a>保持空间</h3><p>保持空间:当改变模式空间中的原始内容时,用于保留当前输入行的副本。影响模式空间的命令</p><table><thead><tr><th align="center">命令</th><th align="center">缩写</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Hold</td><td align="center">h或H</td><td align="center">将模式空间的内容复制或追加到保持空间(大写追加)</td></tr><tr><td align="center">Get</td><td align="center">g或G</td><td align="center">将保持空间的内容复制或追加到模式空间(大写追加)</td></tr><tr><td align="center">Exchange</td><td align="center">x</td><td align="center">交换保持空间和模式空间的内容</td></tr></tbody></table><h3 id="高级的流控制命令"><a href="#高级的流控制命令" class="headerlink" title="高级的流控制命令"></a>高级的流控制命令</h3><ul><li>分支:在脚本中将控制转移到另一行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">:top<br>command1<br>command2<br>/pattern/b top<br>command3<br></code></pre></td></tr></table></figure>如果没有定义top或没有标签(可以为任意命名),则将跳转到脚本末尾,上面例子意思是如果找不到pattern,才执行commmand3<br><strong>注意</strong>不要在标签后加空格</li><li>测试:如果当前匹配行上成功进行了替换,那么test命令就会转到标签处,用法和分支一样,把b改成t即可<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sth/&#123;<br>s/a/b/<br>t<br>s/c/b/<br>t<br>s/d/b/<br>&#125;<br></code></pre></td></tr></table></figure>一旦一个替换被执行，控制就到脚本末尾</li></ul><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><ul><li><code>sed &#39;52q;d&#39; file</code>打印52行，效率高</li><li><code>cat jane.txt | tr &#39;[A-Z]&#39; &#39;[a-z]&#39; | tr &#39;;.?\047,():&quot;-&#39; &#39; &#39;|tr &#39; &#39; &#39;\012&#39; | grep -v &#39;^ *$&#39; | sort | uniq -c | sort -n</code>:统计单词数,首先大写替换为小写，然后替换标点为空格,再替换空格为换行,去空行,排序，计数，再排序。</li><li><code>sed &#39;G&#39; file</code>在每行后添加个空行</li><li><code>sed -n &quot;$!N;/^(.*)n1$/!P;D&#39; test.txt</code>删除文件中连续且重复的行</li><li><code>sed &#39;/^$/d;G&#39;</code>保证每一行后都有个空行，会删除连续空行，并添加空行</li><li><code>sed &#39;n;d&#39; test.txt</code>删除偶数行</li><li><code>sed &#39;/regex/&#123;x;p;x&#125;&#39; test.txt</code>匹配regex之前添加空行</li><li><code>sed &#39;/regex/G&#39; test.txt</code>匹配regex之后添加空行</li><li><code>sed &#39;/regex/&#123;x;p;x;G;&#125;&#39; test.txt</code>之前之后都添加空行</li><li><code>sed &#39;n;n;n;n;G&#39;</code>每5行添加一个空行或<code>sed &#39;0~5G&#39; text.txt</code></li><li><code>sed &#39;=&#39; test.txt | sed &#39;N;s/s*ns*/t/&#39;</code>给每一行添加行号，以制表符分隔</li><li><code>sed &#39;/./=&#39; test.txt | sed &#39;/./N; s/s*ns*/t/&#39;</code>为非空行添加行号</li><li><code>sed -n &#39;$=&#39; test.txt</code>统计行数</li><li><code>sed &#39;s/^[[:blank:]]*|[[:blank:]]*$//&#39; test.txt</code>删除行首和行尾空白</li><li><code>sed &#39;1!G;h;$!d&#39; test.txt</code>反转每一行的顺序(类似tac)</li><li><code>sed &#39;/n/!G;s/(.)(.*n)/&amp;21/;//D;s/.//&#39;</code>反转每一行的字母顺序(类似rev)</li><li><code>sed -e &#39;:a&#39; -e &#39;s/([0-9])([0-9]&#123;3&#125;)($|,)/1,2/;ta&#39; test.txt</code>给数字串加逗号或<code>sed -e &#39;:a&#39; -e &#39;s/(.*[0-9])([0-9]&#123;3&#125;)/1,2/;ta&#39; test.txt</code></li><li><code>sed &#39;q&#39; test.txt</code>打印文件第一行</li><li><code>sed -n &#39;N;P&#39; file</code>打印奇数行</li><li><code>sed -n &#39;/regex/&#123;n;p&#125;&#39; test.txt</code> 打印匹配那一行的后一行</li><li><code>sed -n &#39;/regex/&#123;=;x;1!p;g;$!N;p;D;&#125;; h&#39; test.txt</code>  打印匹配“regex”那一行的前后一行，并且打印匹配行的行号(类似grep -A1 -B1)</li><li><code>sed -n &#39;/^.&#123;65&#125;/p&#39; test.txt</code>打印长于65个字符的行</li><li><code>sed &#39;/^$/N;/n$/D&#39; test.txt</code>压缩连续空行(类似于cat -s)</li><li><code>sed &#39;/./,$!d&#39;</code>删除文件开头的空行</li><li><code>sed &#39;:a;/^n*$/&#123;$d;N;ba&#125;&#39; test.txt</code>删除文件结尾空行</li></ul>]]></content>
    
    
    <categories>
      
      <category>文本处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三剑客sed_grep_awk</title>
    <link href="/2019/07/18/%E4%B8%89%E5%89%91%E5%AE%A2sed_awk_grep/"/>
    <url>/2019/07/18/%E4%B8%89%E5%89%91%E5%AE%A2sed_awk_grep/</url>
    
    <content type="html"><![CDATA[<ol><li>sed为流编辑器,一次读取一行内容,并执行相应的命令,格式如下:<br><code>sed [options] &#39;[command]&#39; (file)</code></li><li>sed选项总结</li></ol><table><thead><tr><th align="center">options</th><th align="center">describe</th><th align="center">example</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">编辑随后的指令</td><td align="center"><code>sed -e &#39;s/brown/green/;s/dog/cat/&#39; data.txt</code></td></tr><tr><td align="center">-f</td><td align="center">跟随脚本中的文件名</td><td align="center"></td></tr><tr><td align="center">-n</td><td align="center">阻止输入行的自动输出</td><td align="center"></td></tr><tr><td align="center">-r</td><td align="center">支持扩展的正则表达式</td><td align="center"></td></tr><tr><td align="center">-i</td><td align="center">直接修改读取的文件内容,而不是由屏幕输出</td><td align="center"></td></tr></tbody></table><ol start="3"><li>sed地址表示方法</li></ol><table><thead><tr><th align="center">地址</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">行号,n是一个正整数</td></tr><tr><td align="center">$</td><td align="center">最后一行</td></tr><tr><td align="center">&#x2F;regexp&#x2F;</td><td align="center">正则表达式匹配行</td></tr><tr><td align="center">addr1,addr2</td><td align="center">从addr1到addr2范围内的文本行,包含地址addr2在内,地址是上述任意的地址形式</td></tr><tr><td align="center">first~step</td><td align="center">匹配由数字first代表的文本行,然后随后的每个在step间隔处的文本行。例如1~2代表奇数行</td></tr><tr><td align="center">addr1,+n</td><td align="center">匹配地址addr1和随后的n个文本行</td></tr><tr><td align="center">addr!</td><td align="center">匹配所有文本行,除了addr之外,addr是上述任意的地址形式</td></tr></tbody></table><ol start="8"><li>替换的标志位</li></ol><table><thead><tr><th align="center">flag</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">1到512之间的一个数字,表示对文本模式中指定模式第n次出现的情况进行替换</td></tr><tr><td align="center">g</td><td align="center">对模式空间的所有出现的情况进行全局更改</td></tr><tr><td align="center">p</td><td align="center">打印模式空间的内容</td></tr><tr><td align="center">W</td><td align="center">将模式空间的内容写到文件file中</td></tr></tbody></table><p>替换部分的元字符:&amp;表示命中的正则表达式,<code>\</code>后面可接回车,<code>\&lt;n&gt;</code>表示匹配的部分</p><p>9.如果模式中含有’&#x2F;‘可以用感叹号作定界符,如<code>s!/usr/mail!/usr2/mail!</code><br>10.其他命令<br>a.追加[line-address(单个行)]a<br>        &lt;text&gt;<br>b.插入[line-address(单个行)]i<br>        &lt;text&gt;<br>c.更改[address(可以是范围)]c<br>        &lt;text&gt;<br>以上三个命令text内容如果是多行,则行末要加反斜线,最后一行不需要,文本内容不影响模式空间,也不参与后面的脚本运行<br>d.列表[address]l;不仅显示内容,非打印字符显示为两个数字的ASCLL代码<br>e.[line-address]&#x3D;;不打印内容,但打印行号<br>f.[address]n;读取输入的下一行,并且后续命令用于新行<br>g.[line-address]r <filename>;在匹配行之后,读入某个文件<br>h.[address]w <filename>;写入某个文件<br>i.[line-address]q;停止读入新行<br>j.[address]y&#x2F;abc&#x2F;xyz&#x2F;;转换(类似于tr),有用的例子转换大小写y&#x2F;abcdefghijklmnopqrstuvwxyz&#x2F;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x2F;<br>8.sed:反斜线圆括号用法<br><code>s/\([0-9]\)-\([0-9]\)/\2-\1/g</code>指交换斜杠前后的两个数字<br>12.脚本中所有编辑命令都将依次应用于每个输入行<br>12.　a.<code>cat jane.txt | tr &#39;[A-Z]&#39; &#39;[a-z]&#39; | tr &#39;;.?\047,():&quot;-&#39; &#39; &#39;|tr &#39; &#39; &#39;\012&#39; | grep -v &#39;^ *$&#39; | sort | uniq -c | sort -n</code>:统计单词数,首先大写替换为小写，然后替换标点为空格,再替换空格为换行,去空行,排序，计数，再排序。<br>13.sed分组命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/pattern/ &#123;<br>动作１<br>动作２<br>&#125;<br></code></pre></td></tr></table></figure><ol start="14"><li><p>多行模式空间:多行Next(N)命令通过读取新的输入行,并将它添加到模式空间的现有内容来创建多行模式空间。模式空间最初的内容和新的输入行之间用换行符分隔。在模式空间中嵌入的换行符可以用转义序列”\n”来匹配。在多行模式空间中,元字符”^”匹配空间中的第一个字条,而不匹配换行符后面的字符。同样,”$”只匹配模式空间中最后的换行符,而不匹配任何嵌入的换行符。在执行next命令之后,控制将被传递给脚本中的后续命令。<br>举例:例如要将”Owner and Operator Guide”换成”Installation Guide”,对于处于不同行的情况可以这样做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Operator$/&#123;<br>N<br>s/Owner and Operator\nGuide/Installation Guide/<br>&#125;<br></code></pre></td></tr></table></figure><p>上面比较不普遍,更普遍做法是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">s/Owner and Operator Guide/Installtion Guide/<br>/Owner/&#123;<br>N<br>s/ *\n/ /<br>s/Owner and Operator Guide *Installation Guide\<br>/<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除命令(d)删除模式空间的内容并导致读入新的输入行,从而在脚本的顶端重新使用编辑方法。删除命令(D)稍微有些不同:它删除模式空间中直到第一个嵌入的换行符的这部分内容。他不会导致读入新的输入行,相反,<strong>它返回到脚本的顶端</strong>,将这些指令应用于模式空间的剩余内容。<br>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/^ $/&#123;<br>N<br>/^ \n$/D<br>&#125;<br></code></pre></td></tr></table></figure><p>以上可以删除连续多个空行,只保留一个空行</p></li><li><p>保持空间:当改变模式空间中的原始内容时,用于保留当前输入行的副本。影响模式空间的命令</p><table><thead><tr><th align="center">命令</th><th align="center">缩写</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Hold</td><td align="center">h或H</td><td align="center">将模式空间的内容复制或追加到保持空间(大写追加)</td></tr><tr><td align="center">Get</td><td align="center">g或G</td><td align="center">将保持空间的内容复制或追加到模式空间(大写追加)</td></tr><tr><td align="center">Exchange</td><td align="center">x</td><td align="center">交换保持空间和模式空间的内容</td></tr></tbody></table></li><li><p>分支:在脚本中将控制转移到另一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">:top<br>command1<br>command2<br>/pattern/b top<br>command3<br></code></pre></td></tr></table></figure><p>如果没有定义top(可以为任意命名),则将跳转到脚本末尾,上面例子意思是如果找不到pattern,才执行commmand3<br>测试:如果当前匹配行上成功进行了替换,那么test命令就会转到标签处,用法和分支一样,把b改成t即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>文本处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++小知识</title>
    <link href="/2019/07/18/C-%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2019/07/18/C-%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ol><li>八进制整型常量以”0”开头如:0123<br>十六进制以”0x(X)”开头<br>长整型以”L(l)”结尾<br>无符号型以”U(u)”结尾<br>2.默认数据类型为int型,默认实型为double型,若要表示float型在结尾加”F(f)”</li><li>extern可以使用后面的定义的数据:<br>extern int h, k;<br>   .<br>   .<br>   .<br>int h&#x3D;1,k&#x3D;2;</li><li>register+类型+变量名,存放在寄存器,加快调用<br>auto+类型+变量名,自动分配存储,默认就是这个可以省略</li><li>内部函数,在前面加static,仅在包含文件中有效.<br>外部函数在前面加extern,默认就是这个.</li><li>const与指针<br><code>const double *cptr; //cptr指针指向一个类型为double的常量值</code><br><code>double *const cura; //cura是一个const指针,即无法改变指向的对象</code> </li><li>指针与函数<br>返回指针的函数称为指针函数，本质上是一个返回指针的函数，示例如下:<br><code>int *test(a,b)</code><br>函数指针就是指向函数的指针。示例如下:<br><code>int (*test)(int a,int b)</code></li><li>数组与指针<br>数组指针是一个指针变量，它指向一个数组。示例如下:<br><code>int (*ap)[2]</code><br>指针数组是一个包含指针元素的数组，它的元素可以指向相同类型的不同对象<br><code>int *ap[2]</code><br>ps:从以上可以看出指针从左至右结合，</li><li>指针与应用<br>.初始化要求不同，引用创建的同时必须初始化，而指针不必，可以重新赋值。<br>.可修改性不同，引用一旦被初始化，就不可更改，而指针可以指向另一个变量<br>.不存在NULL引用，指针可以，指针更灵活，但风险也大<br>.指针是一个实体，引用是一个别名<br>.内存上，指针有分配的存储空间，而应用则不用</li><li>c++无符号右移高位都补0</li><li><code>auto dp = vector&lt;vector&lt;int&gt;&gt;(length, vector&lt;int&gt;(length));</code>可以这样声明数组</li></ol><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="使用初始化列表比较大小"><a href="#使用初始化列表比较大小" class="headerlink" title="使用初始化列表比较大小"></a>使用初始化列表比较大小</h3><p><strong>差：</strong><code>small = min(x,min(y,z));</code><br><strong>好：</strong><code>small = min(&#123;x,y,z,k&#125;);</code></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cur = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">auto</span> [x,y] = cur;<br></code></pre></td></tr></table></figure><h3 id="debug宏"><a href="#debug宏" class="headerlink" title="debug宏"></a>debug宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#definde deb(x) cout&lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x</span><br><span class="hljs-type">int</span> ten = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">deb</span>(ten); <span class="hljs-comment">//prints &quot;ten = 10&quot;</span><br></code></pre></td></tr></table></figure><h3 id="支持多参数的debug宏"><a href="#支持多参数的debug宏" class="headerlink" title="支持多参数的debug宏"></a>支持多参数的debug宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> deb(...) logger(#__VA_ARGS__, __VA_ARGS__)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logger</span><span class="hljs-params">(string vars, Args&amp;&amp;... values)</span> </span>&#123;<br>    cout &lt;&lt; vars &lt;&lt; <span class="hljs-string">&quot; = &quot;</span>;<br>    string delim = <span class="hljs-string">&quot;&quot;</span>;<br>    (..., (cout &lt;&lt; delim &lt;&lt; values, delim = <span class="hljs-string">&quot;, &quot;</span>));<br>&#125;<br><br><span class="hljs-type">int</span> xx = <span class="hljs-number">3</span>, yy = <span class="hljs-number">10</span>, xxyy = <span class="hljs-number">103</span>;<br><span class="hljs-built_in">deb</span>(xx); <span class="hljs-comment">// prints &quot;xx = 3&quot;</span><br><span class="hljs-built_in">deb</span>(xx, yy, xxyy); <span class="hljs-comment">// prints &quot;xx, yy, xxyy = 3, 10, 103&quot;</span><br></code></pre></td></tr></table></figure><h3 id="读写容器和多变量"><a href="#读写容器和多变量" class="headerlink" title="读写容器和多变量"></a>读写容器和多变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;...args)</span> </span>&#123;<br>    ((cin &gt;&gt; args), ...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(string delimiter, T &amp;&amp;...args)</span> </span>&#123;<br>    ((cout &lt;&lt; args &lt;&lt; delimiter), ...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readContainer</span><span class="hljs-params">(T &amp;t)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e : t) &#123;<br>        <span class="hljs-built_in">read</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writeContainer</span><span class="hljs-params">(string delimiter, T &amp;t)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;e : t) &#123;<br>        <span class="hljs-built_in">write</span>(delimiter, e);<br>    &#125;<br>    <span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// Question: read three space seprated integers and print them in different lines.</span><br><span class="hljs-type">int</span> x, y, z;<br><span class="hljs-built_in">read</span>(x, y, z);<br><span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\n&quot;</span>, x, y, z);<br><br><span class="hljs-comment">// even works with variable data types :)</span><br><span class="hljs-type">int</span> n;<br>string s;<br><span class="hljs-built_in">read</span>(n, s);<br><span class="hljs-built_in">write</span>(<span class="hljs-string">&quot; &quot;</span>, s, <span class="hljs-string">&quot;has length&quot;</span>, n, <span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-comment">// Question: read an array of `N` integers and print it to the output console.</span><br><span class="hljs-type">int</span> N;<br><span class="hljs-built_in">read</span>(N);<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(N)</span></span>;<br><span class="hljs-built_in">readContainer</span>(arr);<br><span class="hljs-built_in">writeContainer</span>(<span class="hljs-string">&quot; &quot;</span>, arr); <span class="hljs-comment">// output: arr[0] arr[1] arr[2] ... arr[N - 1]</span><br><span class="hljs-built_in">writeContainer</span>(<span class="hljs-string">&quot;\n&quot;</span>, arr);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* output:</span><br><span class="hljs-comment">* arr[0]</span><br><span class="hljs-comment">* arr[1]</span><br><span class="hljs-comment">* arr[2]</span><br><span class="hljs-comment">* ...</span><br><span class="hljs-comment">* ...</span><br><span class="hljs-comment">* ...</span><br><span class="hljs-comment">* arr[N - 1]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="debug函数"><a href="#debug函数" class="headerlink" title="debug函数"></a>debug函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printer</span><span class="hljs-params">(T&amp;&amp;... args)</span> </span>&#123;<br>    ((cout &lt;&lt; args &lt;&lt; <span class="hljs-string">&quot; &quot;</span>), ...);<br>&#125;<br><br><span class="hljs-type">int</span> age = <span class="hljs-number">25</span>;<br>string name = <span class="hljs-string">&quot;Rachit&quot;</span>;<br><span class="hljs-built_in">printer</span>(<span class="hljs-string">&quot;I am&quot;</span>, name, <span class="hljs-string">&#x27;,&#x27;</span>, age, <span class="hljs-string">&quot;years old&quot;</span>);<br><span class="hljs-comment">// ^ This prints the following</span><br><span class="hljs-comment">// I am Rachit, 25 years old</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">debug_func</span><span class="hljs-params">(<span class="hljs-type">const</span> F&amp; func)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> [func](<span class="hljs-keyword">auto</span> &amp;&amp;...args) &#123; <span class="hljs-comment">// forward reference</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;input = &quot;</span>;<br>        <span class="hljs-built_in">printer</span>(args...);<br>        <span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">func</span>(forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...);<br>        cout &lt;&lt; <span class="hljs-string">&quot;res = &quot;</span> &lt;&lt; res &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>&#125;<br><br><span class="hljs-built_in">debug_func</span>(pow)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// ^ this automatically prints</span><br><span class="hljs-comment">// input = 2 3 res = 8</span><br></code></pre></td></tr></table></figure><h2 id="variant-c-17"><a href="#variant-c-17" class="headerlink" title="variant(c++17)"></a>variant(c++17)</h2><p>代替联合体union，类型安全(切换类型前会自动析构)，见<img src="https://en.cppreference.com/w/cpp/utility/variant" alt="variant"></p><ul><li>构造：<code>std::variant&lt;int, float&gt; tmp</code></li><li>获取类型个数：<code>std::variant_size_v&lt;decltype(tmp)&gt; // 2</code></li><li>获取下标：<code>tmp = 3.2; tmp.index() // 1</code></li><li>判断当前值类型：<code>hold_alternative&lt;float&gt; tmp // true</code></li><li>获取当前值类型：<code>static_assert(std::is_same_v&lt;int, variant_alternative_t&lt;0, tmp&gt;&gt;) // int</code></li></ul><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">std</span>::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; tmp;<br>tmp = <span class="hljs-string">&quot;hi&quot;</span>;<br><span class="hljs-built_in">std</span>::get&lt;<span class="hljs-type">int</span>&gt;(tmp); <span class="hljs-comment">// throw exception</span><br><span class="hljs-type">int</span>* s = <span class="hljs-built_in">std</span>::get_if&lt;<span class="hljs-type">int</span>&gt;(tmp); <span class="hljs-comment">// no throw, but return null</span><br><span class="hljs-built_in">string</span> g = <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(tmp); <span class="hljs-comment">//success</span><br></code></pre></td></tr></table></figure><h3 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h3><p>默认第一个类型的构造函数，第一个类型必须有构造函数，可以用monostate来作第一个参数，类似空指针</p><h2 id="span-c-20"><a href="#span-c-20" class="headerlink" title="span(c++20)"></a>span(c++20)</h2><p>span(std::string_view类似)是对数组的引用，可以对C风格的数组引用，可以使用vector的部分风格，例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(span&lt;<span class="hljs-type">int</span>&gt; r)</span> <span class="hljs-comment">// read into the range of integers r</span><br>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;r.size()&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//100</span><br>&#125;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br>read(a);        <span class="hljs-comment">// better: let the compiler figure out the number of elements</span><br></code></pre></td></tr></table></figure><h2 id="string-view和span"><a href="#string-view和span" class="headerlink" title="string_view和span"></a>string_view和span<char></h2><p>string_view只读，span<char>可变</p><h2 id="maybe-unused"><a href="#maybe-unused" class="headerlink" title="[[maybe_unused]]"></a>[[maybe_unused]]</h2><p>可以使用该attribute，声明条件用到的参数<br><code>Value* find(const set&lt;Value&gt;&amp; s, const Value&amp; v, [[maybe_unused]] Hint hint)</code></p><h2 id="zstring或not-null来表明C字符串"><a href="#zstring或not-null来表明C字符串" class="headerlink" title="zstring或not_null来表明C字符串"></a>zstring或not_null<zstring>来表明C字符串</h2><p><code>int length(const char* p)</code>&#x3D;&gt;<code>int length(zstring p)</code><br><code>int length(not_null&lt;zstring&gt;)</code></p><h2 id="不变参数用模板"><a href="#不变参数用模板" class="headerlink" title="不变参数用模板"></a>不变参数用模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(...)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-comment">/*...*/</span>)<br>        result += va_arg(<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">// BAD, assumes it will be passed ints</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>sum(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// ok</span><br>sum(<span class="hljs-number">3.14159</span>, <span class="hljs-number">2.71828</span>); <span class="hljs-comment">// BAD, undefined</span><br><br>template&lt;class ...Args&gt;<br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(Args... args)</span> <span class="hljs-comment">// GOOD, and much more flexible</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (... + args); <span class="hljs-comment">// note: C++17 &quot;fold expression&quot;</span><br>&#125;<br><br>sum(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// ok: 5</span><br>sum(<span class="hljs-number">3.14159</span>, <span class="hljs-number">2.71828</span>); <span class="hljs-comment">// ok: ~5.85987</span><br></code></pre></td></tr></table></figure><h2 id="原始指针只表示内存地址，owner表示所有权"><a href="#原始指针只表示内存地址，owner表示所有权" class="headerlink" title="原始指针只表示内存地址，owner表示所有权"></a>原始指针只表示内存地址，owner表示所有权</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    owner&lt;T*&gt; p;  <span class="hljs-comment">// OK: p is owning</span><br>    T* q;         <span class="hljs-comment">// OK: q is not owning</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="C和C-互相调用"><a href="#C和C-互相调用" class="headerlink" title="C和C++互相调用"></a>C和C++互相调用</h2><ul><li>从C++调用C:<ul><li>in C:<br>  double sqrt(double);</li><li>in C++:<br>  extern “C” double sqrt(double);<br>  sqrt(2);</li></ul></li><li>从C调用C++:<ul><li>in C:<br>  X call_f(struct Y*, int);</li><li>in C++:<br>  extern “C” X call_f(Y* p, int i)<br>  {<br>  return p-&gt;f(i);   &#x2F;&#x2F; possibly a virtual function call<br>  }</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vi及vim</title>
    <link href="/2019/07/18/vi%E5%8F%8Avim/"/>
    <url>/2019/07/18/vi%E5%8F%8Avim/</url>
    
    <content type="html"><![CDATA[<ol><li>vi:<br>  a.命令模式替换:%s&#x2F;xx&#x2F;xx&#x2F;gc,s代表替换,g代表一行多次匹配,c表示确认。<br>  b.在每行尾部加相同内容技巧:进入列模式(ctrl+v)，按‘G’选中每一行，按‘$’延伸至行尾，再按‘A’添加内容</li><li>sed与awk的命令格式: command [options] script filename</li><li>awk默认模式为所有行，默认操作打印。</li><li>实心句点”.“表示当前行</li><li>$表示最后一行</li><li>ctrl+g显示当前文件名<br>ctrl+s锁住<br>ctrl+q解锁</li><li>一般模式中，”&gt;””&lt;”为缩进层级</li><li>ctrl+a会把当前或之后数字加1，若要一次加10则按10ctrl+a,而ctrl+x则是减</li><li>guu使当前行都变成小写，gUU使当前行都变成大写，g~则反转大小写</li><li>一般模式下按下yt，再按你想要复制内容的后一个词，之后再在插入模式里按ctrl+r+0或ctrl+r+ctrl+p+0，就完成粘贴</li><li>在插入模式中按下ctrl+r+&#x3D;进入计算模式完成后回车完成结果输入。</li><li>在插入模式中可以根据字符编码进行输入字符,汇总如下:</li></ol><table><thead><tr><th align="center">按键操作</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">ctrl+v{123}</td><td align="center">以十进制字符编码插入字符</td></tr><tr><td align="center">ctrl+v+u{1234}</td><td align="center">以十六进制字符编码插入字符</td></tr><tr><td align="center">ctrl+k{char1}{char2}</td><td align="center">插入以二合字母表示的字符</td></tr></tbody></table><p>　　可以在命令模式中输入:h digraph-table，来查看二合字母<br>　　一般模式中，在字符上面输入ga可查看其十进制及十六进制编码<br>13.<br>gv重新选上次的高亮区<br>14.<br>o在可视模式中切换高亮区的活动端<br>15.<br>命令模式中%代表全部行<br>16.<br>可以进入行可视模式，选中对应行，然后进入命令模式进行操作<br>17.<br>命令模式中t为copy命令的简写<br>18.<br>在命令模式中执行普通模式下的命令可以用normal，如:<br><code>:%normal A;</code><br>就是在每行后加;<br>19.<br>一般模式下按*可以查找当前光标下的单词<br>20.<br>可以在命令模式中执行shell命令，只要在命令前加!,这只适合执行一次<br>21.<br>当执行多次命令时，可以在命令模式中输入shell，要想返回vi可以在shell中输入exit<br>22.<br>read,与write命令可以与shell命令结合使用,read把shell命令的标准输出读入缓冲区，write则是把缓冲区当做shell命令的标准输入<br>23.<br>可以用source脚本文件执行一系列的命令<br>24.<br>可以在一般模式中输入ctrl+w+v竖着分隔同一文件<br>25.<br>gj、gk等是在屏幕行上的移动<br>26.<br>文本对象与选择区域</p><table><thead><tr><th align="center">文本对象</th><th align="center">选择区域</th><th align="center">文本对象</th><th align="center">选择区域</th></tr></thead><tbody><tr><td align="center">iw</td><td align="center">当前单词</td><td align="center">aw</td><td align="center">当前单词及空格</td></tr><tr><td align="center">iW</td><td align="center">当前字串</td><td align="center">aw</td><td align="center">当前字串及空格</td></tr><tr><td align="center">is</td><td align="center">当前句子</td><td align="center">as</td><td align="center">当前句子及空格</td></tr><tr><td align="center">ip</td><td align="center">当前段落</td><td align="center">ap</td><td align="center">当前段落及空格</td></tr><tr><td align="center">ab</td><td align="center">当前的圆括号</td><td align="center">ib</td><td align="center">当前圆括号的内部</td></tr><tr><td align="center">aB</td><td align="center">当前的花括号</td><td align="center">iB</td><td align="center">当前花括号内部</td></tr><tr><td align="center">a]</td><td align="center">当前的方括号</td><td align="center">i]</td><td align="center">当前方括号的内部</td></tr><tr><td align="center">a&gt;</td><td align="center">当前尖括号</td><td align="center">i&gt;</td><td align="center">当前尖括号的内部</td></tr><tr><td align="center">a’</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">a”</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">at</td><td align="center">xml标签</td><td align="center">…</td><td align="center">…</td></tr></tbody></table><ol start="27"><li>m{a-zA-Z},标记位置，`{mark}跳转到对应位置,``上次跳转动作之前的位置,经常配合使用</li><li>ctrl+o也可以跳转到上次的位置</li><li>%命令可以在一对任意括号上进行跳转</li><li><code>&quot;add</code>指的是剪切一整行到a寄存器,<code>&quot;ap</code>则粘贴a寄存器里的内容</li><li>寄存器列表</li></ol><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">“”</td><td align="center">无名寄存器</td></tr><tr><td align="center">“0</td><td align="center">复制专用寄存器</td></tr><tr><td align="center">“(a-z)</td><td align="center">自定义寄存器</td></tr><tr><td align="center">“_</td><td align="center">黑洞寄存器</td></tr></tbody></table><p>　　在插入模式下可以用ctrl+r+上寄存器名来粘贴，此时没有”号<br>32.<br>宏录制的过程，q{register}录制开始-&gt;q录制结束-&gt;@{register}执行宏动作,还可以指定次数<br>33.<br>命令模式:reg {register}可以查看寄存器内容<br>34.<br>要想不覆盖寄存器内容，可以q{register}，register名字必须为大写(如qa-&gt;qA)，这样就追加了，否则是覆盖重新录制,<br>35.<br>一般模式下ctrl+b向前翻页<br>一般模式下ctrl+f向后翻页<br>36.<br>dG会删除光标之后的所有内容<br>37.<br>H,M,L,分别是移动到屏幕行的顶,中,尾<br>38.<br>按键映射</p><table><thead><tr><th align="center">递归</th><th align="center">非递归</th><th align="center">模式</th></tr></thead><tbody><tr><td align="center">:map</td><td align="center">:noremap</td><td align="center">normal,visual,operator-pending</td></tr><tr><td align="center">:nmap</td><td align="center">:nnoremap</td><td align="center">normal</td></tr><tr><td align="center">:xmap</td><td align="center">:xnoremap</td><td align="center">visual</td></tr><tr><td align="center">:cmap</td><td align="center">:cnoremap</td><td align="center">command-line</td></tr><tr><td align="center">:omap</td><td align="center">:onoremap</td><td align="center">operator-pending</td></tr><tr><td align="center">:imap</td><td align="center">:inoremap</td><td align="center">insert</td></tr><tr><td align="center">39.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">在.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;.ycm_extra_conf.py配置c++20</td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>文本处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件</title>
    <link href="/2019/07/18/Linux%E6%96%87%E4%BB%B6/"/>
    <url>/2019/07/18/Linux%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<ol><li><p>&#x2F;etc&#x2F;resolv.conf:加快网速的</p></li><li><p>&#x2F;etc&#x2F;apt&#x2F;sources.list:源列表</p></li><li><p>&#x2F;etc&#x2F;sudoers:sudo权限设置</p></li><li><p>&#x2F;etc&#x2F;xinetd.d&#x2F;:守护进程文件夹</p></li><li><p>&#x2F;etc&#x2F;inputrc:登录式bash的热键设置</p></li><li><p>登录式bash加载设置文件顺序:&#x2F;etc&#x2F;profile -&gt; ~&#x2F;.bash_profile(~&#x2F;.bash_login、~&#x2F;.profile) -&gt; ~&#x2F;.bashrc</p></li><li><p>非登录式bash加载设置文件顺序:~&#x2F;.bashrc -&gt; &#x2F;etc&#x2F;bashrc -&gt; &#x2F;etc&#x2F;profile.d&#x2F;*.sh<br>这其中的&#x2F;etc&#x2F;profile.d&#x2F;*.sh里为bash操作界面、语系等</p></li><li><p>&#x2F;dev&#x2F;pts:伪终端设备的目录<br>&#x2F;dev&#x2F;:字符设备对应的节点</p></li><li><p>&#x2F;proc&#x2F;net&#x2F;dev:网络终端接口</p></li><li><p>&#x2F;etc&#x2F;mkinitcpio.conf:钩子的配置文件</p></li><li><p>&#x2F;etc&#x2F;default&#x2F;grub:设置当前系统的启动参数(仅deepin有)<br>&#x2F;boot&#x2F;grub&#x2F;grub.cfg:设置所有系统的启动参数(arch的也可以设置,存在于deepin目录)</p></li><li><p>&#x2F;proc&#x2F;kallsyms:内核导出的符号表，第一列表示内核地址空间地址，第二列表示符号属性，第三段表示符号的字符串，也就是EXPORT_SYMBOL()导出的符号，第四列表示那些模块在使用这些符号</p></li><li><p>&#x2F;proc&#x2F;devices:字符设备,第一列数字代表主设备号,第二列则是设备内核模块名<br>&#x2F;proc&#x2F;(number):进程号的相关动态信息</p></li><li><p>超级块是对一个文件系统的描述<br>索引节点是对一个文件物理属性的描述<br>目录项是对一个文件逻辑属性的描述<br>一个进程所处的位置是由fs_struct来描述的,而一个进程(或用户)打开的文件是由files_struct来描述的,而整个系统所打开的文件是由file结构来描述的<br>17.&#x2F;etc&#x2F;ld.so.conf.d&#x2F;*.conf<br>里面是库文件所在目录，配置完用<code>ldconfig</code>更新一下<br>18.&#x2F;usr&#x2F;share&#x2F;doc目录下为各个安装软件的文档<br>19.&#x2F;usr&#x2F;share&#x2F;dict下竟然存了个英文字典<br>20.修改用户头像<br>&#x2F;var&#x2F;lib&#x2F;AccountsService&#x2F;users&#x2F;[userName]<br>默认icons文件位置在&#x2F;usr&#x2F;share&#x2F;pixmaps&#x2F;faces&#x2F;<br>头像尺寸方形才不缺失</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2019/07/18/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/07/18/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>同时对某个目录下多个文件操作用<code>&#123;a,b&#125;</code></p></li><li><p>搜索某个软件包 <code>sudo apt-cache search &lt;关键字&gt;</code></p></li><li><p>终端快捷键:</p><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">ctrl+a</td><td align="center">命令行首部</td></tr><tr><td align="center">ctrl+e</td><td align="center">命令行尾部</td></tr><tr><td align="center">ctrl+f</td><td align="center">前移一个字符</td></tr><tr><td align="center">ctrl+b</td><td align="center">后移一个字符</td></tr><tr><td align="center">ctrl+l</td><td align="center">等价于clear</td></tr><tr><td align="center">alt+f</td><td align="center">前移一个字</td></tr><tr><td align="center">alt+b</td><td align="center">后移一个字</td></tr><tr><td align="center">alt+c</td><td align="center">单词首字符大写</td></tr><tr><td align="center">alt+t</td><td align="center">光标位置的字和其前面的字互换</td></tr><tr><td align="center">alt+l</td><td align="center">从光标到字尾转换成小写字母</td></tr><tr><td align="center">alt+u</td><td align="center">从光标到字尾转换成大写字母</td></tr><tr><td align="center">alt+d</td><td align="center">剪切从光标到字尾的文本</td></tr><tr><td align="center">alt+#</td><td align="center">注释当前的命令</td></tr><tr><td align="center">alt+.</td><td align="center">插入上一个命令的最后一个参数</td></tr><tr><td align="center">alt+Backspace</td><td align="center">剪切从光标到字首的文本</td></tr><tr><td align="center">ctrl+k</td><td align="center">删除光标后的字符</td></tr><tr><td align="center">ctrl+d</td><td align="center">删除光标上的字符</td></tr><tr><td align="center">ctrl+t</td><td align="center">交换光标处和它的前面字符</td></tr><tr><td align="center">ctrl+s</td><td align="center">锁定屏幕</td></tr><tr><td align="center">ctrl+q</td><td align="center">解锁</td></tr><tr><td align="center">ctrl+h</td><td align="center">删除左侧字符</td></tr><tr><td align="center">ctrl+w</td><td align="center">删除上一个单词</td></tr><tr><td align="center">ctrl+y</td><td align="center">粘贴剪切的文本</td></tr><tr><td align="center">ctrl+k</td><td align="center">剪切从光标到行尾的文本</td></tr><tr><td align="center">ctrl+u</td><td align="center">剪切从光标到行首的文本</td></tr><tr><td align="center">ctrl+v</td><td align="center">输入特殊字符</td></tr><tr><td align="center">ctrl+r</td><td align="center">搜索词,再次按该组合键可以循环搜索,回车选中,ctrl+G不做任何操作返回终端</td></tr><tr><td align="center">ctrl+x ctrl+e</td><td align="center">在文本编辑器中快速打开当前命令,退出编辑器后，自动执行</td></tr><tr><td align="center">set -o vi</td><td align="center">设置vi风格</td></tr><tr><td align="center">!$</td><td align="center">重新使用上一个命令中的最后一项(最好用<code>alt+.</code>可以跳转上几次)</td></tr><tr><td align="center">!number</td><td align="center">重复历史表中第number行命令</td></tr><tr><td align="center">!!</td><td align="center">执行上一个命令(常用于忘加sudo<code>sudo !!</code>)</td></tr></tbody></table></li><li><p>命令间连接</p><ul><li>“;”:一直执行无论成功与否</li><li>“&amp;&amp;”:前面的命令执行成功才能执行后面</li><li>“||”:前面的命令执行失败才能执行后面</li></ul></li><li><p><code>kill %2</code> 2代表jobs命令显示下的任务号码,%区别于进程ID</p></li><li><p>man</p><p><code>man &lt;num&gt; &lt;cmd&gt;</code></p><table><thead><tr><th align="center">章节</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">用户命令</td></tr><tr><td align="center">2</td><td align="center">程序接口内核系统调用</td></tr><tr><td align="center">3</td><td align="center">c库函数程序接口</td></tr><tr><td align="center">4</td><td align="center">特殊文件,比如说设备节点和驱动程序</td></tr><tr><td align="center">5</td><td align="center">文件格式</td></tr><tr><td align="center">6</td><td align="center">游戏娱乐,如屏幕保护程序</td></tr><tr><td align="center">7</td><td align="center">其他方面</td></tr><tr><td align="center">8</td><td align="center">系统管理员命令</td></tr><tr><td align="center">9</td><td align="center">内核例程</td></tr><tr><td align="center"><code>-k &lt;pattern&gt;</code>在文档中搜索某个关键字,</td><td align="center"></td></tr></tbody></table></li><li><p>后台运行</p><p><code>nohup [命令参数] &amp;</code></p></li><li><p>ln命令：</p><ul><li><code>ln source target</code> 硬链接</li><li><code>ln -s source target</code>软连接。</li></ul><p>两者的区别:</p><ul><li>软连接不增加文件的链接数，而硬链接则增加</li><li>不能跨文件系统创建硬链接，硬链接不能连接目录</li><li>硬链接的inode号完全相同，指向同一文件，软连接则有不同的inode号，并且新文件类型为专有软链接类型，其指向的文件内容存储着实际文件的路径</li><li>硬链接指向的文件当链接数减为0时，才真正删除，软链接若实际文件删除，则软链接失效。</li></ul></li></ul><p><code>readlink -f filename</code>可以显示链接的原始指向位置</p><ul><li><p>nslookup</p><p><code>nslookup github.global.ssl.fastly.Net</code><br><code>nslookup github.com</code><br>查到的域名加到&#x2F;etc&#x2F;hosts里可以加快访问速度</p></li></ul><p><code>sudo /etc/init.d/networking restart</code>刷新缓存</p><ul><li><p>systemctl</p><ul><li>systemctl查看&#x2F;etc&#x2F;init.d中哪些服务进程会在引导时启动<br><code>systemctl list-unit-files --type=service | grep enabled</code>  </li><li>查找废弃服务<br><code>systemctl --all | grep not-found</code></li><li>停止某个服务进程、开机禁止启动以及某个进程的状态<br><code>sudo systemctl stop xxx.service</code><br><code>sudo systemctl disable xxx.service</code><br><code>sudo systemctl status xxx.service</code></li></ul></li></ul><p><strong>注</strong>:不能启用或禁用静态服务，这些服务为其他进程所依赖。</p><ul><li><p>查看前一次启动的开机日志<code>journalctl -b -1</code>  </p></li><li><p>查看启动服务消耗时间<code>systemd-analyze blame</code></p></li><li><p>mask禁用某种服务 <code>systemctl mask xx.service</code></p></li><li><p>命令行复制到剪贴板<br><code>cat filename | xsel -b</code></p></li><li><p>plymouth</p><ul><li>主题文件夹：&#x2F;usr&#x2F;share&#x2F;plymouth&#x2F;themes&#x2F;</li><li>设置文件夹:&#x2F;etc&#x2F;plymouth&#x2F;plymouthd.conf</li><li>列出主题列表<code>plymouth-set-default-theme -l</code></li><li>更改Theme&#x3D;的内容<code>sudo vi /etc/plymouth/plymouthd.conf</code><br><code>sudo mkinitcpio -p linux</code>生成新的镜像,重启生效<br>需要’quite splash’静默启动参数,在grub里设置</li></ul></li><li><p><code>grub-mkconfig</code> 刷新grub的配置</p></li><li><p>同个命令对应不同软件版本配置</p><p><code>update-alternatives --install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</code></p><p><code>update-alternatives --install /usr/bin/arm-linux-gnueabi-gcc arm-linux-gnueabi-gcc /usr/bin/arm-linux-gnueabi-gcc-5 5</code></p><p><code>update-alternatives --config arm-linux-gnueabi-gcc</code></p></li><li><p>内核模块相关</p><ul><li><code>modinfo *.ko</code>查看某个编译好的模块</li><li><code>sudo insmod *.ko</code>装入模块</li><li><code>dmesg</code> 查看内核打印信息</li><li><code>lsmod</code> 显示已加载的模块</li><li>已加载的模块会在&#x2F;sys&#x2F;module&#x2F;下建立对应文件夹</li><li><code>sudo rmmod x.ko</code>卸载模块</li></ul></li><li><p>手机USB线wifi共享：</p><ul><li><code>ip addr show</code>查看USB网络借口</li><li><code>dhclient enpxxx</code>给借口设置ip地址，手机热点要开</li></ul></li><li><p>od命令</p><ul><li><code>od -t x1 x.dat</code>以十六进制打印文件x.dat各字节</li><li><code>od -c /bin/bash</code>逐字符方式打印文件,遇到不可打印字符打印编码</li><li><code>echo \&#39; | od -t o1</code>查看单引号的八进制</li></ul></li><li><p>md5sum命令</p><ul><li><code>md5sum file1 file2</code>计算两个文件的md5值,相同文件md5值相同</li></ul></li><li><p>行律问题</p><ul><li><code>ctty -a</code>查看行律配置</li><li><code>ctty erase ^H</code>设置退格键</li></ul></li><li><p>windows文件不兼容</p><ul><li><code>unix2dos filename</code>转换成windows类型的文件,也有dos2unix命令</li></ul></li><li><p>gbk中文字符转换为utf</p><ul><li><code>iconv -f utf-8 -t gbk</code></li><li><code>echo &quot;汉字&quot; | iconv -f utf-8 -t gbk | od -t x1</code></li></ul></li><li><p><code>--</code>显示终止选项命令<br><code>rm -- -i</code>表示删除名为’-i’的文件</p></li><li><p>在任何命令前加<code>time</code>,可以计时运行时间</p></li><li><p>xargs命令</p><p>将标准输入构造为命令的命令行参数,如果命令行参数过多,会启动多个进程,与单一普通管道相比就是批处理<br>举例:<code>find src -name \*.c -print | xargs grep -n -- --help</code></p></li><li><p>输入重定向</p><ul><li><code>cat &lt; filename</code>打印名为filename的文件内容</li><li><code>cat &lt;&lt; END</code>接下来直到END之间的内容</li><li><code>cat &lt;&lt;&lt; filename</code>打印filename这个单词</li><li><code>&gt; 文件名</code>清空文件</li></ul></li><li><p>tee</p><p>从Stdin读取数据，并同时输出到Stdout和文件 <code>ls /usr/bin | tee ls.txt |grep zip</code></p></li><li><p>du命令  </p><ul><li><code>du -sh * | sort -rh</code>查看当前目录下所有文件大小并排序</li><li><code>du -sh</code>统计当前目录大小</li><li><code>du -h --max-depth=1 | sort</code>查看当前所有一级子目录大小并排序</li></ul></li><li><p>at</p><ul><li><code>systemctl start atd.service</code>启动服务</li><li><code>at &lt;时间点&gt;</code>时间点格式举例:19:33、3pm+7 days、20:00 tomorrow 之后进入交互界面,输入命令,ctrl+D退出</li><li><code>at -l 或者 atq</code>查看列表</li><li><code>at -c 任务号</code>查看任务内容</li><li><code>at -r 任务号 或者 atrm 任务号</code>取消任务</li><li><code>at -f 脚本文件</code>不进入交互,直接运行某个脚本</li><li><code>-M</code>忽略产生的任何输出</li><li>&#x2F;etc&#x2F;at.deny,文件中的用户不能执行at(系统默认存在)</li><li>&#x2F;etc&#x2F;at.allow,默认不存在,只要存在的用户才能执行</li></ul></li><li><p>crontab服务定时任务计划</p><ul><li><code>sudo systemctl start cronie.service</code>启动服务</li><li><code>crontab -e</code>新增任务或编辑任务<br>格式如下: <code>&lt;minute&gt; &lt;hour&gt; &lt;day&gt; &lt;month&gt; &lt;week&gt; &lt;command&gt;</code></li></ul><table><thead><tr><th align="center">条目</th><th align="center">取值</th></tr></thead><tbody><tr><td align="center">minute</td><td align="center">0到59之间任何整数</td></tr><tr><td align="center">hour</td><td align="center">0到23之间任何整数</td></tr><tr><td align="center">day</td><td align="center">1到31之间的任何整数</td></tr><tr><td align="center">month</td><td align="center">1到12之间任何整数</td></tr><tr><td align="center">week</td><td align="center">1到7之间任何整数,</td></tr><tr><td align="center">command</td><td align="center">执行的命令</td></tr><tr><td align="center">(*)代表所有可能值</td><td align="center"></td></tr></tbody></table><p>(,)一个列表范围</p><p>(-)表示一个整数范围</p><p>(&#x2F;)指定时间间隔的频率,比如”0-23&#x2F;2”表示每两小时执行</p><ul><li><code>crontab -l</code>显示crontab文件</li><li><code>crontab -r</code>删除crontab文件</li><li><code>crontab -ir</code>删除crontab文件前提醒用户</li></ul><p>如果对时间精读要求不高,可以把脚本复制到&#x2F;etc&#x2F;cron.daily等目录下</p><p>anacron是对该程序的一个补充,它会自动运行crontab原本应该运行但由于关机等原因造成的程序,但它只会处理位于&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly下的脚本文件,它的配置文件位于&#x2F;etc&#x2F;anacrontab</p></li></ul><p>anacron是自动运行的?(有待研究)</p><ul><li><p>run-parts一个接一个运行同一目录下的脚本</p><ul><li><code>run-parts&lt;directory-path&gt;</code></li><li><code>run-parts --list --regex  &#39;^s.\*sh$&#39; &lt;directory&gt; </code></li></ul></li><li><p>ffmpeg</p><ul><li>裁剪:<code>ffmpeg -i xx.mp4 -vcodec copy -acodec copy -ss 00:00:00 -to 01:18:08 output.mp4</code></li><li>合并:<br>先建立个文本文档file,格式如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">file <span class="hljs-string">&#x27;1.mp4&#x27;</span><br>file <span class="hljs-string">&#x27;2.mp4&#x27;</span><br></code></pre></td></tr></table></figure><code>ffmpeg -f concat -i file -c copy output.mkv</code></li></ul><p>或者支持不好先转换ts</p><p><code>ffmpeg -i 1.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 1.ts</code></p><p><code>ffmpeg -i 2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 2.ts</code></p><p><code>ffmpeg -i &quot;concat:1.ts|2.ts&quot; -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4</code></p><ul><li>rmvb-&gt;mp4:<br><code>ffmpeg -i name1.rmvb -c:v libx264 -strict -2 name2.mp4 </code></li><li>添加字幕:<br><code>ffmpeg -i 2020-07-13\ 08-20-26.mkv -vf subtitles=test.srt -y output.mkv</code></li></ul><p>srt格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span><br><span class="hljs-attribute">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">03</span>,<span class="hljs-number">000</span> --&gt; <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">06</span>,<span class="hljs-number">000</span><br><span class="hljs-attribute">Hi</span>,I am Nanbert Don De Niro<br><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">06</span>,<span class="hljs-number">000</span> --&gt; <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">08</span>,<span class="hljs-number">000</span><br><span class="hljs-attribute">Hi</span>,I am Donald Trump<br><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">08</span>,<span class="hljs-number">444</span> --&gt; <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">10</span>,<span class="hljs-number">000</span><br><span class="hljs-attribute">It</span>&#x27;s you,Assole!<br></code></pre></td></tr></table></figure><ul><li>静音:<code>ffmpeg -i 10.mp4 -af &quot;volume=0&quot; 10Silent.mp4</code></li><li>静音一部分:<code>ffmpeg -i 10.mp4 -af &quot;volume=enable=&#39;between(t,0,8)&#39;:volume=0&quot; 10Silent.mp4</code></li><li>一边播放一边保存流媒体:<code>ffmpeg -i host/input.m3u8 -c copy out.mkv -c copy -f matroska - | ffplay - </code></li></ul></li><li><p><code>type &lt;command&gt;</code>识别命令,有以下几种</p><ul><li>可执行命令，给出路径</li><li>shell自身的命令(builtins),内建命令不会产生子进程,代价更小</li><li>一个shell函数</li><li>别名命令</li></ul></li><li><p><code>whatis &lt;command&gt;</code>会给出命令简短的说明</p></li><li><p><code>rm !(*.csv)</code>删除除了csv结尾的所有文件(貌似只有bash支持，zsh不支持)</p></li><li><p><code>mkdir &#123;2007..2009&#125;\_0&#123;1..9&#125;&#123;A,B&#125;</code>创建一系列文件夹,这其实是花括号展开</p></li><li><p><code>apropos &lt;some word&gt;</code>在man手册里搜索关键字</p></li><li><p><code>info &lt;command&gt;</code>man手册的另一种排版，有点鸡肋</p></li><li><p>标准错误的重定向</p><p>标准错误和标准输出重定向同一个文件<br><code>ls -l xx &gt;info.txt 2&gt;&amp;1</code>等价于<code>ls -l xx &amp;&gt; info.txt</code></p></li><li><p>env 或 printenv打印当前环境变量(全局变量)</p></li><li><p>set打印当前环境变量并按字母排列(包括局部变量、全局变量、用户定义变量)</p></li><li><p>alias查看别名,上面的不可以查看</p></li><li><p><code>ps -f --forest</code> 可以显示当前shell的进程关系</p></li><li><p>coproc(这就是协程?)<br><code>coproc [job_name(可选)] [command]</code>等价于<code>( command )&amp;</code><br>即生成后台子shell，并在子shell中执行命令。command本身可以是小括号命令集(嵌套子shell)或大括号命令集</p></li><li><p>lsof列出打开的文件描述符</p><ul><li>-p:指定进程ID</li><li>-d:指定要显示的文件描述符编号</li><li><code>lsof -a -p $$ -d 0,1,2</code>显示当前进程0,1,2的文件描述符信息,信息含义如下:<ul><li>COMMAND 正在运行的命令名的前 9 个字符</li><li>PID 进程的 PID</li><li>USER 进程属主的登录名</li><li>FD 文件描述符号以及访问类型（r 代表读，w 代表写，u 代表读写）</li><li>TYPE 文件的类型（CHR 代表字符型，BLK 代表块型，DIR 代表目录，REG 代表常规文件）</li><li>DEVICE 设备的设备号（主设备号和从设备号）</li><li>SIZE 如果有的话，表示文件的大小</li><li>NODE 本地文件的节点号</li><li>NAME 文件名</li></ul></li></ul></li><li><p>mktemp</p><p>mktemp可以用来创建临时文件,成功会输出文件路径</p><p><code>mktemp [module]</code>不指定[module]会在&#x2F;tmp中创建唯一临时文件,有用户有读写权限(不使用umask值),若指定[module],则会在当前文件夹下产生模板临时文件(会用任意字符替换模板值中的X),如<code>mktemp test.XXX</code>可能会在当前文件夹下产生文件test.UGH</p><p>-t:强制在&#x2F;tmp下创建临时文件</p><p>-d:创建临时目录</p></li><li><p>nice以某个优先级来运行某个程序<br><code>nice -[num] [command]</code>,num值越大,优先级越低,可以通过”ps -o ni”查看优先级,只能降低,不能提高优先级,</p></li><li><p>renice调整某个程序优先级<br><code>renice -[num] -p [process id]</code>普通用户只能降低优先级,root可以任意调整</p></li><li><p>neofetch<br>显示arch linux系统信息</p></li><li><p>ntpd<br><code>sudo ntpd -qg</code>可以校准时间</p></li><li><p>readlink输出文件的绝对路径<br> <code>readlink -f [fileName]</code></p></li><li><p>truncate<br><code>truncate -s 5 test.txt</code>截断test.txt，只保留5个字符</p></li><li><p>nm<br>nm作用于目标文件，统计标识符有大用</p></li><li><p>parallel<br>parallel用法复杂，建议读man<br><strong>用法:</strong></p><ul><li>cmd | parallel [options] ‘somecmd’,parallel会默认把每行的内容,插到命令末尾</li><li>parallel [options] ‘cmd’ ::: [parameter1 list] ::: [parameter2 list]…<br>强大的xargs的升级版（这只是个人感觉啊）</li></ul></li></ul><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-j&#x2F;–jobs [num]</td><td align="center">同时运行num个任务</td></tr><tr><td align="center">–C&#x2F;–colsep [regep]</td><td align="center">参数分隔符号</td></tr><tr><td align="center">–header</td><td align="center">忽略第一行</td></tr><tr><td align="center">–results [file]</td><td align="center">保存输出内容到某文件，还会输出到标准输出</td></tr><tr><td align="center">–keep-order</td><td align="center">并行有时会不按输出行的顺序，这个保持顺序</td></tr><tr><td align="center">–tag</td><td align="center">在每个结果开头，输出参数内容</td></tr><tr><td align="center">–slf&#x2F;–sshloginfile [hostnames]</td><td align="center">使用远程机当算力</td></tr><tr><td align="center">–sshlogin</td><td align="center">登录远程机</td></tr><tr><td align="center">–nonall</td><td align="center">不传递参数，只传递命令给远程机</td></tr><tr><td align="center">-N[num]</td><td align="center">分配给远程多少个参数</td></tr></tbody></table><table><thead><tr><th align="center">特殊变量名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>&#123;&#125;</code></td><td align="center">一行的内容</td></tr><tr><td align="center"><code>&#123;/&#125;</code></td><td align="center">相当于对当前行运行basename</td></tr><tr><td align="center"><code>&#123;井&#125;</code></td><td align="center">任务号，从1开始编号</td></tr></tbody></table><p><strong>例子：</strong></p><ul><li><code>seq 0 2 100 | parallel &quot;echo &#123;&#125;^2 | bc&quot;</code></li><li><code>seq 1000 | parallel -N100 --pipe --slf hostnames &quot;paste -sd+ | bc&quot; | paste -sd+|bc</code>并行算1-1000的和，一个核算一百个参数</li><li>history<br>任何匹配HISTIGNORE环境变量的命令不会被记录,以<code>:</code>分割多个模式</li></ul><ol><li><code>unset HISTFILE</code>当前会话下不记录命令行历史</li><li>设置HISTIGNORE为<code>HISTIGNORE=&quot;[&amp;:\t]&quot;</code>在命令前加空格会使当前命令不被记录到历史,并且<code>&amp;</code>表示上一次执行的命令，就是重复命令只记录一次</li><li><code>HISTFILE=~/docs/shell_history.txt</code>更改历史记录文件</li><li><code>HISTTIMEFORMAT=&quot;%Y-%m-%d %H:%M:%S&quot;</code>在每条记录前加时间戳</li><li>显示执行最多的10个命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> |<br>   sed <span class="hljs-string">&#x27;s/^ \+//;s/  / /&#x27;</span> |<br>   <span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27; &#x27;</span> -f2- |<br>   awk <span class="hljs-string">&#x27;&#123; count[$0]++ &#125; END &#123; for (i in count) print count[i], i &#125;&#x27;</span> |<br>   <span class="hljs-built_in">sort</span> -rn |<br>   <span class="hljs-built_in">head</span> -10<br></code></pre></td></tr></table></figure></li></ol><ul><li>使用python快速搭建web服务器<code>python3 -m http.server 8080</code></li><li>Linux性能分析火焰图<br><img src="/images/flameLinux1.jpg"><br><img src="/images/flameLinux2.jpg"><br><img src="/images/flameLinux3.jpg"><br><img src="/images/flameLinux4.jpg"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html及markdown</title>
    <link href="/2019/07/18/html%E5%8F%8Amarkdown/"/>
    <url>/2019/07/18/html%E5%8F%8Amarkdown/</url>
    
    <content type="html"><![CDATA[<ol><li>粗体&lt;b&gt;…&lt;&#x2F;b&gt;<br>斜体&lt;i&gt;…&lt;&#x2F;i&gt;<br>下标&lt;sub&gt;…&lt;&#x2F;sub&gt;<br>上标&lt;sup&gt;…&lt;&#x2F;sup&gt;<br>希腊字母&lt;greek&gt;…&lt;&#x2F;greek&gt;<br>数学符号&lt;math&gt;…&lt;&#x2F;math&gt;<br>特殊符号&lt;userdef&gt;…&lt;&#x2F;userdef&gt;<br>尖括号的转义则是在&amp;与;之间加入对应的编码</li><li>markdown特殊符号的打出：<br>空格可以全角的空格打出</li><li>字体的形式:<br>*斜体*——&gt;<em>斜体</em><br>**粗体**——&gt;<strong>粗体</strong><br>***粗斜体***——&gt;<em><strong>粗斜体</strong></em><br>~~删除线~~——&gt;<del>删除线</del><br>```<br>代码行１<br>代码行２<br>代码行３<br>```<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">代码行１<br>代码行２<br>代码行３<br></code></pre></td></tr></table></figure></li><li>段落格式:<br>*轻轻的我走了<br>那河畔<br>*那语音下</li></ol>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
